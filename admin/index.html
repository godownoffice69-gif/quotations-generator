<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 2025-11-21 - Materials Calculation & Details Fix -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System - Enhanced</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="shortcut icon" type="image/png" href="logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Modular CSS Files -->
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/tables.css">
    <link rel="stylesheet" href="css/dashboard.css">
    <link rel="stylesheet" href="css/responsive.css">

    <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>

    <!-- Modular JavaScript - Import Firebase Config, Utilities, Translations, Features, and Services -->
    <script type="module">
        // Import Firebase configuration and instances
        import { auth, db } from './js/config/firebase.js';

        // Import utilities
        import { Utils } from './js/utils/helpers.js';

        // Import translations
        import { translations } from './js/core/translations.js';

        // Import feature modules
        import { GlobalSearch } from './js/features/search.js';
        import { Calendar } from './js/features/calendar.js';
        import { Dashboard } from './js/features/dashboard.js';
        import { Inventory } from './js/features/inventory.js';
        import { Customers } from './js/features/customers.js';
        import { Team } from './js/features/team.js';
        import { Analytics } from './js/features/analytics.js';
        import { Settings } from './js/features/settings.js';
        import { Financials } from './js/features/financials.js';
        import { Print } from './js/features/print.js';
        import { Preparation } from './js/features/preparation.js';

        // Import order service modules
        import { OrderForm } from './js/services/order-form.js';
        import { OrderUtils } from './js/services/order-utils.js';
        import { OrderFirestore } from './js/services/order-firestore.js';

        // Make globally available for backward compatibility with inline scripts
        window.auth = auth;
        window.db = db;
        window.Utils = Utils;
        window.translations = translations;
        window.GlobalSearch = GlobalSearch;
        window.Calendar = Calendar;
        window.Dashboard = Dashboard;
        window.Inventory = Inventory;
        window.Customers = Customers;
        window.Team = Team;
        window.Analytics = Analytics;
        window.Settings = Settings;
        window.Financials = Financials;
        window.Print = Print;
        window.Preparation = Preparation;
        window.OrderForm = OrderForm;
        window.OrderUtils = OrderUtils;
        window.OrderFirestore = OrderFirestore;

        console.log('âœ… All modules loaded successfully!');
    </script>

    <!-- Google Maps JavaScript API with Places Library -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAInxvvhevCHpLy9P5K5VvBNxDgbtZF-A4&libraries=places&loading=async&callback=initGoogleMaps" async defer></script>

    <!-- Confetti Library for Login Success -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        /* ğŸ”¥ BURNING FLAMES LOGIN THEME - OPTION 1 */

        #loginScreen {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><rect width="100%25" height="100%25" fill="%23000"/></svg>');
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }

        /* Slideshow Image Styles */
        .slideshow-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: opacity 1s ease-in-out;
        }

        /* Fire Background Image Layer */
        #loginScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://raw.githubusercontent.com/godownoffice69-gif/quotations-generator/main/assets/fire-background.jpg') center/cover no-repeat;
            background-blend-mode: screen;
            opacity: 0.85;
            animation: flame-flicker 3s ease-in-out infinite;
            z-index: 0;
        }

        /* Realistic Flame Flicker Animation */
        @keyframes flame-flicker {
            0%, 100% {
                filter: brightness(1) contrast(1.1);
                transform: scale(1);
            }
            25% {
                filter: brightness(1.15) contrast(1.2);
                transform: scale(1.02);
            }
            50% {
                filter: brightness(0.95) contrast(1.05);
                transform: scale(1.01);
            }
            75% {
                filter: brightness(1.1) contrast(1.15);
                transform: scale(1.015);
            }
        }

        /* Heat Distortion Overlay */
        #loginScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,140,0,0.1) 50%, rgba(255,69,0,0.2) 100%);
            animation: heat-wave 4s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes heat-wave {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }


        /* Floating Embers Canvas */
        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* Login Card with Glass-Morphism */
        .login-card {
            position: relative;
            z-index: 3;
            background: rgba(0, 0, 0, 0.25) !important;
            border: 2px solid rgba(255,140,0,0.5);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            animation: rise-from-flames 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                       card-fire-glow 2s ease-in-out 1.2s infinite;
        }

        /* Card Rises from Flames - Bottom Right */
        @keyframes rise-from-flames {
            0% {
                opacity: 0;
                transform: translate(100px, 100px) scale(0.8);
                filter: blur(10px);
            }
            60% {
                opacity: 0.8;
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
                filter: blur(0);
            }
        }

        @keyframes card-fire-glow {
            0%, 100% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 40px rgba(255,107,0,0.4),
                            inset 0 0 20px rgba(255,140,0,0.15);
                border-color: rgba(255,140,0,0.5);
            }
            50% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 60px rgba(255,140,0,0.6),
                            inset 0 0 30px rgba(255,107,0,0.25);
                border-color: rgba(255,165,0,0.7);
            }
        }

        /* Logo with Fire Animation */
        .login-logo {
            animation: logo-burn 3s ease-in-out infinite;
            color: #ffa500 !important;
            text-shadow: 0 0 15px rgba(255,140,0,1),
                         0 0 30px rgba(255,107,0,0.8),
                         0 0 45px rgba(255,69,0,0.6);
        }

        @keyframes logo-burn {
            0%, 100% {
                transform: translateY(0px);
                text-shadow: 0 0 15px rgba(255,140,0,1),
                             0 0 30px rgba(255,107,0,0.8),
                             0 0 45px rgba(255,69,0,0.6);
            }
            50% {
                transform: translateY(-8px);
                text-shadow: 0 0 20px rgba(255,165,0,1),
                             0 0 40px rgba(255,140,0,0.9),
                             0 0 60px rgba(255,107,0,0.7);
            }
        }

        /* Fire-themed Button */
        #loginBtn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #ff6b00 0%, #ff4500 100%) !important;
            border: 2px solid #ff8c00;
        }

        #loginBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(255,107,0,0.6),
                        0 0 40px rgba(255,69,0,0.4);
            border-color: #ffa500;
        }

        #loginBtn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,215,0,0.4);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #loginBtn:hover::before {
            width: 300px;
            height: 300px;
        }

        /* Input Fields with Glass Effect */
        #loginEmail, #loginPassword {
            background: rgba(255, 255, 255, 0.15) !important;
            color: #fff !important;
            border: 2px solid rgba(255,140,0,0.4) !important;
            backdrop-filter: blur(10px);
        }

        #loginEmail:focus, #loginPassword:focus {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 25px rgba(255,140,0,0.6),
                        inset 0 0 15px rgba(255,165,0,0.2) !important;
            outline: none !important;
            background: rgba(255, 255, 255, 0.2) !important;
        }

        /* Labels in Glass Theme */
        .login-card label {
            color: #ffb347 !important;
            text-shadow: 0 0 8px rgba(255,140,0,0.7);
            font-weight: 600;
        }

        /* Footer Text */
        .login-card > div:last-child {
            color: #ffa500 !important;
            text-shadow: 0 0 5px rgba(255,140,0,0.5);
        }
    </style>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: flex; align-items: flex-end; justify-content: flex-end; padding: 2rem; overflow: hidden;">
        <!-- Slideshow Background -->
        <div id="loginSlideshow" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
            <div class="slideshow-image" style="background-image: url('circle%20flame.jpg'); opacity: 1;"></div>
            <div class="slideshow-image" style="background-image: url('bubble%20from%20Disney.png'); opacity: 0;"></div>
            <div class="slideshow-image" style="background-image: url('firepowersfx.png'); opacity: 0;"></div>
            <div class="slideshow-image" style="background-image: url('flame%20machine%201.jpg'); opacity: 0;"></div>
            <div class="slideshow-image" style="background-image: url('flames%20machine.jpg'); opacity: 0;"></div>
            <div class="slideshow-image" style="background-image: url('peper%20ribbon%20thrower.jpg'); opacity: 0;"></div>
            <div class="slideshow-image" style="background-image: url('sparkle%20fountain%20image%201.jpg'); opacity: 0;"></div>
        </div>

        <div class="login-card" style="position: relative; z-index: 3; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); padding: 2rem; border-radius: 16px; max-width: 320px; width: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);">
            <h1 class="login-logo" style="text-align: center; color: #667eea; margin-bottom: 1.5rem; font-size: 1.75rem;">ğŸ”¥ Firepower SFX</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="ğŸ” Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <div id="weatherMiniDashboard">
                        <span class="weather-mini-icon">ğŸŒ¤ï¸</span>
                        <div class="weather-mini-info">
                            <span class="weather-mini-temp">--Â°C</span>
                            <span class="weather-mini-condition">Loading...</span>
                        </div>
                    </div>
                    <button class="btn btn-info btn-small" onclick="OMS.toggleLanguage()" id="languageToggle" title="Switch Language">
                        ğŸŒ EN
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">âŒ¨ï¸</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">ğŸšª Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">ğŸ“Š Dashboard</button>
                <button class="nav-tab" data-tab="orders">ğŸ“ Orders</button>
                <button class="nav-tab" data-tab="inventory">ğŸ“¦ Inventory</button>
                <button class="nav-tab" data-tab="itemHistory">ğŸ“œ Item History</button>
                <button class="nav-tab" data-tab="preparation">ğŸ“‹ Preparation</button>
                <button class="nav-tab" data-tab="customers">ğŸ‘¥ Customers</button>
                <button class="nav-tab" data-tab="quotations">ğŸ“„ Quotations</button>
                <button class="nav-tab" data-tab="team">ğŸ‘· Team</button>
                <button class="nav-tab" data-tab="calendar">ğŸ—“ï¸ Calendar</button>
                <button class="nav-tab" data-tab="history">ğŸ“š History</button>
                <button class="nav-tab" data-tab="analytics">ğŸ“ˆ Analytics</button>
                <button class="nav-tab" data-tab="financials">ğŸ’° Financials</button>
                <button class="nav-tab" data-tab="settings">âš™ï¸ Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">ğŸ”” Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">ğŸ• Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">ğŸ“ Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Event Type</label>
                                <select id="eventTypeSelect" class="form-select" required>
                                    <option value="single">Single Day Event</option>
                                    <option value="multi">Multi-Day Event</option>
                                </select>
                            </div>
                        </div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-grid">
    <div class="form-group">
        <label class="form-label required">Event Date</label>
        <input type="date" id="orderDate" name="orderDate" class="form-input highlight-datetime" required>
    </div>
    <div class="form-group">
        <label class="form-label">Ready Time</label>
        <select id="readyTime" name="readyTime" class="form-select highlight-datetime"></select>
    </div>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" name="startDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" name="endDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">ğŸ“… Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Contact</label>
                                <input type="tel" id="contact" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Venue</label>
                                <input type="text" id="venue" class="form-input" placeholder="Search for venue...">
                                <!-- Hidden field to store Google Maps link -->
                                <input type="hidden" id="venueMapLink">
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <select id="eventType" class="form-select">
                                    <option value="">Select Event Type</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Transport</label>
                                <select id="transport" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Transport 2 (Optional)</label>
                                <select id="transport2" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransport2Group">
                                <label class="form-label">Custom Transport 2</label>
                                <input type="text" id="customTransport2" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver 2 (Optional)</label>
                                <select id="driverName2" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper(s)</label>
                                <input type="text" id="helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)">
                                <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">ğŸ“¦ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="ğŸ” Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">ğŸ’¾ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-danger" onclick="OMS.clearOrderForm()">ğŸ—‘ï¸ Clear Form</button>
                            <button type="button" class="btn btn-success" onclick="OMS.quickAddPayment()">ğŸ’µ Quick Payment</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">ğŸ‘ï¸ Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">ğŸ“‹ Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">ğŸ“… Same Day</button>
                        </div>
                    </form>
                </div>

                <!-- WhatsApp Date Filter Section -->
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <h2 class="card-title">ğŸ“± WhatsApp Orders Report</h2>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Select Date to View Orders</label>
                        <input type="date" id="whatsappFilterDate" class="form-input" style="max-width: 300px;">
                        <small style="color: var(--text-gray); display: block; margin-top: 0.5rem;">Select a date to see all orders and send them via WhatsApp</small>
                    </div>
                    <div id="whatsappOrdersPreview" style="margin-top: 1rem; display: none;">
                        <div style="background: var(--bg-hover); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <h4 style="margin: 0 0 0.5rem 0;">ğŸ“‹ Orders Found: <span id="whatsappOrderCount">0</span></h4>
                            <div id="whatsappOrdersList" style="max-height: 300px; overflow-y: auto; font-size: 0.9rem; white-space: pre-wrap; font-family: monospace; background: var(--bg-card); padding: 0.75rem; border-radius: 4px;"></div>
                        </div>
                        <button type="button" class="btn btn-success" id="sendWhatsAppOrdersBtn" style="width: 100%;">
                            ğŸ“± Send on WhatsApp
                        </button>
                    </div>
                    <div id="whatsappNoOrders" style="display: none; padding: 1rem; text-align: center; color: var(--text-gray);">
                        ğŸ“­ No orders found for selected date
                    </div>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="itemHistory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="quotations" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="financials" class="tab-content"></div>
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsBackdrop" class="shortcuts-backdrop" onclick="OMS.hideShortcuts()"></div>
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">Ã—</button>
        <h2>âŒ¨ï¸ Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <!-- Modular JavaScript Files -->
    <script type="module">
        // Import utilities and translations
        import { Utils } from './js/utils/helpers.js';
        import { translations } from './js/core/translations.js';

        // Make globally available for inline scripts
        window.Utils = Utils;
        window.translations = translations;
    </script>

    <script>
        


        // ============ FILTERING INFRASTRUCTURE ============

        /**
         * FilterLogger - Detailed logging system for all filtering operations
         * Tracks every filter with timestamp, parameters, results, and performance metrics
         */
        class FilterLogger {
            constructor() {
                this.logs = this.loadLogs();
                this.maxLogs = 1000; // Keep last 1000 operations
            }

            loadLogs() {
                try {
                    const saved = localStorage.getItem('oms_filter_logs');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter logs:', error);
                    return [];
                }
            }

            saveLogs() {
                try {
                    // Keep only the most recent logs
                    if (this.logs.length > this.maxLogs) {
                        this.logs = this.logs.slice(-this.maxLogs);
                    }
                    localStorage.setItem('oms_filter_logs', JSON.stringify(this.logs));
                } catch (error) {
                    console.warn('Failed to save filter logs:', error);
                }
            }

            log(operation, details) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    operation,
                    ...details
                };

                this.logs.push(logEntry);
                this.saveLogs();

                // Also log to console for debugging
                console.log(`ğŸ” [FilterLog] ${operation}:`, details);

                return logEntry;
            }

            getRecentLogs(count = 50) {
                return this.logs.slice(-count);
            }

            getLogsByDate(date) {
                return this.logs.filter(log => log.filterDate === date);
            }

            clearOldLogs(daysToKeep = 30) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - daysToKeep);
                const cutoffTime = cutoff.toISOString();

                this.logs = this.logs.filter(log => log.timestamp > cutoffTime);
                this.saveLogs();
            }
        }

        /**
         * PatternLearner - Machine learning-style pattern recognition system
         * Learns from filtering patterns to detect anomalies and improve accuracy
         */
        class PatternLearner {
            constructor() {
                this.patterns = this.loadPatterns();
                this.anomalyThreshold = 0.3; // 30% deviation triggers alert
            }

            loadPatterns() {
                try {
                    const saved = localStorage.getItem('oms_filter_patterns');
                    return saved ? JSON.parse(saved) : {
                        datePatterns: {}, // date -> expected order count
                        filterResults: [], // historical filter results
                        dateFormats: {}, // learned date format variations
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                } catch (error) {
                    console.warn('Failed to load patterns:', error);
                    return {
                        datePatterns: {},
                        filterResults: [],
                        dateFormats: {},
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                }
            }

            savePatterns() {
                try {
                    localStorage.setItem('oms_filter_patterns', JSON.stringify(this.patterns));
                } catch (error) {
                    console.warn('Failed to save patterns:', error);
                }
            }

            recordFilterResult(date, orderCount, totalAvailable, filterType = 'date') {
                // Update date-specific patterns
                if (!this.patterns.datePatterns[date]) {
                    this.patterns.datePatterns[date] = {
                        counts: [],
                        avgCount: 0,
                        lastSeen: new Date().toISOString()
                    };
                }

                const pattern = this.patterns.datePatterns[date];
                pattern.counts.push(orderCount);
                pattern.lastSeen = new Date().toISOString();

                // Keep only last 10 observations per date
                if (pattern.counts.length > 10) {
                    pattern.counts = pattern.counts.slice(-10);
                }

                // Calculate average
                pattern.avgCount = pattern.counts.reduce((sum, c) => sum + c, 0) / pattern.counts.length;

                // Update weekday/weekend patterns
                const dateObj = new Date(date);
                const dayOfWeek = dateObj.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                const key = isWeekend ? 'weekend' : 'weekday';
                const stats = this.patterns.typicalOrderCounts[key];

                if (stats.samples === 0) {
                    stats.min = orderCount;
                    stats.max = orderCount;
                    stats.avg = orderCount;
                    stats.samples = 1;
                } else {
                    stats.min = Math.min(stats.min, orderCount);
                    stats.max = Math.max(stats.max, orderCount);
                    stats.avg = (stats.avg * stats.samples + orderCount) / (stats.samples + 1);
                    stats.samples++;
                }

                // Record in filter results history
                this.patterns.filterResults.push({
                    timestamp: new Date().toISOString(),
                    date,
                    orderCount,
                    totalAvailable,
                    filterType,
                    dayOfWeek,
                    isWeekend
                });

                // Keep only last 500 results
                if (this.patterns.filterResults.length > 500) {
                    this.patterns.filterResults = this.patterns.filterResults.slice(-500);
                }

                this.savePatterns();
            }

            learnDateFormat(originalDate, normalizedDate) {
                if (!this.patterns.dateFormats[originalDate]) {
                    this.patterns.dateFormats[originalDate] = {
                        normalized: normalizedDate,
                        count: 1,
                        lastSeen: new Date().toISOString()
                    };
                } else {
                    this.patterns.dateFormats[originalDate].count++;
                    this.patterns.dateFormats[originalDate].lastSeen = new Date().toISOString();
                }
                this.savePatterns();
            }

            detectAnomaly(date, actualCount) {
                // Check if we have historical data for this date
                const pattern = this.patterns.datePatterns[date];

                if (pattern && pattern.counts.length >= 3) {
                    const expected = pattern.avgCount;
                    const deviation = Math.abs(actualCount - expected) / Math.max(expected, 1);

                    if (deviation > this.anomalyThreshold) {
                        return {
                            isAnomaly: true,
                            expected,
                            actual: actualCount,
                            deviation: (deviation * 100).toFixed(1) + '%',
                            message: `âš ï¸ Unusual order count! Expected ~${Math.round(expected)} orders, found ${actualCount}`
                        };
                    }
                }

                // Check against weekday/weekend patterns
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                if (stats.samples >= 10) {
                    if (actualCount < stats.min * 0.5 || actualCount > stats.max * 1.5) {
                        return {
                            isAnomaly: true,
                            expected: `${stats.min}-${stats.max}`,
                            actual: actualCount,
                            message: `âš ï¸ Order count outside normal range! Typical ${isWeekend ? 'weekend' : 'weekday'}: ${stats.min}-${stats.max}, found ${actualCount}`
                        };
                    }
                }

                return { isAnomaly: false };
            }

            getExpectedCount(date) {
                const pattern = this.patterns.datePatterns[date];
                if (pattern && pattern.counts.length > 0) {
                    return Math.round(pattern.avgCount);
                }

                // Fallback to weekday/weekend average
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                return stats.samples > 0 ? Math.round(stats.avg) : null;
            }
        }

        /**
         * FuzzyDateMatcher - Handles date format variations and near-matches
         * Provides error tolerance for date matching
         */
        class FuzzyDateMatcher {
            constructor() {
                this.dateFormats = [
                    'YYYY-MM-DD',
                    'DD-MM-YYYY',
                    'MM-DD-YYYY',
                    'DD/MM/YYYY',
                    'MM/DD/YYYY',
                    'YYYY/MM/DD'
                ];
            }

            // Normalize various date formats to YYYY-MM-DD
            normalize(dateStr) {
                if (!dateStr) return null;

                try {
                    // If already a Date object
                    if (dateStr instanceof Date) {
                        return this.toYYYYMMDD(dateStr);
                    }

                    // If ISO format
                    if (dateStr.includes('T') || dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const d = new Date(dateStr);
                        return this.toYYYYMMDD(d);
                    }

                    // Try different formats
                    const formats = [
                        // DD-MM-YYYY or DD/MM/YYYY
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // MM-DD-YYYY or MM/DD/YYYY (US format)
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // YYYY-MM-DD or YYYY/MM/DD
                        /^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/
                    ];

                    for (const format of formats) {
                        const match = dateStr.match(format);
                        if (match) {
                            let year, month, day;

                            if (match[1].length === 4) {
                                // YYYY-MM-DD format
                                [, year, month, day] = match;
                            } else {
                                // Assume DD-MM-YYYY (more common internationally)
                                [, day, month, year] = match;
                            }

                            const d = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                            if (!isNaN(d.getTime())) {
                                return this.toYYYYMMDD(d);
                            }
                        }
                    }

                    // Fallback: try native Date parsing
                    const d = new Date(dateStr);
                    if (!isNaN(d.getTime())) {
                        return this.toYYYYMMDD(d);
                    }

                } catch (error) {
                    console.warn('Failed to normalize date:', dateStr, error);
                }

                return null;
            }

            toYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Check if two dates are the same, handling various formats
            matches(date1, date2) {
                const norm1 = this.normalize(date1);
                const norm2 = this.normalize(date2);
                return norm1 && norm2 && norm1 === norm2;
            }

            // Check if date is within range (inclusive)
            isInRange(dateToCheck, startDate, endDate) {
                const check = new Date(this.normalize(dateToCheck));
                const start = new Date(this.normalize(startDate));
                const end = new Date(this.normalize(endDate));

                return check >= start && check <= end;
            }

            // Find near matches (within N days)
            findNearMatches(targetDate, dates, daysTolerance = 1) {
                const target = new Date(this.normalize(targetDate));
                const matches = [];

                for (const date of dates) {
                    const d = new Date(this.normalize(date));
                    const diffDays = Math.abs((d - target) / (1000 * 60 * 60 * 24));

                    if (diffDays <= daysTolerance) {
                        matches.push({
                            date,
                            daysAway: diffDays,
                            isExact: diffDays === 0
                        });
                    }
                }

                return matches.sort((a, b) => a.daysAway - b.daysAway);
            }

            // Get date variations that should be checked
            getVariations(dateStr) {
                const normalized = this.normalize(dateStr);
                if (!normalized) return [dateStr];

                const d = new Date(normalized);
                const variations = new Set();

                // Add normalized version
                variations.add(normalized);

                // Add original
                variations.add(dateStr);

                // Add common formats
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');

                variations.add(`${year}-${month}-${day}`);
                variations.add(`${day}-${month}-${year}`);
                variations.add(`${month}-${day}-${year}`);
                variations.add(`${day}/${month}/${year}`);
                variations.add(`${month}/${day}/${year}`);

                return Array.from(variations);
            }
        }

        /**
         * OrderValidator - Validation system to detect missing orders
         * Alerts when filtering results seem incomplete
         */
        class OrderValidator {
            constructor(patternLearner) {
                this.patternLearner = patternLearner;
            }

            validate(filterResult) {
                const alerts = [];
                const { date, orderCount, totalAvailable, matchedOrders, allOrders } = filterResult;

                // Alert 1: Check for anomalies based on learned patterns
                const anomaly = this.patternLearner.detectAnomaly(date, orderCount);
                if (anomaly.isAnomaly) {
                    alerts.push({
                        level: 'warning',
                        type: 'anomaly',
                        message: anomaly.message,
                        details: anomaly
                    });
                }

                // Alert 2: Check if there are orders with similar dates that weren't matched
                const targetDate = new Date(date);
                const nearbyOrders = allOrders.filter(order => {
                    if (matchedOrders.includes(order)) return false;

                    const orderDate = new Date(order.date || order.startDate);
                    const diffDays = Math.abs((orderDate - targetDate) / (1000 * 60 * 60 * 24));
                    return diffDays <= 2; // Within 2 days
                });

                if (nearbyOrders.length > 0) {
                    alerts.push({
                        level: 'info',
                        type: 'nearby_dates',
                        message: `â„¹ï¸ Found ${nearbyOrders.length} order(s) within 2 days of ${date}`,
                        details: {
                            nearbyOrders: nearbyOrders.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                date: o.date || o.startDate
                            }))
                        }
                    });
                }

                // Alert 3: Check for orders with blank/missing dates
                const ordersWithoutDates = allOrders.filter(o =>
                    !o.date && !o.startDate && o.status !== 'Completed'
                );

                if (ordersWithoutDates.length > 0) {
                    alerts.push({
                        level: 'warning',
                        type: 'missing_dates',
                        message: `âš ï¸ Found ${ordersWithoutDates.length} order(s) without dates`,
                        details: {
                            orders: ordersWithoutDates.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                status: o.status
                            }))
                        }
                    });
                }

                // Alert 4: Check for multiday orders that might be partially matched
                const multidayOrders = allOrders.filter(o =>
                    o.isMultiDay && !matchedOrders.includes(o)
                );

                for (const order of multidayOrders) {
                    if (order.startDate && order.endDate) {
                        const checkDate = new Date(date);
                        const start = new Date(order.startDate);
                        const end = new Date(order.endDate);

                        // Check if date should fall in range but wasn't matched
                        if (checkDate >= start && checkDate <= end) {
                            alerts.push({
                                level: 'error',
                                type: 'missed_multiday',
                                message: `ğŸš¨ Multi-day order "${order.orderId || order.clientName}" should include ${date} but wasn't matched!`,
                                details: {
                                    orderId: order.orderId,
                                    clientName: order.clientName,
                                    startDate: order.startDate,
                                    endDate: order.endDate
                                }
                            });
                        }
                    }
                }

                return alerts;
            }

            showAlerts(alerts, date) {
                if (alerts.length === 0) return;

                console.group(`ğŸ”” Validation Alerts for ${date}`);

                for (const alert of alerts) {
                    const emoji = alert.level === 'error' ? 'ğŸš¨' :
                                 alert.level === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
                    console.log(`${emoji} [${alert.type}] ${alert.message}`);
                    if (alert.details) {
                        console.log('Details:', alert.details);
                    }
                }

                console.groupEnd();

                // Show toast for critical alerts
                const criticalAlerts = alerts.filter(a => a.level === 'error');
                if (criticalAlerts.length > 0 && window.OMS) {
                    window.OMS.showToast(
                        `${criticalAlerts.length} critical validation issue(s) detected!`,
                        'error'
                    );
                }
            }
        }

        /**
         * FilterRatingSystem - User feedback system for filter algorithm
         * Allows users to rate filtering results and helps system learn from mistakes
         */
        class FilterRatingSystem {
            constructor() {
                this.ratings = this.loadRatings();
                this.currentFilterContext = null;
                this.maxRatings = 500; // Keep last 500 ratings
            }

            loadRatings() {
                try {
                    const saved = localStorage.getItem('oms_filter_ratings');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter ratings:', error);
                    return [];
                }
            }

            saveRatings() {
                try {
                    if (this.ratings.length > this.maxRatings) {
                        this.ratings = this.ratings.slice(-this.maxRatings);
                    }
                    localStorage.setItem('oms_filter_ratings', JSON.stringify(this.ratings));
                } catch (error) {
                    console.warn('Failed to save filter ratings:', error);
                }
            }

            // Store context of current filter operation for rating
            setFilterContext(context) {
                this.currentFilterContext = {
                    timestamp: new Date().toISOString(),
                    date: context.date,
                    normalizedDate: context.normalizedDate,
                    matchedOrders: context.matchedOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    })),
                    totalOrders: context.totalOrders,
                    filterDetails: context.filterDetails,
                    allOrderIds: context.allOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    }))
                };
            }

            // Record user rating with feedback
            recordRating(rating, feedback = {}) {
                if (!this.currentFilterContext) {
                    console.warn('No filter context available for rating');
                    return;
                }

                const ratingEntry = {
                    ...this.currentFilterContext,
                    rating, // 1-5 stars or thumbs up/down
                    feedback: {
                        userComment: feedback.comment || '',
                        incorrectlyIncluded: feedback.incorrectlyIncluded || [], // Order IDs that shouldn't be there
                        incorrectlyExcluded: feedback.incorrectlyExcluded || [], // Order IDs that should be there
                        ratingType: feedback.ratingType || 'numeric', // 'numeric', 'thumbs', 'words'
                        sentimentScore: this.calculateSentiment(rating, feedback),
                        tags: feedback.tags || [] // ['wrong_date', 'missing_orders', 'extra_orders', 'perfect']
                    },
                    ratedAt: new Date().toISOString()
                };

                this.ratings.push(ratingEntry);
                this.saveRatings();

                console.log('âœ¨ Rating recorded:', ratingEntry);

                // Learn from this feedback
                this.learnFromRating(ratingEntry);

                return ratingEntry;
            }

            // Calculate sentiment score from rating
            calculateSentiment(rating, feedback) {
                let score = 0;

                // Numeric rating (1-5 stars)
                if (typeof rating === 'number') {
                    score = (rating - 1) / 4; // Normalize to 0-1
                }
                // Thumbs up/down
                else if (rating === 'up') {
                    score = 1;
                } else if (rating === 'down') {
                    score = 0;
                }
                // Word-based rating
                else if (typeof rating === 'string') {
                    const wordScores = {
                        'perfect': 1.0,
                        'excellent': 1.0,
                        'good': 0.75,
                        'okay': 0.5,
                        'bad': 0.25,
                        'terrible': 0
                    };
                    score = wordScores[rating.toLowerCase()] || 0.5;
                }

                // Adjust based on specific feedback
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    score *= 0.5; // Penalty for wrong inclusions
                }
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    score *= 0.5; // Penalty for missing orders
                }

                return score;
            }

            // Learn from user rating
            learnFromRating(ratingEntry) {
                const { date, normalizedDate, feedback, rating } = ratingEntry;

                // Create learning rules based on feedback
                const learningRules = [];

                // Rule 1: Learn from incorrectly included orders
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    feedback.incorrectlyIncluded.forEach(badOrder => {
                        learningRules.push({
                            type: 'exclusion',
                            targetDate: normalizedDate,
                            orderId: badOrder.orderId,
                            reason: 'User marked as incorrectly included',
                            orderDate: badOrder.date || badOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 2: Learn from incorrectly excluded orders
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    feedback.incorrectlyExcluded.forEach(missedOrder => {
                        learningRules.push({
                            type: 'inclusion',
                            targetDate: normalizedDate,
                            orderId: missedOrder.orderId,
                            reason: 'User marked as incorrectly excluded',
                            orderDate: missedOrder.date || missedOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 3: Learn from overall sentiment
                if (feedback.sentimentScore < 0.5) {
                    learningRules.push({
                        type: 'anomaly',
                        targetDate: normalizedDate,
                        reason: 'Low user satisfaction',
                        sentimentScore: feedback.sentimentScore,
                        weight: 0.5
                    });
                }

                // Store learning rules
                if (learningRules.length > 0) {
                    this.storeLearningRules(learningRules);
                }

                console.log('ğŸ§  Learned from rating:', learningRules.length, 'new rules');
            }

            // Store learning rules for future use
            storeLearningRules(rules) {
                try {
                    let existingRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    existingRules = [...existingRules, ...rules];

                    // Keep only last 1000 rules
                    if (existingRules.length > 1000) {
                        existingRules = existingRules.slice(-1000);
                    }

                    localStorage.setItem('oms_filter_learning_rules', JSON.stringify(existingRules));
                } catch (error) {
                    console.warn('Failed to store learning rules:', error);
                }
            }

            // Get learning rules for a specific date
            getLearningRules(date) {
                try {
                    const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    return rules.filter(rule => rule.targetDate === date);
                } catch (error) {
                    console.warn('Failed to get learning rules:', error);
                    return [];
                }
            }

            // Apply learning rules to filter results
            applyLearningRules(date, orders, allOrders) {
                const rules = this.getLearningRules(date);
                if (rules.length === 0) return { orders, corrections: [] };

                console.log(`ğŸ§  Applying ${rules.length} learning rules for ${date}`);

                const corrections = [];
                let correctedOrders = [...orders];

                // Apply exclusion rules
                const exclusionRules = rules.filter(r => r.type === 'exclusion');
                exclusionRules.forEach(rule => {
                    const idx = correctedOrders.findIndex(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (idx !== -1) {
                        corrections.push({
                            type: 'removed',
                            order: correctedOrders[idx],
                            reason: rule.reason
                        });
                        correctedOrders.splice(idx, 1);
                    }
                });

                // Apply inclusion rules
                const inclusionRules = rules.filter(r => r.type === 'inclusion');
                inclusionRules.forEach(rule => {
                    const order = allOrders.find(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (order && !correctedOrders.find(o => o.orderId === order.orderId)) {
                        corrections.push({
                            type: 'added',
                            order: order,
                            reason: rule.reason
                        });
                        correctedOrders.push(order);
                    }
                });

                if (corrections.length > 0) {
                    console.log(`âœ… Applied ${corrections.length} corrections:`, corrections);
                }

                return { orders: correctedOrders, corrections };
            }

            // Show rating UI modal
            showRatingUI(OMS) {
                if (!this.currentFilterContext) return;

                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>â­ Rate Filter Results</h3>
                            <button onclick="this.closest('.modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 20px; color: var(--text-secondary);">
                                Found <strong>${this.currentFilterContext.matchedOrders.length}</strong> orders for
                                <strong>${this.currentFilterContext.date}</strong>
                            </p>

                            <!-- Star Rating -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">How accurate was this filter?</label>
                                <div id="starRating" style="font-size: 36px; cursor: pointer;">
                                    ${[1, 2, 3, 4, 5].map(i => `<span data-rating="${i}" style="color: #ddd;">â­</span>`).join('')}
                                </div>
                                <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                                    <span id="ratingLabel">Click to rate</span>
                                </div>
                            </div>

                            <!-- Quick Feedback Buttons -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Quick Feedback:</label>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button class="btn btn-sm feedback-tag" data-tag="perfect">âœ… Perfect</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="missing_orders">âŒ Missing Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="extra_orders">â• Extra Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="wrong_date">ğŸ“… Wrong Date</button>
                                </div>
                            </div>

                            <!-- Matched Orders List -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                    Matched Orders (Click to mark as incorrect):
                                </label>
                                <div id="matchedOrdersList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 10px;">
                                    ${this.currentFilterContext.matchedOrders.map(o => `
                                        <div class="order-item" data-order-id="${o.orderId}" data-doc-id="${o.docId}" style="padding: 8px; margin: 5px 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                            <strong>${o.orderId || o.clientName}</strong>
                                            <span style="color: var(--text-secondary); margin-left: 10px; font-size: 12px;">
                                                ${o.date || o.startDate || 'No date'}
                                            </span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Comment -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Additional Comments (Optional):</label>
                                <textarea id="ratingComment" rows="3" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; resize: vertical;" placeholder="Tell us what went wrong or what was good..."></textarea>
                            </div>

                            <!-- Submit Buttons -->
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Skip</button>
                                <button id="submitRating" class="btn btn-primary">Submit Rating</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Star rating interaction
                let selectedRating = 0;
                const stars = modal.querySelectorAll('#starRating span');
                const ratingLabel = modal.querySelector('#ratingLabel');
                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Excellent'];

                stars.forEach(star => {
                    star.addEventListener('mouseenter', function() {
                        const rating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < rating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[rating - 1];
                    });

                    star.addEventListener('click', function() {
                        selectedRating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[selectedRating - 1] + ' â­'.repeat(selectedRating);
                    });
                });

                modal.querySelector('#starRating').addEventListener('mouseleave', function() {
                    stars.forEach((s, i) => {
                        s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                    });
                    ratingLabel.textContent = selectedRating > 0 ? labels[selectedRating - 1] + ' â­'.repeat(selectedRating) : 'Click to rate';
                });

                // Feedback tags interaction
                const selectedTags = new Set();
                modal.querySelectorAll('.feedback-tag').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (selectedTags.has(tag)) {
                            selectedTags.delete(tag);
                            this.style.background = '';
                            this.style.color = '';
                        } else {
                            selectedTags.add(tag);
                            this.style.background = 'var(--primary)';
                            this.style.color = 'white';
                        }
                    });
                });

                // Order selection interaction
                const incorrectOrders = new Set();
                modal.querySelectorAll('.order-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const orderId = this.dataset.orderId || this.dataset.docId;
                        if (incorrectOrders.has(orderId)) {
                            incorrectOrders.delete(orderId);
                            this.style.background = 'var(--bg-card)';
                            this.style.border = '1px solid var(--border)';
                        } else {
                            incorrectOrders.add(orderId);
                            this.style.background = '#ffebee';
                            this.style.border = '2px solid #f44336';
                        }
                    });
                });

                // Submit rating
                modal.querySelector('#submitRating').addEventListener('click', () => {
                    if (selectedRating === 0) {
                        OMS.showToast('Please select a rating', 'error');
                        return;
                    }

                    const incorrectlyIncluded = Array.from(incorrectOrders).map(orderId => {
                        return this.currentFilterContext.matchedOrders.find(o =>
                            o.orderId === orderId || o.docId === orderId
                        );
                    }).filter(Boolean);

                    this.recordRating(selectedRating, {
                        comment: modal.querySelector('#ratingComment').value,
                        incorrectlyIncluded,
                        incorrectlyExcluded: [], // Can be enhanced to allow selecting missing orders
                        ratingType: 'numeric',
                        tags: Array.from(selectedTags)
                    });

                    OMS.showToast('âœ¨ Thank you! The system has learned from your feedback.', 'success');
                    modal.remove();
                });
            }

            // Get statistics about ratings
            getStats() {
                if (this.ratings.length === 0) {
                    return { avgRating: 0, totalRatings: 0, recentRatings: [] };
                }

                const numericRatings = this.ratings.filter(r => typeof r.rating === 'number');
                const avgRating = numericRatings.length > 0
                    ? numericRatings.reduce((sum, r) => sum + r.rating, 0) / numericRatings.length
                    : 0;

                return {
                    avgRating: avgRating.toFixed(2),
                    totalRatings: this.ratings.length,
                    recentRatings: this.ratings.slice(-10),
                    sentimentTrend: this.ratings.slice(-20).map(r => r.feedback.sentimentScore)
                };
            }

            // Clear all ratings
            clearAllRatings() {
                this.ratings = [];
                this.saveRatings();
                localStorage.removeItem('oms_filter_learning_rules');
                console.log('ğŸ—‘ï¸ All ratings and learning rules cleared');
            }
        }

        // Initialize global instances
        const filterLogger = new FilterLogger();
        const patternLearner = new PatternLearner();
        const fuzzyDateMatcher = new FuzzyDateMatcher();
        const orderValidator = new OrderValidator(patternLearner);
        const filterRatingSystem = new FilterRatingSystem();

        // Clean up old logs periodically (keep last 30 days)
        filterLogger.clearOldLogs(30);

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [], deletedItems: [], deletedCategories: [] },
                itemHistory: [],
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                payments: [],
                expenses: [],
                trackingData: [],
                eventsList: [
                    'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                    'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                    'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                    'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                    'Ganesh Agman', 'Ganesh Visarjan'
                ],
                settings: {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["à¤®à¤•à¤° à¤¸à¤‚à¤•à¥à¤°à¤¾à¤‚à¤¤à¤¿", "Makar Sankranti"],
                "2025-01-26": ["à¤—à¤£à¤¤à¤‚à¤¤à¥à¤° à¤¦à¤¿à¤µà¤¸", "Republic Day"],
                "2025-02-13": ["à¤®à¤¹à¤¾ à¤¶à¤¿à¤µà¤°à¤¾à¤¤à¥à¤°à¤¿", "Maha Shivratri"],
                "2025-03-13": ["à¤¹à¥‹à¤²à¥€", "Holi"],
                "2025-03-14": ["à¤§à¥à¤²à¥‡à¤Ÿà¥€", "Dhuleti"],
                "2025-04-06": ["à¤°à¤¾à¤® à¤¨à¤µà¤®à¥€", "Ram Navami"],
                "2025-08-15": ["à¤¸à¥à¤µà¤¤à¤‚à¤¤à¥à¤°à¤¤à¤¾ à¤¦à¤¿à¤µà¤¸", "Independence Day"],
                "2025-08-19": ["à¤œà¤¨à¥à¤®à¤¾à¤·à¥à¤Ÿà¤®à¥€", "Janmashtami"],
                "2025-10-02": ["à¤—à¤¾à¤‚à¤§à¥€ à¤œà¤¯à¤‚à¤¤à¥€", "Gandhi Jayanti"],
                "2025-11-01": ["à¤§à¤¨à¤¤à¥‡à¤°à¤¸", "Dhanteras"],
                "2025-11-02": ["à¤¦à¥€à¤µà¤¾à¤²à¥€", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('âš ï¸ Already initialized - skipping duplicate init');
        return;
    }

    console.log('ğŸš€ Initializing OMS...');
    this.initialized = true;

    // Load user role first
    await this.getCurrentUser();

    await this.loadFromStorage();
    await this.loadEventsListFromFirestore();
    this.populateEventsDatalist(); // Populate events dropdown immediately
    await this.loadTrackingFromFirestore();
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();

    // Apply RBAC to navigation tabs
    await this.applyRBACToNavigation();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
                this.applyLanguage(); // Apply saved language

                // Initialize weather mini dashboard and set up auto-refresh
                this.updateWeatherMiniDashboard();
                setInterval(() => this.updateWeatherMiniDashboard(), 900000); // Refresh every 15 minutes

                // Check for draft order after initialization
                setTimeout(() => this.checkForDraft(), 1000);
            },

            // ============ LANGUAGE SWITCHING ============
            toggleLanguage() {
                const currentLang = this.data.settings.language || 'en';
                const newLang = currentLang === 'en' ? 'gu' : 'en';
                this.data.settings.language = newLang;
                this.saveToStorage();
                this.applyLanguage();
                this.showToast(newLang === 'en' ? 'Language switched to English' : 'àª­àª¾àª·àª¾ àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚ àª¬àª¦àª²àª¾àªˆ àª—àªˆ', 'success');
            },

            applyLanguage() {
                const lang = this.data.settings.language || 'en';
                const t = translations[lang];

                // Update language toggle button
                const toggleBtn = document.getElementById('languageToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = lang === 'en' ? 'ğŸŒ EN' : 'ğŸŒ àª—à«';
                    toggleBtn.title = lang === 'en' ? 'Switch to Gujarati' : 'àª…àª‚àª—à«àª°à«‡àªœà«€àª®àª¾àª‚ àª¬àª¦àª²à«‹';
                }

                // Update header
                const companyName = document.querySelector('.company-name');
                if (companyName) companyName.textContent = t.companyName;

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) searchInput.placeholder = t.searchPlaceholder;

                // Update tabs
                const tabs = document.querySelectorAll('.nav-tab');
                const tabKeys = ['dashboard', 'orders', 'inventory', 'itemHistory', 'preparation', 'customers', 'quotations', 'team', 'calendar', 'history', 'analytics', 'financials', 'settings'];
                tabs.forEach((tab, index) => {
                    if (tabKeys[index] && t[tabKeys[index]]) {
                        tab.textContent = t[tabKeys[index]];
                    }
                });

                // Update Orders tab static labels using data-translate attributes
                this.updateOrdersTabLabels();

                // Update action buttons
                this.updateActionButtons();

                // Re-render current tab to apply translations
                if (this.currentTab) {
                    this.switchTab(this.currentTab);
                }
            },

            updateOrdersTabLabels() {
                // Helper function to update label text
                const updateLabel = (selector, translationKey) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.textContent = this.t(translationKey);
                    });
                };

                // Update form labels by finding them with specific text patterns
                // This will update all label elements in the orders tab
                const labels = {
                    'Client Name': 'clientName',
                    'Contact': 'contact',
                    'Venue': 'venue',
                    'Ready Time': 'readyTime',
                    'Order Status': 'orderStatus',
                    'Notes': 'notes',
                    'Driver Name': 'driverName',
                    'Operator': 'operator',
                    'Helper(s)': 'helpers',
                    'Transport': 'transport'
                };

                document.querySelectorAll('.form-label').forEach(label => {
                    const text = label.textContent.trim();
                    Object.keys(labels).forEach(key => {
                        if (text.includes(key)) {
                            const translatedText = this.t(labels[key]);
                            label.textContent = label.textContent.replace(key, translatedText);
                        }
                    });
                });

                // Update helper placeholder
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.placeholder = this.t('helperPlaceholder');
                }

                // Update client name placeholder
                const clientInput = document.getElementById('clientName');
                if (clientInput) {
                    clientInput.placeholder = this.t('enterClientName');
                }
            },

            updateActionButtons() {
                // Update button texts by finding buttons with specific onclick handlers
                const updateButton = (selector, translationKey) => {
                    const btn = document.querySelector(selector);
                    if (btn) btn.textContent = this.t(translationKey);
                };

                // Update form action buttons
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    const text = btn.textContent.trim();
                    if (text.includes('Save Order')) btn.textContent = this.t('saveOrderShortcut');
                    else if (text.includes('Duplicate Last')) btn.textContent = this.t('duplicateLast');
                    else if (text.includes('Same Day')) btn.textContent = this.t('sameDay');
                    else if (text.includes('Clear') && text.includes('Ctrl')) btn.textContent = this.t('clearFormShortcut');
                    else if (text.includes('Preview')) btn.textContent = `ğŸ‘ï¸ ${this.t('preview')}`;
                    else if (text.includes('Notify')) btn.textContent = this.t('notifyTeam');
                    else if (text.includes('Send Manager')) btn.textContent = this.t('sendReport');
                });
            },

            // Helper function to get translations
            t(key) {
                const lang = this.data.settings.language || 'en';
                return translations[lang][key] || translations.en[key] || key;
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    // FIXED: Get all data attributes from the same element to avoid mismatched selections
                    const actionElement = e.target.closest('[data-action]');
                    if (!actionElement) return;

                    const action = actionElement.dataset.action;
                    const id = actionElement.dataset.id;
                    const type = actionElement.dataset.type;

                    // Log only relevant data for each action type
                    const actionsNeedingIdType = ['edit', 'delete', 'print', 'quickAction'];
                    if (actionsNeedingIdType.includes(action)) {
                        console.log('ğŸ–±ï¸ Button clicked - Action:', action, 'ID:', id, 'Type:', type);
                    } else {
                        console.log('ğŸ–±ï¸ Button clicked - Action:', action);
                    }

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;

        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            container.innerHTML = '';
            return;
        }

        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">${this.t('dayNumber')} ${i + 1} - ${dateStr}</h4>

                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>

                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ${this.t('addFunctionToThisDay')}
                    </button>
                </div>
            `;
        }

        container.innerHTML = html;

        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;

        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }

        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;

        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            venue: '',
            transport: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });

        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">${this.t('functionNumber')} ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">${this.t('removeFunction')}</button>` : ''}
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('functionType')}</label>
                        <select id="${functionId}Type" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                            <option value="">Select Event Type</option>
                            ${(this.data.eventsList || []).map(event => `<option value="${event}">${event}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('timeSlot')}</label>
                        <input type="text" id="${functionId}Time" class="form-input highlight-datetime"
                               placeholder="${this.t('enterTimeSlot')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('venue')}</label>
                        <input type="text" id="${functionId}Venue" class="form-input"
                               placeholder="Enter venue address"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'venue', this.value)">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Transport (Multiple)</label>
                        <select id="${functionId}Transport" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'transport', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                            <option value="New Bolero">New Bolero</option>
                            <option value="Old Bolero">Old Bolero</option>
                            <option value="Isuzu">Isuzu</option>
                            <option value="Porter">Porter</option>
                            <option value="Other">Other</option>
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple transports</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('driver')} (Multiple)</label>
                        <select id="${functionId}Driver" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple drivers</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('operator')}</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">${this.t('selectOperator')}</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('helpers')}</label>
                        <input type="text" id="${functionId}Helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)"
                               oninput="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value.trim())">
                        <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('notes')}</label>
                    <textarea id="${functionId}Notes" class="form-textarea"
                              placeholder="${this.t('functionNotes')}"
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('items')}</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input"
                               placeholder="${this.t('searchItems')}" autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">${this.t('noItemsAdded')}</div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">ğŸ—‘ï¸</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">ğŸ—‘ï¸</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); this.saveOrder(); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); this.clearForm(); },
                            'd': () => { e.preventDefault(); this.clearForm(); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.add('show');
                backdrop.classList.add('show');

                // Add Escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideShortcuts();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                panel._escapeHandler = escapeHandler;
            },

            hideShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.remove('show');
                backdrop.classList.remove('show');

                // Remove escape handler
                if (panel._escapeHandler) {
                    document.removeEventListener('keydown', panel._escapeHandler);
                    panel._escapeHandler = null;
                }
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    const form = document.getElementById('orderForm');
                    if (form && this.hasUnsavedChanges()) {
                        localStorage.setItem('oms_draft', JSON.stringify(this.collectFormData()));
                        // Silent auto-save (no console spam)
                    }
                }, 2000); // Auto-save every 2 seconds
            },

            hasUnsavedChanges() {
                return Utils.get('clientName') || this.currentOrderItems.length > 0;
            },

            checkForDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        // Only show restore option if draft has meaningful data
                        if (draftData.clientName || (draftData.items && draftData.items.length > 0)) {
                            const draftDate = new Date(draftData.createdAt || Date.now()).toLocaleString();
                            const message = `
                                <div style="text-align: left;">
                                    <h3 style="margin-top: 0;">ğŸ“‹ Draft Order Found</h3>
                                    <p>You have an unsaved draft from: <strong>${draftDate}</strong></p>
                                    <p><strong>Client:</strong> ${draftData.clientName || 'Not specified'}</p>
                                    <p><strong>Items:</strong> ${draftData.items?.length || 0} items</p>
                                    <p>Would you like to restore this draft?</p>
                                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                                        <button class="btn btn-success" onclick="OMS.restoreDraft(); OMS.closeModal('draftModal');">âœ… Restore Draft</button>
                                        <button class="btn btn-danger" onclick="OMS.discardDraft(); OMS.closeModal('draftModal');">ğŸ—‘ï¸ Discard Draft</button>
                                        <button class="btn btn-secondary" onclick="OMS.closeModal('draftModal');">â­ï¸ Ignore for Now</button>
                                    </div>
                                </div>
                            `;

                            // Show modal with draft info
                            const modalHTML = `
                                <div class="modal show" id="draftModal" onclick="if(event.target === this) document.getElementById('draftModal').remove()">
                                    <div class="modal-content" style="max-width: 500px;">
                                        ${message}
                                    </div>
                                </div>
                            `;
                            document.body.insertAdjacentHTML('beforeend', modalHTML);
                        }
                    } catch (error) {
                        console.error('Error checking draft:', error);
                    }
                }
            },

            restoreDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        console.log('ğŸ“‹ Restoring draft:', draftData);

                        // Switch to orders tab
                        this.switchTab('orders');

                        // Wait for tab to be visible
                        setTimeout(() => {
                            // Populate form fields
                            if (draftData.clientName) Utils.set('clientName', draftData.clientName);
                            if (draftData.contact) Utils.set('contact', draftData.contact);
                            if (draftData.venue) Utils.set('venue', draftData.venue);
                            if (draftData.eventType) Utils.set('eventType', draftData.eventType);
                            if (draftData.date) Utils.set('orderDate', draftData.date);
                            if (draftData.readyTime) Utils.set('readyTime', draftData.readyTime);
                            if (draftData.transport) Utils.set('transport', draftData.transport);
                            if (draftData.driverName) Utils.set('driverName', draftData.driverName);
                            if (draftData.operator) Utils.set('operator', draftData.operator);
                            if (draftData.status) Utils.set('orderStatus', draftData.status);
                            if (draftData.notes) Utils.set('notes', draftData.notes);

                            // Restore multiday data if exists
                            if (draftData.isMultiDay) {
                                Utils.set('eventTypeSelect', 'multi');
                                if (draftData.startDate) Utils.set('startDate', draftData.startDate);
                                if (draftData.endDate) Utils.set('endDate', draftData.endDate);

                                // Trigger multiday form generation
                                const event = new Event('change');
                                document.getElementById('eventTypeSelect')?.dispatchEvent(event);

                                // Restore day-wise data after form is generated
                                if (draftData.dayWiseData) {
                                    setTimeout(() => {
                                        window.dayFunctionsData = draftData.dayWiseData;
                                        console.log('ğŸ“… Restored multiday data with items');
                                    }, 500);
                                }
                            } else {
                                // Restore items for single-day events only
                                if (draftData.items && Array.isArray(draftData.items) && draftData.items.length > 0) {
                                    console.log('ğŸ“¦ Restoring items:', draftData.items);
                                    this.currentOrderItems = [...draftData.items];
                                    this.updateOrderItemsList();
                                }
                            }

                            this.showToast('âœ… Draft restored successfully!', 'success');
                        }, 100);

                    } catch (error) {
                        console.error('Error restoring draft:', error);
                        this.showToast('âŒ Error restoring draft', 'error');
                    }
                }
            },

            discardDraft() {
                localStorage.removeItem('oms_draft');
                this.showToast('ğŸ—‘ï¸ Draft discarded', 'info');
                console.log('ğŸ—‘ï¸ Draft discarded by user');
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('âœ… Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('âœ… Auto-backup created successfully');
                    this.showToast('ğŸ“¦ Auto-backup created', 'success');
                } catch (error) {
                    console.error('âŒ Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('ğŸ“¥ Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            // ========== GLOBAL SEARCH (Delegated to GlobalSearch module) ==========
            initGlobalSearch() {
                GlobalSearch.init(this);
            },

            performGlobalSearch(query) {
                return GlobalSearch.performSearch(query, this.data);
            },

            displayGlobalSearchResults(results) {
                GlobalSearch.displayResults(results, this);
            },

            navigateToResult(type, id) {
                GlobalSearch.navigateToResult(type, id, this);
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('ğŸ”¥ Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`ğŸ”¥ Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('ğŸ§© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    // FIXED: Search by docId first (always unique), then orderId as fallback
    const index = this.data.orders.findIndex(o => o.docId === id || o.orderId === id);
    if (index === -1) {
        console.warn('âš ï¸ Order not found in local array:', id);
        return false;
    }

    try {
        console.log('ğŸ”„ Attempting to delete orderId:', id);

        // Use the actual docId from the found order
        const orderToDelete = this.data.orders[index];
        const docRef = db.collection('orders').doc(orderToDelete.docId || id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('âœ… Deleted Firestore doc with ID:', id);
        } else {
            console.warn('âš ï¸ No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`ğŸ“ Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('âŒ Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                // Track deleted category to prevent re-addition
                if (!this.data.inventory.deletedCategories) {
                    this.data.inventory.deletedCategories = [];
                }
                if (!this.data.inventory.deletedCategories.includes(id)) {
                    this.data.inventory.deletedCategories.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('âŒ Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                // Track deleted item to prevent re-addition
                if (!this.data.inventory.deletedItems) {
                    this.data.inventory.deletedItems = [];
                }
                if (!this.data.inventory.deletedItems.includes(id)) {
                    this.data.inventory.deletedItems.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('âŒ Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();

        // Reload data from Firestore to ensure all tabs are in sync
        await this.loadOrdersFromFirestore();

        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        console.log('ğŸ” EditItem called with ID:', id);
                        console.log('ğŸ“‹ All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                        // FIXED: Search by docId first (always unique), then orderId as fallback
                        const order = this.data.orders.find(o => o.docId === id || o.orderId === id);
                        console.log('âœ… Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                        if (!order) return;
                        this.switchTab('orders');
                        this.loadOrderToForm(order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
},

            async updateWeatherMiniDashboard() {
                try {
                    const city = this.data.settings.city || 'Delhi';
                    const apiKey = this.data.settings.weatherApiKey || '';
                    const weather = await Utils.getWeather(city, apiKey);

                    const iconElement = document.querySelector('.weather-mini-icon');
                    const tempElement = document.querySelector('.weather-mini-temp');
                    const conditionElement = document.querySelector('.weather-mini-condition');

                    if (iconElement && tempElement && conditionElement) {
                        iconElement.textContent = Utils.getWeatherEmoji(weather.condition);
                        tempElement.textContent = weather.temp !== 'N/A' ? `${weather.temp}Â°C` : '--Â°C';
                        conditionElement.textContent = weather.condition !== 'N/A' ? weather.condition : 'Loading...';
                    }
                } catch (error) {
                    console.error('Error updating weather mini dashboard:', error);
                }
            },

            // ========== ORDER UTILITIES (Delegated to OrderUtils service) ==========
            getNextOrderId() {
                return OrderUtils.getNextOrderId(this.data.settings);
            },

            incrementOrderCounter() {
                const newId = OrderUtils.incrementOrderCounter(this.data.settings);
                this.refreshOrderId();
                return newId;
            },

   // ========== ORDER FORM (Delegated to OrderForm service) ==========
   collectFormData() {
        return OrderForm.collectFormData(this);
    },

    extractLocationFromMapsLink(link) {
        return OrderForm.extractLocationFromMapsLink(link);
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('âœ… Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('âš ï¸ Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('â³ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('ğŸ’¾ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('âœï¸ Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('âœï¸ Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Calculate total amount from items
        const totalAmount = orderData.isMultiDay
            ? (orderData.dayWiseData || []).reduce((sum, day) => {
                const dayTotal = (day.functions || []).reduce((daySum, func) => {
                    const funcTotal = (func.items || []).reduce((itemSum, item) => {
                        return itemSum + ((item.price || 0) * (item.quantity || 0));
                    }, 0);
                    return daySum + funcTotal;
                }, 0);
                return sum + dayTotal;
            }, 0)
            : (orderData.items || []).reduce((sum, item) => {
                return sum + ((item.price || 0) * (item.quantity || 0));
            }, 0);

        console.log('ğŸ’° Calculated total amount:', totalAmount);

        // Fetch weather data for the order
        let weatherData = null;
        try {
            // Get weather API key from settings (if stored) or use default
            const weatherApiKey = this.data.settings?.weatherApiKey || '';
            const defaultCity = this.data.settings?.defaultCity || 'Delhi';

            // Fetch weather data
            weatherData = await Utils.getWeather(defaultCity, weatherApiKey);
            console.log('ğŸŒ¤ï¸ Weather data fetched:', weatherData);
        } catch (error) {
            console.warn('âš ï¸ Could not fetch weather data:', error);
        }

        // Add weather data to orderData
        orderData.weather = weatherData;

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    totalAmount: totalAmount,  // CRITICAL: Add totalAmount field
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    venueMapLink: orderData.venueMapLink || null,  // CRITICAL: Save venue map link
    venueLocation: orderData.venueLocation || null, // CRITICAL: Save venue coordinates
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    transport2: orderData.transport2 || '',
    driverName2: orderData.driverName2 || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    weather: weatherData,  // Add weather data
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('âœï¸ Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('ğŸ”„ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('ğŸ—‘ï¸ Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('âœ… Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} â†’ ${finalOrderId} âœ…`);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('âœ… Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            totalAmount: totalAmount  // Include totalAmount in local data
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        // ITEM HISTORY TRACKING (if order is now completed)
        if (status === 'completed') {
            if (orderData.items && orderData.items.length > 0) {
                this.recordItemHistory(orderData.items, orderData);
            }

            // For multi-day orders, track items from dayWiseData
            if (orderData.isMultiDay && orderData.dayWiseData) {
                orderData.dayWiseData.forEach(day => {
                    day.functions.forEach(func => {
                        if (func.items && func.items.length > 0) {
                            this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                        }
                    });
                });
            }
        }

        this.showToast('Order updated! âœï¸');

        // Auto-clear form after update
        this.clearForm(true);
    }

    // Save new custom events to the list
    await this.addCustomEventsToList(orderData);

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;

} else {
            // CREATE new order
            console.log('ğŸ†• Creating new order');

            // Save to Firestore
            console.log('ğŸ’¾ Saving to Firestore - venue data:', {
                venue: firestoreData.venue,
                venueLocation: firestoreData.venueLocation,
                venueMapLink: firestoreData.venueMapLink
            });

            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
                console.log('âœ… Saved with FP ID:', finalOrderId);
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('âœ… Saved with auto ID:', docRef.id);
            }

            // Verify what was actually saved
            console.log('âœ… venueLocation saved:', !!firestoreData.venueLocation, firestoreData.venueLocation);
            console.log('âœ… venueMapLink saved:', !!firestoreData.venueMapLink, firestoreData.venueMapLink);

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
    console.log('âœ… Order added to local array with totalAmount:', totalAmount);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION & ITEM HISTORY TRACKING (if order is completed)
                if (status === 'completed') {
                    if (orderData.items && orderData.items.length > 0) {
                        this.deductInventory(orderData.items, orderData.orderId);
                        this.recordItemHistory(orderData.items, orderData);
                    }

                    // For multi-day orders, track items from dayWiseData
                    if (orderData.isMultiDay && orderData.dayWiseData) {
                        orderData.dayWiseData.forEach(day => {
                            day.functions.forEach(func => {
                                if (func.items && func.items.length > 0) {
                                    this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                                }
                            });
                        });
                    }
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! ğŸ†•`);

                // Auto-clear form after save
                this.clearForm(true);
                this.refreshOrderId();

                // Save new custom events to the list
                await this.addCustomEventsToList(orderData);

                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('âŒ Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

async addCustomEventsToList(orderData) {
    try {
        const newEvents = new Set();

        // Collect event from single-day order
        if (!orderData.isMultiDay && orderData.eventType && orderData.eventType.trim()) {
            const event = orderData.eventType.trim();
            if (!this.data.eventsList.includes(event)) {
                newEvents.add(event);
            }
        }

        // Collect events from multi-day order functions
        if (orderData.isMultiDay && orderData.dayWiseData) {
            orderData.dayWiseData.forEach(day => {
                if (day.functions) {
                    day.functions.forEach(func => {
                        if (func.functionType && func.functionType.trim()) {
                            const event = func.functionType.trim();
                            if (!this.data.eventsList.includes(event)) {
                                newEvents.add(event);
                            }
                        }
                    });
                }
            });
        }

        // Add new events to the list
        if (newEvents.size > 0) {
            newEvents.forEach(event => {
                this.data.eventsList.push(event);
            });

            // Sort alphabetically
            this.data.eventsList.sort();

            // Save to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                updatedAt: new Date().toISOString()
            });

            // Refresh the datalist
            this.populateEventsDatalist();

            console.log('âœ… Added new custom events:', Array.from(newEvents));
        }
    } catch (error) {
        console.error('Error saving custom events:', error);
    }
},

populateEventsDatalist() {
    console.log('ğŸ” populateEventsDatalist called');

    const eventTypeSelect = document.getElementById('eventType');
    if (!eventTypeSelect) {
        console.warn('âš ï¸ eventType element not found - will populate when orders tab is opened');
        return;
    }

    // Check if eventsList is defined
    if (!this.data.eventsList || !Array.isArray(this.data.eventsList)) {
        console.error('âŒ eventsList not initialized!', {
            exists: !!this.data.eventsList,
            isArray: Array.isArray(this.data.eventsList),
            length: this.data.eventsList?.length
        });
        // Try to initialize with default list
        this.data.eventsList = [
            'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
            'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
            'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
            'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
            'Ganesh Agman', 'Ganesh Visarjan'
        ];
        console.log('âœ… Initialized default events list with', this.data.eventsList.length, 'events');
    }

    console.log(`ğŸ“‹ Populating dropdown with ${this.data.eventsList.length} events`);

    // Get current value to preserve selection
    const currentValue = eventTypeSelect.value;

    // Clear existing options except the first one
    eventTypeSelect.innerHTML = '<option value="">Select Event Type</option>';

    // Add all events as options
    this.data.eventsList.forEach((event, index) => {
        const option = document.createElement('option');
        option.value = event;
        option.textContent = event;
        eventTypeSelect.appendChild(option);
        if (index < 3) {
            console.log(`  âœ“ Added option: ${event}`);
        }
    });

    // Restore previous selection if it exists
    if (currentValue && this.data.eventsList.includes(currentValue)) {
        eventTypeSelect.value = currentValue;
    }

    console.log(`âœ…âœ… Events dropdown fully populated! Total options: ${eventTypeSelect.options.length}`);
    console.log(`   First 5 options:`, Array.from(eventTypeSelect.options).slice(0, 5).map(o => o.value));
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`ğŸ“¦ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} â†’ ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`âš ï¸ LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`ğŸš¨ CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Item Usage History Tracking (for completed orders only)
async recordItemHistory(items, orderData, specificDate = null, functionType = null) {
    if (!items || items.length === 0) return;

    console.log(`ğŸ“œ Recording item history for order ${orderData.orderId}`);

    const usedAt = new Date().toISOString();
    const eventDate = specificDate || orderData.date || orderData.startDate;

    for (const item of items) {
        const historyRecord = {
            itemName: item.name,
            quantity: item.quantity,
            orderId: orderData.orderId,
            clientName: orderData.clientName,
            venue: orderData.venue,
            eventDate: eventDate,
            functionType: functionType || orderData.eventType || '',
            usedAt: usedAt,
            remarks: item.remarks || ''
        };

        // Add to local array
        this.data.itemHistory.push(historyRecord);

        // Save to Firestore
        try {
            await db.collection('itemHistory').add(historyRecord);
            console.log(`âœ… Saved item history: ${item.name} x${item.quantity} for order ${orderData.orderId}`);
        } catch (error) {
            console.error('âŒ Error saving item history to Firestore:', error);
        }
    }

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`ğŸ“ Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
async getCurrentUser() {
    // If already loaded, return cached user
    if (this.data.currentUser && this.data.currentUser.roleLoaded) {
        return this.data.currentUser;
    }

    // Get Firebase Auth user
    const authUser = auth.currentUser;
    if (!authUser) {
        console.warn('âš ï¸ No authenticated user found');
        return null;
    }

    try {
        // Fetch user role from Firestore
        const userRoleDoc = await db.collection('user_roles').doc(authUser.uid).get();

        let role = 'staff'; // Default role
        let email = authUser.email;
        let name = authUser.displayName || authUser.email;

        if (userRoleDoc.exists) {
            const roleData = userRoleDoc.data();
            role = roleData.role || 'staff';
            name = roleData.name || name;
            console.log('âœ… User role loaded from Firestore:', role, 'for', email);
        } else {
            // If no role exists, user defaults to 'staff' with limited access
            // Only admin/owner can create roles in Firestore via admin panel
            console.warn('âš ï¸ No role document found for:', email);
            console.warn('âš ï¸ User defaulted to "staff" role with limited access.');
            console.warn('âš ï¸ Admin must create role in Firestore: user_roles/' + authUser.uid);
        }

        this.data.currentUser = {
            id: authUser.uid,
            email: email,
            name: name,
            role: role,
            roleLoaded: true,
            permissions: this.getRolePermissions(role)
        };

        return this.data.currentUser;
    } catch (error) {
        console.error('âŒ Error loading user role:', error);
        console.error('Full error:', error);
        // Fallback to staff role if error occurs
        this.data.currentUser = {
            id: authUser.uid,
            email: authUser.email,
            name: authUser.displayName || authUser.email,
            role: 'staff',
            roleLoaded: true,
            permissions: this.getRolePermissions('staff')
        };
        return this.data.currentUser;
    }
},

// Force refresh user role from Firestore (bypasses cache)
async refreshUserRole() {
    console.log('ğŸ”„ Force refreshing user role from Firestore...');
    this.data.currentUser = null; // Clear cache
    const user = await this.getCurrentUser();
    console.log('âœ… User role refreshed:', user?.role);
    return user;
},

// Get permissions for a role
getRolePermissions(role) {
    const permissions = {
        admin: ['all'],
        owner: ['all'],
        staff: ['orders.view', 'orders.create', 'inventory.view', 'customers.view', 'team.view']
    };
    return permissions[role] || permissions.staff;
},

// Check if current user has permission
async hasPermission(permission) {
    const user = await this.getCurrentUser();
    if (!user) return false;

    // Admin and owner have all permissions
    if (user.role === 'admin' || user.role === 'owner') {
        return true;
    }

    // Check specific permission
    return user.permissions.includes(permission) || user.permissions.includes('all');
},

// Check if user can view financials
async canViewFinancials() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

// Check if user is admin or owner
async isAdminOrOwner() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Clear the form first to prevent data mixing between orders
        const wasCleared = !this.hasUnsavedChanges();
        if (!wasCleared) {
            // Clear without confirmation since we're loading a different order
            document.getElementById('orderForm').reset();
            this.currentOrderItems = [];
            this.updateOrderItemsTable();
            window.dayFunctionsData = {};

            // Clear multiday containers
            const multiDayContainer = document.getElementById('multiDayContainer');
            if (multiDayContainer) multiDayContainer.innerHTML = '';
            const functionsContainer = document.getElementById('functionsContainer');
            if (functionsContainer) functionsContainer.innerHTML = '';
        }

        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('ğŸ” Loading order to form:', order);
        console.log('ğŸ” Order status:', order.status);
        console.log('ğŸ” Is Multi-Day:', order.isMultiDay);

        // Show merged order indicator if this is a merged order
        if (order.mergedFrom && order.mergedFrom.length > 0) {
            const mergedOrderIds = order.mergedFrom.map(m => m.orderId).join(', ');
            this.showToast(`ğŸ”— MERGED ORDER: This order was created by merging ${order.mergedFrom.length} orders (${mergedOrderIds})`, 'info', 8000);
            console.log('ğŸ”— This is a MERGED order from:', order.mergedFrom);
        }

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('ğŸ“… Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const venueInput = document.getElementById(`${functionId}Venue`);
                                        const transportSelect = document.getElementById(`${functionId}Transport`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (venueInput) venueInput.value = func.venue || '';

                                        // Handle multi-select fields (transport, driver, helper)
                                        if (transportSelect && func.transport) {
                                            const transports = func.transport.split(',').map(t => t.trim());
                                            Array.from(transportSelect.options).forEach(option => {
                                                option.selected = transports.includes(option.value);
                                            });
                                        }

                                        if (driverSelect && func.driver) {
                                            const drivers = func.driver.split(',').map(d => d.trim());
                                            Array.from(driverSelect.options).forEach(option => {
                                                option.selected = drivers.includes(option.value);
                                            });
                                        }

                                        if (operatorSelect) operatorSelect.value = func.operator || '';

                                        if (helperSelect && func.helper) {
                                            helperSelect.value = func.helper;
                                        }

                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'venue', func.venue || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'transport', func.transport || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            // IMPORTANT: Normalize item fields for consistency
                                            window.dayFunctionsData[dayIndex][funcIndex].items = func.items.map(item => ({
                                                name: item.name || '',
                                                quantity: item.quantity || item.qty || 0,
                                                remarks: item.remarks || item.desc || '',
                                                price: item.price || 0
                                            }));
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('âœ… Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order
            // IMPORTANT: Set event type to single day first to ensure proper form display
            Utils.set('eventTypeSelect', 'single');

            // Show single day fields, hide multiday fields
            const singleDayFields = document.getElementById('singleDayFields');
            const multiDayFields = document.getElementById('multiDayFields');
            if (singleDayFields) singleDayFields.style.display = 'grid';
            if (multiDayFields) multiDayFields.style.display = 'none';

            // Trigger event type change to update required fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                transport2: order.transport2 && ['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : (order.transport2 ? 'Other' : ''),
                customTransport2: order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : '',
                driverName2: order.driverName2 || '',
                operator: order.operator,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Load helper names to text input
            if (order.helper) {
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.value = order.helper;
                }
            }

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            if (order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2)) {
                document.getElementById('customTransport2Group').classList.remove('hidden');
            }

            // IMPORTANT: Normalize item fields to ensure consistency
            // Items from Firestore might use 'qty' but UI expects 'quantity'
            this.currentOrderItems = order.items ? order.items.map(item => ({
                name: item.name || '',
                quantity: item.quantity || item.qty || 0, // Support both field names
                remarks: item.remarks || item.desc || '', // Support both field names
                price: item.price || 0
            })) : [];

            console.log(`ğŸ“‹ Loaded ${this.currentOrderItems.length} items for order`, {
                orderId: order.orderId,
                sampleItem: this.currentOrderItems[0],
                isMerged: !!order.mergedFrom
            });

            this.updateOrderItemsTable();

            // Show original orders cards if this is a merged order
            this.renderOriginalOrdersCards(order);
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            // Render editable cards for original orders in a merged order
            renderOriginalOrdersCards(order) {
                const container = document.getElementById('originalOrdersContainer');

                // If container doesn't exist yet, create it
                if (!container) {
                    const orderForm = document.getElementById('orderForm');
                    if (orderForm) {
                        const newContainer = document.createElement('div');
                        newContainer.id = 'originalOrdersContainer';
                        newContainer.style.marginTop = '2rem';
                        orderForm.parentNode.insertBefore(newContainer, orderForm.nextSibling);
                    }
                }

                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (!originalOrdersContainer) return;

                // Check if this is a merged order
                if (!order.mergedFrom || order.mergedFrom.length === 0) {
                    originalOrdersContainer.innerHTML = '';
                    return;
                }

                console.log('ğŸ”— Rendering original orders cards for merged order:', order.orderId);

                // Generate HTML for original orders cards
                const cardsHTML = `
                    <div class="card" style="margin-top: 2rem; background: #f9f9f9; border: 2px solid #667eea;">
                        <div class="card-header" style="background: #667eea; color: white; padding: 1rem;">
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                                ğŸ”— ORIGINAL ORDERS (${order.mergedFrom.length})
                            </h3>
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; opacity: 0.9;">
                                You can edit each original order's details below and save changes individually
                            </p>
                        </div>
                        <div style="padding: 1.5rem;">
                            ${order.mergedFrom.map((originalOrder, index) => this.renderOriginalOrderCard(originalOrder, index)).join('')}
                        </div>
                    </div>
                `;

                originalOrdersContainer.innerHTML = cardsHTML;
            },

            renderOriginalOrderCard(originalOrderData, index) {
                const order = originalOrderData.orderData;
                const cardId = `originalOrder_${index}`;

                // Get items list
                const itemsList = order.items && order.items.length > 0
                    ? order.items.map(item => `${item.name} x${item.quantity || item.qty || 0}`).join(', ')
                    : 'No items';

                return `
                    <div class="card" style="margin-bottom: 1.5rem; background: white; border: 1px solid #ddd;" id="${cardId}">
                        <div style="background: #f5f5f5; padding: 1rem; border-bottom: 2px solid #ddd;">
                            <h4 style="margin: 0; color: #667eea; display: flex; justify-content: space-between; align-items: center;">
                                ğŸ“‹ Order: ${order.orderId}
                                <button type="button" class="btn btn-small"
                                        style="background: #667eea; color: white;"
                                        onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                    âœï¸ Edit
                                </button>
                            </h4>
                        </div>

                        <!-- View Mode -->
                        <div id="${cardId}_view" style="padding: 1.5rem;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>ğŸ“… Date:</strong> ${order.date || 'N/A'}</div>
                                <div><strong>â° Ready Time:</strong> ${order.readyTime || 'N/A'}</div>
                                <div><strong>ğŸ‘¤ Client:</strong> ${order.clientName || 'N/A'}</div>
                                <div><strong>ğŸ“ Contact:</strong> ${order.contact || 'N/A'}</div>
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <strong>ğŸ“ Venue:</strong> ${order.venue || 'N/A'}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>ğŸš— Transport:</strong> ${order.transport || 'N/A'}</div>
                                <div><strong>ğŸš˜ Driver:</strong> ${order.driverName || 'N/A'}</div>
                                <div><strong>ğŸ¬ Operator:</strong> ${order.operator || 'N/A'}</div>
                                <div><strong>ğŸ‘· Helper:</strong> ${order.helper || 'N/A'}</div>
                            </div>
                            <div style="padding: 1rem; background: #f9f9f9; border-radius: 4px;">
                                <strong>ğŸ“¦ Items:</strong> ${itemsList}
                            </div>
                            ${order.notes ? `<div style="margin-top: 1rem;"><strong>ğŸ“ Notes:</strong><br>${order.notes}</div>` : ''}
                        </div>

                        <!-- Edit Mode (Hidden by default) -->
                        <div id="${cardId}_edit" style="display: none; padding: 1.5rem; background: #fefefe;">
                            <form onsubmit="OMS.saveOriginalOrder(event, ${index}, '${order.docId}')">
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ğŸ“… Date</label>
                                        <input type="date" class="form-input" id="${cardId}_date" value="${order.date || ''}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">â° Ready Time</label>
                                        <input type="text" class="form-input" id="${cardId}_readyTime" value="${order.readyTime || ''}" placeholder="e.g., 10:00 AM">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">ğŸ“ Venue</label>
                                    <input type="text" class="form-input" id="${cardId}_venue" value="${order.venue || ''}" required>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ğŸš— Transport</label>
                                        <input type="text" class="form-input" id="${cardId}_transport" value="${order.transport || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">ğŸš˜ Driver</label>
                                        <input type="text" class="form-input" id="${cardId}_driverName" value="${order.driverName || ''}">
                                    </div>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ğŸ¬ Operator</label>
                                        <input type="text" class="form-input" id="${cardId}_operator" value="${order.operator || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">ğŸ‘· Helper</label>
                                        <input type="text" class="form-input" id="${cardId}_helper" value="${order.helper || ''}">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">ğŸ“ Notes</label>
                                    <textarea class="form-textarea" id="${cardId}_notes" rows="3">${order.notes || ''}</textarea>
                                </div>

                                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                                    <button type="button" class="btn btn-secondary" onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                        Cancel
                                    </button>
                                    <button type="submit" class="btn btn-success">
                                        ğŸ’¾ Save Changes
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
            },

            toggleOriginalOrderEdit(cardId) {
                const viewMode = document.getElementById(`${cardId}_view`);
                const editMode = document.getElementById(`${cardId}_edit`);

                if (viewMode && editMode) {
                    const isEditing = editMode.style.display !== 'none';
                    viewMode.style.display = isEditing ? 'block' : 'none';
                    editMode.style.display = isEditing ? 'none' : 'block';
                }
            },

            async saveOriginalOrder(event, index, docId) {
                event.preventDefault();
                const cardId = `originalOrder_${index}`;

                try {
                    // Collect form data
                    const updatedData = {
                        date: Utils.get(`${cardId}_date`),
                        readyTime: Utils.get(`${cardId}_readyTime`),
                        venue: Utils.get(`${cardId}_venue`),
                        transport: Utils.get(`${cardId}_transport`),
                        driverName: Utils.get(`${cardId}_driverName`),
                        operator: Utils.get(`${cardId}_operator`),
                        helper: Utils.get(`${cardId}_helper`),
                        notes: Utils.get(`${cardId}_notes`)
                    };

                    console.log('ğŸ’¾ Saving original order changes:', docId, updatedData);

                    // Get the full order from Firestore
                    const orderDoc = await db.collection('orders').doc(docId).get();
                    if (!orderDoc.exists) {
                        throw new Error('Order not found in Firestore');
                    }

                    const fullOrder = orderDoc.data();

                    // Update with new data
                    const updatedOrder = {
                        ...fullOrder,
                        ...updatedData,
                        updatedAt: new Date().toISOString()
                    };

                    // Save to Firestore
                    await db.collection('orders').doc(docId).update(updatedOrder);

                    this.showToast(`âœ… Order updated successfully!`, 'success');

                    // Toggle back to view mode
                    this.toggleOriginalOrderEdit(cardId);

                    // Reload orders to refresh display
                    await this.loadOrdersFromFirestore();

                    // Reload the current merged order
                    const currentOrder = this.data.orders.find(o => o.docId === this.editingDocId);
                    if (currentOrder) {
                        this.loadOrderToForm(currentOrder);
                    }

                } catch (error) {
                    console.error('âŒ Error saving original order:', error);
                    this.showToast(`Error: ${error.message}`, 'error');
                }
            },

            clearForm(skipConfirmation = false) {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (!skipConfirmation && this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();

                // Clear original orders cards
                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (originalOrdersContainer) {
                    originalOrdersContainer.innerHTML = '';
                }
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');
                document.getElementById('customTransport2Group').classList.add('hidden');

                // Clear venue location data from autocomplete
                window.selectedPlaceData = null;

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'grid';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Trigger event type change to update required fields
                const eventTypeSelect = document.getElementById('eventTypeSelect');
                if (eventTypeSelect) {
                    const event = new Event('change');
                    eventTypeSelect.dispatchEvent(event);
                }

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                // Clear functions container for multiday events
                const functionsContainer = document.getElementById('functionsContainer');
                if (functionsContainer) {
                    functionsContainer.innerHTML = '';
                }

                // Hide day-wise functions section
                const dayWiseFunctions = document.getElementById('dayWiseFunctions');
                if (dayWiseFunctions) {
                    dayWiseFunctions.style.display = 'none';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`âœ… Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                this.loadOrderToForm(lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                // Preview doesn't require validation - just show what's been filled
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong>Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong>Driver 2:</strong> ${order.driverName2}<br>` : ''}
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }

                // ============ START ENHANCED FILTERING WITH LOGGING & VALIDATION ============
                const startTime = performance.now();

                // Normalize the target date using fuzzy matcher
                const normalizedDate = fuzzyDateMatcher.normalize(date);
                filterLogger.log('filter_started', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                // IMPROVED FILTER: Include ALL order types for selected date with fuzzy matching
                const matchedOrders = [];
                const filterDetails = {
                    singleDayMatches: 0,
                    multiDayRangeMatches: 0,
                    dayWiseDataMatches: 0,
                    fuzzyMatches: 0,
                    skipped: 0
                };

                let orders = this.data.orders.filter(o => {
                    // Case 1: Single-day order with matching date (use fuzzy matcher)
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            filterDetails.singleDayMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    // Case 2: Multi-day order WITH dayWiseData - check specific day functions (PRIORITY)
                    if (o.isMultiDay && o.dayWiseData && Array.isArray(o.dayWiseData) && o.dayWiseData.length > 0) {
                        const hasMatch = o.dayWiseData.some(day => fuzzyDateMatcher.matches(day.date, date));
                        if (hasMatch) {
                            filterDetails.dayWiseDataMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                        // If order has dayWiseData but no match, skip it (don't fall through to range check)
                        filterDetails.skipped++;
                        return false;
                    }

                    // Case 3: Multi-day order WITHOUT dayWiseData - fallback to range check
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            filterDetails.multiDayRangeMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    filterDetails.skipped++;
                    return false;
                });

                // Calculate performance metrics
                const endTime = performance.now();
                const filterTime = (endTime - startTime).toFixed(2);

                // Log detailed filter results
                filterLogger.log('filter_completed', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    matchedCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    filterTimeMs: filterTime,
                    breakdown: filterDetails,
                    matchedOrderIds: orders.map(o => o.orderId || o.docId)
                });

                // Record pattern for learning
                patternLearner.recordFilterResult(
                    normalizedDate,
                    orders.length,
                    this.data.orders.length,
                    'downloadSameDayOrders'
                );

                // APPLY LEARNING RULES FROM PREVIOUS USER FEEDBACK (if enabled)
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false'; // Default: enabled for backward compatibility
                let finalOrders = orders;
                let hasCorrections = false;

                if (mlEnabled) {
                    const learningResult = filterRatingSystem.applyLearningRules(
                        normalizedDate,
                        orders,
                        this.data.orders
                    );

                    finalOrders = learningResult.orders;
                    hasCorrections = learningResult.corrections.length > 0;

                    if (hasCorrections) {
                        console.log(`ğŸ§  Smart Learning Applied: ${learningResult.corrections.length} corrections made based on your previous feedback`);
                        learningResult.corrections.forEach(correction => {
                            if (correction.type === 'added') {
                                console.log(`  âœ… Added: ${correction.order.orderId} - ${correction.reason}`);
                            } else if (correction.type === 'removed') {
                                console.log(`  âŒ Removed: ${correction.order.orderId} - ${correction.reason}`);
                            }
                        });
                        this.showToast(`ğŸ§  Smart filter applied ${learningResult.corrections.length} learned corrections`, 'info');
                    }
                } else {
                    console.log('ğŸ”‡ ML Corrections DISABLED - Using original filter results only');
                    console.log('ğŸ’¡ To enable: AdminUtils.enableML() or localStorage.setItem("oms_ml_enabled", "true")');
                }

                // STORE FILTER CONTEXT FOR RATING
                filterRatingSystem.setFilterContext({
                    date,
                    normalizedDate,
                    matchedOrders: finalOrders,
                    totalOrders: this.data.orders.length,
                    filterDetails,
                    allOrders: this.data.orders
                });

                // Validate results and show alerts
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: finalOrders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders: finalOrders,
                    allOrders: this.data.orders
                });
                orderValidator.showAlerts(validationResult, date);

                // Show enhanced console summary
                console.group(`ğŸ“Š Filter Summary for ${date}`);
                console.log(`âœ… Matched: ${finalOrders.length} orders in ${filterTime}ms`);
                if (hasCorrections) {
                    console.log(`ğŸ§  Corrections: ${learningResult.corrections.length} (from your previous ratings)`);
                }
                console.log(`ğŸ“‹ Breakdown:`, filterDetails);
                console.log(`ğŸ¯ Match rate: ${((finalOrders.length / this.data.orders.length) * 100).toFixed(1)}%`);

                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`ğŸ§  Expected based on learning: ~${expectedCount} orders`);
                }

                if (validationResult.length > 0) {
                    console.log(`âš ï¸ Validation alerts: ${validationResult.length}`);
                }

                // Show rating option in console
                console.log(`â­ To rate this filter result, use: AdminUtils.rateLastFilter()`);
                console.groupEnd();
                // ============ END ENHANCED FILTERING ============

                if (finalOrders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    // Still show rating UI for zero results (user can report this as wrong)
                    setTimeout(() => {
                        if (confirm('No orders found. Would you like to rate this filter result?')) {
                            filterRatingSystem.showRatingUI(this);
                        }
                    }, 500);
                    return;
                }

                // Replace orders with finalOrders for rest of the function
                orders = finalOrders;

                // âš ï¸ DEDUPLICATE: Remove duplicate orders (same docId or orderId)
                const seenDocIds = new Set();
                const seenOrderIds = new Set();
                const deduplicatedOrders = [];

                orders.forEach(order => {
                    const docId = order.docId;
                    const orderId = order.orderId;

                    // Skip if we've already seen this docId or orderId
                    if ((docId && seenDocIds.has(docId)) || (orderId && seenOrderIds.has(orderId))) {
                        console.warn(`âš ï¸ Skipping duplicate order: ${orderId || docId}`);
                        return;
                    }

                    // Mark as seen
                    if (docId) seenDocIds.add(docId);
                    if (orderId) seenOrderIds.add(orderId);

                    deduplicatedOrders.push(order);
                });

                if (deduplicatedOrders.length < orders.length) {
                    console.log(`ğŸ§¹ Removed ${orders.length - deduplicatedOrders.length} duplicate(s)`);
                }

                orders = deduplicatedOrders;

                // FILTER MULTIDAY ORDERS TO ONLY INCLUDE SELECTED DATE'S DATA
                const filteredOrders = orders.map(order => {
                    // For single-day orders, return as is
                    if (!order.isMultiDay) {
                        return order;
                    }

                    // For multiday orders, create a filtered copy with only the selected date's data
                    const filteredOrder = { ...order };

                    // Filter dayWiseData to only include the selected date (use fuzzy matcher for better matching)
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        filteredOrder.dayWiseData = order.dayWiseData.filter(day => fuzzyDateMatcher.matches(day.date, date));
                        console.log(`ğŸ” Multiday order ${order.orderId}: Filtered ${filteredOrder.dayWiseData.length}/${order.dayWiseData.length} days for date ${date}`);

                        // Log function and item counts for debugging
                        filteredOrder.dayWiseData.forEach((day, idx) => {
                            const funcCount = day.functions ? day.functions.length : 0;
                            const itemCount = day.functions ? day.functions.reduce((sum, f) => sum + (f.items?.length || 0), 0) : 0;
                            console.log(`  ğŸ“‹ Day ${day.dayNumber}: ${funcCount} functions, ${itemCount} total items`);
                        });
                    }

                    // Update the order to show only selected date info
                    filteredOrder.date = date;
                    filteredOrder.isMultiDay = false; // Treat as single day for display purposes

                    return filteredOrder;
                });

                console.log(`ğŸ“… Found ${filteredOrders.length} orders for ${date}:`, filteredOrders.map(o => o.orderId || o.clientName));
                console.log(`ğŸ’¡ To rate this filter result, use: AdminUtils.rateLastFilter() in console`);

                this.generateMultiOrderImage(filteredOrders, date);
            },

            downloadOrderImage(orderId) {
                // Search by docId first (always unique), then orderId as fallback
                const order = this.data.orders.find(o => o.docId === orderId || o.orderId === orderId);
                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }
                this.generateSingleOrderImage(order);
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? 'Generating image (mobile mode)...' : 'Generating image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Mobile optimization: Validate canvas dimensions before proceeding
                    const baseScale = this.data.settings.imageQuality || 2;
                    const optimizedScale = Utils.getOptimalCanvasScale(baseScale);

                    const canvasWidth = Math.round(paperDimensions.width * optimizedScale);
                    const canvasHeight = Math.round(paperDimensions.height * optimizedScale);

                    const validation = Utils.validateCanvasDimensions(canvasWidth, canvasHeight);
                    if (!validation.valid) {
                        this.hideLoading(loading);
                        this.showToast(`âš ï¸ ${validation.reason}. Please reduce image quality in settings.`, 'error');
                        console.error('Canvas validation failed:', validation.reason);
                        return;
                    }

                    if (isMobile && optimizedScale < baseScale) {
                        console.log(`ğŸ“± Mobile device detected (${deviceType}): Quality auto-reduced from ${baseScale} to ${optimizedScale} for better compatibility`);
                    }

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    template.innerHTML = this.buildOrderHTML(order, fontSize, colors, false, bgColor, textColor);
                    template.style.display = 'block';

                    // Increased wait time for mobile devices (they need more time for DOM to settle)
                    await new Promise(r => setTimeout(r, isMobile ? 500 : 300));

                    // Create canvas with optimized scale
                    let canvas;
                    try {
                        canvas = await html2canvas(template, {
                            scale: optimizedScale,
                            backgroundColor: bgColor,
                            width: paperDimensions.width,
                            logging: false,
                            useCORS: true,
                            allowTaint: false,
                            // Mobile-specific optimizations
                            removeContainer: true,
                            imageTimeout: isMobile ? 30000 : 15000
                        });
                    } catch (canvasError) {
                        console.error('html2canvas failed:', canvasError);

                        // Retry with even lower quality for mobile
                        if (isMobile && optimizedScale > 1) {
                            console.log('âš ï¸ Retrying with scale 1 for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Retrying with lower quality...');

                            canvas = await html2canvas(template, {
                                scale: 1,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: 30000
                            });
                        } else {
                            throw canvasError;
                        }
                    }

                    template.style.display = 'none';

                    // Use Promise-based blob creation with better error handling
                    this.updateLoadingMessage(loading, 'Creating download file...');

                    let blob;
                    try {
                        blob = await Utils.canvasToBlobPromise(canvas, 'image/png', 0.95);
                    } catch (blobError) {
                        console.error('PNG blob creation failed:', blobError);

                        // Fallback to JPEG with lower quality for mobile
                        if (isMobile) {
                            console.log('âš ï¸ Retrying with JPEG format for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Trying alternative format...');
                            blob = await Utils.canvasToBlobPromise(canvas, 'image/jpeg', 0.85);
                        } else {
                            throw blobError;
                        }
                    }

                    // Check blob size
                    const blobSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    console.log(`ğŸ“Š Image size: ${blobSizeMB} MB`);

                    if (blob.size > 50 * 1024 * 1024 && isMobile) {
                        this.hideLoading(loading);
                        this.showToast('âš ï¸ Image too large for mobile device. Please reduce quality in settings.', 'error');
                        return;
                    }

                    // Create download
                    try {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        const fileExt = blob.type.includes('jpeg') ? 'jpg' : 'png';
                        link.download = `Order_${order.orderId}.${fileExt}`;

                        // Mobile-specific download handling
                        if (isMobile) {
                            // For mobile, add a small delay and use different approach
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        } else {
                            link.click();
                        }

                        // Delay cleanup for mobile browsers
                        setTimeout(() => URL.revokeObjectURL(url), isMobile ? 1000 : 100);

                        this.hideLoading(loading);
                        this.showToast(`âœ… Image downloaded! (${blobSizeMB} MB)`);
                    } catch (downloadError) {
                        console.error('Download failed:', downloadError);
                        this.hideLoading(loading);
                        this.showToast('âŒ Download failed: ' + downloadError.message, 'error');
                    }
                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Image generation error:', error);

                    // Mobile-friendly error message
                    if (isMobile) {
                        this.showToast(`âŒ Failed on ${deviceType}: ${error.message}. Try reducing image quality in settings.`, 'error');
                    } else {
                        this.showToast('âŒ Error: ' + error.message, 'error');
                    }
                }
            },

            async generateMultiOrderImage(orders, date) {
                console.log(`\nğŸ¯ ========== GENERATE MULTI ORDER IMAGE CALLED ==========`);
                console.log(`ğŸ“… Date: ${date}`);
                console.log(`ğŸ“¦ Number of orders: ${orders.length}`);
                console.log(`ğŸ“‹ Orders:`, orders.map(o => ({
                    orderId: o.orderId,
                    clientName: o.clientName,
                    isMultiDay: o.isMultiDay,
                    hasDayWiseData: !!(o.dayWiseData && o.dayWiseData.length > 0),
                    dayWiseDataCount: o.dayWiseData ? o.dayWiseData.length : 0,
                    hasItems: !!(o.items && o.items.length > 0),
                    itemsCount: o.items ? o.items.length : 0
                })));
                console.log(`========================================\n`);

                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? `Generating PDF (mobile mode, ${orders.length} orders)...` : 'Generating multi-page PDF...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    // Smart quality adjustment for multi-order images to prevent memory issues
                    let baseQualityScale = this.data.settings.imageQuality || 2;

                    // Apply mobile optimizations first
                    let qualityScale = Utils.getOptimalCanvasScale(baseQualityScale);

                    // Further reduce quality based on number of orders
                    if (orders.length > 5) {
                        qualityScale = Math.min(qualityScale, 2); // Limit to scale 2 for more than 5 orders
                        console.log('âš ï¸ Quality reduced to scale 2 due to multiple orders to prevent memory issues');
                    }
                    if (orders.length > 10) {
                        qualityScale = Math.min(qualityScale, 1.5); // Further reduce for very large sets
                        console.log('âš ï¸ Quality further reduced to scale 1.5 for large order set');
                    }

                    // Extra reduction for mobile with many orders
                    if (isMobile) {
                        if (orders.length > 3) {
                            qualityScale = Math.min(qualityScale, 1);
                            console.log(`ğŸ“± Mobile with ${orders.length} orders: Quality capped at scale 1`);
                        }
                        if (orders.length > 10) {
                            this.hideLoading(loading);
                            this.showToast(`âš ï¸ ${orders.length} orders may be too many for mobile device. Consider downloading fewer orders at once.`, 'error');
                            return;
                        }
                    }

                    if (isMobile && qualityScale < baseQualityScale) {
                        console.log(`ğŸ“± ${deviceType}: Quality auto-adjusted from ${baseQualityScale} to ${qualityScale}`);
                    }

                    // Use fontSize from settings, but slightly smaller for compact multi-order view
                    const compactFontSize = Math.max(16, fontSize - 6);

                    console.log(`ğŸš€ Starting PDF generation for ${orders.length} orders`);

                    // Calculate grand totals for all orders (needed early for page height calculations)
                    let grandTotalDryIce = 0;
                    let grandTotalFlowers = 0;
                    let grandTotalElectricity = 0;
                    let grandTotalDryMachines = 0;
                    let grandTotalFlowerMachines = 0;

                    orders.forEach(order => {
                        const requirements = this.calculateOrderRequirements(order);
                        console.log(`  â†’ Order ${order.orderId} requirements:`, requirements);
                        grandTotalDryIce += requirements.dryIceNeeded;
                        grandTotalFlowers += requirements.flowersNeeded;
                        grandTotalElectricity += requirements.totalElectricityKV;
                        grandTotalDryMachines += requirements.dryMachines;
                        grandTotalFlowerMachines += requirements.flowerShowerMachines;
                    });

                    console.log(`\nğŸ“Š Grand Totals Calculated: DryIce=${grandTotalDryIce}kg, Flowers=${grandTotalFlowers}kg, Electricity=${grandTotalElectricity}KV, DryMachines=${grandTotalDryMachines}, FlowerMachines=${grandTotalFlowerMachines}\n`);

                    // NEW ALGORITHM: Dynamic page building with actual measurements
                    // This ensures ALL orders are included and pages are packed optimally

                    // CRITICAL: Use 'static' positioning for accurate measurements
                    // Using 'absolute' causes grid/flexbox layouts to collapse and gives wrong scrollHeight
                    template.style.height = 'auto';
                    template.style.minHeight = '0';
                    template.style.maxHeight = 'none';
                    template.style.overflow = 'visible';
                    template.style.display = 'block';
                    template.style.visibility = 'hidden'; // Hidden but still in document flow
                    template.style.position = 'static'; // Keep in document flow for accurate measurement
                    template.style.opacity = '0'; // Extra insurance it's not visible

                    const headerHeight = 75; // Header height for date (reduced for better space utilization)
                    const separatorHeight = 15; // Space between orders (reduced for better space utilization)
                    const bottomMargin = 10; // Bottom margin for page (optimized for space utilization)
                    const safetyMargin = 15; // Safety buffer for rendering differences (optimized for maximum space usage)

                    // Measure the actual grand total summary height instead of estimating
                    const hasGrandTotalSummary = (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0);
                    let grandTotalSummaryHeight = 0;

                    if (hasGrandTotalSummary) {
                        // Render the actual summary to measure its real height
                        const summaryHtml = `
                            <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">ğŸ“Š Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                    ${grandTotalDryIce > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">â„ï¸</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalFlowers > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">ğŸŒ¸</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalElectricity > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">âš¡</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;

                        // Temporarily render to measure (use static positioning for accurate height)
                        template.innerHTML = summaryHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Increased wait for layout calculation
                        grandTotalSummaryHeight = template.scrollHeight;
                        console.log(`ğŸ“Š Measured grand total summary height: ${grandTotalSummaryHeight}px`);
                        template.style.display = 'none';
                        template.style.opacity = '1';
                    }

                    const maxContentHeightFirstPage = paperDimensions.height - headerHeight - bottomMargin - safetyMargin - grandTotalSummaryHeight;
                    const maxContentHeightOtherPages = paperDimensions.height - headerHeight - bottomMargin - safetyMargin;

                    console.log(`ğŸ“ Page constraints: Paper=${paperDimensions.height}px, Header=${headerHeight}px, Margins=${bottomMargin + safetyMargin}px, GrandTotal=${grandTotalSummaryHeight}px`);
                    console.log(`ğŸ“Š Max content: First page=${maxContentHeightFirstPage}px, Other pages=${maxContentHeightOtherPages}px`);

                    const pages = [];
                    let processedOrders = new Set(); // Track which orders we've added

                    // Helper function to check if a single order fits on a page
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const checkSingleOrderFits = async (order, maxHeight) => {
                        const testHtml = this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                        template.innerHTML = testHtml;
                        // Ensure template is visible for measurement (but hidden from user)
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Wait for layout
                        const height = template.scrollHeight;
                        return { fits: height <= maxHeight, height: height };
                    };

                    // Helper function to measure multiple orders together
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const measureOrdersHeight = async (ordersList) => {
                        let testHtml = '';
                        ordersList.forEach((o, idx) => {
                            testHtml += this.buildOrderHTML(o, compactFontSize, colors, true, bgColor, textColor);
                            if (idx < ordersList.length - 1) {
                                testHtml += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });
                        template.innerHTML = testHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100));
                        return template.scrollHeight;
                    };

                    // STEP 1: Measure all orders individually first
                    console.log('ğŸ“ Measuring all orders for optimal packing...');
                    const orderHeights = [];
                    for (let i = 0; i < orders.length; i++) {
                        const check = await checkSingleOrderFits(orders[i], maxContentHeightOtherPages);
                        orderHeights.push({
                            order: orders[i],
                            height: check.height,
                            originalIndex: i
                        });
                    }

                    // STEP 2: Sort orders by height (descending) - First Fit Decreasing algorithm
                    orderHeights.sort((a, b) => b.height - a.height);
                    console.log('ğŸ“Š Order heights (sorted descending):', orderHeights.map(oh => `${oh.order.clientName || oh.order.orderId}: ${oh.height}px`).join(', '));

                    // STEP 3: Use First Fit Decreasing bin-packing algorithm
                    for (let i = 0; i < orderHeights.length; i++) {
                        const { order, height, originalIndex } = orderHeights[i];

                        // Check if this single order is too large for any page by itself
                        const fitsOnFirstPage = height <= maxContentHeightFirstPage;
                        const fitsOnOtherPage = height <= maxContentHeightOtherPages;

                        // If order doesn't fit on any page by itself, handle special case
                        if (!fitsOnOtherPage) {
                            // Check if this is a multifunction/multiday order that can be split
                            if (order.dayWiseData && order.dayWiseData.length > 0) {
                                // Try to split by function groups
                                let remainingFunctions = [];
                                order.dayWiseData.forEach(day => {
                                    if (day.functions && day.functions.length > 0) {
                                        day.functions.forEach((func, funcIdx) => {
                                            remainingFunctions.push({
                                                dayNumber: day.dayNumber,
                                                date: day.date,
                                                function: func,
                                                functionIndex: funcIdx
                                            });
                                        });
                                    }
                                });

                                // Split functions across multiple pages
                                while (remainingFunctions.length > 0) {
                                    let currentFunctionSet = [];

                                    for (let f = 0; f < remainingFunctions.length; f++) {
                                        const testFunctions = [...currentFunctionSet, remainingFunctions[f]];

                                        // Create a partial order with only these functions
                                        const partialOrder = {
                                            ...order,
                                            dayWiseData: testFunctions.map(tf => ({
                                                dayNumber: tf.dayNumber,
                                                date: tf.date,
                                                functions: [tf.function]
                                            }))
                                        };

                                        // Test if it fits
                                        const partialCheck = await checkSingleOrderFits(partialOrder, maxContentHeightOtherPages);

                                        if (partialCheck.fits) {
                                            currentFunctionSet.push(remainingFunctions[f]);
                                        } else {
                                            // Can't add more functions, save current set
                                            break;
                                        }
                                    }

                                    // If we couldn't fit even one function, we need to add it anyway
                                    if (currentFunctionSet.length === 0 && remainingFunctions.length > 0) {
                                        currentFunctionSet.push(remainingFunctions[0]);
                                    }

                                    // Create page with current function set
                                    const pageOrder = {
                                        ...order,
                                        orderId: `${order.orderId} (Part ${pages.length + 1})`,
                                        dayWiseData: currentFunctionSet.map(tf => ({
                                            dayNumber: tf.dayNumber,
                                            date: tf.date,
                                            functions: [tf.function]
                                        }))
                                    };

                                    pages.push([pageOrder]);

                                    // Remove processed functions
                                    remainingFunctions = remainingFunctions.slice(currentFunctionSet.length);
                                }

                                processedOrders.add(originalIndex);
                                continue;
                            } else {
                                // Not a multifunction order, add it anyway and let it scale or overflow
                                pages.push([order]);
                                processedOrders.add(originalIndex);
                                continue;
                            }
                        }

                        // FIRST FIT: Try to fit this order in existing pages
                        let placed = false;
                        for (let pageIdx = 0; pageIdx < pages.length; pageIdx++) {
                            const pageOrders = pages[pageIdx];
                            const isFirstPage = pageIdx === 0;
                            const maxHeight = isFirstPage ? maxContentHeightFirstPage : maxContentHeightOtherPages;

                            // Measure current page content
                            const currentHeight = pageOrders.length > 0 ? await measureOrdersHeight(pageOrders) : 0;
                            const availableSpace = maxHeight - currentHeight;

                            // Try adding this order to this page
                            const testOrders = [...pageOrders, order];
                            const testHeight = await measureOrdersHeight(testOrders);
                            const willFit = testHeight <= maxHeight;

                            console.log(`ğŸ“ Page ${pageIdx + 1} (${isFirstPage ? 'FIRST' : 'other'}): has ${pageOrders.length} order(s), used ${currentHeight}px, available ${availableSpace}px/${maxHeight}px`);
                            console.log(`   â†’ Testing "${order.clientName || order.orderId}" (${height}px): total would be ${testHeight}px, fits = ${willFit}`);

                            if (willFit) {
                                // Fits! Add to this page
                                pages[pageIdx].push(order);
                                processedOrders.add(originalIndex);
                                placed = true;
                                console.log(`âœ… Placed order "${order.clientName || order.orderId}" on page ${pageIdx + 1}`);
                                break;
                            }
                        }

                        // If didn't fit in any existing page, create a new page
                        if (!placed) {
                            pages.push([order]);
                            processedOrders.add(originalIndex);
                            console.log(`ğŸ“„ Created new page ${pages.length} for order "${order.clientName || order.orderId}"`);
                        }
                    }

                    // Reset template to normal state
                    template.style.display = 'none';
                    template.style.visibility = 'visible';
                    template.style.position = 'static';
                    template.style.opacity = '1';

                    // VERIFICATION: Check all orders were processed
                    // Note: totalOrdersInPages may be > orders.length due to split multifunction orders
                    if (processedOrders.size !== orders.length) {
                        throw new Error(`Missing orders in PDF! Expected ${orders.length}, but only ${processedOrders.size} were processed.`);
                    }

                    const totalPages = pages.length;
                    console.log(`âœ… Generated ${totalPages} pages for ${orders.length} orders`);

                    // STEP 3: Generate multi-page PDF
                    this.updateLoadingMessage(loading, 'Creating PDF document...');

                    // Initialize jsPDF with exact dimensions matching our measurements (300 DPI)
                    const { jsPDF } = window.jspdf;

                    // CRITICAL FIX: Use the same paperDimensions we used for measurement
                    // This ensures content measured to fit will actually fit in the PDF
                    const pdf = new jsPDF({
                        orientation: 'p', // We handle orientation in paperDimensions
                        unit: 'px',
                        format: [paperDimensions.width, paperDimensions.height], // Use exact dimensions at 300 DPI
                        compress: true
                    });

                    // Get PDF page dimensions (should match paperDimensions)
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    console.log(`ğŸ“ PDF dimensions: ${pdfWidth} x ${pdfHeight} px (should match measurement dimensions)`);
                    console.log(`ğŸ“ Paper dimensions used for measurement: ${paperDimensions.width} x ${paperDimensions.height} px`);

                    // Generate each page and add to PDF
                    for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                        this.updateLoadingMessage(loading, `Adding page ${pageNum + 1} of ${totalPages} to PDF...`);

                        const pageOrders = pages[pageNum];

                        // Build HTML for this page
                        let html = `
                            <div style="text-align: center; margin-bottom: 15px; padding: 8px 0;">
                                <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 10px; margin: 0; font-size: 24px;">
                                    Orders for <span style="font-size: 60px;">${Utils.formatDate(date)}</span> - Page ${pageNum + 1} of ${totalPages}
                                </h1>
                            </div>
                        `;

                        // Add summary section on first page only
                        console.log(`ğŸ” Page ${pageNum}: Checking grand total condition - DryIce=${grandTotalDryIce}, Flowers=${grandTotalFlowers}, Electricity=${grandTotalElectricity}`);
                        if (pageNum === 0 && (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0)) {
                            console.log(`âœ… Adding grand total summary to first page`);
                            html += `
                                <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                    <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">ğŸ“Š Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                        ${grandTotalDryIce > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">â„ï¸</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalFlowers > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">ğŸŒ¸</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalElectricity > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">âš¡</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }

                        pageOrders.forEach((order, i) => {
                            html += this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                            if (i < pageOrders.length - 1) {
                                html += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });

                        template.innerHTML = html;
                        template.style.display = 'block';
                        template.style.visibility = 'visible';
                        template.style.position = 'static';
                        template.style.height = 'auto';

                        // Increased wait time for mobile devices
                        await new Promise(r => setTimeout(r, isMobile ? 500 : 200));

                        // Validate canvas dimensions before creation
                        const expectedWidth = Math.round(paperDimensions.width * qualityScale);
                        const expectedHeight = Math.round(paperDimensions.height * qualityScale);
                        const validation = Utils.validateCanvasDimensions(expectedWidth, expectedHeight);

                        if (!validation.valid) {
                            throw new Error(`Page ${pageNum + 1}: ${validation.reason}`);
                        }

                        // Convert HTML to canvas with error handling
                        let canvas;
                        try {
                            canvas = await html2canvas(template, {
                                scale: qualityScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        } catch (canvasError) {
                            console.error('Canvas generation failed, retrying with lower quality:', canvasError);

                            // Retry with lower quality scale
                            const retryScale = isMobile ? 0.75 : 1;
                            console.log(`âš ï¸ Retrying page ${pageNum + 1} with scale ${retryScale}...`);

                            canvas = await html2canvas(template, {
                                scale: retryScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        }

                        template.style.display = 'none';

                        // Convert canvas to image and add to PDF with error handling
                        let imgData;
                        try {
                            imgData = canvas.toDataURL('image/png', 0.92);
                        } catch (pngError) {
                            console.error('PNG conversion failed, retrying with JPEG:', pngError);
                            // Fallback to JPEG if PNG fails
                            try {
                                imgData = canvas.toDataURL('image/jpeg', 0.85);
                            } catch (jpegError) {
                                console.error('JPEG conversion also failed:', jpegError);
                                if (isMobile) {
                                    throw new Error('Canvas conversion failed on mobile device. Try reducing image quality or downloading fewer orders.');
                                } else {
                                    throw jpegError;
                                }
                            }
                        }

                        // Check data URL size for mobile
                        if (isMobile && imgData.length > 10 * 1024 * 1024) {
                            console.warn(`âš ï¸ Page ${pageNum + 1} is large (${(imgData.length / 1024 / 1024).toFixed(2)} MB)`);
                        }
                        let imgWidth = pdfWidth;
                        let imgHeight = (canvas.height * pdfWidth) / canvas.width;

                        // Add new page if not first page
                        if (pageNum > 0) {
                            pdf.addPage();
                        }

                        // Check if image is too tall - if so, add it without scaling to preserve quality
                        // The content should have been properly split in the page allocation phase
                        if (imgHeight > pdfHeight) {
                            console.warn(`âš ï¸ Page ${pageNum + 1} image height (${imgHeight}px) exceeds PDF height (${pdfHeight}px)`);
                            console.warn(`   This should not happen - the page allocation should have split the content properly`);

                            // Calculate scale factor needed
                            const scaleFactor = pdfHeight / imgHeight;
                            console.warn(`   Content will be scaled down to ${(scaleFactor * 100).toFixed(1)}% to fit the page`);

                            // Scale to fit as last resort
                            imgHeight = pdfHeight;
                            imgWidth = (canvas.width * pdfHeight) / canvas.height;
                        }

                        // Add image to PDF page (centered if scaled down)
                        const xOffset = (pdfWidth - imgWidth) / 2;
                        pdf.addImage(imgData, 'PNG', xOffset, 0, imgWidth, imgHeight, undefined, 'FAST');
                    }

                    // Save the PDF
                    this.updateLoadingMessage(loading, 'Saving PDF...');
                    pdf.save(`Orders_${date}.pdf`);

                    this.hideLoading(loading);
                    this.showToast(`âœ… PDF generated with ${totalPages} page(s)! (${orders.length} orders)`);

                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Error generating multi-order images:', error);

                    // Mobile-friendly error messages
                    if (isMobile) {
                        this.showToast(`âŒ Failed on ${deviceType}: ${error.message}. Try reducing quality in settings or downloading fewer orders.`, 'error');
                    } else {
                        this.showToast('âŒ Error: ' + error.message, 'error');
                    }
                }
            },

            // Helper to update loading message dynamically
            updateLoadingMessage(loadingElement, message) {
                if (loadingElement && loadingElement.querySelector('.loading-text')) {
                    loadingElement.querySelector('.loading-text').textContent = message;
                }
            },

            // Get paper dimensions based on format and orientation
            getPaperDimensions() {
                const format = this.data.settings.paperFormat || 'A4';
                const orientation = this.data.settings.paperOrientation || 'portrait';

                // Paper dimensions in pixels (at 300 DPI)
                const formats = {
                    'A4': { width: 2480, height: 3508 },
                    'Legal': { width: 2550, height: 4200 },
                    'Letter': { width: 2550, height: 3300 },
                    'A3': { width: 3508, height: 4960 },
                    'A5': { width: 1748, height: 2480 },
                    'Tabloid': { width: 3300, height: 5100 }
                };

                let dimensions = formats[format] || formats['A4'];

                // Swap dimensions for landscape
                if (orientation === 'landscape') {
                    return {
                        width: dimensions.height,
                        height: dimensions.width
                    };
                }

                return dimensions;
            },

            // Calculate dry ice, flowers, and electricity requirements for a single order
            calculateOrderRequirements(order) {
                const items = [];

                // Collect all items from the order
                // Check for dayWiseData first (handles both multiday and filtered single-day orders)
                if (order.dayWiseData && Array.isArray(order.dayWiseData) && order.dayWiseData.length > 0) {
                    console.log(`ğŸ“‹ Order ${order.orderId || order.clientName}: Processing dayWiseData (${order.dayWiseData.length} days)`);
                    order.dayWiseData.forEach(day => {
                        if (day.functions && Array.isArray(day.functions)) {
                            day.functions.forEach(func => {
                                if (func.items && Array.isArray(func.items)) {
                                    const funcName = func.functionName || func.name || '(unnamed function)';
                                    console.log(`  â†’ Adding ${func.items.length} items from function "${funcName}"`);
                                    items.push(...func.items);
                                }
                            });
                        }
                    });
                } else if (order.items && Array.isArray(order.items)) {
                    console.log(`ğŸ“‹ Order ${order.orderId || order.clientName}: Processing items array (${order.items.length} items)`);
                    items.push(...order.items);
                }

                console.log(`  â†’ Total items collected: ${items.length}`);

                // DEBUG: Log all item names to understand what we're working with
                if (items.length > 0) {
                    console.log(`  â†’ Item details:`);
                    items.forEach((item, idx) => {
                        console.log(`     ${idx + 1}. Name: "${item.name}" | Pcs: ${item.quantity || 0}`);
                    });
                }

                // Calculate dry ice requirements
                const dryMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = name.includes('dry ice');
                    if (matches) {
                        console.log(`     âœ… DRY ICE MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Calculate flower requirements
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                    if (matches) {
                        console.log(`     âœ… FLOWER SHOWER MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name?.toLowerCase() || '';
                    const qty = item.quantity || 0;

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     âœ… ELECTRICITY 3KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 3}KV)`);
                        totalElectricityKV += qty * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     âœ… ELECTRICITY 1KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 1}KV)`);
                        totalElectricityKV += qty * 1;
                    }
                });

                const result = {
                    dryIceNeeded,
                    dryMachines,
                    flowersNeeded,
                    flowerShowerMachines,
                    totalElectricityKV,
                    items
                };

                // DEBUG: Log the calculated requirements
                console.log(`  â†’ ğŸ“Š Calculated: DryIce=${dryIceNeeded}kg (${dryMachines} machines), Flowers=${flowersNeeded}kg (${flowerShowerMachines} machines), Electricity=${totalElectricityKV}KV`);

                return result;
            },

            buildOrderHTML(order, fontSize, colors, compact = false, bgColor = '#ffffff', textColor = '#000000') {
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                const functionColor = this.data.settings.functionColor || '#667eea';

                // Calculate requirements for this order
                const requirements = this.calculateOrderRequirements(order);

                return `
                    <div style="margin-bottom: ${compact ? '25px' : '60px'}; ${compact ? 'border: 2px solid ' + colors.tableBorder + '; padding: 15px;' : ''}; color: ${textColor}; background: ${bgColor};">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px; color: ${textColor};">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : ''}

                        <!-- FP- Field at center/top -->
                        <div style="text-align: center; margin-bottom: ${compact ? '15px' : '25px'}; margin-top: ${compact ? '10px' : '0'};">
                            <div style="display: inline-block; border: 2px solid ${textColor}; padding: 8px 25px; font-size: ${fontSize + 4}px; font-weight: bold; color: #000000; background: #ffeb3b;">
                                FP-<span style="display: inline-block; min-width: 150px; border-bottom: 2px solid ${textColor}; margin-left: 10px; white-space: nowrap;">${order.orderId && order.orderId.startsWith('FP') ? order.orderId.substring(2) : ''}</span>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ${compact ? '12px' : '20px'}; font-size: ${fontSize}px; margin-bottom: ${compact ? '12px' : '20px'}; color: ${textColor};">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong style="color: ${textColor};">Start Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.startDate) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">End Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.endDate) || 'N/A'}</span><br>
                                ` : `
                                    <strong style="color: ${textColor};">Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.date) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${order.readyTime || '-'}</span><br>
                                `}
                                <strong style="color: ${textColor};">Client:</strong> ${order.clientName || '-'}<br>
                                <strong style="color: ${textColor};">Contact:</strong> ${order.contact || '-'}<br>
                                <strong style="color: ${textColor};">Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Dry Ice: ${requirements.dryIceNeeded > 0 ? requirements.dryIceNeeded + ' kg (' + requirements.dryMachines + ' machine' + (requirements.dryMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Flowers: ${requirements.flowersNeeded > 0 ? requirements.flowersNeeded + ' kg (' + requirements.flowerShowerMachines + ' machine' + (requirements.flowerShowerMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Electricity: ${requirements.totalElectricityKV > 0 ? requirements.totalElectricityKV + ' KV' : ''}</div>
                                <strong style="color: ${textColor};">Transport:</strong> ${order.transport || '-'}<br>
                                <strong style="color: ${textColor};">Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong style="color: ${textColor};">Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong style="color: ${textColor};">Driver 2:</strong> ${order.driverName2}<br>` : ''}
                            </div>
                            <div>
                                <strong style="color: ${textColor};">Event:</strong> ${order.eventType || '-'}<br>
                                <strong style="color: ${textColor};">Operator:</strong> ${order.operator || '-'}<br>
                                <strong style="color: ${textColor};">Helper(s):</strong> ${order.helper || '-'}
                            </div>
                        </div>

                        <!-- Dividing line between top info and items -->
                        <div style="border-top: 3px solid ${textColor}; margin: ${compact ? '15px' : '25px'} 0;"></div>

                            ${order.dayWiseData && order.dayWiseData.length > 0 ?
                            '<div style="margin-top: ' + (compact ? '15px' : '30px') + ';">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: ' + (compact ? '10px' : '15px') + '; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) =>
                                    '<div style="margin-top: ' + (compact ? '12px' : '25px') + '; border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '10px' : '15px') + '; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: ' + (compact ? '8px' : '15px') + ';">Day ' + day.dayNumber + ' - <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + Utils.formatDate(day.date) + '</span></h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: ' + bgColor + '; padding: ' + (compact ? '10px' : '15px') + '; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? (compact ? '8px' : '15px') : '0') + '; color: ' + textColor + ';">' +
                                                    '<h5 style="color: ' + functionColor + '; margin-bottom: ' + (compact ? '6px' : '10px') + '; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ' + (compact ? '8px' : '12px') + '; font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + (func.timeSlot || '-') + '</span>' +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Operator:</strong> ' + (func.operator || '-') +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Helper:</strong> ' + (func.helper || '-') +
                                                        '</div>' +
                                                    '</div>' +
                                                    (func.notes ? '<div style="font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';"><strong style="color: ' + textColor + ';">Notes:</strong> ' + func.notes + '</div>' : '') +
                                                    (func.items && func.items.length > 0 ?
                                                        '<div style="font-size: ' + (fontSize - 4) + 'px; color: ' + textColor + '; margin-top: ' + (compact ? '8px' : '12px') + ';">' +
                                                            func.items.map((item, i) =>
                                                                '<div style="padding: ' + (compact ? '4px' : '6px') + ' 0; color: ' + textColor + ';">' +
                                                                    '<span style="color: ' + textColor + ';">' + (i + 1) + '. ' + item.name + ' - ' + item.quantity + (item.quantity == 1 ? ' Pc' : ' Pcs') + (item.remarks ? ' - Remarks: ' + item.remarks : '') + '</span>' +
                                                                '</div>'
                                                            ).join('') +
                                                        '</div>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '6px' : '10px') + ';">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <div style="font-size: ${fontSize - 4}px; margin-top: ${compact ? '12px' : '20px'}; color: ${textColor};">
                                ${order.items.map((item, i) => `
                                    <div style="padding: ${compact ? '4px' : '6px'} 0; color: ${textColor};">
                                        <span style="color: ${textColor};">${i + 1}. ${item.name} - ${item.quantity} ${item.quantity == 1 ? 'Pc' : 'Pcs'}${item.remarks ? ' - Remarks: ' + item.remarks : ''}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '12px' : '20px') + ';">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: ${compact ? '10px' : '20px'}; font-size: ${fontSize}px; color: ${textColor};">
                                <strong style="color: ${textColor};">Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: ${compact ? '10px' : '15px'}; border: 1px solid ${colors.tableBorder}; color: ${textColor};">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            // ========== CALENDAR (Delegated to Calendar module) ==========
            renderCalendar(date = new Date()) {
                return Calendar.render(date, this);
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const dayDetails = Calendar.getDayDetailsHTML(dateStr, this);
                this.showModal(dayDetails.title, dayDetails.content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders as CSV
                        const headers = ['Order ID', 'Date', 'Client', 'Contact', 'Venue', 'Status', 'Total Items'];
                        const rows = this.data.orders.map(o => [
                            o.orderId, o.date, o.clientName, o.contact, o.venue, o.status, o.items.length
                        ]);
                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();

                // Create close button
                const closeBtn = Utils.elem('button', { class: 'modal-close' }, ['Ã—']);
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeModal();
                });

                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        closeBtn,
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);

                document.getElementById('modalsContainer').appendChild(modal);

                // Also allow closing by clicking the backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal();
                    }
                });

                // Add keyboard handler for Escape key
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

                // Store handler to remove later
                modal._escapeHandler = escapeHandler;
            },

            showToast(message, type = 'success', actions = []) {
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let topOffset = 20; // Initial top position

                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    topOffset = Math.max(topOffset, rect.bottom - document.documentElement.scrollTop + 10);
                });

                // Create action buttons if provided
                const actionButtons = actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' },
                    actions.map(a => {
                        const btn = Utils.elem('button', { class: 'toast-btn' }, [a.label]);
                        btn.addEventListener('click', a.handler);
                        return btn;
                    })
                ) : null;

                const toast = Utils.elem('div', {
                    class: `toast show ${type === 'error' ? 'error' : ''} ${type === 'warning' ? 'warning' : ''}`,
                    style: { top: `${topOffset}px` }
                }, [
                    Utils.elem('div', {}, [message]),
                    actionButtons
                ].filter(Boolean));

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },

            repositionToasts() {
                const toasts = document.querySelectorAll('.toast');
                let topOffset = 20;

                toasts.forEach(toast => {
                    toast.style.top = `${topOffset}px`;
                    const rect = toast.getBoundingClientRect();
                    topOffset = rect.bottom - document.documentElement.scrollTop + 10;
                });
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', { class: 'loading-text' }, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ RBAC NAVIGATION ============
            async applyRBACToNavigation() {
                const canViewFinancials = await this.canViewFinancials();
                const financialsTab = document.querySelector('[data-tab="financials"]');
                const user = await this.getCurrentUser();

                console.log('ğŸ” RBAC Check:', {
                    userRole: user?.role,
                    canViewFinancials: canViewFinancials,
                    tabExists: !!financialsTab
                });

                if (financialsTab) {
                    if (canViewFinancials) {
                        // Show financials tab for admin/owner users
                        financialsTab.style.display = '';
                        console.log('âœ… Financials tab VISIBLE for admin/owner user');
                    } else {
                        // Hide financials tab for non-admin/owner users
                        financialsTab.style.display = 'none';
                        console.log('ğŸ”’ Financials tab HIDDEN for non-admin/owner user');
                    }
                }

                // Display current user role in header
                if (user) {
                    const userInfoDiv = document.createElement('div');
                    userInfoDiv.id = 'userRoleInfo';
                    userInfoDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: rgba(0,0,0,0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; white-space: nowrap; margin-right: 0.5rem;';
                    userInfoDiv.innerHTML = `
                        <span style="opacity: 0.7; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${user.email}</span>
                        <span style="padding: 0.25rem 0.5rem; background: ${user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3'}; color: white; border-radius: 0.25rem; font-weight: bold; text-transform: uppercase; font-size: 0.75rem;">
                            ${user.role}
                        </span>
                    `;

                    // Add to header-controls instead of directly to header
                    const headerControls = document.querySelector('.header-controls');
                    if (headerControls && !document.getElementById('userRoleInfo')) {
                        // Insert at the beginning of header-controls
                        headerControls.insertBefore(userInfoDiv, headerControls.firstChild);
                    }
                }
            },

            // ============ NAVIGATION ============
            async switchTab(tabName) {
                // Check permissions for financial tab
                if (tabName === 'financials') {
                    const canView = await this.canViewFinancials();
                    if (!canView) {
                        this.showToast('â›” Access Denied: Only Admin and Owner can view Financials', 'error');
                        return;
                    }
                }

                // Clean up preparation weather interval when leaving preparation tab
                if (this.currentTab === 'preparation' && tabName !== 'preparation') {
                    if (this.preparationWeatherInterval) {
                        clearInterval(this.preparationWeatherInterval);
                        this.preparationWeatherInterval = null;
                    }
                }

                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(tabName).classList.add('active');

                this.currentTab = tabName;

                // Render tab content
                setTimeout(() => {
                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') this.renderInventory();
                    else if (tabName === 'itemHistory') this.renderItemHistory();
                    else if (tabName === 'preparation') this.renderPreparation();
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'quotations') this.renderQuotations();
                    else if (tabName === 'team') this.renderTeam();
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'financials') this.renderFinancials();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') {
                        this.initItemSearch();
                        // Always populate events dropdown when orders tab is opened
                        console.log('ğŸ“‹ Orders tab opened - populating events dropdown');
                        this.populateEventsDatalist();
                        // Driver and operator dropdowns are populated when form is rendered
                    }
                }, 50);
            },

            // ============ TAB RENDERERS ============
            // ========== DASHBOARD (Delegated to Dashboard module) ==========
            renderDashboard() {
                Dashboard.render(this);
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('inventoryManagement')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">${this.t('batchUpdate')}</button>
                        </div>
                        <div class="card">
                            <h3>${this.t('categories')}</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="${this.t('enterCategoryName')}">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">${this.t('add')}</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>${this.t('items')}</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="${this.t('enterItemName')}">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="${this.t('quantity')}" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">${this.t('add')}</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;

                this.updateInventoryDisplay();
            },

            renderItemHistory() {
                const container = document.getElementById('itemHistory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“œ Item Usage History</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">
                                Track which items were used in which completed orders
                            </p>
                        </div>
                        <div class="form-row" style="margin-bottom: 1rem;">
                            <input type="text" id="itemHistorySearch" class="form-input" placeholder="Search by item name, order ID, or client...">
                            <select id="itemHistoryFilter" class="form-select">
                                <option value="all">All Items</option>
                                ${[...new Set(this.data.itemHistory.map(h => h.itemName))].sort().map(name =>
                                    `<option value="${name}">${name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div id="itemHistoryContainer"></div>
                    </div>
                `;

                this.renderItemHistoryTable();

                // Add search and filter handlers
                document.getElementById('itemHistorySearch')?.addEventListener('input', () => this.renderItemHistoryTable());
                document.getElementById('itemHistoryFilter')?.addEventListener('change', () => this.renderItemHistoryTable());
            },

            renderItemHistoryTable() {
                const searchTerm = document.getElementById('itemHistorySearch')?.value.toLowerCase() || '';
                const filterItem = document.getElementById('itemHistoryFilter')?.value || 'all';

                // Filter history
                let filteredHistory = this.data.itemHistory;

                if (filterItem !== 'all') {
                    filteredHistory = filteredHistory.filter(h => h.itemName === filterItem);
                }

                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(h =>
                        h.itemName.toLowerCase().includes(searchTerm) ||
                        h.orderId.toLowerCase().includes(searchTerm) ||
                        h.clientName.toLowerCase().includes(searchTerm) ||
                        (h.venue && h.venue.toLowerCase().includes(searchTerm))
                    );
                }

                // Sort by most recent first
                filteredHistory.sort((a, b) => new Date(b.usedAt) - new Date(a.usedAt));

                // Render table
                this.renderTable('itemHistoryContainer', [
                    { key: 'itemName', label: 'Item Name' },
                    { key: 'quantity', label: 'Pcs' },
                    { key: 'orderId', label: 'Order ID', render: h => `<span class="order-id-highlight">${h.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'venue', label: 'Venue', render: h => h.venue || 'N/A' },
                    { key: 'eventDate', label: 'Event Date', render: h => Utils.formatDate(h.eventDate) },
                    { key: 'functionType', label: 'Function', render: h => h.functionType || 'N/A' },
                    { key: 'usedAt', label: 'Recorded On', render: h => new Date(h.usedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }) }
                ], filteredHistory, (row) => ``);
            },

            // ========== INVENTORY (Delegated to Inventory module) ==========
            updateInventoryDisplay() {
                Inventory.updateDisplay(this);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Pieces</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">ğŸ’¾ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION / FORECAST FUNCTIONS ============

            renderPreparation() {
                const container = document.getElementById('preparation');
                const today = new Date().toISOString().split('T')[0];
                const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                const nextWeek = new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('preparationForecast')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('itemsToPrep')}</p>
                        </div>

                        <div class="card">
                            <h3>${this.t('selectDateRange')}</h3>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('today')">${this.t('today')}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('tomorrow')">${this.t('tomorrow') || 'Tomorrow'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('week')">${this.t('next7Days') || 'Next 7 Days'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('month')">${this.t('next30Days') || 'Next 30 Days'}</button>
                            </div>
                            <div class="form-row">
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('from')}</label>
                                    <input type="date" id="forecastStartDate" class="form-input" value="${today}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('to')}</label>
                                    <input type="date" id="forecastEndDate" class="form-input" value="${tomorrow}">
                                </div>
                                <div style="display: flex; align-items: flex-end;">
                                    <button class="btn btn-primary" onclick="OMS.generateForecast()" style="height: fit-content;">
                                        ğŸ” ${this.t('generateReport')}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="forecastResults"></div>
                    </div>
                `;

                // Auto-generate forecast for tomorrow by default
                setTimeout(() => this.generateForecast(), 100);
            },

            quickForecast(period) {
                const today = new Date();
                const startInput = document.getElementById('forecastStartDate');
                const endInput = document.getElementById('forecastEndDate');

                let start = new Date(today);
                let end = new Date(today);

                switch(period) {
                    case 'today':
                        // Start and end are same (today)
                        break;
                    case 'tomorrow':
                        start.setDate(start.getDate() + 1);
                        end.setDate(end.getDate() + 1);
                        break;
                    case 'week':
                        end.setDate(end.getDate() + 7);
                        break;
                    case 'month':
                        end.setDate(end.getDate() + 30);
                        break;
                }

                startInput.value = start.toISOString().split('T')[0];
                endInput.value = end.toISOString().split('T')[0];

                this.generateForecast();
            },

            async generateForecast() {
                const startDate = Utils.get('forecastStartDate');
                const endDate = Utils.get('forecastEndDate');

                if (!startDate || !endDate) {
                    this.showToast('Please select both start and end dates', 'error');
                    return;
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (end < start) {
                    this.showToast('End date must be after start date', 'error');
                    return;
                }

                // Get orders in date range
                const ordersInRange = this.getOrdersInDateRange(startDate, endDate);

                // Aggregate items from all orders
                const itemsMap = new Map();
                const orderItemsMap = new Map(); // Track which orders use which items

                ordersInRange.forEach(order => {
                    const items = this.getItemsFromOrder(order, startDate, endDate);

                    items.forEach(item => {
                        // Aggregate quantities
                        const current = itemsMap.get(item.name) || 0;
                        itemsMap.set(item.name, current + item.quantity);

                        // Track order references
                        if (!orderItemsMap.has(item.name)) {
                            orderItemsMap.set(item.name, []);
                        }
                        orderItemsMap.get(item.name).push({
                            orderId: order.orderId,
                            clientName: order.clientName,
                            quantity: item.quantity
                        });
                    });
                });

                // Convert to array and sort by quantity (descending)
                const aggregatedItems = Array.from(itemsMap, ([name, quantity]) => {
                    // Find matching inventory item
                    const inventoryItem = this.data.inventory.items.find(i =>
                        i.name.toLowerCase() === name.toLowerCase()
                    );

                    return {
                        name,
                        required: quantity,
                        inStock: inventoryItem ? inventoryItem.quantity : 0,
                        difference: inventoryItem ? inventoryItem.quantity - quantity : -quantity,
                        orders: orderItemsMap.get(name) || []
                    };
                }).sort((a, b) => b.required - a.required);

                // Fetch weather for the start date
                const weatherApiKey = this.data.settings.weatherApiKey || '';
                const defaultCity = this.data.settings.defaultCity || 'Delhi';
                const weatherData = await Utils.getWeatherForecast(defaultCity, startDate, weatherApiKey);

                // Render forecast results
                this.renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate, weatherData);
            },

            getOrdersInDateRange(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);

                return this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day orders, check if any day falls in range
                        const orderStart = new Date(order.startDate);
                        const orderEnd = new Date(order.endDate);

                        // Check for overlap: order overlaps if it starts before range ends AND ends after range starts
                        return orderStart <= end && orderEnd >= start;
                    } else {
                        // For single-day orders
                        const orderDate = new Date(order.date);
                        return orderDate >= start && orderDate <= end;
                    }
                });
            },

            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            renderForecastResults(orders, items, startDate, endDate, weatherData = null) {
                const container = document.getElementById('forecastResults');

                if (orders.length === 0) {
                    container.innerHTML = `
                        <div class="card" style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <h3>ğŸ“­ ${this.t('noOrdersFoundShort')}</h3>
                            <p>${this.t('noOrdersScheduledBetween')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate statistics
                const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
                const pendingOrders = orders.filter(o => o.status !== 'Confirmed' && o.status !== 'Completed').length;
                const completedOrders = orders.filter(o => o.status === 'Completed').length;
                const totalItems = items.reduce((sum, item) => sum + item.required, 0);
                const shortageItems = items.filter(i => i.difference < 0);
                const okItems = items.filter(i => i.difference >= 0);

                // Calculate dry ice, flowers, and electricity requirements
                // Find all dry ice machines (items containing "dry ice")
                const dryMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return name.includes('dry ice');
                }).reduce((sum, item) => sum + item.required, 0);

                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Find all flower shower machines (items containing "flower shower" or "flower" and "shower")
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                }).reduce((sum, item) => sum + item.required, 0);

                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name.toLowerCase();

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 1;
                    }
                });

                container.innerHTML = `
                    <!-- Summary Cards -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 1.5rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ğŸ“Š ${this.t('summary')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${orders.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalOrders')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${confirmedOrders}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âœ… ${this.t('confirmed')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${items.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('uniqueItems')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${totalItems}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalQuantity')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: ${shortageItems.length > 0 ? '#fca5a5' : '#86efac'};">${shortageItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âš ï¸ ${this.t('shortages')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: #86efac;">${okItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âœ… ${this.t('sufficient')}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Weather Forecast Card -->
                    ${weatherData ? `
                    <div class="card" style="background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ğŸŒ¤ï¸ Weather Forecast for ${Utils.formatDate(startDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 3rem; margin-bottom: 0.5rem;">${Utils.getWeatherEmoji(weatherData.condition)}</div>
                                <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.25rem;">${weatherData.condition}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${weatherData.description}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ğŸŒ¡ï¸ Temperature</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.temp}Â°C</div>
                                ${weatherData.tempMin && weatherData.tempMax ? `
                                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem;">
                                        ${weatherData.tempMin}Â°C - ${weatherData.tempMax}Â°C
                                    </div>
                                ` : ''}
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ğŸ’§ Humidity</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.humidity}%</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ğŸ“ Location</div>
                                <div style="font-size: 1.2rem; font-weight: 600;">${this.data.settings.defaultCity || 'Delhi'}</div>
                                <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.5rem;">
                                    ${weatherData.temp === 'N/A' ? 'Weather unavailable' : 'Live forecast'}
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Materials Calculation Card -->
                    ${(dryMachines > 0 || flowerShowerMachines > 0 || totalElectricityKV > 0) ? `
                    <div class="card" style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ğŸ§Š Materials Required</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                            ${dryMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">â„ï¸</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Dry Ice Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${dryIceNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    ğŸ“¦ ${dryMachines} dry machine(s) Ã— 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${flowerShowerMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">ğŸŒ¸</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Flowers Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${flowersNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    ğŸŒº ${flowerShowerMachines} flower shower machine(s) Ã— 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${totalElectricityKV > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">âš¡</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Electricity Required</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${totalElectricityKV} KV</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    âš¡ 3 KV items: ${items.filter(i => electricity3KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs | 1 KV items: ${items.filter(i => electricity1KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Export Buttons -->
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="OMS.printForecast()">ğŸ–¨ï¸ ${this.t('print')}</button>
                        <button class="btn btn-info" onclick="OMS.exportForecastPDF()">${this.t('exportPDF')}</button>
                        <button class="btn btn-warning" onclick="OMS.shareForecastWhatsApp()">${this.t('shareWhatsApp')}</button>
                    </div>

                    <!-- Items Table -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">ğŸ“¦ ${this.t('itemsPreparationList')}</h3>
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th style="width: 5%;">${this.t('sr')}</th>
                                        <th style="width: 25%;">${this.t('itemName')}</th>
                                        <th style="width: 10%;">${this.t('required')}</th>
                                        <th style="width: 10%;">${this.t('inStock')}</th>
                                        <th style="width: 10%;">${this.t('difference')}</th>
                                        <th style="width: 10%;">${this.t('status')}</th>
                                        <th style="width: 30%;">${this.t('usedInOrders')}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${items.map((item, index) => {
                                        const statusBadge = item.difference >= 0
                                            ? `<span style="background: var(--success); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">âœ… ${this.t('ok')}</span>`
                                            : `<span style="background: var(--danger); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">âš ï¸ ${this.t('short')} ${item.difference}</span>`;

                                        const ordersText = item.orders.slice(0, 3).map(o => o.orderId).join(', ') +
                                            (item.orders.length > 3 ? ` +${item.orders.length - 3} ${this.t('more')}` : '');

                                        return `
                                            <tr style="background: ${item.difference < 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'};">
                                                <td>${index + 1}</td>
                                                <td><strong>${item.name}</strong></td>
                                                <td><strong>${item.required}</strong></td>
                                                <td>${item.inStock}</td>
                                                <td style="color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                </td>
                                                <td>${statusBadge}</td>
                                                <td>
                                                    <small style="color: var(--text-gray);">${ordersText}</small>
                                                    <button class="btn btn-secondary btn-small" onclick="OMS.showItemOrderDetails('${item.name.replace(/'/g, "\\'")}')"> ${this.t('details')}</button>
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                                <tfoot>
                                    <tr style="background: var(--light); font-weight: 700;">
                                        <td colspan="2">${this.t('grandTotal')}</td>
                                        <td>${totalItems}</td>
                                        <td>${items.reduce((sum, i) => sum + i.inStock, 0)}</td>
                                        <td style="color: ${items.reduce((sum, i) => sum + i.difference, 0) >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                            ${items.reduce((sum, i) => sum + i.difference, 0)}
                                        </td>
                                        <td colspan="2"></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Orders Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">ğŸ“‹ ${this.t('orderDetailsBreakdown')}</h3>
                        </div>
                        <div style="display: grid; gap: 1rem;">
                            ${orders.map(order => {
                                const items = this.getItemsFromOrder(order, startDate, endDate);
                                const statusColor = {
                                    'Confirmed': 'var(--success)',
                                    'Completed': 'var(--info)',
                                    'Cancelled': 'var(--danger)'
                                }[order.status] || 'var(--warning)';

                                return `
                                    <div style="border: 2px solid var(--border); border-radius: var(--radius); padding: 1rem; background: var(--bg-card);">
                                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                                            <div>
                                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--primary);">${order.orderId}</div>
                                                <div style="color: var(--text-dark); font-weight: 500;">${order.clientName}</div>
                                                <div style="font-size: 0.9rem; color: var(--text-gray);">
                                                    ğŸ“ ${order.venue} |
                                                    ğŸ“… ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)} |
                                                    ğŸ• ${order.readyTime || 'N/A'}
                                                </div>
                                            </div>
                                            <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                ${order.status || 'Pending'}
                                            </span>
                                        </div>
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                                            <strong style="font-size: 0.9rem; color: var(--text-gray);">Items Required:</strong>
                                            <div style="margin-top: 0.25rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                ${items.map(item => `
                                                    <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                        ${item.name}: <strong>${item.quantity}</strong>
                                                    </span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                // Store current forecast data for export
                this.currentForecastData = {
                    orders,
                    items,
                    startDate,
                    endDate,
                    weatherData,
                    stats: {
                        totalOrders: orders.length,
                        confirmed: confirmedOrders,
                        pending: pendingOrders,
                        completed: completedOrders,
                        totalItems: totalItems,
                        shortages: shortageItems.length,
                        sufficient: okItems.length
                    }
                };

                // Set up weather auto-refresh for preparation tab (every 15 minutes)
                if (this.preparationWeatherInterval) {
                    clearInterval(this.preparationWeatherInterval);
                }
                this.preparationWeatherInterval = setInterval(() => this.updatePreparationWeather(), 900000);
            },

            async updatePreparationWeather() {
                if (!this.currentForecastData || !this.currentForecastData.startDate) return;

                try {
                    const weatherApiKey = this.data.settings.weatherApiKey || '';
                    const defaultCity = this.data.settings.defaultCity || 'Delhi';
                    const weatherData = await Utils.getWeatherForecast(defaultCity, this.currentForecastData.startDate, weatherApiKey);

                    // Update the stored weather data
                    this.currentForecastData.weatherData = weatherData;

                    // Re-render the forecast results with updated weather
                    this.renderForecastResults(
                        this.currentForecastData.orders,
                        this.currentForecastData.items,
                        this.currentForecastData.startDate,
                        this.currentForecastData.endDate,
                        weatherData
                    );
                } catch (error) {
                    console.error('Error updating preparation weather:', error);
                }
            },

            showItemOrderDetails(itemName) {
                if (!this.currentForecastData) return;

                const item = this.currentForecastData.items.find(i => i.name === itemName);
                if (!item) return;

                const ordersHtml = item.orders.map(o => `
                    <div style="padding: 0.75rem; border-bottom: 1px solid var(--border);">
                        <div style="font-weight: 600; color: var(--primary);">${o.orderId}</div>
                        <div style="color: var(--text-gray); font-size: 0.9rem;">${o.clientName}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                Pcs: <strong>${o.quantity}</strong>
                            </span>
                        </div>
                    </div>
                `).join('');

                this.showModal(`ğŸ“¦ ${itemName}`, `
                    <div style="margin-bottom: 1rem;">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${item.required}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Required</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);">${item.inStock}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">In Stock</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Difference</div>
                            </div>
                        </div>
                    </div>
                    <h3 style="margin-bottom: 0.5rem;">Used in ${item.orders.length} order(s):</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: var(--radius);">
                        ${ordersHtml}
                    </div>
                `);
            },

            printForecast() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to print', 'error');
                    return;
                }

                const { items, orders, startDate, endDate, stats } = this.currentForecastData;

                const printWindow = window.open('', '', 'width=800,height=600');
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Preparation Forecast - ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #667eea; margin-top: 20px; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #667eea; color: white; }
                            .shortage { background: #fee; color: #c00; font-weight: bold; }
                            .ok { background: #efe; color: #060; font-weight: bold; }
                            .summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
                            .summary-card { border: 2px solid #667eea; padding: 15px; border-radius: 8px; text-align: center; }
                            .summary-card .value { font-size: 2rem; font-weight: bold; color: #667eea; }
                            .summary-card .label { color: #666; margin-top: 5px; }
                            @media print {
                                button { display: none; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>ğŸ“‹ Preparation & Forecast Report</h1>
                        <p><strong>Period:</strong> ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</p>
                        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

                        <div class="summary">
                            <div class="summary-card">
                                <div class="value">${stats.totalOrders}</div>
                                <div class="label">Total Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${items.length}</div>
                                <div class="label">Unique Items</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.totalItems}</div>
                                <div class="label">Total Pieces</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.confirmed}</div>
                                <div class="label">Confirmed Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: ${stats.shortages > 0 ? '#c00' : '#060'};">${stats.shortages}</div>
                                <div class="label">Items Short</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: #060;">${stats.sufficient}</div>
                                <div class="label">Items OK</div>
                            </div>
                        </div>

                        <h2>ğŸ“¦ Items Preparation List</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Sr</th>
                                    <th>Item Name</th>
                                    <th>Required</th>
                                    <th>In Stock</th>
                                    <th>Difference</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr class="${item.difference < 0 ? 'shortage' : ''}">
                                        <td>${index + 1}</td>
                                        <td><strong>${item.name}</strong></td>
                                        <td>${item.required}</td>
                                        <td>${item.inStock}</td>
                                        <td class="${item.difference >= 0 ? 'ok' : 'shortage'}">
                                            ${item.difference >= 0 ? '+' : ''}${item.difference}
                                        </td>
                                        <td>${item.difference >= 0 ? 'âœ… OK' : 'âš ï¸ SHORT'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <h2>ğŸ“‹ Orders Summary</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order ID</th>
                                    <th>Client</th>
                                    <th>Venue</th>
                                    <th>Date</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${orders.map(order => `
                                    <tr>
                                        <td>${order.orderId}</td>
                                        <td>${order.clientName}</td>
                                        <td>${order.venue}</td>
                                        <td>${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}</td>
                                        <td>${order.status || 'Pending'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <button onclick="window.print()" style="background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-top: 20px;">
                            ğŸ–¨ï¸ Print This Report
                        </button>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            },

            exportForecastPDF() {
                this.showToast('PDF export coming soon! Use Print for now.', 'info');
                // Future: Implement PDF generation using jsPDF or similar
            },

            shareForecastWhatsApp() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to share', 'error');
                    return;
                }

                const { items, startDate, endDate, stats } = this.currentForecastData;

                // Create WhatsApp message
                let message = `ğŸ“‹ *PREPARATION FORECAST*\n\n`;
                message += `ğŸ“… *Period:* ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}\n\n`;
                message += `ğŸ“Š *SUMMARY*\n`;
                message += `â€¢ Total Orders: ${stats.totalOrders}\n`;
                message += `â€¢ Confirmed: ${stats.confirmed}\n`;
                message += `â€¢ Total Items: ${items.length}\n`;
                message += `â€¢ Total Pieces: ${stats.totalItems}\n`;
                message += `â€¢ Shortages: ${stats.shortages}\n\n`;

                message += `ğŸ“¦ *ITEMS NEEDED*\n`;
                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;

                items.forEach((item, index) => {
                    const status = item.difference >= 0 ? 'âœ…' : 'âš ï¸';
                    message += `${index + 1}. ${item.name}\n`;
                    message += `   Required: ${item.required} | Stock: ${item.inStock} | ${item.difference >= 0 ? '+' : ''}${item.difference} ${status}\n`;
                });

                message += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                message += `Generated: ${new Date().toLocaleString()}\n`;
                message += `\n_Powered by FirepowerSFX Admin_`;

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            // ========== CUSTOMERS (Delegated to Customers module) ==========
            renderCustomers() {
                Customers.render(this);
            },

            filterAndDisplayCustomers(searchQuery) {
                Customers.filterAndDisplay(searchQuery, this);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            async viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) {
                    this.showToast('Customer not found!', 'error');
                    return;
                }

                // Get all orders for this customer
                const customerOrders = this.data.orders.filter(o =>
                    o.clientName === customer.name || o.contact === customer.contact
                ).sort((a, b) => {
                    // Sort by date, newest first
                    const dateA = new Date(a.orderDate || a.createdAt || 0);
                    const dateB = new Date(b.orderDate || b.createdAt || 0);
                    return dateB - dateA;
                });

                // Calculate customer lifetime stats
                const totalSpent = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.grandTotal || o.totalAmount || 0), 0);
                const totalPaid = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.advancePaid || 0), 0);
                const totalPending = totalSpent - totalPaid;
                const fullyPaidOrders = customerOrders.filter(o => parseFloat(o.financials?.balanceDue || 0) === 0).length;

                // Check if user can view financials
                const canViewFinancials = await this.canViewFinancials();

                const modalHTML = `
                    <div class="modal show" id="customerProfileModal" onclick="if(event.target === this) OMS.closeModal('customerProfileModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('customerProfileModal')">Ã—</button>
                            <h2>ğŸ‘¤ Customer Profile</h2>

                            <!-- Customer Info -->
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h3 style="margin: 0 0 0.5rem 0; font-size: 1.75rem;">${customer.name}</h3>
                                        <p style="margin: 0.25rem 0; opacity: 0.9;">ğŸ“ ${customer.contact || 'N/A'}</p>
                                        ${customer.email ? `<p style="margin: 0.25rem 0; opacity: 0.9;">ğŸ“§ ${customer.email}</p>` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 1.25rem; font-weight: bold;">Total Orders: ${customerOrders.length}</div>
                                        ${canViewFinancials ? `<div style="font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem;">Lifetime Value: â‚¹${totalSpent.toLocaleString('en-IN')}</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            ${canViewFinancials ? `
                                <!-- Lifetime Stats -->
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                                    <div style="background: #e8f5e9; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #4caf50;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #2e7d32;">â‚¹${totalSpent.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Spent</div>
                                    </div>
                                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #2196f3;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #1565c0;">â‚¹${totalPaid.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Paid</div>
                                    </div>
                                    <div style="background: #ffebee; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #f44336;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #c62828;">â‚¹${totalPending.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Pending</div>
                                    </div>
                                    <div style="background: #f3e5f5; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #9c27b0;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #6a1b9a;">${fullyPaidOrders}/${customerOrders.length}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Fully Paid</div>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- All Orders -->
                            <div>
                                <h3 style="margin: 0 0 1rem 0;">ğŸ“‹ All Orders</h3>
                                ${customerOrders.length === 0 ? '<p style="text-align: center; color: #999; padding: 2rem;">No orders found for this customer.</p>' : customerOrders.map(order => {
                                    const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                                    const totalPaid = parseFloat(order.financials?.advancePaid || 0);
                                    const balanceDue = parseFloat(order.financials?.balanceDue || 0);
                                    const paymentProgress = orderTotal > 0 ? (totalPaid / orderTotal) * 100 : 0;
                                    const paymentStatus = order.financials?.paymentStatus || 'pending';

                                    // Get payment history for this order
                                    const orderPayments = this.data.payments.filter(p => p.orderDocId === order.docId || p.orderId === order.orderId);

                                    // Get items
                                    let items = [];
                                    if (order.isMultiDay && order.dayWiseData) {
                                        order.dayWiseData.forEach(day => {
                                            if (day.functions) {
                                                day.functions.forEach(func => {
                                                    if (func.items) {
                                                        items.push(...func.items);
                                                    }
                                                });
                                            }
                                        });
                                    } else if (order.items) {
                                        items = order.items;
                                    }

                                    const statusColors = {
                                        'confirmed': '#2196f3',
                                        'pending': '#ff9800',
                                        'completed': '#4caf50',
                                        'cancelled': '#f44336'
                                    };
                                    const statusColor = statusColors[order.status?.toLowerCase()] || '#9e9e9e';

                                    return `
                                        <div style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem; background: white;">
                                            <!-- Order Header -->
                                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                                                <div>
                                                    <h4 style="margin: 0 0 0.5rem 0; color: #667eea; font-size: 1.1rem;">${order.orderId || 'Pending'}</h4>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        ğŸ“… ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}
                                                    </p>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        ğŸ“ ${order.venue || 'N/A'}
                                                    </p>
                                                </div>
                                                <div style="text-align: right;">
                                                    <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${order.status || 'Pending'}</span>
                                                    ${canViewFinancials ? `
                                                        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                                                            Total: <strong style="color: #667eea;">â‚¹${orderTotal.toLocaleString('en-IN')}</strong>
                                                        </div>
                                                    ` : ''}
                                                </div>
                                            </div>

                                            ${canViewFinancials ? `
                                                <!-- Payment Progress -->
                                                <div style="background: #f5f5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                                        <span style="font-size: 0.9rem; font-weight: 600;">Payment Status</span>
                                                        <span style="font-size: 0.9rem; font-weight: bold; color: ${paymentProgress === 100 ? '#4caf50' : '#667eea'};">
                                                            ${paymentProgress.toFixed(0)}% (â‚¹${totalPaid.toLocaleString('en-IN')} / â‚¹${orderTotal.toLocaleString('en-IN')})
                                                        </span>
                                                    </div>
                                                    <div style="width: 100%; height: 10px; background: #e0e0e0; border-radius: 5px; overflow: hidden;">
                                                        <div style="width: ${paymentProgress}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                                                    </div>
                                                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                                                        <span>âœ… Paid: â‚¹${totalPaid.toLocaleString('en-IN')}</span>
                                                        <span>â³ Due: â‚¹${balanceDue.toLocaleString('en-IN')}</span>
                                                    </div>
                                                </div>

                                                <!-- Payment History -->
                                                ${orderPayments.length > 0 ? `
                                                    <details style="margin-bottom: 1rem;">
                                                        <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">ğŸ’³ Payment History (${orderPayments.length} payments)</summary>
                                                        <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                            ${orderPayments.map(payment => `
                                                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #eee;">
                                                                    <div>
                                                                        <div style="font-weight: 600; color: #333;">${payment.paymentType || 'Payment'}</div>
                                                                        <div style="font-size: 0.85rem; color: #666;">${Utils.formatDate(payment.paymentDate || payment.timestamp?.toDate?.())} â€¢ ${payment.paymentMethod}</div>
                                                                    </div>
                                                                    <div style="font-weight: bold; color: #4caf50;">â‚¹${parseFloat(payment.amount).toLocaleString('en-IN')}</div>
                                                                </div>
                                                            `).join('')}
                                                        </div>
                                                    </details>
                                                ` : '<p style="font-size: 0.85rem; color: #999; margin-bottom: 1rem;">No payments recorded yet.</p>'}
                                            ` : ''}

                                            <!-- Order Items -->
                                            <details>
                                                <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">ğŸ“¦ Items (${items.length})</summary>
                                                <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                    ${items.map(item => `
                                                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0;">
                                                            <span style="color: #333;">${item.name}</span>
                                                            <span style="font-weight: 600; color: #667eea;">x${item.quantity}</span>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </details>
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid #e0e0e0;">
                                <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('customerProfileModal')">Close</button>
                                <button type="button" class="btn btn-primary" onclick="OMS.createOrderForCustomer('${customerId}'); OMS.closeModal('customerProfileModal');">â• New Order</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ QUOTATIONS MANAGEMENT ============

            renderQuotations() {
                const container = document.getElementById('quotations');

                // Initialize quotations data if not exists
                if (!this.data.quotations) {
                    this.data.quotations = [];
                }

                const viewMode = this.quotationViewMode || 'list'; // 'list' or 'create'

                if (viewMode === 'create' || viewMode === 'edit') {
                    this.renderQuotationForm();
                } else {
                    this.renderQuotationsList();
                }
            },

            renderQuotationsList() {
                const container = document.getElementById('quotations');
                const quotations = this.data.quotations || [];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“„ Quotations</h2>
                            <button class="btn btn-success" onclick="OMS.createNewQuotation()">â• Create New Quotation</button>
                        </div>

                        <div class="form-row">
                            <input type="text" id="quotationSearch" class="form-input" placeholder="Search quotations by customer, date...">
                        </div>

                        <div id="quotationsListContainer">
                            ${quotations.length === 0 ? `
                                <div style="text-align: center; padding: 3rem; color: #999;">
                                    <h3>ğŸ“„ No Quotations Yet</h3>
                                    <p>Create your first quotation to get started</p>
                                    <button class="btn btn-primary" onclick="OMS.createNewQuotation()">Create Quotation</button>
                                </div>
                            ` : this.renderQuotationsTable(quotations)}
                        </div>
                    </div>
                `;

                // Add search listener
                setTimeout(() => {
                    const searchInput = document.getElementById('quotationSearch');
                    if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                            this.filterQuotations(e.target.value);
                        });
                    }
                }, 100);
            },

            renderQuotationsTable(quotations) {
                const sortedQuotations = quotations.sort((a, b) =>
                    new Date(b.createdAt) - new Date(a.createdAt)
                );

                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Customer</th>
                                    <th>Event Date</th>
                                    <th>Amount</th>
                                    <th>Status</th>
                                    <th>Created</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedQuotations.map(q => `
                                    <tr>
                                        <td>
                                            <strong>${q.customer.name}</strong><br>
                                            <small>${q.customer.contact}</small>
                                        </td>
                                        <td>${Utils.formatDate(q.customer.eventDate)}</td>
                                        <td><strong>â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <span class="status-badge ${q.status === 'converted' ? 'success' : q.status === 'sent' ? 'info' : 'warning'}">
                                                ${q.status === 'converted' ? 'âœ“ Converted' : q.status === 'sent' ? 'ğŸ“¤ Sent' : 'ğŸ“ Draft'}
                                            </span>
                                        </td>
                                        <td><small>${Utils.formatDate(q.createdAt)}</small></td>
                                        <td>
                                            <div class="btn-group">
                                                <button class="btn btn-info btn-small" onclick="OMS.viewQuotationPDF('${q.id}')" title="View PDF">ğŸ‘ï¸</button>
                                                <button class="btn btn-primary btn-small" onclick="OMS.editQuotation('${q.id}')" title="Edit">âœï¸</button>
                                                <button class="btn btn-success btn-small" onclick="OMS.sendQuotationWhatsApp('${q.id}')" title="Send WhatsApp">ğŸ“±</button>
                                                ${q.status !== 'converted' ? `<button class="btn btn-warning btn-small" onclick="OMS.convertQuotationToOrder('${q.id}')" title="Convert to Order">ğŸ”„</button>` : ''}
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteQuotation('${q.id}')" title="Delete">ğŸ—‘ï¸</button>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            filterQuotations(searchQuery) {
                const quotations = this.data.quotations || [];
                let filteredQuotations = quotations;

                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredQuotations = quotations.filter(q => {
                        return (
                            (q.customer.name && q.customer.name.toLowerCase().includes(query)) ||
                            (q.customer.contact && q.customer.contact.includes(query)) ||
                            (q.customer.eventVenue && q.customer.eventVenue.toLowerCase().includes(query)) ||
                            (q.quotationNumber && q.quotationNumber.toLowerCase().includes(query))
                        );
                    });
                }

                document.getElementById('quotationsListContainer').innerHTML = this.renderQuotationsTable(filteredQuotations);
            },

            createNewQuotation() {
                this.editingQuotationId = null;
                this.currentQuotation = {
                    items: [],
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                this.quotationViewMode = 'create';
                this.renderQuotations();
            },

            renderQuotationForm() {
                const container = document.getElementById('quotations');
                const q = this.currentQuotation || {
                    items: [],
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                const isEditing = !!this.editingQuotationId;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h2 class="card-title">ğŸ“ ${isEditing ? 'Edit' : 'Create'} Quotation</h2>
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">â† Back to List</button>
                            </div>
                        </div>

                        <div class="card" style="background: #f9f9f9;">
                            <!-- Customer Details -->
                            <h3 style="margin: 0 0 1rem 0;">ğŸ‘¤ Customer Details</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label required">Customer Name</label>
                                    <input type="text" id="quotCustomerName" class="form-input" value="${q.customer.name || ''}" required placeholder="Enter customer name" list="customerNamesList">
                                    <datalist id="customerNamesList">
                                        ${this.data.customers.map(c => `<option value="${c.name}">`).join('')}
                                    </datalist>
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Contact Number</label>
                                    <input type="tel" id="quotCustomerContact" class="form-input" value="${q.customer.contact || ''}" required placeholder="Enter contact number">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Email (Optional)</label>
                                    <input type="email" id="quotCustomerEmail" class="form-input" value="${q.customer.email || ''}" placeholder="Enter email">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Event Date</label>
                                    <input type="date" id="quotEventDate" class="form-input" value="${q.customer.eventDate || ''}" required>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Event Venue</label>
                                <textarea id="quotEventVenue" class="form-input" rows="2" placeholder="Enter event venue address">${q.customer.eventVenue || ''}</textarea>
                            </div>
                        </div>

                        <!-- Items Section -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">ğŸ“¦ Items</h3>
                            <div class="form-group">
                                <input type="text" id="quotItemSearch" class="form-input" placeholder="ğŸ” Search items from inventory or add custom...">
                            </div>

                            <div id="quotationItemsContainer">
                                ${q.items.length === 0 ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No items added yet. Search and add items above.</p>
                                    </div>
                                ` : this.renderQuotationItems(q.items)}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addCustomQuotationItem()">â• Add Custom Item</button>
                        </div>

                        <!-- Discount Section -->
                        <div class="card" style="background: #fff3cd;">
                            <h3 style="margin: 0 0 1rem 0;">ğŸ’° Discount</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Discount Type</label>
                                    <select id="quotDiscountType" class="form-select" onchange="OMS.updateQuotationDiscount()">
                                        <option value="percentage" ${q.discount.type === 'percentage' ? 'selected' : ''}>Percentage (%)</option>
                                        <option value="fixed" ${q.discount.type === 'fixed' ? 'selected' : ''}>Fixed Amount (â‚¹)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Discount Value</label>
                                    <input type="number" id="quotDiscountValue" class="form-input" value="${q.discount.value || 0}" min="0" step="0.01" oninput="OMS.updateQuotationDiscount()">
                                </div>
                            </div>
                        </div>

                        <!-- Financial Summary -->
                        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h3 style="color: white; margin: 0 0 1.5rem 0;">ğŸ’µ Financial Summary</h3>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Subtotal:</span>
                                    <strong id="quotSubtotal">â‚¹0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Discount:</span>
                                    <strong id="quotDiscountAmount">- â‚¹0</strong>
                                </div>
                                <hr style="border-color: rgba(255,255,255,0.3);">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; font-size: 1.25rem;">
                                    <span><strong>Grand Total:</strong></span>
                                    <strong id="quotGrandTotal">â‚¹0</strong>
                                </div>
                            </div>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px;">
                                <h4 style="color: white; margin: 0 0 1rem 0; font-size: 1rem;">Payment Schedule:</h4>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Advance Payment (50%):</span>
                                    <strong id="quotBooking50">â‚¹0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Event Day Payment (50%):</span>
                                    <strong id="quotEventDay50">â‚¹0</strong>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div class="card">
                            <div class="btn-group">
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">Cancel</button>
                                <button class="btn btn-info" onclick="OMS.previewQuotationPDF()">ğŸ‘ï¸ Preview PDF</button>
                                <button class="btn btn-primary" onclick="OMS.saveQuotation('draft')">ğŸ’¾ Save as Draft</button>
                                <button class="btn btn-success" onclick="OMS.saveAndSendQuotation()">ğŸ“± Save & Send WhatsApp</button>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize item search after render
                setTimeout(() => {
                    this.initQuotationItemSearch();
                    this.recalculateQuotation();
                }, 100);
            },

            renderQuotationItems(items) {
                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th style="width: 5%;">#</th>
                                    <th style="width: 35%;">Item Name</th>
                                    <th style="width: 15%;">Quantity</th>
                                    <th style="width: 20%;">Rate (â‚¹)</th>
                                    <th style="width: 20%;">Subtotal</th>
                                    <th style="width: 5%;"></th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>
                                            <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationItem(${index}, 'name', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.quantity}" min="1" onchange="OMS.updateQuotationItem(${index}, 'quantity', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.rate}" min="0" step="0.01" onchange="OMS.updateQuotationItem(${index}, 'rate', this.value)" style="width: 100%;">
                                        </td>
                                        <td><strong>â‚¹${item.subtotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <button class="btn btn-danger btn-small" onclick="OMS.removeQuotationItem(${index})" title="Remove">Ã—</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            initQuotationItemSearch() {
                const searchInput = document.getElementById('quotItemSearch');
                if (!searchInput) return;

                // Create dropdown container
                let dropdown = document.getElementById('quotItemSearchDropdown');
                if (!dropdown) {
                    dropdown = document.createElement('div');
                    dropdown.id = 'quotItemSearchDropdown';
                    dropdown.style.cssText = 'position: absolute; top: 100%; left: 0; right: 0; margin-top: 4px; z-index: 1000; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-height: 250px; overflow-y: auto; display: none;';
                    searchInput.parentElement.style.position = 'relative';
                    searchInput.parentElement.appendChild(dropdown);
                }

                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length < 2) {
                        dropdown.style.display = 'none';
                        return;
                    }

                    // Search from inventory
                    const items = this.data.inventory?.items || [];
                    const matches = items.filter(item =>
                        item.name.toLowerCase().includes(query)
                    ).slice(0, 10);

                    // Show dropdown with results
                    if (matches.length > 0) {
                        dropdown.innerHTML = matches.map(item => `
                            <div onclick="OMS.selectQuotationItem('${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})"
                                 style="padding: 0.75rem 1rem; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s;"
                                 onmouseover="this.style.background='#f5f5f5'"
                                 onmouseout="this.style.background='white'">
                                <div style="font-weight: 500;">${item.name}</div>
                                <div style="font-size: 0.85rem; color: #666;">
                                    ${item.category ? `Category: ${item.category} â€¢ ` : ''}
                                    Price: â‚¹${(item.defaultPrice || 0).toLocaleString('en-IN')}
                                </div>
                            </div>
                        `).join('');
                        dropdown.style.display = 'block';
                    } else {
                        dropdown.style.display = 'none';
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (e.target !== searchInput && !dropdown.contains(e.target)) {
                        dropdown.style.display = 'none';
                    }
                });

                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        dropdown.style.display = 'none';
                        const itemName = e.target.value.trim();
                        if (itemName) {
                            this.addQuotationItemByName(itemName);
                            e.target.value = '';
                        }
                    }
                });
            },

            selectQuotationItem(itemName, price) {
                const dropdown = document.getElementById('quotItemSearchDropdown');
                const searchInput = document.getElementById('quotItemSearch');

                if (dropdown) dropdown.style.display = 'none';
                if (searchInput) searchInput.value = '';

                // Add item with price from inventory
                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: price || 0,
                    subtotal: price || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addQuotationItemByName(itemName) {
                // Search in inventory first
                const inventoryItem = this.data.inventory?.items?.find(i =>
                    i.name.toLowerCase() === itemName.toLowerCase()
                );

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: inventoryItem?.defaultPrice || 0,
                    subtotal: inventoryItem?.defaultPrice || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addCustomQuotationItem() {
                const itemName = prompt('Enter item name:');
                if (!itemName) return;

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: 0,
                    subtotal: 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            updateQuotationItem(index, field, value) {
                if (!this.currentQuotation.items[index]) return;

                this.currentQuotation.items[index][field] = field === 'name' ? value : parseFloat(value) || 0;

                // Recalculate subtotal
                const item = this.currentQuotation.items[index];
                item.subtotal = item.quantity * item.rate;

                this.recalculateQuotation();
                this.updateQuotationDisplay();
            },

            removeQuotationItem(index) {
                this.currentQuotation.items.splice(index, 1);
                this.updateQuotationDisplay();
            },

            updateQuotationDiscount() {
                const type = Utils.get('quotDiscountType');
                const value = parseFloat(Utils.get('quotDiscountValue')) || 0;

                this.currentQuotation.discount = { type, value, amount: 0 };
                this.recalculateQuotation();
            },

            recalculateQuotation() {
                const q = this.currentQuotation;
                if (!q) return;

                // Calculate subtotal
                q.financials.subtotal = q.items.reduce((sum, item) => sum + item.subtotal, 0);

                // Calculate discount
                if (q.discount.type === 'percentage') {
                    q.financials.discountAmount = (q.financials.subtotal * q.discount.value) / 100;
                } else {
                    q.financials.discountAmount = q.discount.value;
                }

                // Calculate grand total
                q.financials.grandTotal = Math.max(0, q.financials.subtotal - q.financials.discountAmount);

                // Calculate payment schedule (50-50 split)
                q.financials.booking50 = (q.financials.grandTotal * 0.5).toFixed(2);
                q.financials.eventDay50 = (q.financials.grandTotal * 0.5).toFixed(2);

                // Update display
                this.updateFinancialDisplay();
            },

            updateFinancialDisplay() {
                const q = this.currentQuotation;
                if (!q) return;

                const subtotalEl = document.getElementById('quotSubtotal');
                const discountEl = document.getElementById('quotDiscountAmount');
                const grandTotalEl = document.getElementById('quotGrandTotal');
                const booking50El = document.getElementById('quotBooking50');
                const eventDay50El = document.getElementById('quotEventDay50');

                if (subtotalEl) subtotalEl.textContent = `â‚¹${q.financials.subtotal.toLocaleString('en-IN')}`;
                if (discountEl) discountEl.textContent = `- â‚¹${q.financials.discountAmount.toLocaleString('en-IN')}`;
                if (grandTotalEl) grandTotalEl.textContent = `â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}`;
                if (booking50El) booking50El.textContent = `â‚¹${parseFloat(q.financials.booking50).toLocaleString('en-IN')}`;
                if (eventDay50El) eventDay50El.textContent = `â‚¹${parseFloat(q.financials.eventDay50).toLocaleString('en-IN')}`;
            },

            updateQuotationDisplay() {
                const container = document.getElementById('quotationItemsContainer');
                if (container && this.currentQuotation) {
                    container.innerHTML = this.currentQuotation.items.length === 0 ?
                        `<div style="text-align: center; padding: 2rem; color: #999;"><p>No items added yet. Search and add items above.</p></div>` :
                        this.renderQuotationItems(this.currentQuotation.items);
                }
                this.recalculateQuotation();
            },

            cancelQuotationEdit() {
                this.quotationViewMode = 'list';
                this.editingQuotationId = null;
                this.currentQuotation = null;
                this.renderQuotations();
            },

            async saveQuotation(status = 'draft') {
                const q = this.currentQuotation;
                if (!q) return;

                // Validate
                const customerName = Utils.get('quotCustomerName');
                const customerContact = Utils.get('quotCustomerContact');
                const eventDate = Utils.get('quotEventDate');

                if (!customerName || !customerContact || !eventDate) {
                    this.showToast('Please fill customer name, contact, and event date', 'error');
                    return;
                }

                if (q.items.length === 0) {
                    this.showToast('Please add at least one item', 'error');
                    return;
                }

                // Gather data
                q.customer = {
                    name: customerName,
                    contact: customerContact,
                    email: Utils.get('quotCustomerEmail'),
                    eventDate: eventDate,
                    eventVenue: Utils.get('quotEventVenue')
                };

                const quotationData = {
                    ...q,
                    status: status,
                    updatedAt: new Date().toISOString()
                };

                try {
                    if (this.editingQuotationId) {
                        // Update existing
                        quotationData.id = this.editingQuotationId;
                        quotationData.quotationNumber = q.quotationNumber;
                        quotationData.createdAt = q.createdAt;

                        await db.collection('quotations').doc(this.editingQuotationId).update(quotationData);
                        this.showToast('âœ… Quotation updated!', 'success');
                    } else {
                        // Create new
                        quotationData.quotationNumber = await this.generateQuotationNumber();
                        quotationData.createdAt = new Date().toISOString();
                        quotationData.quotationDate = new Date().toISOString().split('T')[0];
                        quotationData.validUntil = this.calculateValidUntil();

                        const docRef = await db.collection('quotations').add(quotationData);
                        quotationData.id = docRef.id;

                        this.showToast('âœ… Quotation saved!', 'success');
                    }

                    // Reload quotations
                    await this.loadQuotationsFromFirestore();

                    // Return to list
                    this.quotationViewMode = 'list';
                    this.renderQuotations();

                    return quotationData;
                } catch (error) {
                    console.error('Error saving quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async generateQuotationNumber() {
                const year = new Date().getFullYear();
                const quotations = this.data.quotations || [];
                const thisYearQuotations = quotations.filter(q =>
                    q.quotationNumber && q.quotationNumber.startsWith(`QT-${year}`)
                );

                const nextNumber = thisYearQuotations.length + 1;
                return `QT-${year}-${String(nextNumber).padStart(3, '0')}`;
            },

            calculateValidUntil() {
                const date = new Date();
                date.setDate(date.getDate() + 15); // Valid for 15 days
                return date.toISOString().split('T')[0];
            },

            async saveAndSendQuotation() {
                const quotation = await this.saveQuotation('sent');
                if (quotation) {
                    await this.sendQuotationWhatsApp(quotation.id);
                }
            },

            async editQuotation(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) {
                    this.showToast('Quotation not found', 'error');
                    return;
                }

                this.editingQuotationId = quotationId;
                this.currentQuotation = JSON.parse(JSON.stringify(quotation)); // Deep copy

                // Clean up old tax fields if they exist
                if (this.currentQuotation.financials) {
                    delete this.currentQuotation.financials.tax;
                    delete this.currentQuotation.financials.taxRate;
                }

                this.quotationViewMode = 'edit';
                this.renderQuotations();
            },

            async deleteQuotation(quotationId) {
                if (!confirm('Delete this quotation?')) return;

                try {
                    await db.collection('quotations').doc(quotationId).delete();
                    this.showToast('âœ… Quotation deleted', 'success');

                    await this.loadQuotationsFromFirestore();
                    this.renderQuotations();
                } catch (error) {
                    console.error('Error deleting quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async loadQuotationsFromFirestore() {
                try {
                    const snapshot = await db.collection('quotations').orderBy('createdAt', 'desc').get();
                    const quotations = [];

                    snapshot.forEach(doc => {
                        quotations.push({ id: doc.id, ...doc.data() });
                    });

                    this.data.quotations = quotations;
                    console.log(`âœ… Loaded ${quotations.length} quotations`);
                } catch (error) {
                    console.error('Error loading quotations:', error);
                }
            },

            async viewQuotationPDF(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                this.generateAndShowPDF(quotation);
            },

            async previewQuotationPDF() {
                const q = this.currentQuotation;
                if (!q || q.items.length === 0) {
                    this.showToast('Add items first to preview', 'error');
                    return;
                }

                // Create temporary quotation object for preview
                const tempQuotation = {
                    ...q,
                    customer: {
                        name: Utils.get('quotCustomerName') || 'Customer Name',
                        contact: Utils.get('quotCustomerContact') || '0000000000',
                        email: Utils.get('quotCustomerEmail') || '',
                        eventDate: Utils.get('quotEventDate') || '',
                        eventVenue: Utils.get('quotEventVenue') || ''
                    },
                    quotationDate: new Date().toISOString().split('T')[0],
                    validUntil: this.calculateValidUntil()
                };

                this.generateAndShowPDF(tempQuotation);
            },

            generateAndShowPDF(quotation) {
                // Store quotation for download button
                this.currentPDFQuotation = quotation;

                // This will use jsPDF or html2pdf - for now, show preview in modal
                const modalHTML = `
                    <div class="modal show" id="pdfPreviewModal" onclick="if(event.target === this) OMS.closeModal('pdfPreviewModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('pdfPreviewModal')">Ã—</button>
                            <h2>ğŸ“„ Quotation Preview</h2>

                            ${this.renderQuotationPDFContent(quotation)}

                            <div style="margin-top: 2rem; text-align: center;">
                                <button class="btn btn-primary" onclick="OMS.downloadQuotationPDF()">ğŸ“¥ Download PDF</button>
                                <button class="btn btn-success" onclick="OMS.sendQuotationWhatsApp('${quotation.id}')">ğŸ“± Send WhatsApp</button>
                                <button class="btn btn-secondary" onclick="OMS.closeModal('pdfPreviewModal')">Close</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            renderQuotationPDFContent(q) {
                return `
                    <div id="quotationPDFContent" style="background: white; padding: 3rem; font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; border: 2px solid #ddd;">
                        <!-- Header -->
                        <div style="text-align: center; margin-bottom: 2rem; border-bottom: 3px solid #667eea; padding-bottom: 1.5rem;">
                            <h1 style="margin: 0; font-size: 2.5rem; color: #667eea;">QUOTATION</h1>
                            <div style="margin-top: 1rem; color: #666;">
                                <div>Date: ${Utils.formatDate(q.quotationDate || new Date().toISOString().split('T')[0])}</div>
                                <div>Valid Until: ${Utils.formatDate(q.validUntil || this.calculateValidUntil())}</div>
                            </div>
                        </div>

                        <!-- Customer Details -->
                        <div style="background: #f9f9f9; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">Customer Details</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold; width: 150px;">Name:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.name}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Contact:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.contact}</td>
                                </tr>
                                ${q.customer.email ? `
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Email:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.email}</td>
                                </tr>
                                ` : ''}
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Event Date:</td>
                                    <td style="padding: 0.5rem 0;">${Utils.formatDate(q.customer.eventDate)}</td>
                                </tr>
                                ${q.customer.eventVenue ? `
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold; vertical-align: top;">Venue:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.eventVenue}</td>
                                </tr>
                                ` : ''}
                            </table>
                        </div>

                        <!-- Items Table -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">Items</h3>
                            <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;">
                                <thead style="background: #667eea; color: white;">
                                    <tr>
                                        <th style="padding: 0.75rem; text-align: left; border: 1px solid #ddd;">#</th>
                                        <th style="padding: 0.75rem; text-align: left; border: 1px solid #ddd;">Item Name</th>
                                        <th style="padding: 0.75rem; text-align: center; border: 1px solid #ddd;">Qty</th>
                                        <th style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">Rate (â‚¹)</th>
                                        <th style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">Amount (â‚¹)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${q.items.map((item, index) => `
                                        <tr>
                                            <td style="padding: 0.75rem; border: 1px solid #ddd;">${index + 1}</td>
                                            <td style="padding: 0.75rem; border: 1px solid #ddd;">${item.name}</td>
                                            <td style="padding: 0.75rem; text-align: center; border: 1px solid #ddd;">${item.quantity}</td>
                                            <td style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">â‚¹${item.rate.toLocaleString('en-IN')}</td>
                                            <td style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">â‚¹${item.subtotal.toLocaleString('en-IN')}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>

                        <!-- Financial Summary -->
                        <div style="margin-bottom: 2rem; border: 2px solid #667eea; border-radius: 8px; padding: 1.5rem; background: #f9f9ff;">
                            <table style="width: 100%; max-width: 400px; margin-left: auto;">
                                <tr>
                                    <td style="padding: 0.5rem; text-align: right;">Subtotal:</td>
                                    <td style="padding: 0.5rem; text-align: right; font-weight: bold;">â‚¹${q.financials.subtotal.toLocaleString('en-IN')}</td>
                                </tr>
                                ${q.financials.discountAmount > 0 ? `
                                <tr>
                                    <td style="padding: 0.5rem; text-align: right;">Discount:</td>
                                    <td style="padding: 0.5rem; text-align: right; color: #f44336; font-weight: bold;">- â‚¹${q.financials.discountAmount.toLocaleString('en-IN')}</td>
                                </tr>
                                ` : ''}
                                <tr style="border-top: 2px solid #667eea;">
                                    <td style="padding: 0.75rem; text-align: right; font-size: 1.25rem; font-weight: bold;">Grand Total:</td>
                                    <td style="padding: 0.75rem; text-align: right; font-size: 1.25rem; font-weight: bold; color: #667eea;">â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}</td>
                                </tr>
                            </table>
                        </div>

                        <!-- Payment Schedule -->
                        <div style="background: #e8f5e9; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #2e7d32;">Payment Schedule</h3>
                            <ul style="list-style: none; padding: 0; margin: 0;">
                                <li style="padding: 0.5rem 0; border-bottom: 1px solid #ddd;">
                                    <strong>Advance Payment (50%):</strong>
                                    <span style="float: right; font-weight: bold;">â‚¹${parseFloat(q.financials.booking50).toLocaleString('en-IN')}</span>
                                </li>
                                <li style="padding: 0.5rem 0;">
                                    <strong>Event Day Payment (50%):</strong>
                                    <span style="float: right; font-weight: bold;">â‚¹${parseFloat(q.financials.eventDay50).toLocaleString('en-IN')}</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Terms & Conditions -->
                        <div style="background: #fff3e0; padding: 1.5rem; border-radius: 8px; font-size: 0.9rem; line-height: 1.6;">
                            <h3 style="margin: 0 0 1rem 0; color: #e65100;">Terms & Conditions</h3>

                            <p style="margin: 0 0 0.5rem 0;"><strong>PAYMENT TERMS:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>50% advance payment required to confirm order</li>
                                <li>50% payment on event day before event starts</li>
                            </ul>

                            <p style="margin: 0 0 0.5rem 0;"><strong>INCLUSIONS:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>Generator for electricity provision</li>
                            </ul>

                            <p style="margin: 0 0 0.5rem 0;"><strong>CUSTOMER RESPONSIBILITIES:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>Fire safety permissions and Fire NOC</li>
                                <li>Venue/ground permissions</li>
                                <li>AMC (Amusement Park) permissions</li>
                                <li>First aid provision arrangements</li>
                                <li>Resource/facility manager approval</li>
                                <li>Proof of contractor competence</li>
                                <li>Security clearance for restricted materials</li>
                            </ul>

                            <p style="margin: 0;"><strong>VALIDITY:</strong> 15 days from quotation date</p>
                        </div>

                    </div>
                `;
            },

            async downloadQuotationPDF() {
                // Use stored quotation from preview
                const quotation = this.currentPDFQuotation;
                if (!quotation) {
                    this.showToast('Please open quotation preview first', 'error');
                    return;
                }

                try {
                    // Access jsPDF from global window object
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 15;
                    let yPos = 15;

                    // Purple color theme
                    const primaryColor = [102, 126, 234]; // #667eea
                    const darkText = [31, 41, 55];
                    const grayText = [107, 114, 128];

                    // === HEADER SECTION ===
                    // QUOTATION Title (centered)
                    doc.setFontSize(32);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('QUOTATION', pageWidth / 2, yPos, { align: 'center' });

                    // Date info and contact (centered, compact)
                    yPos += 8;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...grayText);
                    const dateText = `Date: ${Utils.formatDate(quotation.quotationDate || new Date().toISOString().split('T')[0])} | Valid Until: ${Utils.formatDate(quotation.validUntil || this.calculateValidUntil())}`;
                    doc.text(dateText, pageWidth / 2, yPos, { align: 'center' });

                    // Purple line separator
                    yPos += 6;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1.5);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    // === CUSTOMER DETAILS BOX ===
                    yPos += 6;
                    doc.setFillColor(249, 249, 249);
                    const customerBoxHeight = quotation.customer.eventVenue ? 22 : 18;
                    doc.rect(margin, yPos, pageWidth - 2 * margin, customerBoxHeight, 'F');

                    yPos += 5;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Customer Details', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('Name:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.name, margin + 20, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Contact:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.contact, margin + 20, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Event Date:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.customer.eventDate), margin + 25, yPos);

                    if (quotation.customer.eventVenue) {
                        yPos += 4;
                        doc.setFont('helvetica', 'bold');
                        doc.text('Venue:', margin + 3, yPos);
                        doc.setFont('helvetica', 'normal');
                        const venueText = doc.splitTextToSize(quotation.customer.eventVenue, pageWidth - margin - 25);
                        doc.text(venueText, margin + 20, yPos);
                    }

                    // === ITEMS TABLE ===
                    yPos += 4;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Items', margin, yPos);

                    yPos += 3;

                    // Table header
                    doc.setFillColor(...primaryColor);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 6, 'F');

                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text('#', margin + 2, yPos + 4);
                    doc.text('Item Description', margin + 10, yPos + 4);
                    doc.text('Qty', margin + 100, yPos + 4);
                    doc.text('Rate', margin + 118, yPos + 4);
                    doc.text('Total', pageWidth - margin - 15, yPos + 4, { align: 'right' });

                    yPos += 6;

                    // Table rows
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    quotation.items.forEach((item, index) => {
                        if (yPos > pageHeight - 50) {
                            doc.addPage();
                            yPos = 20;
                        }

                        // Alternating row colors
                        if (index % 2 === 0) {
                            doc.setFillColor(248, 249, 250);
                            doc.rect(margin, yPos, pageWidth - 2 * margin, 5, 'F');
                        }

                        doc.setFontSize(8);
                        doc.text(String(index + 1), margin + 2, yPos + 3.5);

                        const itemName = doc.splitTextToSize(item.name, 85);
                        doc.text(itemName, margin + 10, yPos + 3.5);

                        doc.text(String(item.quantity), margin + 100, yPos + 3.5);
                        // Format numbers without toLocaleString to avoid encoding issues
                        const rateStr = String(Math.round(item.rate));
                        const totalStr = String(Math.round(item.subtotal));
                        doc.text(rateStr, margin + 118, yPos + 3.5);
                        doc.text(totalStr, pageWidth - margin - 2, yPos + 3.5, { align: 'right' });

                        yPos += 5;
                    });

                    // Table bottom border
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(0.5);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    // === FINANCIAL SUMMARY BOX ===
                    yPos += 5;

                    const summaryBoxX = pageWidth - margin - 60;

                    // Subtotal
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('Subtotal:', summaryBoxX, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(Math.round(quotation.financials.subtotal)), pageWidth - margin - 2, yPos, { align: 'right' });

                    // Discount
                    if (quotation.financials.discountAmount > 0) {
                        yPos += 4;
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(239, 68, 68); // red
                        doc.text('Discount:', summaryBoxX, yPos);
                        doc.setFont('helvetica', 'bold');
                        doc.text('- ' + String(Math.round(quotation.financials.discountAmount)), pageWidth - margin - 2, yPos, { align: 'right' });
                    }

                    // Grand Total
                    yPos += 5;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1);
                    doc.line(summaryBoxX, yPos - 1, pageWidth - margin, yPos - 1);

                    yPos += 3;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('TOTAL:', summaryBoxX, yPos);
                    doc.setFontSize(12);
                    doc.text(String(Math.round(quotation.financials.grandTotal)), pageWidth - margin - 2, yPos, { align: 'right' });

                    // === PAYMENT SCHEDULE BOX ===
                    yPos += 6;
                    doc.setFillColor(232, 245, 233);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 12, 'F');

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(46, 125, 50);
                    doc.text('Payment Schedule', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('Advance Payment (50%):', margin + 3, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(Math.round(quotation.financials.grandTotal * 0.5)), pageWidth - margin - 3, yPos, { align: 'right' });

                    yPos += 4;
                    doc.setFont('helvetica', 'normal');
                    doc.text('Event Day Payment (50%):', margin + 3, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(Math.round(quotation.financials.grandTotal * 0.5)), pageWidth - margin - 3, yPos, { align: 'right' });

                    // === TERMS & CONDITIONS ===
                    yPos += 6;
                    if (yPos > pageHeight - 65) {
                        doc.addPage();
                        yPos = 15;
                    }

                    doc.setFillColor(255, 243, 224);
                    const termsHeight = 52;
                    doc.rect(margin, yPos, pageWidth - 2 * margin, termsHeight, 'F');

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(230, 81, 0);
                    doc.text('Terms & Conditions', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('PAYMENT:', margin + 3, yPos);

                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    doc.text('50% advance payment, 50% on event day', margin + 5, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('INCLUSIONS:', margin + 3, yPos);
                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    doc.text('Generator for electricity', margin + 5, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('CUSTOMER RESPONSIBILITIES:', margin + 3, yPos);
                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    const responsibilities = [
                        'Fire safety & NOC, Venue permissions, AMC permissions,',
                        'First aid, Manager approval, Contractor competence, Security clearance'
                    ];
                    responsibilities.forEach(resp => {
                        doc.text(resp, margin + 5, yPos);
                        yPos += 3;
                    });

                    yPos += 3;
                    doc.setFont('helvetica', 'bold');
                    doc.text('VALIDITY:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(' 15 days from quotation date', margin + 18, yPos);

                    // === FOOTER ===
                    // (Footer removed as per user request)

                    // Save PDF
                    const fileName = `Quotation_${quotation.customer.name.replace(/\s+/g, '_')}_${quotation.quotationDate || 'draft'}.pdf`;
                    doc.save(fileName);

                    this.showToast('âœ… PDF downloaded successfully!', 'success');
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    this.showToast('Error generating PDF: ' + error.message, 'error');
                }
            },

            async sendQuotationWhatsApp(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) {
                    this.showToast('Quotation not found', 'error');
                    return;
                }

                try {
                    this.showToast('Generating PDF...', 'info');

                    // Generate PDF
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 15;
                    let yPos = 15;

                    const primaryColor = [102, 126, 234];
                    const darkText = [31, 41, 55];
                    const grayText = [107, 114, 128];

                    // Header
                    doc.setFontSize(32);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('QUOTATION', pageWidth / 2, yPos, { align: 'center' });

                    yPos += 8;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...grayText);
                    const dateText = `Date: ${Utils.formatDate(quotation.quotationDate || new Date().toISOString().split('T')[0])} | Valid Until: ${Utils.formatDate(quotation.validUntil || this.calculateValidUntil())}`;
                    doc.text(dateText, pageWidth / 2, yPos, { align: 'center' });

                    yPos += 6;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1.5);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    // Customer Details
                    yPos += 6;
                    doc.setFillColor(249, 249, 249);
                    const customerBoxHeight = quotation.customer.eventVenue ? 22 : 18;
                    doc.rect(margin, yPos, pageWidth - 2 * margin, customerBoxHeight, 'F');

                    yPos += 5;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Customer Details', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('Name:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.name, margin + 20, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Contact:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.contact, margin + 20, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Event Date:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.customer.eventDate), margin + 25, yPos);

                    if (quotation.customer.eventVenue) {
                        yPos += 4;
                        doc.setFont('helvetica', 'bold');
                        doc.text('Venue:', margin + 3, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(quotation.customer.eventVenue, margin + 20, yPos);
                    }

                    // Items Table
                    yPos += customerBoxHeight - 16;
                    doc.setFillColor(...primaryColor);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 5, 'F');

                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text('#', margin + 2, yPos + 3.5);
                    doc.text('Item Name', margin + 10, yPos + 3.5);
                    doc.text('Qty', margin + 100, yPos + 3.5);
                    doc.text('Rate', margin + 118, yPos + 3.5);
                    doc.text('Total', pageWidth - margin - 2, yPos + 3.5, { align: 'right' });

                    yPos += 5;
                    doc.setTextColor(...darkText);
                    doc.setFont('helvetica', 'normal');

                    quotation.items.forEach((item, index) => {
                        if (yPos > pageHeight - 80) {
                            doc.addPage();
                            yPos = 15;
                        }

                        if (index % 2 === 0) {
                            doc.setFillColor(249, 249, 249);
                            doc.rect(margin, yPos, pageWidth - 2 * margin, 5, 'F');
                        }

                        doc.text(String(index + 1), margin + 2, yPos + 3.5);
                        const itemName = doc.splitTextToSize(item.name, 85);
                        doc.text(itemName, margin + 10, yPos + 3.5);
                        doc.text(String(item.quantity), margin + 100, yPos + 3.5);
                        const rateStr = String(Math.round(item.rate));
                        const totalStr = String(Math.round(item.subtotal));
                        doc.text(rateStr, margin + 118, yPos + 3.5);
                        doc.text(totalStr, pageWidth - margin - 2, yPos + 3.5, { align: 'right' });

                        yPos += 5;
                    });

                    // Totals
                    const summaryBoxX = pageWidth - margin - 50;
                    yPos += 3;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('Subtotal:', summaryBoxX, yPos);
                    doc.text(String(Math.round(quotation.financials.subtotal)), pageWidth - margin - 2, yPos, { align: 'right' });

                    yPos += 4;
                    doc.text('Discount:', summaryBoxX, yPos);
                    doc.text(String(Math.round(quotation.financials.discountAmount || 0)), pageWidth - margin - 2, yPos, { align: 'right' });

                    yPos += 5;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1);
                    doc.line(summaryBoxX, yPos - 1, pageWidth - margin, yPos - 1);

                    yPos += 3;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('TOTAL:', summaryBoxX, yPos);
                    doc.setFontSize(12);
                    doc.text(String(Math.round(quotation.financials.grandTotal)), pageWidth - margin - 2, yPos, { align: 'right' });

                    // Payment Schedule
                    yPos += 6;
                    doc.setFillColor(232, 245, 233);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 12, 'F');

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(46, 125, 50);
                    doc.text('Payment Schedule', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('Advance Payment (50%):', margin + 3, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(Math.round(quotation.financials.grandTotal * 0.5)), pageWidth - margin - 3, yPos, { align: 'right' });

                    yPos += 4;
                    doc.setFont('helvetica', 'normal');
                    doc.text('Event Day Payment (50%):', margin + 3, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(Math.round(quotation.financials.grandTotal * 0.5)), pageWidth - margin - 3, yPos, { align: 'right' });

                    // Terms & Conditions
                    yPos += 6;
                    if (yPos > pageHeight - 65) {
                        doc.addPage();
                        yPos = 15;
                    }

                    doc.setFillColor(255, 243, 224);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 52, 'F');

                    yPos += 4;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(230, 81, 0);
                    doc.text('Terms & Conditions', margin + 3, yPos);

                    yPos += 4;
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('PAYMENT:', margin + 3, yPos);
                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    doc.text('50% advance payment, 50% on event day', margin + 5, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('INCLUSIONS:', margin + 3, yPos);
                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    doc.text('Generator for electricity', margin + 5, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.text('CUSTOMER RESPONSIBILITIES:', margin + 3, yPos);
                    yPos += 3;
                    doc.setFont('helvetica', 'normal');
                    doc.text('Fire safety & NOC, Venue permissions, AMC permissions,', margin + 5, yPos);
                    yPos += 3;
                    doc.text('First aid, Manager approval, Contractor competence, Security clearance', margin + 5, yPos);

                    yPos += 6;
                    doc.setFont('helvetica', 'bold');
                    doc.text('VALIDITY:', margin + 3, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(' 15 days from quotation date', margin + 18, yPos);

                    // Convert PDF to Blob and download
                    const pdfBlob = doc.output('blob');
                    const fileName = `Quotation_${quotation.customer.name.replace(/\s+/g, '_')}.pdf`;

                    // Download PDF
                    const url = URL.createObjectURL(pdfBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Open WhatsApp desktop app
                    setTimeout(() => {
                        window.open('whatsapp://', '_blank');
                        this.showToast('ğŸ“¥ PDF downloaded! Now attach it in WhatsApp', 'success');
                    }, 500);

                    // Update status to sent
                    if (quotation.status === 'draft') {
                        await db.collection('quotations').doc(quotationId).update({
                            status: 'sent',
                            sentAt: new Date().toISOString()
                        });

                        await this.loadQuotationsFromFirestore();
                        if (this.quotationViewMode === 'list') {
                            this.renderQuotations();
                        }
                    }

                } catch (error) {
                    console.error('Error generating PDF for WhatsApp:', error);
                    this.showToast('Error generating PDF: ' + error.message, 'error');
                }
            },

            async convertQuotationToOrder(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                if (!confirm(`Convert quotation to order for ${quotation.customer.name}?`)) return;

                // Switch to orders tab and prefill with quotation data
                this.switchTab('orders');

                setTimeout(() => {
                    // Fill customer details
                    Utils.set('clientName', quotation.customer.name);
                    Utils.set('contact', quotation.customer.contact);
                    if (quotation.customer.eventVenue) Utils.set('venue', quotation.customer.eventVenue);
                    if (quotation.customer.eventDate) {
                        Utils.set('date', quotation.customer.eventDate);
                        Utils.set('startDate', quotation.customer.eventDate);
                    }

                    // TODO: Add items to order (requires integration with order form)
                    // For now, just navigate to orders tab with customer info prefilled

                    this.showToast('âœ… Order form prefilled with quotation data', 'success');
                }, 200);

                // Mark quotation as converted
                try {
                    await db.collection('quotations').doc(quotationId).update({
                        status: 'converted',
                        convertedAt: new Date().toISOString()
                    });

                    await this.loadQuotationsFromFirestore();
                } catch (error) {
                    console.error('Error updating quotation status:', error);
                }
            },

            // ========== TEAM MANAGEMENT (Delegated to Team module) ==========

            renderTeam() {
                return Team.renderTeam(this);
            },

            renderTeamTable() {
                return Team.renderTeamTable(this);
            },

            addTeamMember() {
                return Team.addTeamMember(this);
            },

            clearTeamForm() {
                return Team.clearTeamForm();
            },

            editTeamMember(id) {
                return Team.editTeamMember(this, id);
            },

            saveTeamMemberEdit(id) {
                return Team.saveTeamMemberEdit(this, id);
            },

            deleteTeamMember(id) {
                return Team.deleteTeamMember(this, id);
            },

            async renderUserRoles() {
                return await Team.renderUserRoles(this);
            },

            populateTeamDropdowns() {
                return Team.populateTeamDropdowns(this);
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                return Team.populateFunctionTeamDropdowns(this, dayIndex, functionIndex);
            },

            updateTeamDropdowns() {
                return Team.updateTeamDropdowns(this);
            },

            async saveTeamMemberToFirestore(teamMember) {
                return await Team.saveTeamMemberToFirestore(this, teamMember);
            },

            async loadTeamFromFirestore() {
                return await Team.loadTeamFromFirestore(this);
            },

            async deleteTeamMemberFromFirestore(teamMemberId) {
                return await Team.deleteTeamMemberFromFirestore(teamMemberId);
            },

            // ========== ANALYTICS (Delegated to Analytics module) ==========

            renderAnalytics() {
                return Analytics.renderAnalytics(this);
            },

            // ========== SETTINGS (Delegated to Settings module) ==========

            renderSettings() {
                return Settings.renderSettings(this);
            },

            async saveSettings() {
                return await Settings.saveSettings(this);
            },

            resetAllData() {
                return Settings.resetAllData(this);
            },

            resetSettings() {
                return Settings.resetSettings(this);
            },

            async saveSettingsToFirestore() {
                return await Settings.saveSettingsToFirestore(this);
            },

            async loadSettingsFromFirestore() {
                return await Settings.loadSettingsFromFirestore(this);
            },

            // ========== FINANCIALS (Delegated to Financials module) ==========

            async renderFinancials() {
                return await Financials.renderFinancials(this);
            },

            setFinancialRange(range) {
                return Financials.setFinancialRange(this, range);
            },

            applyFinancialRange() {
                return Financials.applyFinancialRange(this);
            },

            async showAddPaymentModal() {
                return await Financials.showAddPaymentModal(this);
            },

            async loadOrderForPayment() {
                return await Financials.loadOrderForPayment(this);
            },

            updateRemainingAfterNewPayment() {
                return Financials.updateRemainingAfterNewPayment(this);
            },

            async savePayment(event) {
                return await Financials.savePayment(this, event);
            },

            togglePaymentBreakdown(paymentId) {
                return Financials.togglePaymentBreakdown(this, paymentId);
            },

            async deletePayment(paymentId) {
                return await Financials.deletePayment(this, paymentId);
            },

            editPayment(paymentId) {
                return Financials.editPayment(this, paymentId);
            },

            async saveEditedPayment(event, paymentId) {
                return await Financials.saveEditedPayment(this, event, paymentId);
            },

            async recalculateOrderFinancials(orderDocId) {
                return await Financials.recalculateOrderFinancials(this, orderDocId);
            },

            async addPaymentForOrder(orderId) {
                return await Financials.addPaymentForOrder(this, orderId);
            },

            async showAddExpenseModal() {
                return await Financials.showAddExpenseModal(this);
            },

            async saveExpense(event) {
                return await Financials.saveExpense(this, event);
            },

            async deleteExpense(expenseId) {
                return await Financials.deleteExpense(this, expenseId);
            },

            editExpense(expenseId) {
                return Financials.editExpense(this, expenseId);
            },

            async updateExpense(event, expenseId) {
                return await Financials.updateExpense(this, event, expenseId);
            },

            exportFinancialReport() {
                return Financials.exportFinancialReport(this);
            },

            showMonthlyComparison() {
                return Financials.showMonthlyComparison(this);
            },

            // ========== PRINT/PDF (Delegated to Print module) ==========

            downloadOrderImage(orderId) {
                return Print.downloadOrderImage(this, orderId);
            },

            async generateSingleOrderImage(order) {
                return await Print.generateSingleOrderImage(this, order);
            },

            async generateMultiOrderImage(orders, date) {
                return await Print.generateMultiOrderImage(this, orders, date);
            },

            getPaperDimensions() {
                return Print.getPaperDimensions(this);
            },

            updateLoadingMessage(loading, message) {
                return Print.updateLoadingMessage(loading, message);
            },

            // ========== PREPARATION (Delegated to Preparation module) ==========

            renderPreparation() {
                return Preparation.renderPreparation(this);
            },

            quickForecast(period) {
                return Preparation.quickForecast(this, period);
            },

            async generateForecast() {
                return await Preparation.generateForecast(this);
            },

            getOrdersInDateRange(startDate, endDate) {
                return Preparation.getOrdersInDateRange(this, startDate, endDate);
            },

            // ============ TEAM NOTIFICATIONS (Kept in main file) ============


            notifyAllocatedTeam() {
                // Get current order form data
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v) : [];

                // Get order details
                const orderId = Utils.get('orderId') || 'NEW';
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const venueMapLink = Utils.get('venueMapLink');
                const date = Utils.get('orderDate');
                const readyTime = Utils.get('readyTime');
                const contact = Utils.get('contact');

                if (!clientName || !venue || !date) {
                    this.showToast('Please fill Order ID, Client Name, Venue, and Date first', 'error');
                    return;
                }

                // Get items from current order
                const items = this.currentOrderItems || [];

                // Collect all team members to notify
                const teamToNotify = [];

                // Prepare team list for messages
                const teamListForMessage = [
                    driverName ? `Driver: ${driverName}` : null,
                    operatorName ? `Operator: ${operatorName}` : null,
                    helperNames.length > 0 ? `Helper(s): ${helperNames.join(', ')}` : null
                ].filter(Boolean).join(', ');

                // Add Driver
                if (driverName) {
                    const driver = this.data.team.find(m => m.name === driverName);
                    if (driver && driver.whatsApp) {
                        teamToNotify.push({ member: driver, role: 'Driver' });
                    }
                }

                // Add Operator
                if (operatorName) {
                    const operator = this.data.team.find(m => m.name === operatorName);
                    if (operator && operator.whatsApp) {
                        teamToNotify.push({ member: operator, role: 'Operator' });
                    }
                }

                // Add ALL Helpers
                if (helperNames.length > 0) {
                    helperNames.forEach(helperName => {
                        const helper = this.data.team.find(m => m.name === helperName);
                        if (helper && helper.whatsApp) {
                            teamToNotify.push({ member: helper, role: 'Helper' });
                        }
                    });
                }

                if (teamToNotify.length === 0) {
                    this.showToast('No team members selected or no WhatsApp numbers found', 'warning');
                    return;
                }

                // Send notifications with delay to prevent popup blocking
                teamToNotify.forEach((item, index) => {
                    setTimeout(() => {
                        this.sendTeamMemberNotification(item.member, item.role, {
                            orderId, clientName, venue, venueMapLink, date, readyTime, contact, items,
                            teamList: teamListForMessage
                        });
                    }, index * 500); // 500ms delay between each window
                });

                this.showToast(`Opening WhatsApp for ${teamToNotify.length} team member(s): ${teamToNotify.map(t => t.member.name).join(', ')}`, 'success');

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'team_allocation',
                    orderId,
                    recipients: teamToNotify.map(t => t.member.name),
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);
            },

            sendTeamMemberNotification(teamMember, role, orderDetails) {
                const { orderId, clientName, venue, date, readyTime, contact, items, teamList, venueMapLink } = orderDetails;

                // Format items list
                const itemsList = items && items.length > 0
                    ? items.map(item => `â€¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}`).join('\n')
                    : 'â€¢ No items added yet';

                // Create WhatsApp message
                let message = `ğŸ‰ *NEW ORDER ASSIGNED TO YOU*\n\n`;
                message += `ğŸ“‹ *Order ID:* ${orderId}\n`;
                message += `ğŸ‘¤ *Client:* ${clientName}\n`;
                message += `ğŸ“ *Venue:* ${venue}\n`;
                if (venueMapLink) {
                    message += `ğŸ—ºï¸ *Location:* ${venueMapLink}\n`;
                }
                message += `ğŸ“… *Date:* ${Utils.formatDate(date)}\n`;
                message += `ğŸ• *Ready Time:* ${readyTime || 'TBD'}\n\n`;
                message += `ğŸ­ *Your Role:* ${role.toUpperCase()}\n\n`;

                if (teamList) {
                    message += `ğŸ‘· *Team Members:*\n${teamList}\n\n`;
                }

                message += `ğŸ“¦ *Items Required:*\n${itemsList}\n\n`;

                if (contact) {
                    message += `ğŸ“ *Client Contact:* ${contact}\n\n`;
                }

                message += `âš¡ Please confirm receipt by replying "OK"\n\n`;
                message += `--\n_FirepowerSFX Order Management_`;

                // Encode and open WhatsApp
                const phoneNumber = teamMember.whatsApp.replace(/[^0-9]/g, '');
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
            },

            sendManagerReport() {
                // Get all managers
                const managers = this.data.team.filter(m => m.roles.includes('Manager') && m.status === 'Active');

                if (managers.length === 0) {
                    this.showToast('No managers found in team. Add a team member with Manager role first.', 'warning');
                    return;
                }

                // Get the current order data from the form
                const currentOrderId = Utils.get('orderId');
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const venueMapLink = Utils.get('venueMapLink');
                const currentOrderDate = Utils.get('orderDate');
                const currentStartDate = Utils.get('startDate');
                const eventType = Utils.get('eventTypeSelect');
                const isMultiDay = eventType === 'multi';
                const readyTime = Utils.get('readyTime');
                const status = Utils.get('orderStatus');
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get helpers from text input (comma-separated)
                const helperInput = document.getElementById('helper');
                const helperNames = helperInput ? helperInput.value.trim() : '';

                // Check if we have order data in the form
                if (!clientName || !venue) {
                    this.showToast('Please open/select an order first to send report', 'warning');
                    return;
                }

                // Use the order date from the form
                const targetDate = isMultiDay ? currentStartDate : currentOrderDate;

                if (!targetDate) {
                    this.showToast('Order date is missing', 'error');
                    return;
                }

                // Build manager report for THIS SPECIFIC ORDER ONLY
                let message = `ğŸ“Š *ORDER REPORT*\n`;
                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

                message += `*ORDER ID:* ${currentOrderId || 'NEW'}\n`;
                message += `ğŸ‘¤ *Client:* ${clientName}\n`;
                message += `ğŸ“ *Venue:* ${venue}\n`;
                if (venueMapLink) {
                    message += `ğŸ—ºï¸ *Location:* ${venueMapLink}\n`;
                }
                message += `ğŸ“… *Date:* ${Utils.formatDate(targetDate)}\n`;
                message += `ğŸ• *Ready Time:* ${readyTime || 'TBD'}\n`;
                message += `ğŸ“Š *Status:* ${status || 'Pending'}\n\n`;

                if (driverName || operatorName || helperNames) {
                    message += `ğŸ‘· *Team Allocation:*\n`;
                    if (driverName) message += `  â€¢ Driver: ${driverName}\n`;
                    if (operatorName) message += `  â€¢ Operator: ${operatorName}\n`;
                    if (helperNames) message += `  â€¢ Helper(s): ${helperNames}\n`;
                } else {
                    message += `âš ï¸ *Team Not Allocated Yet*\n`;
                }

                message += `\n`;

                // Get items from current order
                const items = this.currentOrderItems || [];
                if (items.length > 0) {
                    message += `ğŸ“¦ *Items Required:*\n`;
                    items.forEach(item => {
                        message += `  â€¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}\n`;
                    });
                    message += `\n`;
                }

                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                message += `--\n_FirepowerSFX Admin_`;

                // Filter managers with valid WhatsApp numbers
                const managersWithWhatsApp = managers.filter(m => m.whatsApp && m.whatsApp.trim() !== '');

                if (managersWithWhatsApp.length === 0) {
                    this.showToast('No managers have WhatsApp numbers configured', 'warning');
                    return;
                }

                // Send to all managers with delay to prevent popup blocking
                const encodedMessage = encodeURIComponent(message);
                const managerNames = [];

                managersWithWhatsApp.forEach((manager, index) => {
                    const phoneNumber = manager.whatsApp.replace(/[^0-9]/g, '');
                    if (phoneNumber) {
                        managerNames.push(manager.name);
                        // Add delay between each window to prevent popup blocking
                        setTimeout(() => {
                            window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
                        }, index * 500); // 500ms delay between each window
                    }
                });

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'manager_report',
                    recipients: managerNames,
                    orderId: currentOrderId,
                    targetDate: targetDate,
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);

                this.showToast(`Opening WhatsApp for ${managerNames.length} manager(s): ${managerNames.join(', ')}`, 'success');
            },

            // WhatsApp Date Filter Methods
            filterOrdersByDate(selectedDate) {
                if (!selectedDate) return [];

                // Filter orders that match the selected date
                const filteredOrders = this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day events, check if selected date falls within the range
                        const startDate = new Date(order.startDate);
                        const endDate = new Date(order.endDate);
                        const checkDate = new Date(selectedDate);
                        return checkDate >= startDate && checkDate <= endDate;
                    } else {
                        // For single-day events, match the exact date
                        return order.date === selectedDate;
                    }
                });

                // Sort by order ID or creation time
                return filteredOrders.sort((a, b) => {
                    const aId = a.orderId || '';
                    const bId = b.orderId || '';
                    return aId.localeCompare(bId);
                });
            },

            generateWhatsAppOrdersMessage(orders, selectedDate) {
                if (!orders || orders.length === 0) return '';

                // Header with date (only once for entire message)
                let message = `ğŸ“… ${Utils.formatDate(selectedDate)}\n`;
                message += `Total Orders: ${orders.length}\n\n`;

                // Collect special items for RAW MATERIAL calculations (like preparation tab)
                let totalDryIceMachines = 0;
                let totalFlowerShowerMachines = 0;
                let totalElectricityKV = 0;

                orders.forEach((order, index) => {
                    // Collect all items from this order
                    let orderItems = [];

                    // Find specific day data for multi-day orders
                    let specificDayData = null;
                    if (order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0) {
                        specificDayData = order.dayWiseData.find(dayData => dayData.date === selectedDate);
                    }

                    // Collect items from order
                    if (specificDayData && specificDayData.functions) {
                        specificDayData.functions.forEach(func => {
                            if (func.items && func.items.length > 0) {
                                orderItems = orderItems.concat(func.items);
                            }
                        });
                    } else if (order.items && order.items.length > 0) {
                        orderItems = order.items;
                    }

                    // Calculate dry ice machines (20kg per machine)
                    orderItems.forEach(item => {
                        const itemNameLower = item.name?.toLowerCase() || '';
                        const qty = item.quantity || 0;

                        // Dry ice machines
                        if (itemNameLower.includes('dry ice')) {
                            totalDryIceMachines += qty;
                        }

                        // Flower shower machines
                        if ((itemNameLower.includes('flower') && itemNameLower.includes('shower')) ||
                            itemNameLower.includes('flower shower machine')) {
                            totalFlowerShowerMachines += qty;
                        }

                        // Electricity - 3KV machines
                        const electricity3KV = ['showven sonic boom (co2 jet)', 'sonic boom', 'dry ice machine', '5 head flame'];
                        if (electricity3KV.some(name => itemNameLower.includes(name))) {
                            totalElectricityKV += qty * 3;
                        }
                        // Electricity - 1KV machines
                        else {
                            const electricity1KV = ['sparkular', 'spinner', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];
                            if (electricity1KV.some(name => itemNameLower.includes(name))) {
                                totalElectricityKV += qty * 1;
                            }
                        }
                    });

                    // Order details (compact format)
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `${order.clientName || 'N/A'}\n`;
                    message += `Contact: ${order.contact || 'N/A'}\n`;

                    // Venue with location combined
                    if (order.venue && order.venue !== 'N/A') {
                        message += `Venue: ${order.venue}`;

                        // DEBUG: Log venue location data
                        console.log(`ğŸ—ºï¸ Order ${order.orderId} venue data:`, {
                            venue: order.venue,
                            venueLocation: order.venueLocation,
                            venueMapLink: order.venueMapLink
                        });

                        // Add Google Maps location link - check all possible sources
                        let mapsUrl = null;

                        // Priority 1: venueLocation with coordinates
                        if (order.venueLocation && order.venueLocation.lat && order.venueLocation.lng) {
                            if (order.venueLocation.place_id) {
                                mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}&query_place_id=${order.venueLocation.place_id}`;
                                console.log(`âœ… Using place_id link for ${order.orderId}`);
                            } else {
                                mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}+${order.venueLocation.lat},${order.venueLocation.lng}`;
                                console.log(`âœ… Using lat/lng link for ${order.orderId}`);
                            }
                        }
                        // Priority 2: venueMapLink (stored link)
                        else if (order.venueMapLink && order.venueMapLink.trim()) {
                            mapsUrl = order.venueMapLink;
                            console.log(`âœ… Using venueMapLink for ${order.orderId}`);
                        } else {
                            console.warn(`âš ï¸ No location data found for ${order.orderId}`);
                        }

                        if (mapsUrl) {
                            message += `\nğŸ“ ${mapsUrl}`;
                        }
                        message += `\n`;
                    }

                    message += `Time: ${order.readyTime || 'TBD'}\n`;

                    // Functions and items (compact format - no "Items:" label)
                    if (specificDayData && specificDayData.functions) {
                        specificDayData.functions.forEach((func, funcIdx) => {
                            if (func.items && func.items.length > 0) {
                                // Function name
                                if (func.functionType) {
                                    message += `Function - ${func.functionType}`;
                                    if (func.timeSlot) message += ` (${func.timeSlot})`;
                                    message += `\n`;
                                } else if (specificDayData.functions.length > 1) {
                                    message += `Function ${funcIdx + 1}`;
                                    if (func.timeSlot) message += ` (${func.timeSlot})`;
                                    message += `\n`;
                                }

                                // Items directly (no "Items:" label)
                                func.items.forEach(item => {
                                    message += `${item.name} ${item.quantity}`;
                                    if (item.remarks) message += ` (${item.remarks})`;
                                    message += `\n`;
                                });
                            }
                        });
                    } else if (order.items && order.items.length > 0) {
                        // Single-day order items
                        order.items.forEach(item => {
                            message += `${item.name} ${item.quantity}`;
                            if (item.remarks) message += ` (${item.remarks})`;
                            message += `\n`;
                        });
                    }

                    message += `\n`;
                });

                // RAW MATERIALS GRAND TOTAL summary (calculated like preparation tab)
                if (totalDryIceMachines > 0) {
                    const dryIceNeeded = totalDryIceMachines * 20; // 20kg per machine
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `ğŸ§Š DRY ICE - GRAND TOTAL: ${dryIceNeeded}kg\n`;
                    message += `(${totalDryIceMachines} machine${totalDryIceMachines !== 1 ? 's' : ''} Ã— 20kg)\n\n`;
                }

                if (totalFlowerShowerMachines > 0) {
                    const flowersNeeded = totalFlowerShowerMachines * 20; // 20kg per machine
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `ğŸŒ¸ FLOWERS - GRAND TOTAL: ${flowersNeeded}kg\n`;
                    message += `(${totalFlowerShowerMachines} machine${totalFlowerShowerMachines !== 1 ? 's' : ''} Ã— 20kg)\n\n`;
                }

                if (totalElectricityKV > 0) {
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `âš¡ ELECTRICITY - GRAND TOTAL: ${totalElectricityKV}KV\n\n`;
                }

                message += `FirepowerSFX Order Management`;

                return message;
            },

            updateWhatsAppDateFilter() {
                const dateInput = document.getElementById('whatsappFilterDate');
                const previewDiv = document.getElementById('whatsappOrdersPreview');
                const noOrdersDiv = document.getElementById('whatsappNoOrders');
                const ordersListDiv = document.getElementById('whatsappOrdersList');
                const orderCountSpan = document.getElementById('whatsappOrderCount');

                if (!dateInput || !dateInput.value) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'none';
                    return;
                }

                const selectedDate = dateInput.value;
                const filteredOrders = this.filterOrdersByDate(selectedDate);

                if (filteredOrders.length === 0) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'block';
                    return;
                }

                // Show preview
                noOrdersDiv.style.display = 'none';
                previewDiv.style.display = 'block';
                orderCountSpan.textContent = filteredOrders.length;

                // Generate and display message preview
                const message = this.generateWhatsAppOrdersMessage(filteredOrders, selectedDate);
                ordersListDiv.textContent = message;

                // Store message for sending
                this.whatsappCurrentMessage = message;
            },

            sendWhatsAppOrdersReport() {
                if (!this.whatsappCurrentMessage) {
                    this.showToast('Please select a date first', 'warning');
                    return;
                }

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(this.whatsappCurrentMessage);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCalendarTab() {
                document.getElementById('calendar').innerHTML = this.renderCalendar(this.currentCalendarDate || new Date());
            },

            async renderHistory() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('orderHistory')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">${this.t('export')}</button>
                        </div>
                        <!-- Floating Merge Button -->
                        <button class="btn btn-primary" id="mergeSelectedBtn" style="display: none; position: fixed; bottom: 30px; right: 30px; z-index: 1000; padding: 1rem 1.5rem; font-size: 1.1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" onclick="OMS.showMergeModal()">ğŸ”— Merge Selected Orders</button>

                        <div class="form-group" style="margin: 20px 0;">
                            <label class="form-label">ğŸ” Search Orders</label>
                            <input type="text" id="historySearch" class="form-input" placeholder="Search by client name, order ID, date, or venue...">
                            <div id="historySearchResults" class="search-dropdown"></div>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;

                // Add search functionality
                this.setupHistorySearch();

                // Initialize selected orders array
                this.selectedOrdersForMerge = [];

                // Check if user can manage financials
                const canManageFinancials = await this.canViewFinancials();

                // IMPORTANT: Filter out orders that have been merged into other orders
                // Only show orders that are NOT marked as isMerged
                const visibleOrders = this.data.orders.filter(o => !o.isMerged);
                console.log(`ğŸ“‹ History: Showing ${visibleOrders.length} orders (filtered out ${this.data.orders.length - visibleOrders.length} merged orders)`);

                this.renderTable('historyContainer', [
                    { key: 'select', label: 'â˜‘ï¸', render: o => {
                        const isMergedOrder = o.mergedFrom && o.mergedFrom.length > 0;
                        return `<input type="checkbox" class="order-select-checkbox" data-order-id="${o.docId || o.orderId}" ${isMergedOrder ? 'disabled' : ''} onchange="OMS.toggleOrderSelection('${o.docId || o.orderId}')">`;
                    }},
                    { key: 'orderId', label: this.t('orderId'), render: o => {
                        const mergeStatus = o.mergedFrom && o.mergedFrom.length > 0
                            ? `<span style="color: #667eea; font-weight: bold;">ğŸ”— MERGED (${o.mergedFrom.length} orders)</span>`
                            : '';
                        return `<span class="order-id-highlight">${o.orderId}</span> ${mergeStatus}`;
                    }},
                    { key: 'clientName', label: this.t('client') },
                    { key: 'venue', label: this.t('venue') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${this.t(o.status.toLowerCase())}</span>` }
                ], visibleOrders, (row) => {
                    const isMergedOrder = row.mergedFrom && row.mergedFrom.length > 0;
                    const unmergeBtn = isMergedOrder ? `<button class="btn btn-info btn-small" onclick="OMS.unmergeOrder('${row.docId || row.orderId}')">ğŸ”“ Unmerge</button>` : '';
                    const paymentExpenseButtons = canManageFinancials ? `
                        <button class="btn btn-primary btn-small" onclick="OMS.addPaymentForOrder('${row.docId || row.orderId}')">ğŸ’µ Payment</button>
                        <button class="btn btn-warning btn-small" onclick="OMS.addExpenseForOrder('${row.docId || row.orderId}')">ğŸ’¸ Expense</button>
                    ` : '';
                    return `
                        <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('edit')}</button>
                        <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                        ${paymentExpenseButtons}
                        ${unmergeBtn}
                        <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.docId || row.orderId}">${this.t('delete')}</button>
                    `;
                });
            },

            setupHistorySearch() {
                const searchInput = document.getElementById('historySearch');
                const searchResults = document.getElementById('historySearchResults');

                if (!searchInput || !searchResults) return;

                let searchTimeout;

                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim().toLowerCase();

                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        searchResults.innerHTML = '';
                        return;
                    }

                    searchTimeout = setTimeout(() => {
                        // Search through all orders
                        const results = this.data.orders.filter(order => {
                            const clientName = (order.clientName || '').toLowerCase();
                            const orderId = (order.orderId || '').toLowerCase();
                            const venue = (order.venue || '').toLowerCase();
                            const date = order.isMultiDay
                                ? `${Utils.formatDate(order.startDate)} ${Utils.formatDate(order.endDate)}`.toLowerCase()
                                : Utils.formatDate(order.date).toLowerCase();

                            return clientName.includes(query) ||
                                   orderId.includes(query) ||
                                   venue.includes(query) ||
                                   date.includes(query);
                        }); // Show all matching results (no limit)

                        if (results.length === 0) {
                            searchResults.innerHTML = '<div class="search-dropdown-item">No orders found</div>';
                            searchResults.style.display = 'block';
                        } else {
                            searchResults.innerHTML = results.map(order => {
                                const dateDisplay = order.isMultiDay
                                    ? `${Utils.formatDate(order.startDate)} - ${Utils.formatDate(order.endDate)}`
                                    : Utils.formatDate(order.date);
                                const statusClass = `status-${order.status.toLowerCase()}`;

                                return `
                                    <div class="search-dropdown-item" data-order-id="${order.docId || order.orderId}" style="cursor: pointer; padding: 10px; border-bottom: 1px solid var(--border-color);">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <strong>${order.orderId || '[No ID]'}</strong> - ${order.clientName}
                                                <br>
                                                <small style="color: var(--text-gray);">
                                                    ğŸ“… ${dateDisplay} | ğŸ“ ${order.venue || 'N/A'}
                                                </small>
                                            </div>
                                            <span class="status-badge ${statusClass}">${order.status}</span>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            searchResults.style.display = 'block';

                            // Add click handlers to search results
                            searchResults.querySelectorAll('.search-dropdown-item').forEach(item => {
                                const orderId = item.getAttribute('data-order-id');
                                if (orderId && orderId !== 'null') {
                                    item.addEventListener('click', () => {
                                        // Find the order
                                        const order = this.data.orders.find(o =>
                                            o.docId === orderId || o.orderId === orderId
                                        );

                                        if (order) {
                                            // Switch to orders tab
                                            this.switchTab('orders');
                                            // Load order into form for editing
                                            this.loadOrderToForm(order);
                                            // Clear search
                                            searchInput.value = '';
                                            searchResults.style.display = 'none';
                                        }
                                    });
                                }
                            });
                        }
                    }, 300); // Debounce 300ms
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            },

            // ============ MERGE/UNMERGE ORDERS ============
            toggleOrderSelection(orderId) {
                const checkbox = document.querySelector(`.order-select-checkbox[data-order-id="${orderId}"]`);
                if (!checkbox) return;

                if (checkbox.checked) {
                    if (!this.selectedOrdersForMerge.includes(orderId)) {
                        this.selectedOrdersForMerge.push(orderId);
                    }
                } else {
                    this.selectedOrdersForMerge = this.selectedOrdersForMerge.filter(id => id !== orderId);
                }

                // Show/hide merge button based on selection count
                const mergeBtn = document.getElementById('mergeSelectedBtn');
                if (mergeBtn) {
                    mergeBtn.style.display = this.selectedOrdersForMerge.length >= 2 ? 'inline-block' : 'none';
                    mergeBtn.textContent = `ğŸ”— Merge Selected Orders (${this.selectedOrdersForMerge.length})`;
                }
            },

            showMergeModal() {
                if (this.selectedOrdersForMerge.length < 2) {
                    alert('Please select at least 2 orders to merge');
                    return;
                }

                // Get selected orders
                const selectedOrders = this.selectedOrdersForMerge.map(id =>
                    this.data.orders.find(o => (o.docId || o.orderId) === id)
                ).filter(o => o);

                if (selectedOrders.length < 2) {
                    alert('Error: Could not find selected orders');
                    return;
                }

                // Create modal HTML
                const modalHTML = `
                    <div class="modal show" id="mergeModalOverlay" onclick="if(event.target === this) document.getElementById('mergeModalOverlay').remove();">
                        <div class="modal-content" style="max-width: 600px;">
                            <div class="modal-header">
                                <h2>ğŸ”— Merge Orders</h2>
                            </div>
                            <div class="modal-body">
                                <p style="margin-bottom: 1rem; color: #666;">Select which order to keep as the base. All other orders' content will be merged into it.</p>

                                <div class="form-group">
                                    <label class="form-label">Select Base Order:</label>
                                    <select id="mergeBaseOrder" class="form-select" onchange="OMS.updateMergeOrderId()">
                                        ${selectedOrders.map(order => `
                                            <option value="${order.docId || order.orderId}">
                                                ${order.orderId} - ${order.clientName} (${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)})
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Merged Order ID (editable):</label>
                                    <input type="text" id="mergedOrderId" class="form-input" value="${selectedOrders[0].orderId}">
                                    <small style="color: #666;">You can change the Order ID for the merged order</small>
                                </div>

                                <div style="background: #f0f0f0; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                                    <h4 style="margin: 0 0 0.5rem 0;">Orders to be merged:</h4>
                                    <ul style="margin: 0; padding-left: 1.5rem;">
                                        ${selectedOrders.map(order => `
                                            <li>${order.orderId} - ${order.clientName}</li>
                                        `).join('')}
                                    </ul>
                                    <p style="margin-top: 0.5rem; font-size: 0.9em; color: #666;">
                                        Original orders will be marked as "merged" and can be unmerged later.
                                    </p>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" onclick="document.getElementById('mergeModalOverlay').remove()">Cancel</button>
                                <button class="btn btn-primary" onclick="OMS.performMerge()">ğŸ”— Merge Orders</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', modalHTML);
            },

            updateMergeOrderId() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');
                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const baseOrder = this.data.orders.find(o => (o.docId || o.orderId) === baseOrderId);
                if (baseOrder) {
                    orderIdInput.value = baseOrder.orderId;
                }
            },

            async performMerge() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');

                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const newOrderId = orderIdInput.value.trim();

                if (!newOrderId) {
                    alert('Please enter an Order ID for the merged order');
                    return;
                }

                try {
                    // Get all selected orders
                    const ordersToMerge = this.selectedOrdersForMerge.map(id =>
                        this.data.orders.find(o => (o.docId || o.orderId) === id)
                    ).filter(o => o);

                    // Get base order
                    const baseOrder = ordersToMerge.find(o => (o.docId || o.orderId) === baseOrderId);
                    const otherOrders = ordersToMerge.filter(o => (o.docId || o.orderId) !== baseOrderId);

                    if (!baseOrder) {
                        alert('Error: Base order not found');
                        return;
                    }

                    // Store original orders data for unmerge
                    const mergedFromData = ordersToMerge.map(order => ({
                        docId: order.docId,
                        orderId: order.orderId,
                        orderData: JSON.parse(JSON.stringify(order)) // Deep copy
                    }));

                    // Create merged order by combining content
                    const mergedOrder = JSON.parse(JSON.stringify(baseOrder)); // Deep copy
                    mergedOrder.orderId = newOrderId;
                    mergedOrder.mergedFrom = mergedFromData;
                    mergedOrder.mergedAt = new Date().toISOString();

                    // Merge items from other orders (for single-day orders)
                    if (!mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (!order.isMultiDay && order.items && order.items.length > 0) {
                                mergedOrder.items = [...(mergedOrder.items || []), ...order.items];
                            }
                        });
                    }

                    // Merge day-wise data for multi-day orders
                    if (mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (order.isMultiDay && order.dayWiseData) {
                                // Merge dayWiseData intelligently
                                order.dayWiseData.forEach(dayData => {
                                    const existingDayIndex = mergedOrder.dayWiseData.findIndex(d => d.date === dayData.date);
                                    if (existingDayIndex >= 0) {
                                        // Merge functions for same date
                                        mergedOrder.dayWiseData[existingDayIndex].functions = [
                                            ...(mergedOrder.dayWiseData[existingDayIndex].functions || []),
                                            ...(dayData.functions || [])
                                        ];
                                    } else {
                                        // Add new date
                                        mergedOrder.dayWiseData.push(dayData);
                                    }
                                });
                            }
                        });
                    }

                    // Merge notes
                    const allNotes = ordersToMerge.map(o => o.notes).filter(n => n && n.trim()).join('\n---\n');
                    if (allNotes) {
                        mergedOrder.notes = allNotes;
                    }

                    // Update merged order in Firebase
                    await this.updateOrderInFirebase(mergedOrder, baseOrder.docId);

                    // Mark other orders as merged
                    for (const order of otherOrders) {
                        const updatedOrder = { ...order, isMerged: true, mergedInto: newOrderId };
                        await this.updateOrderInFirebase(updatedOrder, order.docId);
                    }

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Close modal
                    document.getElementById('mergeModalOverlay')?.remove();

                    // Clear selection
                    this.selectedOrdersForMerge = [];

                    // Refresh history view
                    this.renderHistory();

                    // Update dashboard to reflect merged order count
                    this.renderDashboard();

                    alert(`âœ… Successfully merged ${ordersToMerge.length} orders into ${newOrderId}`);

                } catch (error) {
                    console.error('Error merging orders:', error);
                    alert('Error merging orders: ' + error.message);
                }
            },

            async unmergeOrder(orderId) {
                if (!confirm('Are you sure you want to unmerge this order? This will restore all original separate orders.')) {
                    return;
                }

                try {
                    // Find the merged order
                    const mergedOrder = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                    if (!mergedOrder || !mergedOrder.mergedFrom) {
                        alert('Error: This is not a merged order');
                        return;
                    }

                    // Restore all original orders
                    for (const originalData of mergedOrder.mergedFrom) {
                        const restoredOrder = originalData.orderData;
                        delete restoredOrder.isMerged;
                        delete restoredOrder.mergedInto;

                        await this.updateOrderInFirebase(restoredOrder, originalData.docId);
                    }

                    // Delete the merged order
                    await this.deleteOrder(mergedOrder.docId || mergedOrder.orderId);

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Refresh history view
                    this.renderHistory();

                    // Update dashboard to reflect unmerged order count
                    this.renderDashboard();

                    alert(`âœ… Successfully unmerged order. ${mergedOrder.mergedFrom.length} original orders restored.`);

                } catch (error) {
                    console.error('Error unmerging order:', error);
                    alert('Error unmerging order: ' + error.message);
                }
            },

            async updateOrderInFirebase(orderData, docId) {
                if (!docId) {
                    throw new Error('Document ID is required for update');
                }

                const orderRef = firebase.firestore().collection('orders').doc(docId);
                await orderRef.update(orderData);

                console.log(`Order ${docId} updated in Firebase`);
            },


            // ============ ITEM SEARCH ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Prevent duplicate event listener registration
                if (itemSearch.dataset.searchInitialized === 'true') return;
                itemSearch.dataset.searchInitialized = 'true';

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                // Capture OMS context
                const self = this;

                const handleSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const items = self.data.inventory.items.filter(i =>
                            i.name.toLowerCase().includes(query)
                        );

                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                itemSearch.addEventListener('input', Utils.debounce(handleSearch, 300));

                // Initialize client name search with autocomplete
                this.initClientSearch();
            },

            initClientSearch() {
                const clientInput = document.getElementById('clientName');
                const dropdown = document.getElementById('clientSearchDropdown');

                if (!clientInput || !dropdown) return;

                // Prevent duplicate event listener registration
                if (clientInput.dataset.searchInitialized === 'true') return;
                clientInput.dataset.searchInitialized = 'true';

                // Capture OMS context
                const self = this;

                const handleClientSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const customers = self.data.customers.filter(c =>
                            c.name.toLowerCase().includes(query)
                        );

                        if (customers.length > 0) {
                            dropdown.innerHTML = customers.map(c => `
                                <div class="search-item" onclick="OMS.selectCustomer('${c.id}')">
                                    <span>${c.name}</span>
                                    <span style="color: var(--text-gray);">${c.contact}</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                clientInput.addEventListener('input', Utils.debounce(handleClientSearch, 300));

                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!clientInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            },

            selectCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                // Auto-fill customer name and contact
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);

                // Hide dropdown
                document.getElementById('clientSearchDropdown').classList.remove('show');

                this.showToast(`Selected: ${customer.name}`, 'success');
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;
                
                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }
                
                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;
                
                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }
                
                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)" 
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}" 
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">ğŸ—‘ï¸</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('ğŸ“¥ Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                itemHistory: [], // Will load from Firestore
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        // Check if user has permission to load financial data
        const canViewFinancials = await this.canViewFinancials();

        const loadPromises = [
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadItemHistoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore(),
            this.loadQuotationsFromFirestore()
        ];

        // Only load financial data if user has permission
        if (canViewFinancials) {
            loadPromises.push(this.loadPaymentsFromFirestore());
            loadPromises.push(this.loadExpensesFromFirestore());
        } else {
            console.log('â„¹ï¸ Skipping financial data - user does not have admin/owner role');
        }

        await Promise.all(loadPromises);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('âœ… All data loaded from Firestore successfully!');

        // Update all displays after data is loaded to ensure dashboard and other tabs show fresh data
        this.updateAllDisplays();

    } catch (error) {
        console.error('âŒ Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('ğŸ“¥ Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`âš ï¸ Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                console.warn(`   Customer: ${customer.name}, Date: ${customer.dates}`);
                skippedDeleted++;
                return;
            }

            // IMPORTANT: Include ALL fields from Firestore
            const loadedOrder = {
                ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                // Legacy field mappings for backwards compatibility
                date: orderData.date || Utils.convertDateFormat(customer.dates) || '',
                readyTime: orderData.readyTime || customer.timeSlot || '',
                clientName: orderData.clientName || customer.name || '',
                contact: orderData.contact || customer.phone || '',
                venue: orderData.venue || customer.venue || '',
                eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                // Normalize items to use consistent field names
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.quantity || item.qty || 0,
                    remarks: item.remarks || item.desc || '',
                    price: item.price || 0
                }))
            };

            // Debug log multi-day and merged orders
            if (orderData.isMultiDay) {
                console.log(`ğŸ“… Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }
            if (orderData.isMerged) {
                console.log(`ğŸ”— Loaded merged order ${orderId}:`, {
                    isMerged: loadedOrder.isMerged,
                    mergedInto: loadedOrder.mergedInto
                });
            }
            if (orderData.mergedFrom) {
                console.log(`ğŸ”— Loaded MERGED result order ${orderId}:`, {
                    mergedFrom: loadedOrder.mergedFrom?.length || 0,
                    mergedAt: loadedOrder.mergedAt
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`âœ… Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('âŒ Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('ğŸ“Š Loading tracking data from Firestore...');

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('âš ï¸ Not authenticated yet - skipping tracking data load');
            this.data.trackingData = [];
            return;
        }

        // Load without orderBy to avoid index requirement
        // We'll sort in JavaScript instead
        const trackingSnapshot = await db.collection('tracking')
            .limit(500)  // Get more data, will sort client-side
            .get();

        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });

        // Sort by timestamp in JavaScript (newest first)
        this.data.trackingData.sort((a, b) => b.timestamp - a.timestamp);

        console.log(`âœ… Loaded ${this.data.trackingData.length} tracking events from website`);
        console.log(`ğŸ“ Sample data:`, this.data.trackingData.slice(0, 3));

    } catch (error) {
        console.error('âŒ Error loading tracking data:', error);
        console.error('Error details:', error.code, error.message);

        // If permissions error, log it but don't retry
        // (retrying won't help if Firestore rules don't allow access)
        if (error.code === 'permission-denied') {
            console.warn('âš ï¸ Insufficient permissions to access tracking data. Please check Firestore security rules.');
        }

        this.data.trackingData = [];
    }
},

async loadEventsListFromFirestore() {
    try {
        console.log('ğŸ“‹ Loading events list from Firestore...');

        // Ensure eventsList has a default value if not already set
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            console.log('ğŸ“ Initializing default events list');
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
            console.log('âœ… Default events list initialized with', this.data.eventsList.length, 'events');
        }

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('âš ï¸ Not authenticated yet - using default events list');
            return;
        }

        const eventsDoc = await db.collection('settings').doc('eventsList').get();

        if (eventsDoc.exists) {
            const data = eventsDoc.data();
            if (data.events && Array.isArray(data.events)) {
                this.data.eventsList = data.events;
                console.log(`âœ… Loaded ${this.data.eventsList.length} events from Firestore`);
            }
        } else {
            console.log('ğŸ“ No events list in Firestore yet - saving default list');
            // Save the default list to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                createdAt: new Date().toISOString()
            });
            console.log('âœ… Saved default events list to Firestore');
        }

    } catch (error) {
        console.error('âŒ Error loading events list:', error);
        console.warn('âš ï¸ Using default events list');
        // Ensure default list is available even on error
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
        }
    }
},


// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('ğŸ“¦ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`ğŸ“¦ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`ğŸ“¦ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`âœ… Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`âœ… Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`âš ï¸ Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('ğŸ”„ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('âœ… Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('âš ï¸âš ï¸ Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('âŒâŒ CRITICAL: Both Firestore AND local are empty!');
            console.error('âŒ ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('âŒ Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('âš ï¸ Keeping existing local inventory due to error');
        return false;
    }
},

async loadItemHistoryFromFirestore() {
    try {
        console.log('ğŸ“œ Loading item history from Firestore...');

        const snapshot = await db.collection('itemHistory').orderBy('usedAt', 'desc').get();
        const history = [];
        snapshot.forEach(doc => {
            history.push({ id: doc.id, ...doc.data() });
        });

        this.data.itemHistory = history;
        console.log(`âœ… Loaded ${history.length} item history records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading item history from Firestore:', error);
        return false;
    }
},

async loadPaymentsFromFirestore() {
    try {
        console.log('ğŸ’µ Loading payments from Firestore...');

        const snapshot = await db.collection('payments').orderBy('timestamp', 'desc').get();
        const payments = [];
        snapshot.forEach(doc => {
            payments.push({ id: doc.id, ...doc.data() });
        });

        this.data.payments = payments;
        console.log(`âœ… Loaded ${payments.length} payment records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading payments from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('ğŸ”’ Permission Denied: You need admin/owner role to access financial data');
            console.error('ğŸ’¡ Solution: Run the setup script or create your user_roles document manually');
            console.error('ğŸ“– Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async loadExpensesFromFirestore() {
    try {
        console.log('ğŸ’¸ Loading expenses from Firestore...');

        const snapshot = await db.collection('expenses').orderBy('timestamp', 'desc').get();
        const expenses = [];
        snapshot.forEach(doc => {
            expenses.push({ id: doc.id, ...doc.data() });
        });

        this.data.expenses = expenses;
        console.log(`âœ… Loaded ${expenses.length} expense records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading expenses from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('ğŸ”’ Permission Denied: You need admin/owner role to access financial data');
            console.error('ğŸ’¡ Solution: Run the setup script or create your user_roles document manually');
            console.error('ğŸ“– Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('âœ… Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('âœ… Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('âœ… Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('âŒ Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('ğŸ”” Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`âœ… Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('âš ï¸ All listeners already active');
        return;
    }

    console.log('ğŸ”„ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('ğŸ‘· Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                    console.log('ğŸ‘· Team member updated:', teamMember.name);
                }
                // Update UI in real-time - always render when data changes
                this.renderTeamTable();
                // Also update dropdowns in order form
                this.updateTeamDropdowns();
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('ğŸ‘· Team member removed:', teamMember.name);
                    // Update UI in real-time
                    this.renderTeamTable();
                    this.updateTeamDropdowns();
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('ğŸ“¦ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`âš ï¸âš ï¸ BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if category was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedCategories &&
                                      this.data.inventory.deletedCategories.includes(category.id);
                    if (wasDeleted) {
                        console.warn('âš ï¸ Category was previously deleted - ignoring:', category.name);
                        return;
                    }

                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`ğŸ“ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        // Track deleted categories to prevent re-addition
                        if (!this.data.inventory.deletedCategories) {
                            this.data.inventory.deletedCategories = [];
                        }
                        if (!this.data.inventory.deletedCategories.includes(category.id)) {
                            this.data.inventory.deletedCategories.push(category.id);
                        }
                        console.log(`ğŸ—‘ï¸ Category removed:`, category.name);
                    }
                }
            });

            console.log(`ğŸ“¦ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('ğŸ“¦ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`âš ï¸âš ï¸ BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if item was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedItems &&
                                      this.data.inventory.deletedItems.includes(item.id);
                    if (wasDeleted) {
                        console.warn('âš ï¸ Inventory item was previously deleted - ignoring:', item.name);
                        return;
                    }

                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`ğŸ“¦ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        // Track deleted items to prevent re-addition
                        if (!this.data.inventory.deletedItems) {
                            this.data.inventory.deletedItems = [];
                        }
                        if (!this.data.inventory.deletedItems.includes(item.id)) {
                            this.data.inventory.deletedItems.push(item.id);
                        }
                        console.log(`ğŸ—‘ï¸ Item removed:`, item.name);
                    }
                }
            });

            console.log(`ğŸ“¦ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('âš™ï¸ Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    // Payments real-time listener
    this.paymentsUnsubscribe = db.collection('payments').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const payment = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index === -1) {
                    this.data.payments.push(payment);
                    console.log('ğŸ’µ Payment added:', payment.id);
                } else {
                    this.data.payments[index] = payment;
                    console.log('ğŸ’µ Payment updated:', payment.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index !== -1) {
                    this.data.payments.splice(index, 1);
                    console.log('ğŸ’µ Payment removed:', payment.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    // Expenses real-time listener
    this.expensesUnsubscribe = db.collection('expenses').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const expense = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index === -1) {
                    this.data.expenses.push(expense);
                    console.log('ğŸ’¸ Expense added:', expense.id);
                } else {
                    this.data.expenses[index] = expense;
                    console.log('ğŸ’¸ Expense updated:', expense.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index !== -1) {
                    this.data.expenses.splice(index, 1);
                    console.log('ğŸ’¸ Expense removed:', expense.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    // Quotations real-time listener
    this.quotationsUnsubscribe = db.collection('quotations').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const quotation = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.quotations.findIndex(q => q.id === quotation.id);
                if (index === -1) {
                    this.data.quotations.push(quotation);
                    console.log('ğŸ“„ Quotation added:', quotation.customer?.name);
                } else {
                    this.data.quotations[index] = quotation;
                    console.log('ğŸ“„ Quotation updated:', quotation.customer?.name);
                }
                // Update UI in real-time if on quotations tab
                if (this.currentTab === 'quotations') {
                    this.renderQuotations();
                }
            } else if (change.type === 'removed') {
                const index = this.data.quotations.findIndex(q => q.id === quotation.id);
                if (index !== -1) {
                    this.data.quotations.splice(index, 1);
                    console.log('ğŸ“„ Quotation removed:', quotation.customer?.name);
                    // Update UI in real-time if on quotations tab
                    if (this.currentTab === 'quotations') {
                        this.renderQuotations();
                    }
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    console.log('âœ… All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('âš ï¸ Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('ğŸ›‘ Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('ğŸ”„ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`ğŸ“‹ Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('âš ï¸ Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('ğŸ†• New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    // IMPORTANT: Include ALL fields from Firestore
                    const newOrder = {
                        ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        // Legacy field mappings for backwards compatibility
                        date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
                        readyTime: orderData.readyTime || customer.timeSlot || '',
                        clientName: orderData.clientName || customer.name || '',
                        contact: orderData.contact || customer.phone || '',
                        venue: orderData.venue || customer.venue || '',
                        eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                        // Normalize items to use consistent field names
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.quantity || item.qty || 0,
                            remarks: item.remarks || item.desc || '',
                            price: item.price || 0
                        }))
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        // Update dashboard statistics in real-time
                        if (this.currentTab === 'dashboard') {
                            this.renderDashboard();
                        }
                        this.showToast(`ğŸ†• New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('âœï¸ Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // IMPORTANT: Preserve ALL fields from Firebase including merged data and financials
        this.data.orders[index] = {
            ...orderData, // Include ALL fields from Firebase
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            // Legacy field mappings for backwards compatibility
            date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
            readyTime: orderData.readyTime || customer.timeSlot || '',
            clientName: orderData.clientName || customer.name || '',
            contact: orderData.contact || customer.phone || '',
            venue: orderData.venue || customer.venue || '',
            eventType: orderData.eventType || orderData.functionType || customer.functionType || ''
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();

        // Force update all tabs in real-time
        if (this.currentTab === 'dashboard') {
            this.renderDashboard();
        } else if (this.currentTab === 'history') {
            this.renderHistory();
        } else if (this.currentTab === 'calendar') {
            this.renderCalendarTab();
        } else if (this.currentTab === 'financials') {
            this.renderFinancials();
        }

        console.log('âœ… Real-time update applied successfully');
        this.showToast(`âœï¸ Order updated: ${this.data.orders[index].clientName}`, 'info', 3000);
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('âš ï¸ Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('âš ï¸ Modified order not found locally, adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                console.log('ğŸ—‘ï¸ Order removed from Firestore:', orderData.orderId || change.doc.id);
                const index = this.data.orders.findIndex(o => o.orderId === (orderData.orderId || change.doc.id));
                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();
                    this.showToast(`ğŸ—‘ï¸ Order deleted: ${deleted.orderId}`, 'success');
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`âœ… Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('âœ… Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('ğŸ“‹ Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('âš ï¸ Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('âš ï¸ Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('ğŸ“‹ No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('âœ… Demo data loaded for first-time user');
    } else {
        console.log('âœ… Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') this.updateInventoryDisplay();
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();
        else if (this.currentTab === 'financials') this.renderFinancials();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `âš ï¸ OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'ğŸ”¥ TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = 'âš¡ TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `â° In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `ğŸ“… In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    âœ“ Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            this.loadOrderToForm(order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('âœ… Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('âŒ Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('âŒ Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // Expose OMS globally for console access and backward compatibility
        window.OMS = OMS;
        window.appManager = OMS;

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`âœ… Cleared ${count} entries from deletedOrders list`);
                console.log('ğŸ”„ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('âœ… Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('ğŸ”„ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('âœ… Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`ğŸ“‹ Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('âŒ Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`âœ… Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`âœ… Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`âš ï¸ Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('âŒ Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('âœ… No demo orders found!');
                        return [];
                    }

                    console.log(`âš ï¸ Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`âœ… Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('âŒ Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('âœ… Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`ğŸ“‹ Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Restore a specific order (remove from deletedOrders list)
            async restoreDeletedOrder(orderId) {
                console.log(`ğŸ”„ Attempting to restore order: ${orderId}`);

                // Find the order in deletedOrders list
                const deletedOrder = OMS.data.deletedOrders.find(o => o.orderId === orderId || o.docId === orderId);

                if (!deletedOrder) {
                    console.warn(`âš ï¸ Order ${orderId} not found in deletedOrders list`);
                    console.log('ğŸ’¡ Run AdminUtils.viewDeletedOrders() to see all deleted orders');
                    return false;
                }

                console.log(`âœ… Found deleted order: ${deletedOrder.orderId || orderId}`);
                console.log(`   Client: ${deletedOrder.clientName || 'N/A'}`);
                console.log(`   Deleted at: ${deletedOrder.deletedAt || 'N/A'}`);

                // Remove from deletedOrders list
                const beforeCount = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o =>
                    o.orderId !== orderId && o.docId !== orderId
                );
                const afterCount = OMS.data.deletedOrders.length;

                // Save to localStorage
                OMS.saveToStorage();
                console.log(`âœ… Removed from deletedOrders list (${beforeCount} â†’ ${afterCount})`);

                // Reload orders from Firestore
                console.log('ğŸ”„ Reloading orders from Firestore...');
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();

                // Check if order is now visible
                const restoredOrder = OMS.data.orders.find(o => o.orderId === orderId || o.docId === orderId);
                if (restoredOrder) {
                    console.log(`âœ…âœ… SUCCESS! Order ${orderId} has been restored and is now visible!`);
                    console.log(`   Client: ${restoredOrder.clientName}`);
                    console.log(`   Status: ${restoredOrder.status}`);
                    return true;
                } else {
                    console.warn(`âš ï¸ Order removed from block list, but not found in Firestore.`);
                    console.log(`ğŸ’¡ The order may have been permanently deleted from Firestore.`);
                    console.log(`ğŸ’¡ If you saved it again, try refreshing the page or run:`);
                    console.log(`   await AdminUtils.forceFullSync()`);
                    return false;
                }
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('ğŸ”„ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('ğŸ“¦ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('âŒ Firestore inventory is empty! Nothing to recover.');
                        console.log('ğŸ’¡ Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('âœ… Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('âŒ Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('âŒ No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('âŒ No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('ğŸ“¦ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('âœ… Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('âŒ Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('ğŸ“¦ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('ğŸ” Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`ğŸ“ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`ğŸ“¦ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('âŒ Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`ğŸ“‹ Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('âŒ Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`âœ… Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`âœ… Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`âš ï¸ Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('âŒ Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('ğŸ‘» Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('âœ… No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`ğŸ‘» Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nğŸ’¡ These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('âŒ Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('âš ï¸ This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('âŒ Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('âœ… Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`ğŸ—‘ï¸ Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`âš ï¸ Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('ğŸ” Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`ğŸ”¥ Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('âœ… Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('âœ… Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('âš ï¸ Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('âŒ Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('âœ… Added to deletedOrders block list');
                } else {
                    console.log('â„¹ï¸ Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\nâœ… Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  âœ“ Firestore database');
                console.log('  âœ“ Local data');
                console.log('  âœ“ Added to block list (deletedOrders)');
                console.log('  âœ“ Saved to localStorage');
                console.log('\nğŸ›¡ï¸ This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('ğŸ” Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('ğŸ“Š ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`âš ï¸ Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('âœ… Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nğŸ“¦ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('âŒ CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('ğŸ§¹ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`âš ï¸ Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`âœ… Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`ğŸ“‹ Deleted orders list: ${before} â†’ ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('âœ… No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('ğŸ”ğŸ”ğŸ” COMPREHENSIVE SYSTEM DIAGNOSTIC ğŸ”ğŸ”ğŸ”\n');

                // 1. Check localStorage
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('1ï¸âƒ£ LOCALSTORAGE CHECK');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('âœ… localStorage exists');
                    console.log(`  ğŸ“¦ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  ğŸ“¦ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  ğŸ“‹ Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  ğŸ—‘ï¸ Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('âŒ NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('2ï¸âƒ£ CURRENT MEMORY (OMS.data)');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log(`  ğŸ“¦ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  ğŸ“¦ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  ğŸ“‹ Orders: ${OMS.data.orders.length}`);
                console.log(`  ğŸ—‘ï¸ Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('3ï¸âƒ£ FIRESTORE CHECK');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  ğŸ“‹ Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  ğŸ“¦ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  ğŸ“¦ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('4ï¸âƒ£ MISMATCH ANALYSIS');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  âš ï¸ Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  âŒ DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  âœ… ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  âš ï¸ Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('5ï¸âƒ£ RECOMMENDATIONS');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  âŒ INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  ğŸ’¡ Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  âŒ INVENTORY EMPTY IN MEMORY!');
                    console.log('  ğŸ’¡ Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  ğŸ’¡ Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\nâœ… Diagnostic complete!\n');
            },

            // ============ FILTERING DIAGNOSTICS ============

            // View filter logs
            viewFilterLogs(count = 50) {
                const logs = filterLogger.getRecentLogs(count);
                console.group(`ğŸ“Š Recent Filter Logs (${logs.length})`);
                console.table(logs.map(log => ({
                    Time: new Date(log.timestamp).toLocaleString(),
                    Operation: log.operation,
                    Date: log.filterDate,
                    Matched: log.matchedCount,
                    Total: log.totalAvailable,
                    Time_ms: log.filterTimeMs
                })));
                console.groupEnd();
                return logs;
            },

            // View learned patterns
            viewLearnedPatterns() {
                const patterns = patternLearner.patterns;
                console.group('ğŸ§  Learned Patterns');

                console.log('\nğŸ“… Date-specific patterns:');
                const datePatterns = Object.entries(patterns.datePatterns)
                    .sort((a, b) => new Date(b[0]) - new Date(a[0]))
                    .slice(0, 20);
                console.table(datePatterns.map(([date, data]) => ({
                    Date: date,
                    AvgOrders: data.avgCount.toFixed(1),
                    Observations: data.counts.length,
                    LastSeen: new Date(data.lastSeen).toLocaleDateString()
                })));

                console.log('\nğŸ“Š Typical order counts:');
                console.table({
                    Weekday: {
                        Min: patterns.typicalOrderCounts.weekday.min,
                        Avg: patterns.typicalOrderCounts.weekday.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekday.max,
                        Samples: patterns.typicalOrderCounts.weekday.samples
                    },
                    Weekend: {
                        Min: patterns.typicalOrderCounts.weekend.min,
                        Avg: patterns.typicalOrderCounts.weekend.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekend.max,
                        Samples: patterns.typicalOrderCounts.weekend.samples
                    }
                });

                console.log('\nğŸ”„ Learned date formats:');
                const dateFormats = Object.entries(patterns.dateFormats).slice(0, 10);
                if (dateFormats.length > 0) {
                    console.table(dateFormats.map(([original, data]) => ({
                        Original: original,
                        Normalized: data.normalized,
                        Count: data.count
                    })));
                } else {
                    console.log('  No custom date formats learned yet');
                }

                console.groupEnd();
                return patterns;
            },

            // Clear all filter logs
            clearFilterLogs() {
                const count = filterLogger.logs.length;
                filterLogger.logs = [];
                filterLogger.saveLogs();
                console.log(`âœ… Cleared ${count} filter logs`);
            },

            // Reset learned patterns
            resetLearnedPatterns() {
                const confirmed = confirm('Reset all learned patterns? This cannot be undone.');
                if (confirmed) {
                    localStorage.removeItem('oms_filter_patterns');
                    location.reload();
                    console.log('âœ… Patterns reset. Page reloading...');
                }
            },

            // Test filter accuracy for a specific date
            async testFilterAccuracy(date) {
                console.group(`ğŸ§ª Testing Filter Accuracy for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                console.log(`ğŸ“… Normalized date: ${normalizedDate}`);

                // Test all date variations
                const variations = fuzzyDateMatcher.getVariations(date);
                console.log(`ğŸ”„ Testing ${variations.length} date variations:`, variations);

                // Run the actual filter
                const startTime = performance.now();
                const matchedOrders = [];
                const orders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    return false;
                });
                const filterTime = (performance.now() - startTime).toFixed(2);

                console.log(`âœ… Found ${orders.length} orders in ${filterTime}ms`);

                // Show expected count
                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`ğŸ§  Expected based on learning: ~${expectedCount} orders`);
                    const deviation = Math.abs(orders.length - expectedCount);
                    if (deviation > 0) {
                        console.log(`ğŸ“Š Deviation: ${deviation} orders (${((deviation / Math.max(expectedCount, 1)) * 100).toFixed(1)}%)`);
                    }
                }

                // Run validation
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: OMS.data.orders.length,
                    matchedOrders,
                    allOrders: OMS.data.orders
                });

                if (validationResult.length > 0) {
                    console.log(`\nâš ï¸ Validation Issues (${validationResult.length}):`);
                    validationResult.forEach(alert => {
                        console.log(`  ${alert.level.toUpperCase()}: ${alert.message}`);
                    });
                } else {
                    console.log('\nâœ… No validation issues detected');
                }

                console.log(`\nğŸ“‹ Matched orders:`);
                console.table(orders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    Date: o.date || `${o.startDate} to ${o.endDate}`,
                    Status: o.status,
                    MultiDay: o.isMultiDay ? 'Yes' : 'No'
                })));

                console.groupEnd();
                return { orders, validationResult, filterTime };
            },

            // Show filtering statistics
            showFilteringStats() {
                console.group('ğŸ“Š Filtering System Statistics');

                const logs = filterLogger.logs;
                const patterns = patternLearner.patterns;

                console.log(`ğŸ“ Total filter operations logged: ${logs.length}`);
                console.log(`ğŸ§  Patterns learned for ${Object.keys(patterns.datePatterns).length} dates`);
                console.log(`ğŸ“… Date formats learned: ${Object.keys(patterns.dateFormats).length}`);
                console.log(`ğŸ“ˆ Filter results history: ${patterns.filterResults.length} entries`);

                if (logs.length > 0) {
                    const avgTime = logs
                        .filter(l => l.filterTimeMs)
                        .reduce((sum, l) => sum + parseFloat(l.filterTimeMs), 0) / logs.filter(l => l.filterTimeMs).length;
                    console.log(`âš¡ Average filter time: ${avgTime.toFixed(2)}ms`);
                }

                console.log('\nğŸ’¡ Available commands:');
                console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
                console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
                console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a date');
                console.log('  - AdminUtils.clearFilterLogs() - Clear all logs');
                console.log('  - AdminUtils.resetLearnedPatterns() - Reset all patterns');

                console.groupEnd();
            },

            // ============ RATING & LEARNING UTILITIES ============

            // Show rating UI for last filter result
            rateLastFilter() {
                if (!filterRatingSystem.currentFilterContext) {
                    console.warn('âš ï¸ No filter result available to rate. Run a filter first.');
                    return;
                }
                filterRatingSystem.showRatingUI(OMS);
            },

            // View all ratings
            viewRatings(count = 20) {
                const ratings = filterRatingSystem.ratings.slice(-count);
                if (ratings.length === 0) {
                    console.log('ğŸ“­ No ratings yet. Use AdminUtils.rateLastFilter() after filtering orders.');
                    return;
                }

                console.group(`â­ Recent Ratings (${ratings.length})`);
                console.table(ratings.map(r => ({
                    Date: r.date,
                    Rating: typeof r.rating === 'number' ? 'â­'.repeat(r.rating) : r.rating,
                    Matched: r.matchedOrders.length,
                    WrongIncluded: r.feedback.incorrectlyIncluded.length,
                    WrongExcluded: r.feedback.incorrectlyExcluded.length,
                    Tags: r.feedback.tags.join(', '),
                    RatedAt: new Date(r.ratedAt).toLocaleString()
                })));

                const stats = filterRatingSystem.getStats();
                console.log(`\nğŸ“Š Overall Statistics:`);
                console.log(`  Average Rating: ${stats.avgRating} / 5`);
                console.log(`  Total Ratings: ${stats.totalRatings}`);
                console.log(`  Sentiment Trend: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' â†’ ')}`);

                console.groupEnd();
            },

            // View learning rules
            viewLearningRules(date = null) {
                const rules = date
                    ? filterRatingSystem.getLearningRules(date)
                    : JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (rules.length === 0) {
                    console.log(`ğŸ“­ No learning rules${date ? ' for ' + date : ''}.`);
                    return;
                }

                console.group(`ğŸ§  Learning Rules${date ? ' for ' + date : ''} (${rules.length})`);
                console.table(rules.map(r => ({
                    Type: r.type,
                    Date: r.targetDate,
                    OrderID: r.orderId || 'N/A',
                    Reason: r.reason,
                    Weight: r.weight
                })));
                console.groupEnd();
            },

            // View rating statistics
            getRatingStats() {
                const stats = filterRatingSystem.getStats();
                console.group('ğŸ“Š Rating System Statistics');
                console.log(`Average Rating: ${stats.avgRating} / 5`);
                console.log(`Total Ratings: ${stats.totalRatings}`);
                console.log(`Recent Sentiment: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' â†’ ')}`);

                const learningRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                console.log(`\nLearning Rules: ${learningRules.length}`);
                console.log(`  - Exclusions: ${learningRules.filter(r => r.type === 'exclusion').length}`);
                console.log(`  - Inclusions: ${learningRules.filter(r => r.type === 'inclusion').length}`);
                console.log(`  - Anomalies: ${learningRules.filter(r => r.type === 'anomaly').length}`);

                console.log('\nğŸ’¡ Available commands:');
                console.log('  - AdminUtils.rateLastFilter() - Rate the last filter result');
                console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
                console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
                console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
                console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');

                console.groupEnd();
            },

            // Test learning corrections for a date
            testLearning(date) {
                console.group(`ğŸ§ª Testing Learning Corrections for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                const learningRules = filterRatingSystem.getLearningRules(normalizedDate);

                if (learningRules.length === 0) {
                    console.log('ğŸ“­ No learning rules for this date yet. Rate a filter result first.');
                    console.groupEnd();
                    return;
                }

                console.log(`ğŸ§  Found ${learningRules.length} learning rules`);
                console.table(learningRules);

                // Run filter without corrections
                const originalOrders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) return true;
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) return true;
                    }
                    return false;
                });

                console.log(`\nğŸ“‹ Original filter: ${originalOrders.length} orders`);

                // Apply learning corrections
                const result = filterRatingSystem.applyLearningRules(normalizedDate, originalOrders, OMS.data.orders);

                console.log(`ğŸ§  After learning: ${result.orders.length} orders`);
                console.log(`âœ… Corrections applied: ${result.corrections.length}`);

                if (result.corrections.length > 0) {
                    console.log('\nğŸ“ Corrections:');
                    console.table(result.corrections.map(c => ({
                        Type: c.type,
                        OrderID: c.order.orderId,
                        Client: c.order.clientName,
                        Reason: c.reason
                    })));
                }

                console.groupEnd();
                return result;
            },

            // Clear all ratings and learning rules
            clearAllRatings() {
                const confirmed = confirm('Clear all ratings and learning rules? This cannot be undone.');
                if (confirmed) {
                    filterRatingSystem.clearAllRatings();
                    console.log('âœ… All ratings and learning rules cleared');
                }
            },

            // Export ratings and learning data
            exportLearningData() {
                const data = {
                    ratings: filterRatingSystem.ratings,
                    learningRules: JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]'),
                    patterns: patternLearner.patterns,
                    exportedAt: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `filter-learning-data-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                console.log('âœ… Learning data exported');
            },

            // Import ratings and learning data
            async importLearningData() {
                return new Promise((resolve, reject) => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';

                    input.onchange = async (e) => {
                        try {
                            const file = e.target.files[0];
                            const text = await file.text();
                            const data = JSON.parse(text);

                            if (data.ratings) {
                                filterRatingSystem.ratings = data.ratings;
                                filterRatingSystem.saveRatings();
                            }

                            if (data.learningRules) {
                                localStorage.setItem('oms_filter_learning_rules', JSON.stringify(data.learningRules));
                            }

                            if (data.patterns) {
                                localStorage.setItem('oms_filter_patterns', JSON.stringify(data.patterns));
                            }

                            console.log('âœ… Learning data imported successfully');
                            console.log(`  - Ratings: ${data.ratings?.length || 0}`);
                            console.log(`  - Learning Rules: ${data.learningRules?.length || 0}`);

                            resolve(data);
                        } catch (error) {
                            console.error('âŒ Failed to import learning data:', error);
                            reject(error);
                        }
                    };

                    input.click();
                });
            },

            // Enable ML corrections
            enableML() {
                localStorage.setItem('oms_ml_enabled', 'true');
                console.log('âœ… ML Corrections ENABLED');
                console.log('ğŸ§  The system will now apply learned corrections from previous ratings');
                console.log('ğŸ’¡ To disable: AdminUtils.disableML()');
                console.log('ğŸ’¡ To clear learned rules: AdminUtils.clearAllRatings()');
                return true;
            },

            // Disable ML corrections
            disableML() {
                localStorage.setItem('oms_ml_enabled', 'false');
                console.log('âœ… ML Corrections DISABLED');
                console.log('ğŸ“Š Filter will now use ONLY the original logic (no ML modifications)');
                console.log('ğŸ’¡ To enable: AdminUtils.enableML()');
                console.log('âš ï¸ Note: This does NOT clear learned rules, just stops applying them');
                return true;
            },

            // Check ML status
            checkMLStatus() {
                const enabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const ratings = JSON.parse(localStorage.getItem('oms_filter_ratings') || '[]');
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                console.log('ğŸ¤– ML System Status:');
                console.log(`  Status: ${enabled ? 'âœ… ENABLED' : 'ğŸ”‡ DISABLED'}`);
                console.log(`  Ratings stored: ${ratings.length}`);
                console.log(`  Learning rules: ${rules.length}`);

                if (enabled && rules.length > 0) {
                    console.log('\nâš ï¸ WARNING: ML is ACTIVE and will modify filter results');
                    console.log('ğŸ’¡ To disable: AdminUtils.disableML()');
                    console.log('ğŸ’¡ To clear rules: AdminUtils.clearAllRatings()');
                } else if (!enabled) {
                    console.log('\nâœ… ML is disabled - using original filter logic only');
                } else {
                    console.log('\nğŸ“‹ ML is enabled but no learning rules stored yet');
                }

                return { enabled, ratingsCount: ratings.length, rulesCount: rules.length };
            },

            // Quick fix: Disable ML and clear all learned rules
            resetMLSystem() {
                const confirmed = confirm('This will:\n1. Disable ML corrections\n2. Clear all ratings and learning rules\n\nContinue?');
                if (confirmed) {
                    this.disableML();
                    filterRatingSystem.clearAllRatings();
                    console.log('\nâœ… ML System Reset Complete!');
                    console.log('ğŸ“Š Filter will now use ONLY original logic');
                    console.log('ğŸ’¡ To re-enable: AdminUtils.enableML()');
                    return true;
                }
                return false;
            }
        };

        console.log('ğŸ› ï¸ Admin utilities loaded. Available commands:');
        console.log('\nğŸ“‹ ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - â­ PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nğŸ“¦ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - â­ LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nğŸ” DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - â­ FULL SYSTEM DIAGNOSTIC (find all bugs)');
        console.log('\nğŸ¯ FILTERING DIAGNOSTICS:');
        console.log('  - AdminUtils.showFilteringStats() - Show filtering system overview');
        console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
        console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
        console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a specific date');
        console.log('  - AdminUtils.clearFilterLogs() - Clear all filter logs');
        console.log('  - AdminUtils.resetLearnedPatterns() - Reset learned patterns');
        console.log('\nâ­ RATING & LEARNING SYSTEM:');
        console.log('  - AdminUtils.rateLastFilter() - â­ Rate the last filter result');
        console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
        console.log('  - AdminUtils.getRatingStats() - View rating statistics and trends');
        console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
        console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');
        console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
        console.log('  - AdminUtils.exportLearningData() - Export learning data to JSON');
        console.log('  - await AdminUtils.importLearningData() - Import learning data from JSON');
        console.log('\nğŸ¤– ML SYSTEM CONTROLS:');
        console.log('  - AdminUtils.checkMLStatus() - â­ Check if ML is enabled/disabled and view stats');
        console.log('  - AdminUtils.disableML() - â­ DISABLE ML corrections (use original filter only)');
        console.log('  - AdminUtils.enableML() - Enable ML corrections');
        console.log('  - AdminUtils.resetMLSystem() - â­ DISABLE ML + clear all learned rules');

        // ============ GOOGLE MAPS INITIALIZATION ============
        // Global variable to store selected place from autocomplete
        let selectedPlaceData = null;

        // This function is called when Google Maps API finishes loading
        function initGoogleMaps() {
            console.log('Google Maps API loaded successfully');

            const venueInput = document.getElementById('venue');
            const mapLinkInput = document.getElementById('venueMapLink');

            if (!venueInput) {
                console.error('Venue input field not found');
                return;
            }

            try {
                // Initialize Autocomplete with new Places API
                const autocomplete = new google.maps.places.Autocomplete(venueInput, {
                    componentRestrictions: { country: 'in' },
                    fields: ['name', 'formatted_address', 'geometry', 'place_id'],
                    types: ['establishment', 'geocode']
                });

                // Listen for place selection
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace();

                    if (!place.geometry || !place.geometry.location) {
                        console.warn('No location details available for selected place');
                        selectedPlaceData = null;
                        return;
                    }

                    // Store place data globally
                    selectedPlaceData = {
                        name: place.name || place.formatted_address || venueInput.value,
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        formatted_address: place.formatted_address || '',
                        place_id: place.place_id || '',
                        source: 'google_autocomplete'
                    };

                    console.log('Place selected from autocomplete:', selectedPlaceData);

                    // Update venue input with selected place name
                    venueInput.value = selectedPlaceData.name;

                    // Auto-fill the venueMapLink field with Google Maps URL
                    if (mapLinkInput && selectedPlaceData.lat && selectedPlaceData.lng) {
                        const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${selectedPlaceData.lat},${selectedPlaceData.lng}&query_place_id=${selectedPlaceData.place_id}`;
                        mapLinkInput.value = mapsUrl;
                    }
                });

                console.log('Google Maps Autocomplete initialized successfully');
            } catch (error) {
                console.error('Error initializing Google Maps Autocomplete:', error);
            }
        }

        // Make function globally accessible
        window.initGoogleMaps = initGoogleMaps;

        // ============ LOGIN SLIDESHOW ============
        function startLoginSlideshow() {
            const images = document.querySelectorAll('.slideshow-image');
            if (images.length === 0) return;

            let currentIndex = 0;

            // Change image every 3 seconds
            setInterval(() => {
                // Fade out current image
                images[currentIndex].style.opacity = '0';

                // Move to next image
                currentIndex = (currentIndex + 1) % images.length;

                // Fade in next image
                images[currentIndex].style.opacity = '1';
            }, 3000);
        }

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Check ML status on page load
            setTimeout(() => {
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (mlEnabled && rules.length > 0) {
                    console.warn('âš ï¸ ML SYSTEM IS ACTIVE! The filter may automatically modify results based on previous feedback.');
                    console.warn(`ğŸ“Š ${rules.length} learning rules are stored and will be applied.`);
                    console.warn('ğŸ’¡ To disable: AdminUtils.disableML()');
                    console.warn('ğŸ’¡ To check status: AdminUtils.checkMLStatus()');
                    console.warn('ğŸ’¡ To reset everything: AdminUtils.resetMLSystem()');
                } else if (!mlEnabled) {
                    console.log('âœ… ML corrections are DISABLED - using original filter logic only');
                    console.log('ğŸ’¡ To enable: AdminUtils.enableML()');
                }
            }, 1000);

            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'grid';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Set required fields for single day
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;

            // Show event type field for single-day
            document.getElementById('eventType').parentElement.style.display = 'block';

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Set required fields for multi-day
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;

            // Show event type field for multi-day
            document.getElementById('eventType').parentElement.style.display = 'block';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });

        // Initialize required attributes based on default state (single day)
        if (eventTypeSelect && eventTypeSelect.value === 'single') {
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;
        } else if (eventTypeSelect && eventTypeSelect.value === 'multi') {
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;
        }
    }

    // WhatsApp Date Filter Event Listeners
    const whatsappFilterDate = document.getElementById('whatsappFilterDate');
    const sendWhatsAppOrdersBtn = document.getElementById('sendWhatsAppOrdersBtn');

    if (whatsappFilterDate) {
        whatsappFilterDate.addEventListener('change', () => {
            OMS.updateWhatsAppDateFilter();
        });
    }

    if (sendWhatsAppOrdersBtn) {
        sendWhatsAppOrdersBtn.addEventListener('click', () => {
            OMS.sendWhatsAppOrdersReport();
        });
    }

    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">âš ï¸ End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">âš ï¸ Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // ========== FIREBASE AUTH STATE LISTENER ==========
            // Check if user is logged in (Firebase initialized via firebase.js module)
            auth.onAuthStateChanged((user) => {
                if (user) {
                    // User is logged in
                    console.log('âœ… User logged in:', user.email);
                    tokenErrorCount = 0; // Reset error counter on successful auth
                    document.getElementById('loginScreen').style.display = 'none';
                    document.querySelector('.app-container').style.display = 'flex';
                    OMS.init().then(() => OMS.updateAllDisplays());
                } else {
                    // User is logged out
                    console.log('âŒ User not logged in');
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.querySelector('.app-container').style.display = 'none';

                    // Start the login slideshow animation
                    startLoginSlideshow();
                }
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');
                
                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';
                
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('âœ… Login successful!');

                    // ğŸ† FIREPOWER SFX LOGIN SUCCESS!
                    loginBtn.textContent = 'âœ… Success!';
                    loginBtn.style.background = 'linear-gradient(135deg, #00c853 0%, #00e676 100%)';

                    // Confetti Blast!
                    if (typeof confetti !== 'undefined') {
                        const count = 200;
                        const defaults = {
                            origin: { y: 0.7 },
                            colors: ['#FFD700', '#FFA500', '#FF6347', '#8B00FF', '#00BFFF']
                        };

                        function fire(particleRatio, opts) {
                            confetti(Object.assign({}, defaults, opts, {
                                particleCount: Math.floor(count * particleRatio)
                            }));
                        }

                        fire(0.25, { spread: 26, startVelocity: 55 });
                        fire(0.2, { spread: 60 });
                        fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8 });
                        fire(0.1, { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2 });
                        fire(0.1, { spread: 120, startVelocity: 45 });
                    }
                } catch (error) {
                    console.error('âŒ Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

            // Transport 2 custom field
            document.getElementById('transport2').addEventListener('change', (e) => {
                const group = document.getElementById('customTransport2Group');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('âœ… Date restrictions removed - can add orders from any date');

    // ============ FIREPOWER SFX LOGIN THEME ANIMATIONS ============

    // Floating Particles Background
    const canvas = document.getElementById('particles-canvas');
    const ctx = canvas ? canvas.getContext('2d') : null;

    if (canvas && ctx) {
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const particles = [];
        const particleCount = 50;

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.speedX = Math.random() * 0.5 - 0.25;
                this.speedY = Math.random() * -1 - 0.5;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = ['#ffd700', '#ffa500', '#ff6347'][Math.floor(Math.random() * 3)];
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.y < 0 || this.x < 0 || this.x > canvas.width) {
                    this.reset();
                    this.y = canvas.height;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Create particles
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animateParticles() {
            if (loginScreen.style.display === 'flex') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animateParticles);
            } else {
                // Clear canvas when login screen hidden
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Start animation when login screen is visible
        const particleObserver = new MutationObserver(() => {
            if (loginScreen.style.display === 'flex') {
                animateParticles();
            }
        });

        particleObserver.observe(loginScreen, { attributes: true, attributeFilter: ['style'] });
    }

    console.log('ğŸ† Firepower SFX Login Theme Activated!');

        });

    </script>
</body>
</html>
