<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 2025-12-28-LAZY-LOADING-v17 -->
    <!-- TIMESTAMP: 1735411200 -->
    <!-- DAY 2 OPTIMIZATION: Lazy loading system implemented -->
    <!-- - Created lazy-loader.js for on-demand module loading -->
    <!-- - Supports 12 feature modules (dashboard, inventory, etc.) -->
    <!-- - Modules load only when tabs are clicked (not at startup) -->
    <!-- - Preloads critical tabs after 2s delay -->
    <!-- - Next: Remove duplicate code from index.html for speed gains -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, proxy-revalidate, max-age=0, s-maxage=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Order Management System [v9-PACKAGES-WORKING]</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="shortcut icon" type="image/png" href="logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --light: #f8fafc;
            --white: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        /* Light Theme Variables */
        :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-hover: rgba(102, 126, 234, 0.05);
            --bg-input: #ffffff;
            --table-header-bg: #f8f9fa;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Noto Sans Gujarati', sans-serif;
            background: var(--bg-body);
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Layout */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        
        .app-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--white);
            padding: 1rem 0;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .company-name { font-size: 1.8rem; font-weight: 700; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #weatherMiniDashboard {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
            padding: 0.5rem 1rem;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.9rem;
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        #weatherMiniDashboard:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.3));
            border-color: rgba(59, 130, 246, 0.5);
        }

        .weather-mini-icon {
            font-size: 1.5rem;
            line-height: 1;
        }

        .weather-mini-info {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .weather-mini-temp {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .weather-mini-condition {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .search-global {
            position: relative;
            width: 300px;
        }

        .search-global input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        .search-global-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            margin-top: 0.25rem;
            box-shadow: var(--shadow-lg);
        }

        .search-results.show { display: block; }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-dark);
        }

        .search-result-item:hover { background: var(--bg-hover); }

        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-gray);
            text-transform: uppercase;
        }

        /* Navigation */
        .nav-tabs {
            position: sticky;
            top: 70px;
            z-index: 999;
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            padding: 0 1rem;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-gray);
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tab:hover { color: var(--primary); background: var(--bg-hover); }
        .nav-tab.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg-hover); }

        .main-content {
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
            width: 100%;
        }

        .tab-content { display: none; animation: fadeIn 0.3s ease-in; }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .card-header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Forms */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        .form-label.required::after { content: ' *'; color: var(--danger); }

        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--bg-input);
            color: var(--text-dark);
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Highlighted Date & Time Fields */
        .highlight-datetime {
            background-color: #fef3c7 !important;
            font-weight: 500;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Noto Sans Gujarati', sans-serif;
        }

        /* Checkboxes - Make them bigger and easier to click */
        .order-select-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary);
        }

        .order-select-checkbox:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: var(--white); }
        .btn-secondary { background: var(--white); color: var(--primary); border: 2px solid var(--primary); }
        .btn-success { background: var(--success); color: var(--white); }
        .btn-warning { background: var(--warning); color: var(--white); }
        .btn-danger { background: var(--danger); color: var(--white); }
        .btn-info { background: var(--info); color: var(--white); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.info { border-left-color: var(--info); }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-gray);
            font-weight: 500;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--success);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th, .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-dark);
        }

        .table tr:hover { background: var(--bg-hover); }
        .table tr:last-child td { border-bottom: none; }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-confirmed { background: rgba(16, 185, 129, 0.1); color: var(--success); }
        .status-completed { background: rgba(102, 126, 234, 0.1); color: var(--primary); }
        .status-cancelled { background: rgba(239, 68, 68, 0.1); color: var(--danger); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2000;
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-left: 4px solid var(--success);
            padding: 1rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            transform: translateX(400px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            color: var(--text-dark);
        }

        .toast.show { transform: translateX(0); }
        .toast.error { border-left-color: var(--danger); }
        .toast.warning { border-left-color: #ff9800; }
        .toast-actions { display: flex; gap: 0.5rem; }
        .toast-btn { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            text-align: center;
            color: var(--text-dark);
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ============ AD ANIMATION EFFECTS ============ */

        /* Fade In/Out */
        @keyframes adFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes adFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Slide In Effects */
        @keyframes adSlideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes adSlideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes adSlideInTop {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes adSlideInBottom {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Bounce */
        @keyframes adBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-30px); }
            60% { transform: translateY(-15px); }
        }

        /* Zoom In/Out */
        @keyframes adZoomIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes adZoomOut {
            from { transform: scale(1.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Rotate */
        @keyframes adRotateIn {
            from { transform: rotate(-360deg) scale(0); opacity: 0; }
            to { transform: rotate(0deg) scale(1); opacity: 1; }
        }

        /* Pulse/Glow */
        @keyframes adPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes adGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 1), 0 0 30px rgba(102, 126, 234, 0.8); }
        }

        /* Flip */
        @keyframes adFlipIn {
            from { transform: perspective(400px) rotateY(90deg); opacity: 0; }
            to { transform: perspective(400px) rotateY(0deg); opacity: 1; }
        }

        @keyframes adFlipX {
            0% { transform: perspective(400px) rotateX(0deg); }
            50% { transform: perspective(400px) rotateX(180deg); }
            100% { transform: perspective(400px) rotateX(360deg); }
        }

        /* Wave */
        @keyframes adWave {
            0%, 100% { transform: translateY(0px); }
            25% { transform: translateY(-10px); }
            50% { transform: translateY(0px); }
            75% { transform: translateY(10px); }
        }

        /* Type Writer Effect */
        @keyframes adTypeWriter {
            from { width: 0; }
            to { width: 100%; }
        }

        @keyframes adBlink {
            0%, 100% { border-color: transparent; }
            50% { border-color: currentColor; }
        }

        /* Sparkle */
        @keyframes adSparkle {
            0%, 100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            25% {
                opacity: 0.7;
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(-5deg);
                filter: brightness(1.5);
            }
            75% {
                opacity: 0.8;
                transform: scale(1.1) rotate(3deg);
                filter: brightness(1.2);
            }
        }

        /* Shake */
        @keyframes adShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Swing */
        @keyframes adSwing {
            20% { transform: rotate(15deg); }
            40% { transform: rotate(-10deg); }
            60% { transform: rotate(5deg); }
            80% { transform: rotate(-5deg); }
            100% { transform: rotate(0deg); }
        }

        /* Rubber Band */
        @keyframes adRubberBand {
            0% { transform: scale(1); }
            30% { transform: scaleX(1.25) scaleY(0.75); }
            40% { transform: scaleX(0.75) scaleY(1.25); }
            50% { transform: scaleX(1.15) scaleY(0.85); }
            65% { transform: scaleX(0.95) scaleY(1.05); }
            75% { transform: scaleX(1.05) scaleY(0.95); }
            100% { transform: scale(1); }
        }

        /* Animation Classes */
        .ad-animation-fadeIn { animation: adFadeIn 1s ease-in-out infinite; }
        .ad-animation-fadeOut { animation: adFadeOut 1s ease-in-out infinite alternate; }
        .ad-animation-slideInLeft { animation: adSlideInLeft 1s ease-out infinite; }
        .ad-animation-slideInRight { animation: adSlideInRight 1s ease-out infinite; }
        .ad-animation-slideInTop { animation: adSlideInTop 1s ease-out infinite; }
        .ad-animation-slideInBottom { animation: adSlideInBottom 1s ease-out infinite; }
        .ad-animation-bounce { animation: adBounce 2s ease infinite; }
        .ad-animation-zoomIn { animation: adZoomIn 1s ease-in-out infinite; }
        .ad-animation-zoomOut { animation: adZoomOut 1s ease-in-out infinite; }
        .ad-animation-rotateIn { animation: adRotateIn 1s ease-in-out infinite; }
        .ad-animation-pulse { animation: adPulse 1.5s ease-in-out infinite; }
        .ad-animation-glow { animation: adGlow 2s ease-in-out infinite; }
        .ad-animation-flipIn { animation: adFlipIn 1s ease-in-out infinite; }
        .ad-animation-flipX { animation: adFlipX 2s ease-in-out infinite; }
        .ad-animation-wave { animation: adWave 2s ease-in-out infinite; }
        .ad-animation-sparkle { animation: adSparkle 2s ease-in-out infinite; }
        .ad-animation-shake { animation: adShake 0.5s ease infinite; }
        .ad-animation-swing { animation: adSwing 1s ease infinite; }
        .ad-animation-rubberBand { animation: adRubberBand 1s ease infinite; }
        .ad-animation-none { animation: none; }

        /* Calendar */
        .calendar-container {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .calendar-day-header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .calendar-day {
            background: var(--bg-card);
            min-height: 100px;
            padding: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .calendar-day:hover { background: var(--bg-hover); }
        .calendar-day.today { background: rgba(102, 126, 234, 0.2); }
        .calendar-day.has-orders { border-left: 4px solid var(--success); }
        .calendar-day.has-tasks { border-right: 4px solid var(--warning); }
        .calendar-day.has-festival { border-top: 4px solid var(--danger); }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .calendar-day-content {
            font-size: 0.8rem;
            color: var(--text-gray);
        }

        .festival-text {
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .order-count {
            background: var(--success);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
        }

        /* Quantity Controls */
        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Search Dropdown */
        .search-container { position: relative; margin-bottom: 1rem; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-dropdown.show { display: block; }

        .search-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-dark);
        }

        .search-item:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.3s ease;
        }

        /* Order ID Highlight */
        .order-id-highlight {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }

        /* Print Template - Force Light Theme Colors */
        .print-template {
            display: none;
            width: 2480px;
            min-height: 3508px;
            background: white !important;
            color: #000000 !important;
            padding: 80px 80px 80px 590px;
            font-family: 'Noto Sans Gujarati', Arial, sans-serif;
            font-size: 32px;
            line-height: 1.4;
            /* Force light theme - prevent dark theme inheritance */
            --text-dark: #1f2937 !important;
            --text-gray: #6b7280 !important;
            --border: #e5e7eb !important;
        }

        /* Ensure all text within print template is black */
        .print-template * {
            color: inherit;
        }

        /* Undo Bar */
        .undo-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: transform 0.3s ease;
        }

        .undo-bar.show { transform: translateX(-50%) translateY(0); }

        .undo-btn {
            background: var(--white);
            color: var(--text-dark);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Quick Action Menu */
        .quick-menu {
            position: absolute;
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 0.5rem 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .quick-menu.show { display: block; }

        .quick-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quick-menu-item:hover { background: var(--light); }

        /* Keyboard Shortcuts Panel */
        .shortcuts-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2499;
            display: none;
        }

        .shortcuts-backdrop.show {
            display: block;
        }

        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 2500;
            max-width: 600px;
            display: none;
        }

        .shortcuts-panel.show { display: block; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-key {
            background: var(--light);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Drag Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        /* Mobile Responsive - Comprehensive Optimization */
        @media (max-width: 768px) {
            /* Typography */
            html {
                font-size: 14px;
            }

            body {
                overflow-x: hidden;
            }

            /* Header Optimization */
            .app-header {
                padding: 0.75rem 0;
                position: relative;
            }

            .header-content {
                flex-direction: column;
                gap: 0.75rem;
                padding: 0 0.75rem;
            }

            .company-name {
                font-size: 1.4rem;
                text-align: center;
                width: 100%;
            }

            .header-controls {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                gap: 0.5rem;
                padding-bottom: 0.75rem;
                margin-bottom: 0.5rem;
                border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            }

            /* Logout Button Safety - Prevent Accidental Clicks */
            .header-controls .btn-danger {
                order: -1; /* Move logout button to the first position (top) */
                width: 100%;
                max-width: 200px;
                margin-bottom: 0.75rem;
                padding: 0.75rem 1.5rem;
                font-size: 0.95rem;
                font-weight: 600;
                border: 2px solid rgba(255, 255, 255, 0.3);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            }

            /* Other header buttons */
            .header-controls .btn-info,
            .header-controls .btn-secondary {
                flex: 1;
                min-width: 90px;
            }

            /* Weather Mini Dashboard */
            #weatherMiniDashboard {
                font-size: 0.8rem;
                padding: 0.4rem 0.75rem;
                gap: 0.5rem;
            }

            .weather-mini-icon {
                font-size: 1.2rem;
            }

            .weather-mini-temp {
                font-size: 0.95rem;
            }

            /* Search Optimization */
            .search-global {
                width: 100%;
                max-width: 300px;
            }

            .search-global input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 0.65rem 2.5rem 0.65rem 1rem;
            }

            .search-results {
                max-height: 300px;
            }

            /* Navigation Tabs */
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .nav-container {
                padding: 0 0.5rem;
                min-width: min-content;
            }

            .nav-tab {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
                min-width: max-content;
            }

            /* Main Content */
            .main-content {
                padding: 1rem 0.75rem;
            }

            /* Cards */
            .card {
                padding: 1rem;
                margin-bottom: 1rem;
                border-radius: 12px;
            }

            .card-header {
                margin-bottom: 1rem;
                padding-bottom: 0.75rem;
            }

            .card-title {
                font-size: 1.25rem;
                flex-wrap: wrap;
            }

            /* Forms - Touch Friendly */
            .form-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .form-group {
                gap: 0.4rem;
            }

            .form-label {
                font-size: 0.9rem;
            }

            .form-input,
            .form-select,
            .form-textarea {
                padding: 0.85rem;
                font-size: 16px; /* Prevents zoom on iOS */
                border-width: 2px;
                min-height: 44px; /* Touch-friendly minimum */
            }

            .form-textarea {
                min-height: 120px;
            }

            /* Buttons - Touch Friendly */
            .btn {
                padding: 0.85rem 1.25rem;
                font-size: 1rem;
                min-height: 44px; /* Touch-friendly minimum */
                width: 100%;
                justify-content: center;
            }

            .btn-small {
                padding: 0.65rem 1rem;
                font-size: 0.85rem;
                min-height: 40px;
            }

            .btn-group {
                flex-direction: column;
                gap: 0.75rem;
                width: 100%;
            }

            .btn-group .btn {
                width: 100%;
            }

            /* Stats Grid */
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .stat-card {
                padding: 1.25rem;
            }

            .stat-value {
                font-size: 2rem;
            }

            /* Tables - Horizontal Scroll */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 0 -0.75rem;
                border-radius: 0;
            }

            .table {
                min-width: 600px; /* Ensures table doesn't squish */
            }

            .table th,
            .table td {
                padding: 0.65rem 0.5rem;
                font-size: 0.85rem;
                white-space: nowrap;
            }

            .table th {
                position: sticky;
                top: 0;
                z-index: 10;
            }

            /* Status Badges */
            .status-badge {
                padding: 0.3rem 0.65rem;
                font-size: 0.8rem;
            }

            /* Modals - Full Screen on Mobile */
            .modal {
                padding: 0;
                align-items: stretch;
            }

            .modal.show {
                padding: 0;
            }

            .modal-content {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
                border-radius: 0;
                padding: 1rem;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .modal-close {
                top: 0.75rem;
                right: 0.75rem;
                font-size: 2rem;
                padding: 0.5rem;
                z-index: 1001;
                background: var(--bg-card);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Calendar Optimization */
            .calendar-container {
                padding: 0.75rem;
                margin: 0 -0.75rem;
                border-radius: 0;
            }

            .calendar-header {
                flex-wrap: wrap;
                gap: 0.75rem;
            }

            .calendar-nav {
                gap: 0.5rem;
                flex-wrap: wrap;
            }

            .calendar-grid {
                gap: 1px;
            }

            .calendar-day-header {
                padding: 0.5rem 0.25rem;
                font-size: 0.75rem;
            }

            .calendar-day {
                min-height: 60px;
                padding: 0.3rem;
            }

            .calendar-day-number {
                font-size: 0.85rem;
            }

            .calendar-day-content {
                font-size: 0.7rem;
            }

            .festival-text {
                font-size: 0.65rem;
            }

            .order-count {
                width: 18px;
                height: 18px;
                font-size: 0.65rem;
            }

            /* Quantity Controls */
            .quantity-controls {
                gap: 0.4rem;
            }

            .quantity-btn {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            /* Toast Notifications */
            .toast {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
                padding: 0.85rem;
                font-size: 0.9rem;
            }

            /* Undo Bar */
            .undo-bar {
                bottom: 10px;
                left: 10px;
                right: 10px;
                transform: translateY(100px);
                padding: 0.85rem;
                min-width: auto;
            }

            .undo-bar.show {
                transform: translateY(0);
            }

            /* Loading Spinner */
            .loading {
                padding: 1.5rem;
                max-width: calc(100% - 2rem);
            }

            /* Quick Menu */
            .quick-menu {
                min-width: 160px;
                max-width: calc(100vw - 2rem);
            }

            .quick-menu-item {
                padding: 0.85rem;
                min-height: 44px;
            }

            /* Shortcuts Panel */
            .shortcuts-panel {
                max-width: calc(100% - 2rem);
                padding: 1.5rem;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
            }

            .shortcut-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
                padding: 0.75rem 0;
            }

            /* Drop Zone */
            .drop-zone {
                padding: 1.5rem 1rem;
                font-size: 0.9rem;
            }

            /* Search Dropdown */
            .search-dropdown {
                max-height: 250px;
            }

            .search-item {
                padding: 0.85rem;
                min-height: 44px;
            }

            /* Print Template - Adjust for Mobile Preview */
            .print-template {
                width: 100%;
                padding: 40px 20px;
                font-size: 14px;
            }

            /* Order ID Highlight */
            .order-id-highlight {
                padding: 0.3rem 0.65rem;
                font-size: 0.85rem;
            }

            /* Progress Bar */
            .progress-bar {
                height: 6px;
                margin: 0.75rem 0;
            }

            /* Utility Adjustments */
            .text-center {
                text-align: center !important;
            }
        }

        /* Extra Small Devices */
        @media (max-width: 480px) {
            html {
                font-size: 13px;
            }

            .company-name {
                font-size: 1.2rem;
            }

            .nav-tab {
                padding: 0.65rem 0.85rem;
                font-size: 0.85rem;
            }

            .card {
                padding: 0.85rem;
            }

            .card-title {
                font-size: 1.1rem;
            }

            .form-input,
            .form-select,
            .form-textarea {
                padding: 0.75rem;
            }

            .btn {
                padding: 0.75rem 1rem;
            }

            .stat-value {
                font-size: 1.75rem;
            }

            .calendar-day {
                min-height: 50px;
            }

            .modal-content {
                padding: 0.75rem;
            }
        }

        /* Landscape Orientation Optimization */
        @media (max-width: 768px) and (orientation: landscape) {
            .modal-content {
                height: auto;
                max-height: 95vh;
            }

            .calendar-day {
                min-height: 45px;
            }
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: 0.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }

    </style>
    <!-- Firebase SDKs (loaded first, used by core modules) -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-storage-compat.js"></script>

    <!-- Core Modules - Utils loaded synchronously (required by inline code) -->
    <script src="./js/core/utils-sync.js"></script>

    <!-- Lazy Loading System - Load feature modules on demand -->
    <script src="./js/core/lazy-loader.js"></script>

    <!-- Google Maps callback stub (real implementation defined later in page) -->
    <script>
        // Define stub early so Google Maps callback doesn't fail
        // Real implementation will override this when page fully loads
        window.initGoogleMaps = function() {
            console.log('‚è≥ Google Maps loaded (waiting for full page init)');
        };
    </script>

    <!-- Google Maps JavaScript API with Places Library -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAInxvvhevCHpLy9P5K5VvBNxDgbtZF-A4&libraries=places&loading=async&callback=initGoogleMaps" async defer></script>

    <!-- Confetti Library for Login Success -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        /* üî• BURNING FLAMES LOGIN THEME - OPTION 1 */

        #loginScreen {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><rect width="100%25" height="100%25" fill="%23000"/></svg>');
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }

        /* Login Slideshow Container */
        .login-slideshow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .login-slideshow-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        .login-slideshow-slide.active {
            opacity: 0.85;
        }

        /* Realistic Flame Flicker Animation */
        @keyframes flame-flicker {
            0%, 100% {
                filter: brightness(1) contrast(1.1);
                transform: scale(1);
            }
            25% {
                filter: brightness(1.15) contrast(1.2);
                transform: scale(1.02);
            }
            50% {
                filter: brightness(0.95) contrast(1.05);
                transform: scale(1.01);
            }
            75% {
                filter: brightness(1.1) contrast(1.15);
                transform: scale(1.015);
            }
        }

        /* Heat Distortion Overlay */
        #loginScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,140,0,0.1) 50%, rgba(255,69,0,0.2) 100%);
            animation: heat-wave 4s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes heat-wave {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }


        /* Floating Embers Canvas */
        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* Login Card with Glass-Morphism */
        .login-card {
            position: relative;
            z-index: 3;
            background: rgba(0, 0, 0, 0.25) !important;
            border: 2px solid rgba(255,140,0,0.5);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            animation: rise-from-flames 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                       card-fire-glow 2s ease-in-out 1.2s infinite;
        }

        /* Card Rises from Flames - Bottom Right */
        @keyframes rise-from-flames {
            0% {
                opacity: 0;
                transform: translate(100px, 100px) scale(0.8);
                filter: blur(10px);
            }
            60% {
                opacity: 0.8;
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
                filter: blur(0);
            }
        }

        @keyframes card-fire-glow {
            0%, 100% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 40px rgba(255,107,0,0.4),
                            inset 0 0 20px rgba(255,140,0,0.15);
                border-color: rgba(255,140,0,0.5);
            }
            50% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 60px rgba(255,140,0,0.6),
                            inset 0 0 30px rgba(255,107,0,0.25);
                border-color: rgba(255,165,0,0.7);
            }
        }

        /* Logo with Fire Animation */
        .login-logo {
            animation: logo-burn 3s ease-in-out infinite;
            color: #ffa500 !important;
            text-shadow: 0 0 15px rgba(255,140,0,1),
                         0 0 30px rgba(255,107,0,0.8),
                         0 0 45px rgba(255,69,0,0.6);
        }

        @keyframes logo-burn {
            0%, 100% {
                transform: translateY(0px);
                text-shadow: 0 0 15px rgba(255,140,0,1),
                             0 0 30px rgba(255,107,0,0.8),
                             0 0 45px rgba(255,69,0,0.6);
            }
            50% {
                transform: translateY(-8px);
                text-shadow: 0 0 20px rgba(255,165,0,1),
                             0 0 40px rgba(255,140,0,0.9),
                             0 0 60px rgba(255,107,0,0.7);
            }
        }

        /* Fire-themed Button */
        #loginBtn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #ff6b00 0%, #ff4500 100%) !important;
            border: 2px solid #ff8c00;
        }

        #loginBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(255,107,0,0.6),
                        0 0 40px rgba(255,69,0,0.4);
            border-color: #ffa500;
        }

        #loginBtn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,215,0,0.4);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #loginBtn:hover::before {
            width: 300px;
            height: 300px;
        }

        /* Input Fields with Glass Effect */
        #loginEmail, #loginPassword {
            background: rgba(255, 255, 255, 0.15) !important;
            color: #fff !important;
            border: 2px solid rgba(255,140,0,0.4) !important;
            backdrop-filter: blur(10px);
        }

        #loginEmail:focus, #loginPassword:focus {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 25px rgba(255,140,0,0.6),
                        inset 0 0 15px rgba(255,165,0,0.2) !important;
            outline: none !important;
            background: rgba(255, 255, 255, 0.2) !important;
        }

        /* Labels in Glass Theme */
        .login-card label {
            color: #ffb347 !important;
            text-shadow: 0 0 8px rgba(255,140,0,0.7);
            font-weight: 600;
        }

        /* Footer Text */
        .login-card > div:last-child {
            color: #ffa500 !important;
            text-shadow: 0 0 5px rgba(255,140,0,0.5);
        }
    </style>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: flex; align-items: flex-end; justify-content: flex-end; padding: 2rem;">
        <!-- Login Background Slideshow -->
        <div class="login-slideshow">
            <div class="login-slideshow-slide active" style="background-image: url('bubble from Disney.png');"></div>
            <div class="login-slideshow-slide" style="background-image: url('circle flame.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('firepowersfx.png');"></div>
            <div class="login-slideshow-slide" style="background-image: url('flame machine 1.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('flames machine.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('peper ribbon thrower.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('sparkle fountain image 1.jpg');"></div>
        </div>

        <!-- Floating Particles Background -->
        <canvas id="particles-canvas"></canvas>

        <div class="login-card" style="background: white; padding: 2rem; border-radius: 16px; max-width: 320px; width: auto;">
            <h1 class="login-logo" style="text-align: center; color: #667eea; margin-bottom: 1.5rem; font-size: 1.75rem;">üî• Firepower SFX</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="üîç Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <div id="weatherMiniDashboard">
                        <span class="weather-mini-icon">üå§Ô∏è</span>
                        <div class="weather-mini-info">
                            <span class="weather-mini-temp">--¬∞C</span>
                            <span class="weather-mini-condition">Loading...</span>
                        </div>
                    </div>
                    <button class="btn btn-info btn-small" onclick="OMS.toggleLanguage()" id="languageToggle" title="Switch Language">
                        üåê EN
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">‚å®Ô∏è</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">üö™ Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">üìä Dashboard</button>
                <button class="nav-tab" data-tab="orders">üìù Orders</button>
                <button class="nav-tab" data-tab="inventory">üì¶ Inventory</button>
                <button class="nav-tab" data-tab="productPhotos">üì∏ Product Photos</button>
                <button class="nav-tab" data-tab="itemHistory">üìú Item History</button>
                <button class="nav-tab" data-tab="preparation">üìã Preparation</button>
                <button class="nav-tab" data-tab="customers">üë• Customers</button>
                <button class="nav-tab" data-tab="quotations">üìÑ Quotations</button>
                <button class="nav-tab" data-tab="team">üë∑ Team</button>
                <button class="nav-tab" data-tab="calendar">üóìÔ∏è Calendar</button>
                <button class="nav-tab" data-tab="history">üìö History</button>
                <button class="nav-tab" data-tab="analytics">üìà Analytics</button>
                <button class="nav-tab" data-tab="financials">üí∞ Financials</button>
                <button class="nav-tab" data-tab="conversion">üöÄ Marketing</button>
                <button class="nav-tab" data-tab="settings">‚öôÔ∏è Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Analytics Charts Section -->
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <h2 class="card-title">üìä Advanced Analytics</h2>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 1.5rem; margin-top: 1rem;">
                        <!-- Revenue Trend Chart -->
                        <div style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border);">
                            <h4 style="margin: 0 0 1rem 0; color: var(--primary);">Revenue Trend (Last 6 Months)</h4>
                            <canvas id="revenueTrendChart" style="max-height: 300px;"></canvas>
                        </div>

                        <!-- Orders by Status Chart -->
                        <div style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border);">
                            <h4 style="margin: 0 0 1rem 0; color: var(--primary);">Orders by Status</h4>
                            <canvas id="ordersByStatusChart" style="max-height: 300px;"></canvas>
                        </div>

                        <!-- Monthly Orders Chart -->
                        <div style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border);">
                            <h4 style="margin: 0 0 1rem 0; color: var(--primary);">Orders per Month (Last 6 Months)</h4>
                            <canvas id="monthlyOrdersChart" style="max-height: 300px;"></canvas>
                        </div>

                        <!-- Top Items Chart -->
                        <div style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border);">
                            <h4 style="margin: 0 0 1rem 0; color: var(--primary);">Top 10 Popular Items</h4>
                            <canvas id="topItemsChart" style="max-height: 300px;"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">üîî Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üçï Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìù Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Event Type</label>
                                <select id="eventTypeSelect" class="form-select" required>
                                    <option value="single">Single Day Event</option>
                                    <option value="multi">Multi-Day Event</option>
                                </select>
                            </div>
                        </div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-grid">
    <div class="form-group">
        <label class="form-label required">Event Date</label>
        <input type="date" id="orderDate" name="orderDate" class="form-input highlight-datetime" required>
    </div>
    <div class="form-group">
        <label class="form-label">Ready Time</label>
        <select id="readyTime" name="readyTime" class="form-select highlight-datetime"></select>
    </div>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" name="startDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" name="endDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">üìÖ Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Contact</label>
                                <input type="tel" id="contact" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Venue</label>
                                <input type="text" id="venue" class="form-input" placeholder="Search for venue...">
                                <!-- Hidden field to store Google Maps link -->
                                <input type="hidden" id="venueMapLink">
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <select id="eventType" class="form-select">
                                    <option value="">Select Event Type</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Transport</label>
                                <select id="transport" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Transport 2 (Optional)</label>
                                <select id="transport2" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransport2Group">
                                <label class="form-label">Custom Transport 2</label>
                                <input type="text" id="customTransport2" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver 2 (Optional)</label>
                                <select id="driverName2" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper(s)</label>
                                <input type="text" id="helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)">
                                <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">üì¶ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="üîç Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">üíæ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-success" onclick="OMS.quickAddPayment()">üíµ Quick Payment</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">üëÅÔ∏è Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">üìã Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">üìÖ Same Day</button>
                            <button type="button" class="btn btn-danger" data-action="clear">üóëÔ∏è Clear (Ctrl+D)</button>
                        </div>
                    </form>
                </div>

                <!-- WhatsApp Date Filter Section -->
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <h2 class="card-title">üì± WhatsApp Orders Report</h2>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Select Date to View Orders</label>
                        <input type="date" id="whatsappFilterDate" class="form-input" style="max-width: 300px;">
                        <small style="color: var(--text-gray); display: block; margin-top: 0.5rem;">Select a date to see all orders and send them via WhatsApp</small>
                    </div>
                    <div id="whatsappOrdersPreview" style="margin-top: 1rem; display: none;">
                        <div style="background: var(--bg-hover); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <h4 style="margin: 0 0 0.5rem 0;">üìã Orders Found: <span id="whatsappOrderCount">0</span></h4>
                            <small style="color: var(--text-gray); display: block; margin-bottom: 1rem;">Each order has its own WhatsApp message. Copy and send individually to different contacts.</small>
                            <div id="whatsappOrdersList" style="max-height: 500px; overflow-y: auto;"></div>
                        </div>
                    </div>
                    <div id="whatsappNoOrders" style="display: none; padding: 1rem; text-align: center; color: var(--text-gray);">
                        üì≠ No orders found for selected date
                    </div>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="productPhotos" class="tab-content"></div>
            <div id="itemHistory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="quotations" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="financials" class="tab-content"></div>

            <!-- Marketing & Conversion Tab (includes Videos, Ads, Packages, Leads as sub-tabs) -->
            <div id="conversion" class="tab-content"></div>

            <!-- Settings Tab -->
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsBackdrop" class="shortcuts-backdrop" onclick="OMS.hideShortcuts()"></div>
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">√ó</button>
        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <script>
        
        // ============ UTILITIES ============
        // Utils object now loaded from /js/core/utils.js module
        // Available globally as window.Utils

        // ============ TRANSLATIONS ============
        const translations = {
            en: {
                // Header
                companyName: 'Order Management System',
                searchPlaceholder: 'üîç Search everything...',
                next: 'Next',
                logout: 'üö™ Logout',

                // Tabs
                dashboard: 'üìä Dashboard',
                orders: 'üìã Orders',
                inventory: 'üì¶ Inventory',
                productPhotos: 'üì∏ Product Photos',
                itemHistory: 'üìú Item History',
                preparation: 'üç≥ Preparation',
                customers: 'üë• Customers',
                quotations: 'üìÑ Quotations',
                team: 'üë®‚Äçüíº Team',
                calendar: 'üìÖ Calendar',
                history: 'üïí History',
                analytics: 'üìà Analytics',
                financials: 'üí∞ Financials',
                videos: 'üé• Videos',
                advertisements: 'üì¢ Ads',
                packages: 'üì¶ Packages',
                leads: 'üéØ Leads',
                conversion: 'üöÄ Marketing',
                settings: '‚öôÔ∏è Settings',

                // Common Buttons
                save: 'Save',
                cancel: 'Cancel',
                edit: 'Edit',
                delete: 'Delete',
                add: 'Add',
                close: 'Close',
                confirm: 'Confirm',
                clear: 'Clear',
                preview: 'Preview',
                duplicate: 'Duplicate',
                export: 'Export',
                import: 'Import',
                reset: 'Reset',
                search: 'Search',
                download: 'Download',
                upload: 'Upload',
                filter: 'Filter',
                print: 'Print',

                // Order Form
                orderDetails: 'Order Details',
                clientName: 'Client Name',
                contact: 'Contact',
                venue: 'Venue',
                orderDate: 'Order Date',
                readyTime: 'Ready Time',
                eventType: 'Event Type',
                transport: 'Transport',
                customTransport: 'Custom Transport',
                driverName: 'Driver Name',
                operator: 'Operator',
                helpers: 'Helper(s)',
                helperPlaceholder: 'Enter helper name(s), separate multiple with commas',
                orderStatus: 'Order Status',
                notes: 'Notes',
                items: 'Items',
                addItem: 'Add Item',
                itemName: 'Item Name',
                quantity: 'Pieces',
                remarks: 'Remarks',
                serialNumber: 'Sr. No.',

                // Status
                confirmed: 'Confirmed',
                completed: 'Completed',
                cancelled: 'Cancelled',
                pending: 'Pending',
                active: 'Active',
                inactive: 'Inactive',

                // Actions
                saveOrder: 'üíæ Save Order',
                saveOrderShortcut: 'üíæ Save Order (Ctrl+S)',
                duplicateLast: 'üìã Duplicate Last',
                sameDay: 'üìÖ Same Day',
                clearForm: 'üóëÔ∏è Clear',
                clearFormShortcut: 'üóëÔ∏è Clear (Ctrl+D)',

                // Settings
                systemSettings: '‚öôÔ∏è System Settings',
                printSettings: 'üñ®Ô∏è Print Settings',
                tableLayoutSettings: 'üìã Table Layout Settings',
                colorCustomization: 'üé® Color Customization',
                systemPreferences: 'üîß System Preferences',
                dataManagement: 'üìä Data Management',

                fontSize: 'Default Font Size',
                paperFormat: 'Paper Format',
                pageOrientation: 'Page Orientation',
                imageQuality: 'Image Quality',
                functionColor: 'Function Slot Color',
                portrait: 'üìÑ Portrait',
                landscape: 'üìÉ Landscape',
                low: 'Low',
                medium: 'Medium',
                high: 'High',
                ultra: 'Ultra',
                faster: 'Faster',
                balanced: 'Balanced',
                betterQuality: 'Better Quality',
                bestQuality: 'Best Quality',

                srColumnWidth: 'Sr.No Column Width',
                itemColumnWidth: 'Item Name Width',
                qtyColumnWidth: 'Pieces Width',
                remarksColumnWidth: 'Remarks Width',
                leftMarginFiling: 'Left Margin (filing)',

                headerBackground: 'Header Background',
                headerText: 'Header Text',
                orderIdBackground: 'Order ID Background',
                orderIdText: 'Order ID Text',
                tableHeaderBackground: 'Table Header Background',
                tableHeaderText: 'Table Header Text',
                tableBorder: 'Table Border',
                notesBackground: 'Notes Background',

                defaultOrderStatus: 'Default Order Status',
                lowStockThreshold: 'Low Stock Threshold',
                language: 'Language',
                invoiceFormat: 'Invoice Number Format',

                saveAllSettings: 'üíæ Save All Settings',
                resetToDefaults: 'üîÑ Reset to Defaults',
                exportJSON: 'üì§ Export JSON',
                exportCSV: 'üìä Export CSV',
                importBackup: 'üì• Import Backup',
                resetAllData: 'üóëÔ∏è Reset All Data',

                // Multi-day
                multiDayOrder: 'Multi-day Order',
                singleDayOrder: 'Single-day Order',
                startDate: 'Start Date',
                endDate: 'End Date',
                addDay: '‚ûï Add Day',
                addFunction: '‚ûï Add Function',
                removeDay: 'üóëÔ∏è Remove Day',
                removeFunction: 'üóëÔ∏è Remove Function',
                dayNumber: 'Day',
                functionNumber: 'Function',
                functionType: 'Function Type',
                timeSlot: 'Time Slot',
                driver: 'Driver',

                // Dashboard
                totalOrders: 'Total Orders',
                confirmedOrders: 'Confirmed',
                completedOrders: 'Completed',
                cancelledOrders: 'Cancelled',
                pendingOrders: 'Pending',
                recentOrders: 'Recent Orders',
                quickStats: 'Quick Stats',
                thisMonth: 'This Month',
                thisWeek: 'This Week',
                today: 'Today',

                // Team
                teamManagement: 'Team Management',
                addTeamMember: 'Add Team Member',
                memberName: 'Member Name',
                role: 'Role',
                roles: 'Roles',
                phoneNumber: 'Phone Number',
                email: 'Email',
                status: 'Status',
                actions: 'Actions',

                // Inventory
                inventoryManagement: 'Inventory Management',
                addCategory: 'Add Category',
                addInventoryItem: 'Add Inventory Item',
                categoryName: 'Category Name',
                currentStock: 'Current Stock',
                unit: 'Unit',
                reorderLevel: 'Reorder Level',

                // Calendar
                month: 'Month',
                week: 'Week',
                day: 'Day',
                ordersFor: 'Orders for',
                noOrders: 'No orders for this date',

                // History
                orderHistory: 'Order History',
                deletedOrders: 'Deleted Orders',
                restore: 'Restore',
                permanentlyDelete: 'Permanently Delete',

                // Analytics
                analyticsReport: 'Analytics Report',
                dateRange: 'Date Range',
                from: 'From',
                to: 'To',
                generateReport: 'Generate Report',
                topItems: 'Top Items',
                orderTrends: 'Order Trends',

                // Messages
                orderSaved: 'Order saved successfully!',
                orderDeleted: 'Order deleted!',
                settingsSaved: 'All settings saved successfully!',
                itemAdded: 'Item added!',
                itemRemoved: 'Item removed!',
                error: 'Error',
                success: 'Success',
                warning: 'Warning',
                info: 'Info',
                loading: 'Loading...',
                generatingImage: 'Generating image...',
                downloadComplete: 'Download complete!',

                // Placeholders
                enterClientName: 'Enter client name',
                enterContact: 'Enter contact number',
                enterVenue: 'Enter venue',
                selectDate: 'Select date',
                selectTime: 'Select time',
                selectEventType: 'Select event type',
                selectTransport: 'Select transport',
                selectDriver: 'Select Driver',
                selectOperator: 'Select Operator',
                selectHelper: 'Select Helper',
                enterNotes: 'Enter notes...',
                searchItem: 'Search item...',

                // Confirmations
                confirmDelete: 'Are you sure you want to delete?',
                confirmReset: 'Reset all settings?',
                confirmClear: 'Clear form?',
                cannotUndo: 'This action cannot be undone.',

                // Info messages
                multiOrderNote: 'Note: Multi-order images use smart auto-sizing',
                higherQualityNote: 'Higher quality = larger file size',
                multipleHelpersNote: 'You can add multiple helpers separated by commas (e.g., John, Mary, David)',
                chooseFormat: 'Choose paper size for print layout',
                portraitOrLandscape: 'Portrait or landscape mode',
                customColorNote: 'Custom color for function slots',

                // Additional translations for complete coverage
                lowStock: 'Low Stock',
                orderId: 'Order ID',
                client: 'Client',
                event: 'Event',
                date: 'Date',
                view: 'View',
                ordersText: 'orders',
                batchUpdate: '‚ö° Batch Update',
                categories: 'Categories',
                enterCategoryName: 'Category name',
                enterItemName: 'Item name',
                selectCategory: 'Select category',
                category: 'Category',
                item: 'Item',
                stock: 'Stock',
                topCustomer: 'Top Customer',
                preparationForecast: 'Preparation Forecast',
                selectDateRange: 'Select Date Range',
                generate: 'Generate',
                aggregatedItems: 'Aggregated Items for Date Range',
                forecastSummary: 'Forecast Summary',
                totalItems: 'Total Items',
                ordersInRange: 'Orders in Range',
                itemsToPrep: 'Items to Prepare',
                noOrdersFound: 'No orders found in the selected date range',
                customers: 'Customers',
                addCustomer: 'Add Customer',
                customerName: 'Customer Name',
                totalOrdersCount: 'Total Orders',
                lastOrder: 'Last Order',
                never: 'Never',
                na: 'N/A',
                viewOrders: 'View Orders',
                editTeamMember: 'Edit Team Member',
                addThisDay: '‚ûï Add to This Day',
                removeThisDay: 'üóëÔ∏è Remove',
                functionColor: 'Function Slot Color',
                addFunctionToThisDay: 'Add Function to This Day',
                selectOperatorPlaceholder: 'Select Operator',
                selectHelperPlaceholder: 'Select Helper',
                functionNotes: 'Special requirements for this function...',
                searchItems: 'üîç Search items...',
                noItemsAdded: 'No items added yet',
                calendarView: 'Calendar View',
                previousMonth: '‚Äπ Previous',
                nextMonth: 'Next ‚Ä∫',
                ordersScheduled: 'orders scheduled',
                noOrdersForDate: 'No orders for this date',
                viewOrderDetails: 'View details',
                restoreOrder: 'Restore',
                permanentDelete: 'Permanently Delete',
                ordersInHistory: 'orders in history',
                deletedOrdersCount: 'deleted orders',
                chartPlaceholder: 'Chart will appear here',
                noDataForRange: 'No data available for selected range',
                multiDayToggle: 'Multi-day Order',
                singleDay: 'Single Day',
                multiDay: 'Multi Day',
                transportOptions: 'Transport',
                customTransportOption: 'Custom',
                enterCustomTransport: 'Enter custom transport',
                selectStatus: 'Select Status',
                switchToEnglish: 'Switch to English',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: 'Preparation',
                forecast: 'Forecast',
                selectOperatorDropdown: 'Select Operator',
                noSelection: '',
                multiDayFormLabel: 'Multi-day Order?',
                enterFunctionType: 'e.g., Sangeet, Reception',
                enterTimeSlot: 'e.g., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: 'You can add multiple helpers separated by commas',
                tomorrow: 'Tomorrow',
                next7Days: 'Next 7 Days',
                next30Days: 'Next 30 Days',
                noOrdersFoundShort: 'No Orders Found',
                noOrdersScheduledBetween: 'No orders scheduled between',
                summary: 'Summary',
                uniqueItems: 'Unique Items',
                totalQuantity: 'Total Pieces',
                shortages: 'Shortages',
                sufficient: 'Sufficient',
                itemsPreparationList: 'Items Preparation List',
                sr: 'Sr',
                required: 'Required',
                inStock: 'In Stock',
                difference: 'Difference',
                usedInOrders: 'Used In Orders',
                ok: 'OK',
                short: 'SHORT',
                more: 'more',
                details: 'Details',
                grandTotal: 'GRAND TOTAL',
                orderDetailsBreakdown: 'Order Details Breakdown',
                shareWhatsApp: 'üì± Share WhatsApp',
                exportPDF: 'üìÑ Export PDF'
            },
            gu: {
                // Header
                companyName: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ',
                searchPlaceholder: 'üîç ‡™¨‡™ß‡´Å‡™Ç ‡™∂‡´ã‡™ß‡´ã...',
                next: '‡™Ü‡™ó‡™≥',
                logout: 'üö™ ‡™≤‡´ã‡™ó‡™Ü‡™â‡™ü',

                // Tabs
                dashboard: 'üìä ‡™°‡´á‡™∂‡™¨‡´ã‡™∞‡´ç‡™°',
                orders: 'üìã ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                inventory: 'üì¶ ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä',
                productPhotos: 'üì∏ ‡™â‡™§‡´ç‡™™‡™æ‡™¶‡™® ‡™´‡´ã‡™ü‡™æ',
                itemHistory: 'üìú ‡™Ü‡™á‡™ü‡™Æ ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                preparation: 'üç≥ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                customers: 'üë• ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                quotations: 'üìÑ ‡™Ö‡™µ‡™§‡™∞‡™£',
                team: 'üë®‚Äçüíº ‡™ü‡´Ä‡™Æ',
                calendar: 'üìÖ ‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞',
                history: 'üïí ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                analytics: 'üìà ‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£',
                financials: 'üí∞ ‡™®‡™æ‡™£‡™æ‡™ï‡´Ä‡™Ø',
                videos: 'üé• ‡™µ‡™ø‡™°‡™ø‡™Ø‡´ã',
                advertisements: 'üì¢ ‡™ú‡™æ‡™π‡´á‡™∞‡™æ‡™§',
                packages: 'üì¶ ‡™™‡´á‡™ï‡´á‡™ú‡´ã',
                leads: 'üéØ ‡™≤‡´Ä‡™°‡´ç‡™∏',
                conversion: 'üöÄ ‡™Æ‡™æ‡™∞‡´ç‡™ï‡´á‡™ü‡™ø‡™Ç‡™ó',
                settings: '‚öôÔ∏è ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',

                // Common Buttons
                save: '‡™∏‡™æ‡™ö‡™µ‡´ã',
                cancel: '‡™∞‡™¶ ‡™ï‡™∞‡´ã',
                edit: '‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                delete: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                add: '‡™â‡™Æ‡´á‡™∞‡´ã',
                close: '‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã',
                confirm: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™ï‡™∞‡´ã',
                clear: '‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                preview: '‡™™‡´Ç‡™∞‡´ç‡™µ‡™æ‡™µ‡™≤‡´ã‡™ï‡™®',
                duplicate: '‡™®‡™ï‡™≤',
                export: '‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                import: '‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                reset: '‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                search: '‡™∂‡´ã‡™ß‡´ã',
                download: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                upload: '‡™Ö‡™™‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                filter: '‡™´‡™ø‡™≤‡´ç‡™ü‡™∞',
                print: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü',

                // Order Form
                orderDetails: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™µ‡™ø‡™ó‡™§‡´ã',
                clientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                contact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï',
                venue: '‡™∏‡´ç‡™•‡™≥',
                orderDate: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                readyTime: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™∏‡™Æ‡™Ø',
                eventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                transport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                driverName: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                operator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞',
                helpers: '‡™π‡´á‡™≤‡´ç‡™™‡™∞(‡™∏)',
                helperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞‡™®‡™æ ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã, ‡™µ‡™ß‡´Å ‡™Æ‡™æ‡™ü‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´ã',
                orderStatus: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                notes: '‡™®‡´ã‡™Ç‡™ß',
                items: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                addItem: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                itemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                quantity: '‡™ú‡™•‡´ç‡™•‡´ã',
                remarks: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä',
                serialNumber: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï',

                // Status
                confirmed: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completed: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelled: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pending: '‡™¨‡™æ‡™ï‡´Ä',
                active: '‡™∏‡™ï‡´ç‡™∞‡™ø‡™Ø',
                inactive: '‡™®‡™ø‡™∑‡´ç‡™ï‡´ç‡™∞‡™ø‡™Ø',

                // Actions
                saveOrder: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                saveOrderShortcut: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã (Ctrl+S)',
                duplicateLast: 'üìã ‡™õ‡´á‡™≤‡´ç‡™≤‡´Ä ‡™®‡™ï‡™≤',
                sameDay: 'üìÖ ‡™∏‡™Æ‡™æ‡™® ‡™¶‡™ø‡™µ‡™∏',
                clearForm: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                clearFormShortcut: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã (Ctrl+D)',

                // Settings
                systemSettings: '‚öôÔ∏è ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                printSettings: 'üñ®Ô∏è ‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                tableLayoutSettings: 'üìã ‡™ü‡´á‡™¨‡™≤ ‡™≤‡´á‡™Ü‡™â‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                colorCustomization: 'üé® ‡™∞‡™Ç‡™ó ‡™ï‡™∏‡´ç‡™ü‡™Æ‡™æ‡™á‡™ù‡´á‡™∂‡™®',
                systemPreferences: 'üîß ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™™‡™∏‡™Ç‡™¶‡™ó‡´Ä‡™ì',
                dataManagement: 'üìä ‡™°‡´á‡™ü‡™æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',

                fontSize: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™´‡´ã‡™®‡´ç‡™ü ‡™∏‡™æ‡™á‡™ù',
                paperFormat: '‡™™‡´á‡™™‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',
                pageOrientation: '‡™™‡´á‡™ú ‡™ì‡™∞‡™ø‡™è‡™®‡´ç‡™ü‡´á‡™∂‡™®',
                imageQuality: '‡™á‡™Æ‡´á‡™ú ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                portrait: 'üìÑ ‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü',
                landscape: 'üìÉ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™',
                low: '‡™ì‡™õ‡´Ä',
                medium: '‡™Æ‡™ß‡´ç‡™Ø‡™Æ',
                high: '‡™â‡™ö‡´ç‡™ö',
                ultra: '‡™Ö‡™≤‡´ç‡™ü‡´ç‡™∞‡™æ',
                faster: '‡™ù‡™°‡™™‡´Ä',
                balanced: '‡™∏‡™Ç‡™§‡´Å‡™≤‡™ø‡™§',
                betterQuality: '‡™∏‡™æ‡™∞‡´Ä ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                bestQuality: '‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',

                srColumnWidth: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï ‡™ï‡´â‡™≤‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                itemColumnWidth: '‡™Ü‡™á‡™ü‡™Æ ‡™®‡™æ‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                qtyColumnWidth: '‡™™‡´Ä‡™∏‡´Ä‡™∏ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                remarksColumnWidth: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                leftMarginFiling: '‡™°‡™æ‡™¨‡´ã ‡™Æ‡™æ‡™∞‡´ç‡™ú‡™ø‡™® (‡™´‡™æ‡™á‡™≤‡™ø‡™Ç‡™ó)',

                headerBackground: '‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                headerText: '‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                orderIdBackground: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                orderIdText: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableHeaderBackground: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                tableHeaderText: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableBorder: '‡™ü‡´á‡™¨‡™≤ ‡™¨‡´ã‡™∞‡´ç‡™°‡™∞',
                notesBackground: '‡™®‡´ã‡™Ç‡™ß ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',

                defaultOrderStatus: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                lowStockThreshold: '‡™ì‡™õ‡™æ ‡™∏‡´ç‡™ü‡´â‡™ï‡™®‡´Ä ‡™Æ‡™∞‡´ç‡™Ø‡™æ‡™¶‡™æ',
                language: '‡™≠‡™æ‡™∑‡™æ',
                invoiceFormat: '‡™á‡™®‡´ç‡™µ‡´â‡™á‡™∏ ‡™®‡™Ç‡™¨‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',

                saveAllSettings: 'üíæ ‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                resetToDefaults: 'üîÑ ‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™™‡™∞ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                exportJSON: 'üì§ JSON ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                exportCSV: 'üìä CSV ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                importBackup: 'üì• ‡™¨‡´á‡™ï‡™Ö‡™™ ‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                resetAllData: 'üóëÔ∏è ‡™¨‡™ß‡´ã ‡™°‡´á‡™ü‡™æ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',

                // Multi-day
                multiDayOrder: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDayOrder: '‡™∏‡™ø‡™Ç‡™ó‡™≤-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                startDate: '‡™∂‡™∞‡´Ç‡™Ü‡™§‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                endDate: '‡™Ö‡™Ç‡™§‡™ø‡™Æ ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                addDay: '‚ûï ‡™¶‡™ø‡™µ‡™∏ ‡™â‡™Æ‡´á‡™∞‡´ã',
                addFunction: '‚ûï ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeDay: 'üóëÔ∏è ‡™¶‡™ø‡™µ‡™∏ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                removeFunction: 'üóëÔ∏è ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                dayNumber: '‡™¶‡™ø‡™µ‡™∏',
                functionNumber: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®',
                functionType: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                timeSlot: '‡™∏‡™Æ‡™Ø',
                driver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞',

                // Dashboard
                totalOrders: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                confirmedOrders: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completedOrders: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelledOrders: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pendingOrders: '‡™¨‡™æ‡™ï‡´Ä',
                recentOrders: '‡™§‡™æ‡™ú‡´á‡™§‡™∞‡™®‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                quickStats: '‡™ù‡™°‡™™‡´Ä ‡™Ü‡™Ç‡™ï‡™°‡™æ',
                thisMonth: '‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á',
                thisWeek: '‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´á',
                today: '‡™Ü‡™ú‡´á',

                // Team
                teamManagement: '‡™ü‡´Ä‡™Æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™â‡™Æ‡´á‡™∞‡´ã',
                memberName: '‡™∏‡™≠‡´ç‡™Ø‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                role: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ',
                roles: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ‡™ì',
                phoneNumber: '‡™´‡´ã‡™® ‡™®‡™Ç‡™¨‡™∞',
                email: '‡™á‡™Æ‡´á‡™á‡™≤',
                status: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                actions: '‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ‡™ì',

                // Inventory
                inventoryManagement: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™â‡™Æ‡´á‡™∞‡´ã',
                addInventoryItem: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                categoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                currentStock: '‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™∏‡´ç‡™ü‡´â‡™ï',
                unit: '‡™è‡™ï‡™Æ',
                reorderLevel: '‡™´‡™∞‡´Ä‡™•‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™∏‡´ç‡™§‡™∞',

                // Calendar
                month: '‡™Æ‡™π‡™ø‡™®‡´ã',
                week: '‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´Å‡™Ç',
                day: '‡™¶‡™ø‡™µ‡™∏',
                ordersFor: '‡™Æ‡™æ‡™ü‡´á ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                noOrders: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',

                // History
                orderHistory: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                deletedOrders: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                restore: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentlyDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',

                // Analytics
                analyticsReport: '‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü',
                dateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä',
                from: '‡™•‡´Ä',
                to: '‡™∏‡´Å‡™ß‡´Ä',
                generateReport: '‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™¨‡™®‡™æ‡™µ‡´ã',
                topItems: '‡™ü‡´ã‡™™ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                orderTrends: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ü‡´ç‡™∞‡´á‡™®‡´ç‡™°‡´ç‡™∏',

                // Messages
                orderSaved: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´ç‡™Ø‡´ã!',
                orderDeleted: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ç‡™Ø‡´ã!',
                settingsSaved: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´Ä!',
                itemAdded: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                itemRemoved: '‡™Ü‡™á‡™ü‡™Æ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                error: '‡™≠‡´Ç‡™≤',
                success: '‡™∏‡™´‡™≥‡™§‡™æ',
                warning: '‡™ö‡´á‡™§‡™µ‡™£‡´Ä',
                info: '‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä',
                loading: '‡™≤‡´ã‡™° ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´Å‡™Ç ‡™õ‡´á...',
                generatingImage: '‡™á‡™Æ‡´á‡™ú ‡™¨‡™®‡™æ‡™µ‡´Ä ‡™∞‡™π‡´ç‡™Ø‡™æ ‡™õ‡´Ä‡™è...',
                downloadComplete: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™™‡´Ç‡™∞‡´ç‡™£!',

                // Placeholders
                enterClientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterContact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï ‡™®‡™Ç‡™¨‡™∞ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterVenue: '‡™∏‡´ç‡™•‡™≥ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectDate: '‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTime: '‡™∏‡™Æ‡™Ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectEventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTransport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectDriver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectOperator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelper: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                enterNotes: '‡™®‡´ã‡™Ç‡™ß ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã...',
                searchItem: '‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',

                // Confirmations
                confirmDelete: '‡™∂‡´Å‡™Ç ‡™§‡™Æ‡´á ‡™ñ‡™∞‡´á‡™ñ‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã?',
                confirmReset: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡™µ‡´Ä ‡™õ‡´á?',
                confirmClear: '‡™´‡´ã‡™∞‡´ç‡™Æ ‡™∏‡™æ‡™´ ‡™ï‡™∞‡™µ‡´Å‡™Ç ‡™õ‡´á?',
                cannotUndo: '‡™Ü ‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§‡´ç ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡™æ‡™§‡´Ä ‡™®‡™•‡´Ä.',

                // Info messages
                multiOrderNote: '‡™®‡´ã‡™Ç‡™ß: ‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™Æ‡´á‡™ú‡´Ä‡™∏ ‡™∏‡´ç‡™Æ‡™æ‡™∞‡´ç‡™ü ‡™ì‡™ü‡´ã-‡™∏‡™æ‡™á‡™ù‡™ø‡™Ç‡™ó ‡™µ‡™æ‡™™‡™∞‡´á ‡™õ‡´á',
                higherQualityNote: '‡™â‡™ö‡´ç‡™ö ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ = ‡™Æ‡´ã‡™ü‡´Ä ‡™´‡™æ‡™á‡™≤ ‡™∏‡™æ‡™á‡™ù',
                multipleHelpersNote: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã (‡™¶‡™æ.‡™§., ‡™ú‡´ã‡™®, ‡™Æ‡´á‡™∞‡´Ä, ‡™°‡´á‡™µ‡™ø‡™°)',
                chooseFormat: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™≤‡´á‡™Ü‡™â‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™™‡´á‡™™‡™∞ ‡™∏‡™æ‡™á‡™ù ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                portraitOrLandscape: '‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü ‡™Ö‡™•‡™µ‡™æ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™ ‡™Æ‡´ã‡™°',
                customColorNote: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™∞‡™Ç‡™ó',

                // Additional translations for complete coverage
                lowStock: '‡™ì‡™õ‡´ã ‡™∏‡´ç‡™ü‡´â‡™ï',
                orderId: '‡™ì‡™∞‡´ç‡™°‡™∞ ID',
                client: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                event: '‡™á‡™µ‡´á‡™®‡´ç‡™ü',
                date: '‡™§‡™æ‡™∞‡´Ä‡™ñ',
                view: '‡™ú‡´Å‡™ì',
                ordersText: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                batchUpdate: '‚ö° ‡™¨‡´á‡™ö ‡™Ö‡™™‡™°‡´á‡™ü',
                categories: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™ì',
                enterCategoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                enterItemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                selectCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                category: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä',
                item: '‡™Ü‡™á‡™ü‡™Æ',
                stock: '‡™∏‡´ç‡™ü‡´â‡™ï',
                topCustomer: '‡™ü‡´ã‡™™ ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                preparationForecast: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectDateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                generate: '‡™¨‡™®‡™æ‡™µ‡´ã',
                aggregatedItems: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™è‡™ï‡™§‡´ç‡™∞‡™ø‡™§ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                forecastSummary: '‡™Ö‡™Ç‡™¶‡™æ‡™ú ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                totalItems: '‡™ï‡´Å‡™≤ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                ordersInRange: '‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                itemsToPrep: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™ï‡™∞‡™µ‡™æ‡™®‡´Ä ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                noOrdersFound: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                customers: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                addCustomer: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï ‡™â‡™Æ‡´á‡™∞‡´ã',
                customerName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                totalOrdersCount: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                lastOrder: '‡™õ‡´á‡™≤‡´ç‡™≤‡´ã ‡™ì‡™∞‡´ç‡™°‡™∞',
                never: '‡™ï‡´ç‡™Ø‡™æ‡™∞‡´á‡™Ø ‡™®‡™π‡´Ä‡™Ç',
                na: '‡™≤‡™æ‡™ó‡´Å ‡™®‡™•‡´Ä',
                viewOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™ú‡´Å‡™ì',
                editTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                addThisDay: '‚ûï ‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeThisDay: 'üóëÔ∏è ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                addFunctionToThisDay: '‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                selectOperatorPlaceholder: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                functionNotes: '‡™Ü ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™Æ‡™æ‡™ü‡´á ‡™µ‡™ø‡™∂‡´á‡™∑ ‡™ú‡™∞‡´Ç‡™∞‡™ø‡™Ø‡™æ‡™§‡´ã...',
                searchItems: 'üîç ‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',
                noItemsAdded: '‡™π‡™ú‡´Å ‡™∏‡´Å‡™ß‡´Ä ‡™ï‡´ã‡™à ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                calendarView: '‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞ ‡™¶‡´É‡™∂‡´ç‡™Ø',
                previousMonth: '‚Äπ ‡™™‡™π‡´á‡™≤‡™æ‡™Ç',
                nextMonth: '‡™Ü‡™ó‡™≥ ‚Ä∫',
                ordersScheduled: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§',
                noOrdersForDate: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',
                viewOrderDetails: '‡™µ‡™ø‡™ó‡™§‡´ã ‡™ú‡´Å‡™ì',
                restoreOrder: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                ordersInHistory: '‡™á‡™§‡™ø‡™π‡™æ‡™∏‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                deletedOrdersCount: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                chartPlaceholder: '‡™ö‡™æ‡™∞‡´ç‡™ü ‡™Ö‡™π‡´Ä‡™Ç ‡™¶‡´á‡™ñ‡™æ‡™∂‡´á',
                noDataForRange: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™°‡´á‡™ü‡™æ ‡™â‡™™‡™≤‡™¨‡´ç‡™ß ‡™®‡™•‡´Ä',
                multiDayToggle: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDay: '‡™∏‡™ø‡™Ç‡™ó‡™≤ ‡™°‡´á',
                multiDay: '‡™Æ‡™≤‡´ç‡™ü‡™ø ‡™°‡´á',
                transportOptions: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransportOption: '‡™ï‡™∏‡´ç‡™ü‡™Æ',
                enterCustomTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectStatus: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                switchToEnglish: '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                forecast: '‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectOperatorDropdown: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                noSelection: '',
                multiDayFormLabel: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞?',
                enterFunctionType: '‡™¶‡™æ.‡™§., ‡™∏‡™Ç‡™ó‡´Ä‡™§, ‡™∞‡™ø‡™∏‡´á‡™™‡´ç‡™∂‡™®',
                enterTimeSlot: '‡™¶‡™æ.‡™§., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã',
                tomorrow: '‡™Ü‡™µ‡™§‡´Ä ‡™ï‡™æ‡™≤‡´á',
                next7Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 7 ‡™¶‡™ø‡™µ‡™∏',
                next30Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 30 ‡™¶‡™ø‡™µ‡™∏',
                noOrdersFoundShort: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                noOrdersScheduledBetween: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§ ‡™®‡™•‡´Ä',
                summary: '‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                uniqueItems: '‡™Ö‡™®‡™®‡´ç‡™Ø ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                totalQuantity: '‡™ï‡´Å‡™≤ ‡™™‡´Ä‡™∏‡´Ä‡™∏',
                shortages: '‡™â‡™£‡™™',
                sufficient: '‡™™‡™∞‡´ç‡™Ø‡™æ‡™™‡´ç‡™§',
                itemsPreparationList: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ø‡™æ‡™¶‡´Ä',
                sr: '‡™ï‡´ç‡™∞‡™Æ',
                required: '‡™ú‡™∞‡´Ç‡™∞‡´Ä',
                inStock: '‡™∏‡´ç‡™ü‡´â‡™ï‡™Æ‡™æ‡™Ç',
                difference: '‡™§‡™´‡™æ‡™µ‡™§',
                usedInOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏‡™Æ‡™æ‡™Ç ‡™µ‡™™‡™∞‡™æ‡™Ø‡´á‡™≤',
                ok: '‡™¨‡™∞‡™æ‡™¨‡™∞',
                short: '‡™ì‡™õ‡´Å‡™Ç',
                more: '‡™µ‡™ß‡´Å',
                details: '‡™µ‡™ø‡™ó‡™§‡´ã',
                grandTotal: '‡™ï‡´Å‡™≤ ‡™∏‡™∞‡™µ‡™æ‡™≥‡´ã',
                orderDetailsBreakdown: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™µ‡™ø‡™ó‡™§ ‡™µ‡™ø‡™≠‡™æ‡™ú‡™®',
                shareWhatsApp: 'üì± WhatsApp ‡™∂‡´á‡™∞ ‡™ï‡™∞‡´ã',
                exportPDF: 'üìÑ PDF ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã'
            }
        };

        // ============ FILTERING INFRASTRUCTURE ============

        /**
         * FilterLogger - Detailed logging system for all filtering operations
         * Tracks every filter with timestamp, parameters, results, and performance metrics
         */
        class FilterLogger {
            constructor() {
                this.logs = this.loadLogs();
                this.maxLogs = 1000; // Keep last 1000 operations
            }

            loadLogs() {
                try {
                    const saved = localStorage.getItem('oms_filter_logs');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter logs:', error);
                    return [];
                }
            }

            saveLogs() {
                try {
                    // Keep only the most recent logs
                    if (this.logs.length > this.maxLogs) {
                        this.logs = this.logs.slice(-this.maxLogs);
                    }
                    localStorage.setItem('oms_filter_logs', JSON.stringify(this.logs));
                } catch (error) {
                    console.warn('Failed to save filter logs:', error);
                }
            }

            log(operation, details) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    operation,
                    ...details
                };

                this.logs.push(logEntry);
                this.saveLogs();

                // Also log to console for debugging
                console.log(`üîç [FilterLog] ${operation}:`, details);

                return logEntry;
            }

            getRecentLogs(count = 50) {
                return this.logs.slice(-count);
            }

            getLogsByDate(date) {
                return this.logs.filter(log => log.filterDate === date);
            }

            clearOldLogs(daysToKeep = 30) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - daysToKeep);
                const cutoffTime = cutoff.toISOString();

                this.logs = this.logs.filter(log => log.timestamp > cutoffTime);
                this.saveLogs();
            }
        }

        /**
         * PatternLearner - Machine learning-style pattern recognition system
         * Learns from filtering patterns to detect anomalies and improve accuracy
         */
        class PatternLearner {
            constructor() {
                this.patterns = this.loadPatterns();
                this.anomalyThreshold = 0.3; // 30% deviation triggers alert
            }

            loadPatterns() {
                try {
                    const saved = localStorage.getItem('oms_filter_patterns');
                    return saved ? JSON.parse(saved) : {
                        datePatterns: {}, // date -> expected order count
                        filterResults: [], // historical filter results
                        dateFormats: {}, // learned date format variations
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                } catch (error) {
                    console.warn('Failed to load patterns:', error);
                    return {
                        datePatterns: {},
                        filterResults: [],
                        dateFormats: {},
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                }
            }

            savePatterns() {
                try {
                    localStorage.setItem('oms_filter_patterns', JSON.stringify(this.patterns));
                } catch (error) {
                    console.warn('Failed to save patterns:', error);
                }
            }

            recordFilterResult(date, orderCount, totalAvailable, filterType = 'date') {
                // Update date-specific patterns
                if (!this.patterns.datePatterns[date]) {
                    this.patterns.datePatterns[date] = {
                        counts: [],
                        avgCount: 0,
                        lastSeen: new Date().toISOString()
                    };
                }

                const pattern = this.patterns.datePatterns[date];
                pattern.counts.push(orderCount);
                pattern.lastSeen = new Date().toISOString();

                // Keep only last 10 observations per date
                if (pattern.counts.length > 10) {
                    pattern.counts = pattern.counts.slice(-10);
                }

                // Calculate average
                pattern.avgCount = pattern.counts.reduce((sum, c) => sum + c, 0) / pattern.counts.length;

                // Update weekday/weekend patterns
                const dateObj = new Date(date);
                const dayOfWeek = dateObj.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                const key = isWeekend ? 'weekend' : 'weekday';
                const stats = this.patterns.typicalOrderCounts[key];

                if (stats.samples === 0) {
                    stats.min = orderCount;
                    stats.max = orderCount;
                    stats.avg = orderCount;
                    stats.samples = 1;
                } else {
                    stats.min = Math.min(stats.min, orderCount);
                    stats.max = Math.max(stats.max, orderCount);
                    stats.avg = (stats.avg * stats.samples + orderCount) / (stats.samples + 1);
                    stats.samples++;
                }

                // Record in filter results history
                this.patterns.filterResults.push({
                    timestamp: new Date().toISOString(),
                    date,
                    orderCount,
                    totalAvailable,
                    filterType,
                    dayOfWeek,
                    isWeekend
                });

                // Keep only last 500 results
                if (this.patterns.filterResults.length > 500) {
                    this.patterns.filterResults = this.patterns.filterResults.slice(-500);
                }

                this.savePatterns();
            }

            learnDateFormat(originalDate, normalizedDate) {
                if (!this.patterns.dateFormats[originalDate]) {
                    this.patterns.dateFormats[originalDate] = {
                        normalized: normalizedDate,
                        count: 1,
                        lastSeen: new Date().toISOString()
                    };
                } else {
                    this.patterns.dateFormats[originalDate].count++;
                    this.patterns.dateFormats[originalDate].lastSeen = new Date().toISOString();
                }
                this.savePatterns();
            }

            detectAnomaly(date, actualCount) {
                // Check if we have historical data for this date
                const pattern = this.patterns.datePatterns[date];

                if (pattern && pattern.counts.length >= 3) {
                    const expected = pattern.avgCount;
                    const deviation = Math.abs(actualCount - expected) / Math.max(expected, 1);

                    if (deviation > this.anomalyThreshold) {
                        return {
                            isAnomaly: true,
                            expected,
                            actual: actualCount,
                            deviation: (deviation * 100).toFixed(1) + '%',
                            message: `‚ö†Ô∏è Unusual order count! Expected ~${Math.round(expected)} orders, found ${actualCount}`
                        };
                    }
                }

                // Check against weekday/weekend patterns
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                if (stats.samples >= 10) {
                    if (actualCount < stats.min * 0.5 || actualCount > stats.max * 1.5) {
                        return {
                            isAnomaly: true,
                            expected: `${stats.min}-${stats.max}`,
                            actual: actualCount,
                            message: `‚ö†Ô∏è Order count outside normal range! Typical ${isWeekend ? 'weekend' : 'weekday'}: ${stats.min}-${stats.max}, found ${actualCount}`
                        };
                    }
                }

                return { isAnomaly: false };
            }

            getExpectedCount(date) {
                const pattern = this.patterns.datePatterns[date];
                if (pattern && pattern.counts.length > 0) {
                    return Math.round(pattern.avgCount);
                }

                // Fallback to weekday/weekend average
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                return stats.samples > 0 ? Math.round(stats.avg) : null;
            }
        }

        /**
         * FuzzyDateMatcher - Handles date format variations and near-matches
         * Provides error tolerance for date matching
         */
        class FuzzyDateMatcher {
            constructor() {
                this.dateFormats = [
                    'YYYY-MM-DD',
                    'DD-MM-YYYY',
                    'MM-DD-YYYY',
                    'DD/MM/YYYY',
                    'MM/DD/YYYY',
                    'YYYY/MM/DD'
                ];
            }

            // Normalize various date formats to YYYY-MM-DD
            normalize(dateStr) {
                if (!dateStr) return null;

                try {
                    // If already a Date object
                    if (dateStr instanceof Date) {
                        return this.toYYYYMMDD(dateStr);
                    }

                    // If ISO format
                    if (dateStr.includes('T') || dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const d = new Date(dateStr);
                        return this.toYYYYMMDD(d);
                    }

                    // Try different formats
                    const formats = [
                        // DD-MM-YYYY or DD/MM/YYYY
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // MM-DD-YYYY or MM/DD/YYYY (US format)
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // YYYY-MM-DD or YYYY/MM/DD
                        /^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/
                    ];

                    for (const format of formats) {
                        const match = dateStr.match(format);
                        if (match) {
                            let year, month, day;

                            if (match[1].length === 4) {
                                // YYYY-MM-DD format
                                [, year, month, day] = match;
                            } else {
                                // Assume DD-MM-YYYY (more common internationally)
                                [, day, month, year] = match;
                            }

                            const d = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                            if (!isNaN(d.getTime())) {
                                return this.toYYYYMMDD(d);
                            }
                        }
                    }

                    // Fallback: try native Date parsing
                    const d = new Date(dateStr);
                    if (!isNaN(d.getTime())) {
                        return this.toYYYYMMDD(d);
                    }

                } catch (error) {
                    console.warn('Failed to normalize date:', dateStr, error);
                }

                return null;
            }

            toYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Check if two dates are the same, handling various formats
            matches(date1, date2) {
                const norm1 = this.normalize(date1);
                const norm2 = this.normalize(date2);
                return norm1 && norm2 && norm1 === norm2;
            }

            // Check if date is within range (inclusive)
            isInRange(dateToCheck, startDate, endDate) {
                const check = new Date(this.normalize(dateToCheck));
                const start = new Date(this.normalize(startDate));
                const end = new Date(this.normalize(endDate));

                return check >= start && check <= end;
            }

            // Find near matches (within N days)
            findNearMatches(targetDate, dates, daysTolerance = 1) {
                const target = new Date(this.normalize(targetDate));
                const matches = [];

                for (const date of dates) {
                    const d = new Date(this.normalize(date));
                    const diffDays = Math.abs((d - target) / (1000 * 60 * 60 * 24));

                    if (diffDays <= daysTolerance) {
                        matches.push({
                            date,
                            daysAway: diffDays,
                            isExact: diffDays === 0
                        });
                    }
                }

                return matches.sort((a, b) => a.daysAway - b.daysAway);
            }

            // Get date variations that should be checked
            getVariations(dateStr) {
                const normalized = this.normalize(dateStr);
                if (!normalized) return [dateStr];

                const d = new Date(normalized);
                const variations = new Set();

                // Add normalized version
                variations.add(normalized);

                // Add original
                variations.add(dateStr);

                // Add common formats
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');

                variations.add(`${year}-${month}-${day}`);
                variations.add(`${day}-${month}-${year}`);
                variations.add(`${month}-${day}-${year}`);
                variations.add(`${day}/${month}/${year}`);
                variations.add(`${month}/${day}/${year}`);

                return Array.from(variations);
            }
        }

        /**
         * OrderValidator - Validation system to detect missing orders
         * Alerts when filtering results seem incomplete
         */
        class OrderValidator {
            constructor(patternLearner) {
                this.patternLearner = patternLearner;
            }

            validate(filterResult) {
                const alerts = [];
                const { date, orderCount, totalAvailable, matchedOrders, allOrders } = filterResult;

                // Alert 1: Check for anomalies based on learned patterns
                const anomaly = this.patternLearner.detectAnomaly(date, orderCount);
                if (anomaly.isAnomaly) {
                    alerts.push({
                        level: 'warning',
                        type: 'anomaly',
                        message: anomaly.message,
                        details: anomaly
                    });
                }

                // Alert 2: Check if there are orders with similar dates that weren't matched
                const targetDate = new Date(date);
                const nearbyOrders = allOrders.filter(order => {
                    if (matchedOrders.includes(order)) return false;

                    const orderDate = new Date(order.date || order.startDate);
                    const diffDays = Math.abs((orderDate - targetDate) / (1000 * 60 * 60 * 24));
                    return diffDays <= 2; // Within 2 days
                });

                if (nearbyOrders.length > 0) {
                    alerts.push({
                        level: 'info',
                        type: 'nearby_dates',
                        message: `‚ÑπÔ∏è Found ${nearbyOrders.length} order(s) within 2 days of ${date}`,
                        details: {
                            nearbyOrders: nearbyOrders.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                date: o.date || o.startDate
                            }))
                        }
                    });
                }

                // Alert 3: Check for orders with blank/missing dates
                const ordersWithoutDates = allOrders.filter(o =>
                    !o.date && !o.startDate && o.status !== 'Completed'
                );

                if (ordersWithoutDates.length > 0) {
                    alerts.push({
                        level: 'warning',
                        type: 'missing_dates',
                        message: `‚ö†Ô∏è Found ${ordersWithoutDates.length} order(s) without dates`,
                        details: {
                            orders: ordersWithoutDates.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                status: o.status
                            }))
                        }
                    });
                }

                // Alert 4: Check for multiday orders that might be partially matched
                const multidayOrders = allOrders.filter(o =>
                    o.isMultiDay && !matchedOrders.includes(o)
                );

                for (const order of multidayOrders) {
                    if (order.startDate && order.endDate) {
                        const checkDate = new Date(date);
                        const start = new Date(order.startDate);
                        const end = new Date(order.endDate);

                        // Check if date should fall in range but wasn't matched
                        if (checkDate >= start && checkDate <= end) {
                            alerts.push({
                                level: 'error',
                                type: 'missed_multiday',
                                message: `üö® Multi-day order "${order.orderId || order.clientName}" should include ${date} but wasn't matched!`,
                                details: {
                                    orderId: order.orderId,
                                    clientName: order.clientName,
                                    startDate: order.startDate,
                                    endDate: order.endDate
                                }
                            });
                        }
                    }
                }

                return alerts;
            }

            showAlerts(alerts, date) {
                if (alerts.length === 0) return;

                console.group(`üîî Validation Alerts for ${date}`);

                for (const alert of alerts) {
                    const emoji = alert.level === 'error' ? 'üö®' :
                                 alert.level === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                    console.log(`${emoji} [${alert.type}] ${alert.message}`);
                    if (alert.details) {
                        console.log('Details:', alert.details);
                    }
                }

                console.groupEnd();

                // Show toast for critical alerts
                const criticalAlerts = alerts.filter(a => a.level === 'error');
                if (criticalAlerts.length > 0 && window.OMS) {
                    window.OMS.showToast(
                        `${criticalAlerts.length} critical validation issue(s) detected!`,
                        'error'
                    );
                }
            }
        }

        /**
         * FilterRatingSystem - User feedback system for filter algorithm
         * Allows users to rate filtering results and helps system learn from mistakes
         */
        class FilterRatingSystem {
            constructor() {
                this.ratings = this.loadRatings();
                this.currentFilterContext = null;
                this.maxRatings = 500; // Keep last 500 ratings
            }

            loadRatings() {
                try {
                    const saved = localStorage.getItem('oms_filter_ratings');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter ratings:', error);
                    return [];
                }
            }

            saveRatings() {
                try {
                    if (this.ratings.length > this.maxRatings) {
                        this.ratings = this.ratings.slice(-this.maxRatings);
                    }
                    localStorage.setItem('oms_filter_ratings', JSON.stringify(this.ratings));
                } catch (error) {
                    console.warn('Failed to save filter ratings:', error);
                }
            }

            // Store context of current filter operation for rating
            setFilterContext(context) {
                this.currentFilterContext = {
                    timestamp: new Date().toISOString(),
                    date: context.date,
                    normalizedDate: context.normalizedDate,
                    matchedOrders: context.matchedOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    })),
                    totalOrders: context.totalOrders,
                    filterDetails: context.filterDetails,
                    allOrderIds: context.allOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    }))
                };
            }

            // Record user rating with feedback
            recordRating(rating, feedback = {}) {
                if (!this.currentFilterContext) {
                    console.warn('No filter context available for rating');
                    return;
                }

                const ratingEntry = {
                    ...this.currentFilterContext,
                    rating, // 1-5 stars or thumbs up/down
                    feedback: {
                        userComment: feedback.comment || '',
                        incorrectlyIncluded: feedback.incorrectlyIncluded || [], // Order IDs that shouldn't be there
                        incorrectlyExcluded: feedback.incorrectlyExcluded || [], // Order IDs that should be there
                        ratingType: feedback.ratingType || 'numeric', // 'numeric', 'thumbs', 'words'
                        sentimentScore: this.calculateSentiment(rating, feedback),
                        tags: feedback.tags || [] // ['wrong_date', 'missing_orders', 'extra_orders', 'perfect']
                    },
                    ratedAt: new Date().toISOString()
                };

                this.ratings.push(ratingEntry);
                this.saveRatings();

                console.log('‚ú® Rating recorded:', ratingEntry);

                // Learn from this feedback
                this.learnFromRating(ratingEntry);

                return ratingEntry;
            }

            // Calculate sentiment score from rating
            calculateSentiment(rating, feedback) {
                let score = 0;

                // Numeric rating (1-5 stars)
                if (typeof rating === 'number') {
                    score = (rating - 1) / 4; // Normalize to 0-1
                }
                // Thumbs up/down
                else if (rating === 'up') {
                    score = 1;
                } else if (rating === 'down') {
                    score = 0;
                }
                // Word-based rating
                else if (typeof rating === 'string') {
                    const wordScores = {
                        'perfect': 1.0,
                        'excellent': 1.0,
                        'good': 0.75,
                        'okay': 0.5,
                        'bad': 0.25,
                        'terrible': 0
                    };
                    score = wordScores[rating.toLowerCase()] || 0.5;
                }

                // Adjust based on specific feedback
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    score *= 0.5; // Penalty for wrong inclusions
                }
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    score *= 0.5; // Penalty for missing orders
                }

                return score;
            }

            // Learn from user rating
            learnFromRating(ratingEntry) {
                const { date, normalizedDate, feedback, rating } = ratingEntry;

                // Create learning rules based on feedback
                const learningRules = [];

                // Rule 1: Learn from incorrectly included orders
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    feedback.incorrectlyIncluded.forEach(badOrder => {
                        learningRules.push({
                            type: 'exclusion',
                            targetDate: normalizedDate,
                            orderId: badOrder.orderId,
                            reason: 'User marked as incorrectly included',
                            orderDate: badOrder.date || badOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 2: Learn from incorrectly excluded orders
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    feedback.incorrectlyExcluded.forEach(missedOrder => {
                        learningRules.push({
                            type: 'inclusion',
                            targetDate: normalizedDate,
                            orderId: missedOrder.orderId,
                            reason: 'User marked as incorrectly excluded',
                            orderDate: missedOrder.date || missedOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 3: Learn from overall sentiment
                if (feedback.sentimentScore < 0.5) {
                    learningRules.push({
                        type: 'anomaly',
                        targetDate: normalizedDate,
                        reason: 'Low user satisfaction',
                        sentimentScore: feedback.sentimentScore,
                        weight: 0.5
                    });
                }

                // Store learning rules
                if (learningRules.length > 0) {
                    this.storeLearningRules(learningRules);
                }

                console.log('üß† Learned from rating:', learningRules.length, 'new rules');
            }

            // Store learning rules for future use
            storeLearningRules(rules) {
                try {
                    let existingRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    existingRules = [...existingRules, ...rules];

                    // Keep only last 1000 rules
                    if (existingRules.length > 1000) {
                        existingRules = existingRules.slice(-1000);
                    }

                    localStorage.setItem('oms_filter_learning_rules', JSON.stringify(existingRules));
                } catch (error) {
                    console.warn('Failed to store learning rules:', error);
                }
            }

            // Get learning rules for a specific date
            getLearningRules(date) {
                try {
                    const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    return rules.filter(rule => rule.targetDate === date);
                } catch (error) {
                    console.warn('Failed to get learning rules:', error);
                    return [];
                }
            }

            // Apply learning rules to filter results
            applyLearningRules(date, orders, allOrders) {
                const rules = this.getLearningRules(date);
                if (rules.length === 0) return { orders, corrections: [] };

                console.log(`üß† Applying ${rules.length} learning rules for ${date}`);

                const corrections = [];
                let correctedOrders = [...orders];

                // Apply exclusion rules
                const exclusionRules = rules.filter(r => r.type === 'exclusion');
                exclusionRules.forEach(rule => {
                    const idx = correctedOrders.findIndex(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (idx !== -1) {
                        corrections.push({
                            type: 'removed',
                            order: correctedOrders[idx],
                            reason: rule.reason
                        });
                        correctedOrders.splice(idx, 1);
                    }
                });

                // Apply inclusion rules
                const inclusionRules = rules.filter(r => r.type === 'inclusion');
                inclusionRules.forEach(rule => {
                    const order = allOrders.find(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (order && !correctedOrders.find(o => o.orderId === order.orderId)) {
                        corrections.push({
                            type: 'added',
                            order: order,
                            reason: rule.reason
                        });
                        correctedOrders.push(order);
                    }
                });

                if (corrections.length > 0) {
                    console.log(`‚úÖ Applied ${corrections.length} corrections:`, corrections);
                }

                return { orders: correctedOrders, corrections };
            }

            // Show rating UI modal
            showRatingUI(OMS) {
                if (!this.currentFilterContext) return;

                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>‚≠ê Rate Filter Results</h3>
                            <button onclick="this.closest('.modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 20px; color: var(--text-secondary);">
                                Found <strong>${this.currentFilterContext.matchedOrders.length}</strong> orders for
                                <strong>${this.currentFilterContext.date}</strong>
                            </p>

                            <!-- Star Rating -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">How accurate was this filter?</label>
                                <div id="starRating" style="font-size: 36px; cursor: pointer;">
                                    ${[1, 2, 3, 4, 5].map(i => `<span data-rating="${i}" style="color: #ddd;">‚≠ê</span>`).join('')}
                                </div>
                                <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                                    <span id="ratingLabel">Click to rate</span>
                                </div>
                            </div>

                            <!-- Quick Feedback Buttons -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Quick Feedback:</label>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button class="btn btn-sm feedback-tag" data-tag="perfect">‚úÖ Perfect</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="missing_orders">‚ùå Missing Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="extra_orders">‚ûï Extra Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="wrong_date">üìÖ Wrong Date</button>
                                </div>
                            </div>

                            <!-- Matched Orders List -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                    Matched Orders (Click to mark as incorrect):
                                </label>
                                <div id="matchedOrdersList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 10px;">
                                    ${this.currentFilterContext.matchedOrders.map(o => `
                                        <div class="order-item" data-order-id="${o.orderId}" data-doc-id="${o.docId}" style="padding: 8px; margin: 5px 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                            <strong>${o.orderId || o.clientName}</strong>
                                            <span style="color: var(--text-secondary); margin-left: 10px; font-size: 12px;">
                                                ${o.date || o.startDate || 'No date'}
                                            </span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Comment -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Additional Comments (Optional):</label>
                                <textarea id="ratingComment" rows="3" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; resize: vertical;" placeholder="Tell us what went wrong or what was good..."></textarea>
                            </div>

                            <!-- Submit Buttons -->
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Skip</button>
                                <button id="submitRating" class="btn btn-primary">Submit Rating</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Star rating interaction
                let selectedRating = 0;
                const stars = modal.querySelectorAll('#starRating span');
                const ratingLabel = modal.querySelector('#ratingLabel');
                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Excellent'];

                stars.forEach(star => {
                    star.addEventListener('mouseenter', function() {
                        const rating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < rating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[rating - 1];
                    });

                    star.addEventListener('click', function() {
                        selectedRating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[selectedRating - 1] + ' ‚≠ê'.repeat(selectedRating);
                    });
                });

                modal.querySelector('#starRating').addEventListener('mouseleave', function() {
                    stars.forEach((s, i) => {
                        s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                    });
                    ratingLabel.textContent = selectedRating > 0 ? labels[selectedRating - 1] + ' ‚≠ê'.repeat(selectedRating) : 'Click to rate';
                });

                // Feedback tags interaction
                const selectedTags = new Set();
                modal.querySelectorAll('.feedback-tag').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (selectedTags.has(tag)) {
                            selectedTags.delete(tag);
                            this.style.background = '';
                            this.style.color = '';
                        } else {
                            selectedTags.add(tag);
                            this.style.background = 'var(--primary)';
                            this.style.color = 'white';
                        }
                    });
                });

                // Order selection interaction
                const incorrectOrders = new Set();
                modal.querySelectorAll('.order-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const orderId = this.dataset.orderId || this.dataset.docId;
                        if (incorrectOrders.has(orderId)) {
                            incorrectOrders.delete(orderId);
                            this.style.background = 'var(--bg-card)';
                            this.style.border = '1px solid var(--border)';
                        } else {
                            incorrectOrders.add(orderId);
                            this.style.background = '#ffebee';
                            this.style.border = '2px solid #f44336';
                        }
                    });
                });

                // Submit rating
                modal.querySelector('#submitRating').addEventListener('click', () => {
                    if (selectedRating === 0) {
                        OMS.showToast('Please select a rating', 'error');
                        return;
                    }

                    const incorrectlyIncluded = Array.from(incorrectOrders).map(orderId => {
                        return this.currentFilterContext.matchedOrders.find(o =>
                            o.orderId === orderId || o.docId === orderId
                        );
                    }).filter(Boolean);

                    this.recordRating(selectedRating, {
                        comment: modal.querySelector('#ratingComment').value,
                        incorrectlyIncluded,
                        incorrectlyExcluded: [], // Can be enhanced to allow selecting missing orders
                        ratingType: 'numeric',
                        tags: Array.from(selectedTags)
                    });

                    OMS.showToast('‚ú® Thank you! The system has learned from your feedback.', 'success');
                    modal.remove();
                });
            }

            // Get statistics about ratings
            getStats() {
                if (this.ratings.length === 0) {
                    return { avgRating: 0, totalRatings: 0, recentRatings: [] };
                }

                const numericRatings = this.ratings.filter(r => typeof r.rating === 'number');
                const avgRating = numericRatings.length > 0
                    ? numericRatings.reduce((sum, r) => sum + r.rating, 0) / numericRatings.length
                    : 0;

                return {
                    avgRating: avgRating.toFixed(2),
                    totalRatings: this.ratings.length,
                    recentRatings: this.ratings.slice(-10),
                    sentimentTrend: this.ratings.slice(-20).map(r => r.feedback.sentimentScore)
                };
            }

            // Clear all ratings
            clearAllRatings() {
                this.ratings = [];
                this.saveRatings();
                localStorage.removeItem('oms_filter_learning_rules');
                console.log('üóëÔ∏è All ratings and learning rules cleared');
            }
        }

        // Initialize global instances
        const filterLogger = new FilterLogger();
        const patternLearner = new PatternLearner();
        const fuzzyDateMatcher = new FuzzyDateMatcher();
        const orderValidator = new OrderValidator(patternLearner);
        const filterRatingSystem = new FilterRatingSystem();

        // Clean up old logs periodically (keep last 30 days)
        filterLogger.clearOldLogs(30);

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [], deletedItems: [], deletedCategories: [] },
                itemHistory: [],
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                payments: [],
                expenses: [],
                trackingData: [],
                eventsList: [
                    'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                    'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                    'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                    'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                    'Ganesh Agman', 'Ganesh Visarjan'
                ],
                settings: {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["‡§Æ‡§ï‡§∞ ‡§∏‡§Ç‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡§ø", "Makar Sankranti"],
                "2025-01-26": ["‡§ó‡§£‡§§‡§Ç‡§§‡•ç‡§∞ ‡§¶‡§ø‡§µ‡§∏", "Republic Day"],
                "2025-02-13": ["‡§Æ‡§π‡§æ ‡§∂‡§ø‡§µ‡§∞‡§æ‡§§‡•ç‡§∞‡§ø", "Maha Shivratri"],
                "2025-03-13": ["‡§π‡•ã‡§≤‡•Ä", "Holi"],
                "2025-03-14": ["‡§ß‡•Å‡§≤‡•á‡§ü‡•Ä", "Dhuleti"],
                "2025-04-06": ["‡§∞‡§æ‡§Æ ‡§®‡§µ‡§Æ‡•Ä", "Ram Navami"],
                "2025-08-15": ["‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞‡§§‡§æ ‡§¶‡§ø‡§µ‡§∏", "Independence Day"],
                "2025-08-19": ["‡§ú‡§®‡•ç‡§Æ‡§æ‡§∑‡•ç‡§ü‡§Æ‡•Ä", "Janmashtami"],
                "2025-10-02": ["‡§ó‡§æ‡§Ç‡§ß‡•Ä ‡§ú‡§Ø‡§Ç‡§§‡•Ä", "Gandhi Jayanti"],
                "2025-11-01": ["‡§ß‡§®‡§§‡•á‡§∞‡§∏", "Dhanteras"],
                "2025-11-02": ["‡§¶‡•Ä‡§µ‡§æ‡§≤‡•Ä", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('‚ö†Ô∏è Already initialized - skipping duplicate init');
        return;
    }

    console.log('üöÄ Initializing OMS...');
    this.initialized = true;

    // Load user role first
    await this.getCurrentUser();

    await this.loadFromStorage();
    await this.loadEventsListFromFirestore();
    this.populateEventsDatalist(); // Populate events dropdown immediately
    await this.loadTrackingFromFirestore();
    await this.loadVideosFromFirestore(); // Load videos from Firestore
    await this.loadAdsFromFirestore(); // Load advertisements from Firestore
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();

    // Apply RBAC to navigation tabs
    await this.applyRBACToNavigation();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
                this.applyLanguage(); // Apply saved language

                // Initialize weather mini dashboard and set up auto-refresh
                this.updateWeatherMiniDashboard();
                setInterval(() => this.updateWeatherMiniDashboard(), 900000); // Refresh every 15 minutes

                // Check for draft order after initialization
                setTimeout(() => this.checkForDraft(), 1000);
            },

            // ============ LANGUAGE SWITCHING ============
            toggleLanguage() {
                const currentLang = this.data.settings.language || 'en';
                const newLang = currentLang === 'en' ? 'gu' : 'en';
                this.data.settings.language = newLang;
                this.saveToStorage();
                this.applyLanguage();
                this.showToast(newLang === 'en' ? 'Language switched to English' : '‡™≠‡™æ‡™∑‡™æ ‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡™æ‡™à ‡™ó‡™à', 'success');
            },

            applyLanguage() {
                const lang = this.data.settings.language || 'en';
                const t = translations[lang];

                // Update language toggle button
                const toggleBtn = document.getElementById('languageToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = lang === 'en' ? 'üåê EN' : 'üåê ‡™ó‡´Å';
                    toggleBtn.title = lang === 'en' ? 'Switch to Gujarati' : '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã';
                }

                // Update header
                const companyName = document.querySelector('.company-name');
                if (companyName) companyName.textContent = t.companyName;

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) searchInput.placeholder = t.searchPlaceholder;

                // Update tabs
                const tabs = document.querySelectorAll('.nav-tab');
                const tabKeys = ['dashboard', 'orders', 'inventory', 'productPhotos', 'itemHistory', 'preparation', 'customers', 'quotations', 'team', 'calendar', 'history', 'analytics', 'financials', 'conversion', 'settings'];
                tabs.forEach((tab, index) => {
                    if (tabKeys[index] && t[tabKeys[index]]) {
                        tab.textContent = t[tabKeys[index]];
                    }
                });

                // Update Orders tab static labels using data-translate attributes
                this.updateOrdersTabLabels();

                // Update action buttons
                this.updateActionButtons();

                // Re-render current tab to apply translations
                if (this.currentTab) {
                    this.switchTab(this.currentTab);
                }
            },

            updateOrdersTabLabels() {
                // Helper function to update label text
                const updateLabel = (selector, translationKey) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.textContent = this.t(translationKey);
                    });
                };

                // Update form labels by finding them with specific text patterns
                // This will update all label elements in the orders tab
                const labels = {
                    'Client Name': 'clientName',
                    'Contact': 'contact',
                    'Venue': 'venue',
                    'Ready Time': 'readyTime',
                    'Order Status': 'orderStatus',
                    'Notes': 'notes',
                    'Driver Name': 'driverName',
                    'Operator': 'operator',
                    'Helper(s)': 'helpers',
                    'Transport': 'transport'
                };

                document.querySelectorAll('.form-label').forEach(label => {
                    const text = label.textContent.trim();
                    Object.keys(labels).forEach(key => {
                        if (text.includes(key)) {
                            const translatedText = this.t(labels[key]);
                            label.textContent = label.textContent.replace(key, translatedText);
                        }
                    });
                });

                // Update helper placeholder
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.placeholder = this.t('helperPlaceholder');
                }

                // Update client name placeholder
                const clientInput = document.getElementById('clientName');
                if (clientInput) {
                    clientInput.placeholder = this.t('enterClientName');
                }
            },

            updateActionButtons() {
                // Update button texts by finding buttons with specific onclick handlers
                const updateButton = (selector, translationKey) => {
                    const btn = document.querySelector(selector);
                    if (btn) btn.textContent = this.t(translationKey);
                };

                // Update form action buttons
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    const text = btn.textContent.trim();
                    if (text.includes('Save Order')) btn.textContent = this.t('saveOrderShortcut');
                    else if (text.includes('Duplicate Last')) btn.textContent = this.t('duplicateLast');
                    else if (text.includes('Same Day')) btn.textContent = this.t('sameDay');
                    else if (text.includes('Clear') && text.includes('Ctrl')) btn.textContent = this.t('clearFormShortcut');
                    else if (text.includes('Preview')) btn.textContent = `üëÅÔ∏è ${this.t('preview')}`;
                });
            },

            // Helper function to get translations
            t(key) {
                const lang = this.data.settings.language || 'en';
                return translations[lang][key] || translations.en[key] || key;
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    // FIXED: Get all data attributes from the same element to avoid mismatched selections
                    const actionElement = e.target.closest('[data-action]');
                    if (!actionElement) return;

                    const action = actionElement.dataset.action;
                    const id = actionElement.dataset.id;
                    const type = actionElement.dataset.type;

                    // Log only relevant data for each action type
                    const actionsNeedingIdType = ['edit', 'delete', 'print', 'quickAction'];
                    if (actionsNeedingIdType.includes(action)) {
                        console.log('üñ±Ô∏è Button clicked - Action:', action, 'ID:', id, 'Type:', type);
                    } else {
                        console.log('üñ±Ô∏è Button clicked - Action:', action);
                    }

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;

        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            container.innerHTML = '';
            // CRITICAL FIX: Clear function data when dates are cleared
            window.dayFunctionsData = {};
            return;
        }

        // CRITICAL FIX: Reset function data before regenerating days
        // This prevents duplicate functions when generateDayWiseFunctions() is called multiple times
        window.dayFunctionsData = {};

        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">${this.t('dayNumber')} ${i + 1} - ${dateStr}</h4>

                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>

                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ${this.t('addFunctionToThisDay')}
                    </button>
                </div>
            `;
        }

        container.innerHTML = html;

        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;

        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }

        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;

        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            venue: '',
            transport: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });

        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">${this.t('functionNumber')} ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">${this.t('removeFunction')}</button>` : ''}
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('functionType')}</label>
                        <select id="${functionId}Type" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                            <option value="">Select Event Type</option>
                            ${(this.data.eventsList || []).map(event => `<option value="${event}">${event}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('timeSlot')}</label>
                        <input type="text" id="${functionId}Time" class="form-input highlight-datetime"
                               placeholder="${this.t('enterTimeSlot')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('venue')}</label>
                        <input type="text" id="${functionId}Venue" class="form-input"
                               placeholder="Enter venue address"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'venue', this.value)">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Transport (Multiple)</label>
                        <select id="${functionId}Transport" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'transport', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                            <option value="New Bolero">New Bolero</option>
                            <option value="Old Bolero">Old Bolero</option>
                            <option value="Isuzu">Isuzu</option>
                            <option value="Porter">Porter</option>
                            <option value="Other">Other</option>
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple transports</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('driver')} (Multiple)</label>
                        <select id="${functionId}Driver" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple drivers</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('operator')}</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">${this.t('selectOperator')}</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('helpers')}</label>
                        <input type="text" id="${functionId}Helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)"
                               oninput="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value.trim())">
                        <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('notes')}</label>
                    <textarea id="${functionId}Notes" class="form-textarea"
                              placeholder="${this.t('functionNotes')}"
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('items')}</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input"
                               placeholder="${this.t('searchItems')}" autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">${this.t('noItemsAdded')}</div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); Orders.saveOrder(this); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); Orders.clearForm(this); },
                            'd': () => { e.preventDefault(); Orders.clearForm(this); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.add('show');
                backdrop.classList.add('show');

                // Add Escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideShortcuts();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                panel._escapeHandler = escapeHandler;
            },

            hideShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.remove('show');
                backdrop.classList.remove('show');

                // Remove escape handler
                if (panel._escapeHandler) {
                    document.removeEventListener('keydown', panel._escapeHandler);
                    panel._escapeHandler = null;
                }
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    if (this.hasUnsavedChanges()) {
                        let draftData = null;

                        // Check if working on order
                        const orderForm = document.getElementById('orderForm');
                        if (orderForm && (Utils.get('clientName') || this.currentOrderItems.length > 0)) {
                            draftData = this.collectFormData();
                            draftData.workType = 'order';
                        }
                        // Check if working on quotation
                        else if (this.currentQuotation && (
                            this.currentQuotation.customer?.name ||
                            (this.currentQuotation.days && this.currentQuotation.days.length > 0)
                        )) {
                            draftData = {
                                workType: 'quotation',
                                editMode: this.editingQuotationId ? true : false,
                                editingQuotationId: this.editingQuotationId || null,
                                quotationData: JSON.parse(JSON.stringify(this.currentQuotation)),
                                createdAt: new Date().toISOString()
                            };
                        }

                        if (draftData) {
                            localStorage.setItem('oms_draft', JSON.stringify(draftData));
                            console.log(`üìù ${draftData.workType} draft auto-saved`);
                        }
                    }
                }, 2000); // Auto-save every 2 seconds
            },

            hasUnsavedChanges() {
                // Check for unsaved order work
                const hasOrderWork = Utils.get('clientName') || this.currentOrderItems.length > 0;

                // Check for unsaved quotation work
                const hasQuotationWork = this.currentQuotation && (
                    this.currentQuotation.customer?.name ||
                    (this.currentQuotation.days && this.currentQuotation.days.length > 0)
                );

                return hasOrderWork || hasQuotationWork;
            },

            checkForDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        // Only show restore option if draft has meaningful data
                        if (draftData.clientName || (draftData.items && draftData.items.length > 0)) {
                            const draftDate = new Date(draftData.createdAt || Date.now()).toLocaleString();
                            const message = `
                                <div style="text-align: left;">
                                    <h3 style="margin-top: 0;">üìã Draft Order Found</h3>
                                    <p>You have an unsaved draft from: <strong>${draftDate}</strong></p>
                                    <p><strong>Client:</strong> ${draftData.clientName || 'Not specified'}</p>
                                    <p><strong>Items:</strong> ${draftData.items?.length || 0} items</p>
                                    <p>Would you like to restore this draft?</p>
                                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                                        <button class="btn btn-success" onclick="OMS.restoreDraft(); OMS.closeModal('draftModal');">‚úÖ Restore Draft</button>
                                        <button class="btn btn-danger" onclick="OMS.discardDraft(); OMS.closeModal('draftModal');">üóëÔ∏è Discard Draft</button>
                                        <button class="btn btn-secondary" onclick="OMS.closeModal('draftModal');">‚è≠Ô∏è Ignore for Now</button>
                                    </div>
                                </div>
                            `;

                            // Show modal with draft info
                            const modalHTML = `
                                <div class="modal show" id="draftModal" onclick="if(event.target === this) document.getElementById('draftModal').remove()">
                                    <div class="modal-content" style="max-width: 500px;">
                                        ${message}
                                    </div>
                                </div>
                            `;
                            document.body.insertAdjacentHTML('beforeend', modalHTML);
                        }
                    } catch (error) {
                        console.error('Error checking draft:', error);
                    }
                }
            },

            restoreDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (!draft) return;

                try {
                    const draftData = JSON.parse(draft);
                    console.log('üìã Restoring draft:', draftData);

                    // Handle QUOTATION drafts
                    if (draftData.workType === 'quotation') {
                        this.switchTab('quotations');

                        setTimeout(() => {
                            if (draftData.editMode && draftData.editingQuotationId) {
                                // Editing existing quotation
                                console.log('‚úèÔ∏è Restoring quotation edit mode for ID:', draftData.editingQuotationId);
                                this.editingQuotationId = draftData.editingQuotationId;
                            } else {
                                // Creating new quotation
                                console.log('üìù Restoring new quotation draft');
                                this.editingQuotationId = null;
                            }

                            // Restore quotation data
                            this.currentQuotation = draftData.quotationData;
                            this.renderQuotationForm();
                            this.showToast('‚úÖ Quotation draft restored!', 'success');
                        }, 100);
                        return;
                    }

                    // Handle ORDER drafts (workType === 'order' or undefined for backward compatibility)
                    this.switchTab('orders');

                    setTimeout(() => {
                        // Set edit mode flags if editing existing order
                        if (draftData.editMode) {
                            console.log('‚úèÔ∏è Restoring order edit mode for:', draftData.editingOrderId);
                            this.editingOrderId = draftData.editingOrderId;
                            this.editingDocId = draftData.editingDocId;
                        } else {
                            // Clear edit flags for new order
                            this.editingOrderId = null;
                            this.editingDocId = null;
                        }

                        // Populate form fields
                        if (draftData.orderId) Utils.set('orderId', draftData.orderId);
                        if (draftData.clientName) Utils.set('clientName', draftData.clientName);
                        if (draftData.contact) Utils.set('contact', draftData.contact);
                        if (draftData.venue) Utils.set('venue', draftData.venue);
                        if (draftData.eventType) Utils.set('eventType', draftData.eventType);
                        if (draftData.date) Utils.set('orderDate', draftData.date);
                        if (draftData.readyTime) Utils.set('readyTime', draftData.readyTime);
                        if (draftData.transport) Utils.set('transport', draftData.transport);
                        if (draftData.driverName) Utils.set('driverName', draftData.driverName);
                        if (draftData.operator) Utils.set('operator', draftData.operator);
                        if (draftData.status) Utils.set('orderStatus', draftData.status);
                        if (draftData.notes) Utils.set('orderNotes', draftData.notes);

                        // Restore multiday data if exists
                        if (draftData.isMultiDay) {
                            Utils.set('eventTypeSelect', 'multi');
                            if (draftData.startDate) Utils.set('startDate', draftData.startDate);
                            if (draftData.endDate) Utils.set('endDate', draftData.endDate);

                            // Trigger multiday form generation
                            const event = new Event('change');
                            document.getElementById('eventTypeSelect')?.dispatchEvent(event);

                            // Restore day-wise data after form is generated
                            if (draftData.dayWiseData) {
                                setTimeout(() => {
                                    window.dayFunctionsData = draftData.dayWiseData;
                                    console.log('üìÖ Restored multiday data');
                                }, 500);
                            }
                        } else {
                            // Restore items for single-day events
                            if (draftData.items && Array.isArray(draftData.items) && draftData.items.length > 0) {
                                console.log('üì¶ Restoring items:', draftData.items);
                                this.currentOrderItems = [...draftData.items];
                                this.updateOrderItemsTable();
                            }
                        }

                        const editLabel = draftData.editMode ? ' (editing existing order)' : '';
                        this.showToast(`‚úÖ Order draft restored${editLabel}!`, 'success');
                    }, 100);

                } catch (error) {
                    console.error('Error restoring draft:', error);
                    this.showToast('‚ùå Error restoring draft', 'error');
                }
            },

            discardDraft() {
                localStorage.removeItem('oms_draft');
                this.showToast('üóëÔ∏è Draft discarded', 'info');
                console.log('üóëÔ∏è Draft discarded by user');
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('‚úÖ Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('‚úÖ Auto-backup created successfully');
                    this.showToast('üì¶ Auto-backup created', 'success');
                } catch (error) {
                    console.error('‚ùå Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('üì• Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            initGlobalSearch() {
                const input = document.getElementById('globalSearch');
                const results = document.getElementById('globalSearchResults');

                input.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    if (query.length < 2) {
                        results.classList.remove('show');
                        return;
                    }

                    const searchResults = this.performGlobalSearch(query);
                    this.displayGlobalSearchResults(searchResults);
                }, 300));

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        results.classList.remove('show');
                        input.value = '';
                    }
                });
            },

            performGlobalSearch(query) {
                const results = [];

                // Search orders
                this.data.orders.forEach(order => {
                    if (order.orderId.toLowerCase().includes(query) ||
                        order.clientName.toLowerCase().includes(query) ||
                        order.venue.toLowerCase().includes(query)) {
                        results.push({ type: 'order', data: order });
                    }
                });

                // Search customers
                this.data.customers.forEach(customer => {
                    if (customer.name.toLowerCase().includes(query) ||
                        customer.contact.includes(query)) {
                        results.push({ type: 'customer', data: customer });
                    }
                });

                // Search inventory
                this.data.inventory.items.forEach(item => {
                    if (item.name.toLowerCase().includes(query)) {
                        results.push({ type: 'item', data: item });
                    }
                });

                return results.slice(0, 10);
            },

            displayGlobalSearchResults(results) {
                const container = document.getElementById('globalSearchResults');
                if (results.length === 0) {
                    container.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    container.innerHTML = results.map(r => `
                        <div class="search-result-item" onclick="OMS.navigateToResult('${r.type}', '${r.data.id || r.data.orderId}')">
                            <div>
                                <div class="search-result-type">${r.type}</div>
                                <div>${r.type === 'order' ? r.data.orderId + ' - ' + r.data.clientName : 
                                       r.type === 'customer' ? r.data.name : r.data.name}</div>
                            </div>
                        </div>
                    `).join('');
                }
                container.classList.add('show');
            },

            navigateToResult(type, id) {
                const tabMap = { order: 'history', customer: 'customers', item: 'inventory' };
                this.switchTab(tabMap[type]);
                document.getElementById('globalSearchResults').classList.remove('show');
                document.getElementById('globalSearch').value = '';
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('üî• Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`üî• Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('üß© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    // FIXED: Search by docId first (always unique), then orderId as fallback
    const index = this.data.orders.findIndex(o => o.docId === id || o.orderId === id);
    if (index === -1) {
        console.warn('‚ö†Ô∏è Order not found in local array:', id);
        return false;
    }

    try {
        console.log('üîÑ Attempting to delete orderId:', id);

        // Use the actual docId from the found order
        const orderToDelete = this.data.orders[index];
        const docRef = db.collection('orders').doc(orderToDelete.docId || id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('‚úÖ Deleted Firestore doc with ID:', id);
        } else {
            console.warn('‚ö†Ô∏è No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`üìù Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('‚ùå Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                // Track deleted category to prevent re-addition
                if (!this.data.inventory.deletedCategories) {
                    this.data.inventory.deletedCategories = [];
                }
                if (!this.data.inventory.deletedCategories.includes(id)) {
                    this.data.inventory.deletedCategories.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                // Track deleted item to prevent re-addition
                if (!this.data.inventory.deletedItems) {
                    this.data.inventory.deletedItems = [];
                }
                if (!this.data.inventory.deletedItems.includes(id)) {
                    this.data.inventory.deletedItems.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();

        // Reload data from Firestore to ensure all tabs are in sync
        await this.loadOrdersFromFirestore();

        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        console.log('üîç EditItem called with ID:', id);
                        console.log('üìã All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                        // FIXED: Search by docId first (always unique), then orderId as fallback
                        const order = this.data.orders.find(o => o.docId === id || o.orderId === id);
                        console.log('‚úÖ Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                        if (!order) return;
                        this.switchTab('orders');
                        Orders.loadOrderToForm(this, order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
},

            async updateWeatherMiniDashboard() {
                try {
                    // Use consistent city field name - defaultCity (not city)
                    const city = this.data.settings?.defaultCity || 'Delhi';
                    const apiKey = this.data.settings?.weatherApiKey || '';

                    console.log('üå§Ô∏è Fetching weather for:', city, 'at', new Date().toLocaleTimeString());
                    const weather = await Utils.getWeather(city, apiKey);

                    const iconElement = document.querySelector('.weather-mini-icon');
                    const tempElement = document.querySelector('.weather-mini-temp');
                    const conditionElement = document.querySelector('.weather-mini-condition');

                    if (iconElement && tempElement && conditionElement) {
                        iconElement.textContent = Utils.getWeatherEmoji(weather.condition);
                        tempElement.textContent = weather.temp !== 'N/A' ? `${weather.temp}¬∞C` : '--¬∞C';
                        conditionElement.textContent = weather.condition !== 'N/A' ? weather.condition : 'Loading...';

                        console.log('‚úÖ Weather updated:', weather.temp + '¬∞C', weather.condition);
                    }
                } catch (error) {
                    console.error('‚ùå Error updating weather mini dashboard:', error);

                    // Show error state in UI
                    const iconElement = document.querySelector('.weather-mini-icon');
                    const tempElement = document.querySelector('.weather-mini-temp');
                    const conditionElement = document.querySelector('.weather-mini-condition');

                    if (iconElement && tempElement && conditionElement) {
                        iconElement.textContent = '‚ö†Ô∏è';
                        tempElement.textContent = '--¬∞C';
                        conditionElement.textContent = 'Error';
                    }
                }
            },

            getNextOrderId() {
                const prefix = this.data.settings.invoicePrefix || 'FP';
                const counter = this.data.settings.orderIdCounter || 1;
                return `${prefix}${String(counter).padStart(3, '0')}`;
            },

            incrementOrderCounter() {
                this.data.settings.orderIdCounter = (this.data.settings.orderIdCounter || 1) + 1;
                this.refreshOrderId();
            },

   collectFormData() {

        const transport = Utils.get('transport');
        const eventType = Utils.get('eventTypeSelect');
        const isMultiDay = eventType === 'multi';

        // Get helper names from text input
        const helperInput = document.getElementById('helper');
        const selectedHelpers = helperInput ? helperInput.value.trim() : '';

        // Collect day-wise data for multi-day events
        let dayWiseData = [];
        if (isMultiDay) {
            const startDate = Utils.get('startDate');
            const endDate = Utils.get('endDate');
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

            for (let i = 0; i < diffDays; i++) {
                const currentDate = new Date(start);
                currentDate.setDate(start.getDate() + i);

                // Get functions for this day
                const dayFunctions = window.dayFunctionsData?.[i] || [];

                dayWiseData.push({
                    dayNumber: i + 1,
                    date: Utils.toDateString(currentDate),
                    functions: dayFunctions.map(func => ({
                        functionType: func.functionType || '',
                        timeSlot: func.timeSlot || '',
                        driver: func.driver || '',
                        operator: func.operator || '',
                        helper: func.helper || '',
                        notes: func.notes || '',
                        items: func.items || []
                    }))
                });
            }
        }

        const transport2 = Utils.get('transport2');

        // Get location data - prioritize autocomplete selection, then fall back to manual Maps link
        let venueLocation = null;
        const mapLink = Utils.get('venueMapLink');

        // Check if user selected place from autocomplete
        if (window.selectedPlaceData) {
            venueLocation = {
                lat: window.selectedPlaceData.lat,
                lng: window.selectedPlaceData.lng,
                source: 'google_autocomplete',
                place_id: window.selectedPlaceData.place_id,
                formatted_address: window.selectedPlaceData.formatted_address
            };
            console.log('‚úÖ Using location from autocomplete:', venueLocation);
            console.log('üìç Will save to Firestore:', {
                venue: Utils.get('venue'),
                venueLocation: venueLocation,
                venueMapLink: mapLink
            });
        }
        // Otherwise, try to extract from manually pasted Maps link
        else if (mapLink && mapLink.trim()) {
            venueLocation = this.extractLocationFromMapsLink(mapLink);
            console.log('‚úÖ Using location extracted from Maps link:', venueLocation);
        } else {
            console.warn('‚ö†Ô∏è No venue location data available - neither autocomplete nor map link provided');
        }

        return {
            // Draft metadata
            workType: 'order', // Track what user is working on
            editMode: this.editingOrderId ? true : false, // Are we editing existing order?
            editingOrderId: this.editingOrderId || null, // Which order ID is being edited
            editingDocId: this.editingDocId || null, // Firestore document ID being edited

            // Order data
            orderId: Utils.get('orderId'),
            isMultiDay: isMultiDay,
            date: isMultiDay ? null : Utils.get('orderDate'),
            startDate: isMultiDay ? Utils.get('startDate') : null,
            endDate: isMultiDay ? Utils.get('endDate') : null,
            dayWiseData: dayWiseData,
            lastEventDate: isMultiDay ? Utils.get('endDate') : Utils.get('orderDate'),
            readyTime: Utils.get('readyTime'),
            clientName: Utils.get('clientName'),
            contact: Utils.get('contact'),
            venue: Utils.get('venue'),
            venueMapLink: mapLink || null, // Store the Google Maps link
            venueLocation: venueLocation, // Extracted coordinates from Maps link
            eventType: Utils.get('eventType'),
            transport: transport === 'Other' ? Utils.get('customTransport') : transport,
            driverName: Utils.get('driverName'),
            transport2: transport2 === 'Other' ? Utils.get('customTransport2') : transport2,
            driverName2: Utils.get('driverName2'),
            operator: Utils.get('operator'),
            helper: selectedHelpers,
            status: Utils.get('orderStatus'),
            notes: Utils.get('orderNotes'),
            items: isMultiDay ? [] : [...this.currentOrderItems],
            createdAt: new Date().toISOString()
        };
    },

    // Extract latitude and longitude from Google Maps link
    extractLocationFromMapsLink(link) {
        if (!link) return null;

        try {
            // Google Maps link formats:
            // https://maps.app.goo.gl/... (short link - can't extract directly)
            // https://www.google.com/maps/place/.../@LAT,LNG,ZOOMz/...
            // https://www.google.com/maps/@LAT,LNG,ZOOMz
            // https://maps.google.com/?q=LAT,LNG
            // https://www.google.com/maps/search/?api=1&query=LAT,LNG
            // https://goo.gl/maps/... (short link)

            // Try to find coordinates in various formats
            let lat = null, lng = null;

            // Format 1: query=LAT,LNG (from API links)
            const queryMatch = link.match(/[?&]query=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (queryMatch) {
                lat = parseFloat(queryMatch[1]);
                lng = parseFloat(queryMatch[2]);
            }

            // Format 2: @LAT,LNG or ?q=LAT,LNG
            if (!lat) {
                const coordMatch = link.match(/[@?]q?=?(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                if (coordMatch) {
                    lat = parseFloat(coordMatch[1]);
                    lng = parseFloat(coordMatch[2]);
                }
            }

            // Format 3: /maps/place/NAME/@LAT,LNG
            if (!lat) {
                const placeMatch = link.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                if (placeMatch) {
                    lat = parseFloat(placeMatch[1]);
                    lng = parseFloat(placeMatch[2]);
                }
            }

            if (lat && lng) {
                return {
                    lat: lat,
                    lng: lng,
                    source: 'google_maps_link'
                };
            }

            // Only warn once per unique link to avoid console spam
            if (!this._warnedLinks) this._warnedLinks = new Set();
            if (!this._warnedLinks.has(link)) {
                console.warn('Could not extract coordinates from Maps link:', link);
                this._warnedLinks.add(link);
            }
            return null;
        } catch (error) {
            console.error('Error extracting location from Maps link:', error);
            return null;
        }
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('‚úÖ Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('‚ö†Ô∏è Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('‚è≥ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('üíæ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('‚úèÔ∏è Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('‚úèÔ∏è Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Calculate total amount from items
        const totalAmount = orderData.isMultiDay
            ? (orderData.dayWiseData || []).reduce((sum, day) => {
                const dayTotal = (day.functions || []).reduce((daySum, func) => {
                    const funcTotal = (func.items || []).reduce((itemSum, item) => {
                        return itemSum + ((item.price || 0) * (item.quantity || 0));
                    }, 0);
                    return daySum + funcTotal;
                }, 0);
                return sum + dayTotal;
            }, 0)
            : (orderData.items || []).reduce((sum, item) => {
                return sum + ((item.price || 0) * (item.quantity || 0));
            }, 0);

        console.log('üí∞ Calculated total amount:', totalAmount);

        // Fetch weather data for the order
        let weatherData = null;
        try {
            // Get weather API key from settings (if stored) or use default
            const weatherApiKey = this.data.settings?.weatherApiKey || '';
            const defaultCity = this.data.settings?.defaultCity || 'Delhi';

            // Fetch weather data
            weatherData = await Utils.getWeather(defaultCity, weatherApiKey);
            console.log('üå§Ô∏è Weather data fetched:', weatherData);
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not fetch weather data:', error);
        }

        // Add weather data to orderData
        orderData.weather = weatherData;

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    totalAmount: totalAmount,  // CRITICAL: Add totalAmount field
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    venueMapLink: orderData.venueMapLink || null,  // CRITICAL: Save venue map link
    venueLocation: orderData.venueLocation || null, // CRITICAL: Save venue coordinates
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    transport2: orderData.transport2 || '',
    driverName2: orderData.driverName2 || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    weather: weatherData,  // Add weather data
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('‚úèÔ∏è Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('üîÑ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('üóëÔ∏è Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('‚úÖ Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} ‚Üí ${finalOrderId} ‚úÖ`);

        // Auto-clear form after upgrade
        Orders.clearForm(this, true);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('‚úÖ Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            totalAmount: totalAmount  // Include totalAmount in local data
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        // ITEM HISTORY TRACKING (if order is now completed)
        if (status === 'completed') {
            if (orderData.items && orderData.items.length > 0) {
                this.recordItemHistory(orderData.items, orderData);
            }

            // For multi-day orders, track items from dayWiseData
            if (orderData.isMultiDay && orderData.dayWiseData) {
                orderData.dayWiseData.forEach(day => {
                    day.functions.forEach(func => {
                        if (func.items && func.items.length > 0) {
                            this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                        }
                    });
                });
            }
        }

        this.showToast('Order updated! ‚úèÔ∏è');

        // Auto-clear form after update
        Orders.clearForm(this, true);
    }

    // Save new custom events to the list
    await this.addCustomEventsToList(orderData);

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;

} else {
            // CREATE new order
            console.log('üÜï Creating new order');

            // Save to Firestore
            console.log('üíæ Saving to Firestore - venue data:', {
                venue: firestoreData.venue,
                venueLocation: firestoreData.venueLocation,
                venueMapLink: firestoreData.venueMapLink
            });

            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
                console.log('‚úÖ Saved with FP ID:', finalOrderId);
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('‚úÖ Saved with auto ID:', docRef.id);
            }

            // Verify what was actually saved
            console.log('‚úÖ venueLocation saved:', !!firestoreData.venueLocation, firestoreData.venueLocation);
            console.log('‚úÖ venueMapLink saved:', !!firestoreData.venueMapLink, firestoreData.venueMapLink);

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
    console.log('‚úÖ Order added to local array with totalAmount:', totalAmount);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION & ITEM HISTORY TRACKING (if order is completed)
                if (status === 'completed') {
                    if (orderData.items && orderData.items.length > 0) {
                        this.deductInventory(orderData.items, orderData.orderId);
                        this.recordItemHistory(orderData.items, orderData);
                    }

                    // For multi-day orders, track items from dayWiseData
                    if (orderData.isMultiDay && orderData.dayWiseData) {
                        orderData.dayWiseData.forEach(day => {
                            day.functions.forEach(func => {
                                if (func.items && func.items.length > 0) {
                                    this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                                }
                            });
                        });
                    }
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! üÜï`);

                // Auto-clear form after save
                Orders.clearForm(this, true);
                this.refreshOrderId();

                // Save new custom events to the list
                await this.addCustomEventsToList(orderData);

                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('‚ùå Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

async addCustomEventsToList(orderData) {
    try {
        const newEvents = new Set();

        // Collect event from single-day order
        if (!orderData.isMultiDay && orderData.eventType && orderData.eventType.trim()) {
            const event = orderData.eventType.trim();
            if (!this.data.eventsList.includes(event)) {
                newEvents.add(event);
            }
        }

        // Collect events from multi-day order functions
        if (orderData.isMultiDay && orderData.dayWiseData) {
            orderData.dayWiseData.forEach(day => {
                if (day.functions) {
                    day.functions.forEach(func => {
                        if (func.functionType && func.functionType.trim()) {
                            const event = func.functionType.trim();
                            if (!this.data.eventsList.includes(event)) {
                                newEvents.add(event);
                            }
                        }
                    });
                }
            });
        }

        // Add new events to the list
        if (newEvents.size > 0) {
            newEvents.forEach(event => {
                this.data.eventsList.push(event);
            });

            // Sort alphabetically
            this.data.eventsList.sort();

            // Save to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                updatedAt: new Date().toISOString()
            });

            // Refresh the datalist
            this.populateEventsDatalist();

            console.log('‚úÖ Added new custom events:', Array.from(newEvents));
        }
    } catch (error) {
        console.error('Error saving custom events:', error);
    }
},

populateEventsDatalist() {
    console.log('üîç populateEventsDatalist called');

    const eventTypeSelect = document.getElementById('eventType');
    if (!eventTypeSelect) {
        console.warn('‚ö†Ô∏è eventType element not found - will populate when orders tab is opened');
        return;
    }

    // Check if eventsList is defined
    if (!this.data.eventsList || !Array.isArray(this.data.eventsList)) {
        console.error('‚ùå eventsList not initialized!', {
            exists: !!this.data.eventsList,
            isArray: Array.isArray(this.data.eventsList),
            length: this.data.eventsList?.length
        });
        // Try to initialize with default list
        this.data.eventsList = [
            'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
            'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
            'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
            'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
            'Ganesh Agman', 'Ganesh Visarjan'
        ];
        console.log('‚úÖ Initialized default events list with', this.data.eventsList.length, 'events');
    }

    console.log(`üìã Populating dropdown with ${this.data.eventsList.length} events`);

    // Get current value to preserve selection
    const currentValue = eventTypeSelect.value;

    // Clear existing options except the first one
    eventTypeSelect.innerHTML = '<option value="">Select Event Type</option>';

    // Add all events as options
    this.data.eventsList.forEach((event, index) => {
        const option = document.createElement('option');
        option.value = event;
        option.textContent = event;
        eventTypeSelect.appendChild(option);
        if (index < 3) {
            console.log(`  ‚úì Added option: ${event}`);
        }
    });

    // Restore previous selection if it exists
    if (currentValue && this.data.eventsList.includes(currentValue)) {
        eventTypeSelect.value = currentValue;
    }

    console.log(`‚úÖ‚úÖ Events dropdown fully populated! Total options: ${eventTypeSelect.options.length}`);
    console.log(`   First 5 options:`, Array.from(eventTypeSelect.options).slice(0, 5).map(o => o.value));
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`üì¶ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} ‚Üí ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`‚ö†Ô∏è LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`üö® CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Item Usage History Tracking (for completed orders only)
async recordItemHistory(items, orderData, specificDate = null, functionType = null) {
    if (!items || items.length === 0) return;

    console.log(`üìú Recording item history for order ${orderData.orderId}`);

    const usedAt = new Date().toISOString();
    const eventDate = specificDate || orderData.date || orderData.startDate;

    for (const item of items) {
        const historyRecord = {
            itemName: item.name,
            quantity: item.quantity,
            orderId: orderData.orderId,
            clientName: orderData.clientName,
            venue: orderData.venue,
            eventDate: eventDate,
            functionType: functionType || orderData.eventType || '',
            usedAt: usedAt,
            remarks: item.remarks || ''
        };

        // Add to local array
        this.data.itemHistory.push(historyRecord);

        // Save to Firestore
        try {
            await db.collection('itemHistory').add(historyRecord);
            console.log(`‚úÖ Saved item history: ${item.name} x${item.quantity} for order ${orderData.orderId}`);
        } catch (error) {
            console.error('‚ùå Error saving item history to Firestore:', error);
        }
    }

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`üìù Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
async getCurrentUser() {
    // If already loaded, return cached user
    if (this.data.currentUser && this.data.currentUser.roleLoaded) {
        return this.data.currentUser;
    }

    // Get Firebase Auth user
    const authUser = auth.currentUser;
    if (!authUser) {
        console.warn('‚ö†Ô∏è No authenticated user found');
        return null;
    }

    try {
        // Fetch user role from Firestore
        const userRoleDoc = await db.collection('user_roles').doc(authUser.uid).get();

        let role = 'staff'; // Default role
        let email = authUser.email;
        let name = authUser.displayName || authUser.email;

        if (userRoleDoc.exists) {
            const roleData = userRoleDoc.data();
            role = roleData.role || 'staff';
            name = roleData.name || name;
            console.log('‚úÖ User role loaded from Firestore:', role, 'for', email);
        } else {
            // If no role exists, user defaults to 'staff' with limited access
            // Only admin/owner can create roles in Firestore via admin panel
            console.warn('‚ö†Ô∏è No role document found for:', email);
            console.warn('‚ö†Ô∏è User defaulted to "staff" role with limited access.');
            console.warn('‚ö†Ô∏è Admin must create role in Firestore: user_roles/' + authUser.uid);
        }

        this.data.currentUser = {
            id: authUser.uid,
            email: email,
            name: name,
            role: role,
            roleLoaded: true,
            permissions: this.getRolePermissions(role)
        };

        return this.data.currentUser;
    } catch (error) {
        console.error('‚ùå Error loading user role:', error);
        console.error('Full error:', error);
        // Fallback to staff role if error occurs
        this.data.currentUser = {
            id: authUser.uid,
            email: authUser.email,
            name: authUser.displayName || authUser.email,
            role: 'staff',
            roleLoaded: true,
            permissions: this.getRolePermissions('staff')
        };
        return this.data.currentUser;
    }
},

// Force refresh user role from Firestore (bypasses cache)
async refreshUserRole() {
    console.log('üîÑ Force refreshing user role from Firestore...');
    this.data.currentUser = null; // Clear cache
    const user = await this.getCurrentUser();
    console.log('‚úÖ User role refreshed:', user?.role);
    return user;
},

// Get permissions for a role
getRolePermissions(role) {
    const permissions = {
        admin: ['all'],
        owner: ['all'],
        staff: ['orders.view', 'orders.create', 'inventory.view', 'customers.view', 'team.view']
    };
    return permissions[role] || permissions.staff;
},

// Check if current user has permission
async hasPermission(permission) {
    const user = await this.getCurrentUser();
    if (!user) return false;

    // Admin and owner have all permissions
    if (user.role === 'admin' || user.role === 'owner') {
        return true;
    }

    // Check specific permission
    return user.permissions.includes(permission) || user.permissions.includes('all');
},

// Check if user can view financials
async canViewFinancials() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

// Check if user is admin or owner
async isAdminOrOwner() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Clear the form first to prevent data mixing between orders
        const wasCleared = !this.hasUnsavedChanges();
        if (!wasCleared) {
            // Clear without confirmation since we're loading a different order
            document.getElementById('orderForm').reset();
            this.currentOrderItems = [];
            this.updateOrderItemsTable();
            window.dayFunctionsData = {};

            // Clear multiday containers
            const multiDayContainer = document.getElementById('multiDayContainer');
            if (multiDayContainer) multiDayContainer.innerHTML = '';
            const functionsContainer = document.getElementById('functionsContainer');
            if (functionsContainer) functionsContainer.innerHTML = '';
        }

        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('üîç Loading order to form:', order);
        console.log('üîç Order status:', order.status);
        console.log('üîç Is Multi-Day:', order.isMultiDay);

        // Show merged order indicator if this is a merged order
        if (order.mergedFrom && order.mergedFrom.length > 0) {
            const mergedOrderIds = order.mergedFrom.map(m => m.orderId).join(', ');
            this.showToast(`üîó MERGED ORDER: This order was created by merging ${order.mergedFrom.length} orders (${mergedOrderIds})`, 'info', 8000);
            console.log('üîó This is a MERGED order from:', order.mergedFrom);
        }

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('üìÖ Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const venueInput = document.getElementById(`${functionId}Venue`);
                                        const transportSelect = document.getElementById(`${functionId}Transport`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (venueInput) venueInput.value = func.venue || '';

                                        // Handle multi-select fields (transport, driver, helper)
                                        if (transportSelect && func.transport) {
                                            const transports = func.transport.split(',').map(t => t.trim());
                                            Array.from(transportSelect.options).forEach(option => {
                                                option.selected = transports.includes(option.value);
                                            });
                                        }

                                        if (driverSelect && func.driver) {
                                            const drivers = func.driver.split(',').map(d => d.trim());
                                            Array.from(driverSelect.options).forEach(option => {
                                                option.selected = drivers.includes(option.value);
                                            });
                                        }

                                        if (operatorSelect) operatorSelect.value = func.operator || '';

                                        if (helperSelect && func.helper) {
                                            helperSelect.value = func.helper;
                                        }

                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'venue', func.venue || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'transport', func.transport || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            // IMPORTANT: Normalize item fields for consistency
                                            window.dayFunctionsData[dayIndex][funcIndex].items = func.items.map(item => ({
                                                name: item.name || '',
                                                quantity: item.quantity || item.qty || 0,
                                                remarks: item.remarks || item.desc || '',
                                                price: item.price || 0
                                            }));
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('‚úÖ Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order
            // IMPORTANT: Set event type to single day first to ensure proper form display
            Utils.set('eventTypeSelect', 'single');

            // Show single day fields, hide multiday fields
            const singleDayFields = document.getElementById('singleDayFields');
            const multiDayFields = document.getElementById('multiDayFields');
            if (singleDayFields) singleDayFields.style.display = 'grid';
            if (multiDayFields) multiDayFields.style.display = 'none';

            // Trigger event type change to update required fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                transport2: order.transport2 && ['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : (order.transport2 ? 'Other' : ''),
                customTransport2: order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : '',
                driverName2: order.driverName2 || '',
                operator: order.operator,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Load helper names to text input
            if (order.helper) {
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.value = order.helper;
                }
            }

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            if (order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2)) {
                document.getElementById('customTransport2Group').classList.remove('hidden');
            }

            // IMPORTANT: Normalize item fields to ensure consistency
            // Items from Firestore might use 'qty' but UI expects 'quantity'
            this.currentOrderItems = order.items ? order.items.map(item => ({
                name: item.name || '',
                quantity: item.quantity || item.qty || 0, // Support both field names
                remarks: item.remarks || item.desc || '', // Support both field names
                price: item.price || 0
            })) : [];

            console.log(`üìã Loaded ${this.currentOrderItems.length} items for order`, {
                orderId: order.orderId,
                sampleItem: this.currentOrderItems[0],
                isMerged: !!order.mergedFrom
            });

            this.updateOrderItemsTable();

            // Show original orders cards if this is a merged order
            this.renderOriginalOrdersCards(order);
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            // Render editable cards for original orders in a merged order
            renderOriginalOrdersCards(order) {
                const container = document.getElementById('originalOrdersContainer');

                // If container doesn't exist yet, create it
                if (!container) {
                    const orderForm = document.getElementById('orderForm');
                    if (orderForm) {
                        const newContainer = document.createElement('div');
                        newContainer.id = 'originalOrdersContainer';
                        newContainer.style.marginTop = '2rem';
                        orderForm.parentNode.insertBefore(newContainer, orderForm.nextSibling);
                    }
                }

                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (!originalOrdersContainer) return;

                // Check if this is a merged order
                if (!order.mergedFrom || order.mergedFrom.length === 0) {
                    originalOrdersContainer.innerHTML = '';
                    return;
                }

                console.log('üîó Rendering original orders cards for merged order:', order.orderId);

                // Generate HTML for original orders cards
                const cardsHTML = `
                    <div class="card" style="margin-top: 2rem; background: #f9f9f9; border: 2px solid #667eea;">
                        <div class="card-header" style="background: #667eea; color: white; padding: 1rem;">
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                                üîó ORIGINAL ORDERS (${order.mergedFrom.length})
                            </h3>
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; opacity: 0.9;">
                                You can edit each original order's details below and save changes individually
                            </p>
                        </div>
                        <div style="padding: 1.5rem;">
                            ${order.mergedFrom.map((originalOrder, index) => this.renderOriginalOrderCard(originalOrder, index)).join('')}
                        </div>
                    </div>
                `;

                originalOrdersContainer.innerHTML = cardsHTML;
            },

            renderOriginalOrderCard(originalOrderData, index) {
                const order = originalOrderData.orderData;
                const cardId = `originalOrder_${index}`;

                // Get items list
                const itemsList = order.items && order.items.length > 0
                    ? order.items.map(item => `${item.name} x${item.quantity || item.qty || 0}`).join(', ')
                    : 'No items';

                return `
                    <div class="card" style="margin-bottom: 1.5rem; background: white; border: 1px solid #ddd;" id="${cardId}">
                        <div style="background: #f5f5f5; padding: 1rem; border-bottom: 2px solid #ddd;">
                            <h4 style="margin: 0; color: #667eea; display: flex; justify-content: space-between; align-items: center;">
                                üìã Order: ${order.orderId}
                                <button type="button" class="btn btn-small"
                                        style="background: #667eea; color: white;"
                                        onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                    ‚úèÔ∏è Edit
                                </button>
                            </h4>
                        </div>

                        <!-- View Mode -->
                        <div id="${cardId}_view" style="padding: 1.5rem;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>üìÖ Date:</strong> ${order.date || 'N/A'}</div>
                                <div><strong>‚è∞ Ready Time:</strong> ${order.readyTime || 'N/A'}</div>
                                <div><strong>üë§ Client:</strong> ${order.clientName || 'N/A'}</div>
                                <div><strong>üìû Contact:</strong> ${order.contact || 'N/A'}</div>
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <strong>üìç Venue:</strong> ${order.venue || 'N/A'}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>üöó Transport:</strong> ${order.transport || 'N/A'}</div>
                                <div><strong>üöò Driver:</strong> ${order.driverName || 'N/A'}</div>
                                <div><strong>üé¨ Operator:</strong> ${order.operator || 'N/A'}</div>
                                <div><strong>üë∑ Helper:</strong> ${order.helper || 'N/A'}</div>
                            </div>
                            <div style="padding: 1rem; background: #f9f9f9; border-radius: 4px;">
                                <strong>üì¶ Items:</strong> ${itemsList}
                            </div>
                            ${order.notes ? `<div style="margin-top: 1rem;"><strong>üìù Notes:</strong><br>${order.notes}</div>` : ''}
                        </div>

                        <!-- Edit Mode (Hidden by default) -->
                        <div id="${cardId}_edit" style="display: none; padding: 1.5rem; background: #fefefe;">
                            <form onsubmit="OMS.saveOriginalOrder(event, ${index}, '${order.docId}')">
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">üìÖ Date</label>
                                        <input type="date" class="form-input" id="${cardId}_date" value="${order.date || ''}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">‚è∞ Ready Time</label>
                                        <input type="text" class="form-input" id="${cardId}_readyTime" value="${order.readyTime || ''}" placeholder="e.g., 10:00 AM">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">üìç Venue</label>
                                    <input type="text" class="form-input" id="${cardId}_venue" value="${order.venue || ''}" required>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">üöó Transport</label>
                                        <input type="text" class="form-input" id="${cardId}_transport" value="${order.transport || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">üöò Driver</label>
                                        <input type="text" class="form-input" id="${cardId}_driverName" value="${order.driverName || ''}">
                                    </div>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">üé¨ Operator</label>
                                        <input type="text" class="form-input" id="${cardId}_operator" value="${order.operator || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">üë∑ Helper</label>
                                        <input type="text" class="form-input" id="${cardId}_helper" value="${order.helper || ''}">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">üìù Notes</label>
                                    <textarea class="form-textarea" id="${cardId}_notes" rows="3">${order.notes || ''}</textarea>
                                </div>

                                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                                    <button type="button" class="btn btn-secondary" onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                        Cancel
                                    </button>
                                    <button type="submit" class="btn btn-success">
                                        üíæ Save Changes
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
            },

            toggleOriginalOrderEdit(cardId) {
                const viewMode = document.getElementById(`${cardId}_view`);
                const editMode = document.getElementById(`${cardId}_edit`);

                if (viewMode && editMode) {
                    const isEditing = editMode.style.display !== 'none';
                    viewMode.style.display = isEditing ? 'block' : 'none';
                    editMode.style.display = isEditing ? 'none' : 'block';
                }
            },

            async saveOriginalOrder(event, index, docId) {
                event.preventDefault();
                const cardId = `originalOrder_${index}`;

                try {
                    // Collect form data
                    const updatedData = {
                        date: Utils.get(`${cardId}_date`),
                        readyTime: Utils.get(`${cardId}_readyTime`),
                        venue: Utils.get(`${cardId}_venue`),
                        transport: Utils.get(`${cardId}_transport`),
                        driverName: Utils.get(`${cardId}_driverName`),
                        operator: Utils.get(`${cardId}_operator`),
                        helper: Utils.get(`${cardId}_helper`),
                        notes: Utils.get(`${cardId}_notes`)
                    };

                    console.log('üíæ Saving original order changes:', docId, updatedData);

                    // Get the full order from Firestore
                    const orderDoc = await db.collection('orders').doc(docId).get();
                    if (!orderDoc.exists) {
                        throw new Error('Order not found in Firestore');
                    }

                    const fullOrder = orderDoc.data();

                    // Update with new data
                    const updatedOrder = {
                        ...fullOrder,
                        ...updatedData,
                        updatedAt: new Date().toISOString()
                    };

                    // Save to Firestore
                    await db.collection('orders').doc(docId).update(updatedOrder);

                    this.showToast(`‚úÖ Order updated successfully!`, 'success');

                    // Toggle back to view mode
                    this.toggleOriginalOrderEdit(cardId);

                    // Reload orders to refresh display
                    await this.loadOrdersFromFirestore();

                    // Reload the current merged order
                    const currentOrder = this.data.orders.find(o => o.docId === this.editingDocId);
                    if (currentOrder) {
                        Orders.loadOrderToForm(this, currentOrder);
                    }

                } catch (error) {
                    console.error('‚ùå Error saving original order:', error);
                    this.showToast(`Error: ${error.message}`, 'error');
                }
            },

            clearForm(skipConfirmation = false) {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (!skipConfirmation && this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();

                // Clear original orders cards
                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (originalOrdersContainer) {
                    originalOrdersContainer.innerHTML = '';
                }
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');
                document.getElementById('customTransport2Group').classList.add('hidden');

                // Clear venue location data from autocomplete
                window.selectedPlaceData = null;

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'grid';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Trigger event type change to update required fields
                const eventTypeSelect = document.getElementById('eventTypeSelect');
                if (eventTypeSelect) {
                    const event = new Event('change');
                    eventTypeSelect.dispatchEvent(event);
                }

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                // Clear functions container for multiday events
                const functionsContainer = document.getElementById('functionsContainer');
                if (functionsContainer) {
                    functionsContainer.innerHTML = '';
                }

                // Hide day-wise functions section
                const dayWiseFunctions = document.getElementById('dayWiseFunctions');
                if (dayWiseFunctions) {
                    dayWiseFunctions.style.display = 'none';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`‚úÖ Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                Orders.loadOrderToForm(this, lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                // Preview doesn't require validation - just show what's been filled
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong>Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong>Driver 2:</strong> ${order.driverName2}<br>` : ''}
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }

                // ============ START ENHANCED FILTERING WITH LOGGING & VALIDATION ============
                const startTime = performance.now();

                // Normalize the target date using fuzzy matcher
                const normalizedDate = fuzzyDateMatcher.normalize(date);
                filterLogger.log('filter_started', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                // IMPROVED FILTER: Include ALL order types for selected date with fuzzy matching
                const matchedOrders = [];
                const filterDetails = {
                    singleDayMatches: 0,
                    multiDayRangeMatches: 0,
                    dayWiseDataMatches: 0,
                    fuzzyMatches: 0,
                    skipped: 0
                };

                let orders = this.data.orders.filter(o => {
                    // Case 1: Single-day order with matching date (use fuzzy matcher)
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            filterDetails.singleDayMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    // Case 2: Multi-day order WITH dayWiseData - check specific day functions (PRIORITY)
                    if (o.isMultiDay && o.dayWiseData && Array.isArray(o.dayWiseData) && o.dayWiseData.length > 0) {
                        const hasMatch = o.dayWiseData.some(day => fuzzyDateMatcher.matches(day.date, date));
                        if (hasMatch) {
                            filterDetails.dayWiseDataMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                        // If order has dayWiseData but no match, skip it (don't fall through to range check)
                        filterDetails.skipped++;
                        return false;
                    }

                    // Case 3: Multi-day order WITHOUT dayWiseData - fallback to range check
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            filterDetails.multiDayRangeMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    filterDetails.skipped++;
                    return false;
                });

                // Calculate performance metrics
                const endTime = performance.now();
                const filterTime = (endTime - startTime).toFixed(2);

                // Log detailed filter results
                filterLogger.log('filter_completed', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    matchedCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    filterTimeMs: filterTime,
                    breakdown: filterDetails,
                    matchedOrderIds: orders.map(o => o.orderId || o.docId)
                });

                // Record pattern for learning
                patternLearner.recordFilterResult(
                    normalizedDate,
                    orders.length,
                    this.data.orders.length,
                    'downloadSameDayOrders'
                );

                // APPLY LEARNING RULES FROM PREVIOUS USER FEEDBACK (if enabled)
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false'; // Default: enabled for backward compatibility
                let finalOrders = orders;
                let hasCorrections = false;

                if (mlEnabled) {
                    const learningResult = filterRatingSystem.applyLearningRules(
                        normalizedDate,
                        orders,
                        this.data.orders
                    );

                    finalOrders = learningResult.orders;
                    hasCorrections = learningResult.corrections.length > 0;

                    if (hasCorrections) {
                        console.log(`üß† Smart Learning Applied: ${learningResult.corrections.length} corrections made based on your previous feedback`);
                        learningResult.corrections.forEach(correction => {
                            if (correction.type === 'added') {
                                console.log(`  ‚úÖ Added: ${correction.order.orderId} - ${correction.reason}`);
                            } else if (correction.type === 'removed') {
                                console.log(`  ‚ùå Removed: ${correction.order.orderId} - ${correction.reason}`);
                            }
                        });
                        this.showToast(`üß† Smart filter applied ${learningResult.corrections.length} learned corrections`, 'info');
                    }
                } else {
                    console.log('üîá ML Corrections DISABLED - Using original filter results only');
                    console.log('üí° To enable: AdminUtils.enableML() or localStorage.setItem("oms_ml_enabled", "true")');
                }

                // STORE FILTER CONTEXT FOR RATING
                filterRatingSystem.setFilterContext({
                    date,
                    normalizedDate,
                    matchedOrders: finalOrders,
                    totalOrders: this.data.orders.length,
                    filterDetails,
                    allOrders: this.data.orders
                });

                // Validate results and show alerts
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: finalOrders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders: finalOrders,
                    allOrders: this.data.orders
                });
                orderValidator.showAlerts(validationResult, date);

                // Show enhanced console summary
                console.group(`üìä Filter Summary for ${date}`);
                console.log(`‚úÖ Matched: ${finalOrders.length} orders in ${filterTime}ms`);
                if (hasCorrections) {
                    console.log(`üß† Corrections: ${learningResult.corrections.length} (from your previous ratings)`);
                }
                console.log(`üìã Breakdown:`, filterDetails);
                console.log(`üéØ Match rate: ${((finalOrders.length / this.data.orders.length) * 100).toFixed(1)}%`);

                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`üß† Expected based on learning: ~${expectedCount} orders`);
                }

                if (validationResult.length > 0) {
                    console.log(`‚ö†Ô∏è Validation alerts: ${validationResult.length}`);
                }

                // Show rating option in console
                console.log(`‚≠ê To rate this filter result, use: AdminUtils.rateLastFilter()`);
                console.groupEnd();
                // ============ END ENHANCED FILTERING ============

                if (finalOrders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    // Still show rating UI for zero results (user can report this as wrong)
                    setTimeout(() => {
                        if (confirm('No orders found. Would you like to rate this filter result?')) {
                            filterRatingSystem.showRatingUI(this);
                        }
                    }, 500);
                    return;
                }

                // Replace orders with finalOrders for rest of the function
                orders = finalOrders;

                // FILTER MULTIDAY ORDERS TO ONLY INCLUDE SELECTED DATE'S DATA
                const filteredOrders = orders.map(order => {
                    // For single-day orders, return as is
                    if (!order.isMultiDay) {
                        return order;
                    }

                    // For multiday orders, create a filtered copy with only the selected date's data
                    const filteredOrder = { ...order };

                    // Filter dayWiseData to only include the selected date (use fuzzy matcher for better matching)
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        filteredOrder.dayWiseData = order.dayWiseData.filter(day => fuzzyDateMatcher.matches(day.date, date));
                        console.log(`üîç Multiday order ${order.orderId}: Filtered ${filteredOrder.dayWiseData.length}/${order.dayWiseData.length} days for date ${date}`);

                        // Log function and item counts for debugging
                        filteredOrder.dayWiseData.forEach((day, idx) => {
                            const funcCount = day.functions ? day.functions.length : 0;
                            const itemCount = day.functions ? day.functions.reduce((sum, f) => sum + (f.items?.length || 0), 0) : 0;
                            console.log(`  üìã Day ${day.dayNumber}: ${funcCount} functions, ${itemCount} total items`);
                        });
                    }

                    // Update the order to show only selected date info
                    filteredOrder.date = date;
                    filteredOrder.isMultiDay = false; // Treat as single day for display purposes

                    return filteredOrder;
                });

                console.log(`üìÖ Found ${filteredOrders.length} orders for ${date}:`, filteredOrders.map(o => o.orderId || o.clientName));
                console.log(`üí° To rate this filter result, use: AdminUtils.rateLastFilter() in console`);

                Orders.generateMultiOrderImage(this, filteredOrders, date);
            },

            downloadOrderImage(orderId) {
                // Wrapper function - delegates to Print module if loaded
                if (window.Print && typeof window.Print.downloadOrderImage === 'function') {
                    window.Print.downloadOrderImage(this, orderId);
                } else {
                    console.log('Print module not loaded yet');
                }
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? 'Generating image (mobile mode)...' : 'Generating image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Mobile optimization: Validate canvas dimensions before proceeding
                    const baseScale = this.data.settings.imageQuality || 2;
                    const optimizedScale = Utils.getOptimalCanvasScale(baseScale);

                    const canvasWidth = Math.round(paperDimensions.width * optimizedScale);
                    const canvasHeight = Math.round(paperDimensions.height * optimizedScale);

                    const validation = Utils.validateCanvasDimensions(canvasWidth, canvasHeight);
                    if (!validation.valid) {
                        this.hideLoading(loading);
                        this.showToast(`‚ö†Ô∏è ${validation.reason}. Please reduce image quality in settings.`, 'error');
                        console.error('Canvas validation failed:', validation.reason);
                        return;
                    }

                    if (isMobile && optimizedScale < baseScale) {
                        console.log(`üì± Mobile device detected (${deviceType}): Quality auto-reduced from ${baseScale} to ${optimizedScale} for better compatibility`);
                    }

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    template.innerHTML = Orders.buildOrderHTML(this, order, fontSize, colors, false, bgColor, textColor);
                    template.style.display = 'block';

                    // Increased wait time for mobile devices (they need more time for DOM to settle)
                    await new Promise(r => setTimeout(r, isMobile ? 500 : 300));

                    // Create canvas with optimized scale
                    let canvas;
                    try {
                        canvas = await html2canvas(template, {
                            scale: optimizedScale,
                            backgroundColor: bgColor,
                            width: paperDimensions.width,
                            logging: false,
                            useCORS: true,
                            allowTaint: false,
                            // Mobile-specific optimizations
                            removeContainer: true,
                            imageTimeout: isMobile ? 30000 : 15000
                        });
                    } catch (canvasError) {
                        console.error('html2canvas failed:', canvasError);

                        // Retry with even lower quality for mobile
                        if (isMobile && optimizedScale > 1) {
                            console.log('‚ö†Ô∏è Retrying with scale 1 for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Retrying with lower quality...');

                            canvas = await html2canvas(template, {
                                scale: 1,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: 30000
                            });
                        } else {
                            throw canvasError;
                        }
                    }

                    template.style.display = 'none';

                    // Use Promise-based blob creation with better error handling
                    this.updateLoadingMessage(loading, 'Creating download file...');

                    let blob;
                    try {
                        blob = await Utils.canvasToBlobPromise(canvas, 'image/png', 0.95);
                    } catch (blobError) {
                        console.error('PNG blob creation failed:', blobError);

                        // Fallback to JPEG with lower quality for mobile
                        if (isMobile) {
                            console.log('‚ö†Ô∏è Retrying with JPEG format for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Trying alternative format...');
                            blob = await Utils.canvasToBlobPromise(canvas, 'image/jpeg', 0.85);
                        } else {
                            throw blobError;
                        }
                    }

                    // Check blob size
                    const blobSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    console.log(`üìä Image size: ${blobSizeMB} MB`);

                    if (blob.size > 50 * 1024 * 1024 && isMobile) {
                        this.hideLoading(loading);
                        this.showToast('‚ö†Ô∏è Image too large for mobile device. Please reduce quality in settings.', 'error');
                        return;
                    }

                    // Create download
                    try {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        const fileExt = blob.type.includes('jpeg') ? 'jpg' : 'png';
                        link.download = `Order_${order.orderId}.${fileExt}`;

                        // Mobile-specific download handling
                        if (isMobile) {
                            // For mobile, add a small delay and use different approach
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        } else {
                            link.click();
                        }

                        // Delay cleanup for mobile browsers
                        setTimeout(() => URL.revokeObjectURL(url), isMobile ? 1000 : 100);

                        this.hideLoading(loading);
                        this.showToast(`‚úÖ Image downloaded! (${blobSizeMB} MB)`);
                    } catch (downloadError) {
                        console.error('Download failed:', downloadError);
                        this.hideLoading(loading);
                        this.showToast('‚ùå Download failed: ' + downloadError.message, 'error');
                    }
                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Image generation error:', error);

                    // Mobile-friendly error message
                    if (isMobile) {
                        this.showToast(`‚ùå Failed on ${deviceType}: ${error.message}. Try reducing image quality in settings.`, 'error');
                    } else {
                        this.showToast('‚ùå Error: ' + error.message, 'error');
                    }
                }
            },

            async generateMultiOrderImage(orders, date) {
                console.log(`\nüéØ ========== GENERATE MULTI ORDER IMAGE CALLED ==========`);
                console.log(`üìÖ Date: ${date}`);
                console.log(`üì¶ Number of orders: ${orders.length}`);

                // CRITICAL: Sort orders by original creation timestamp (earliest first)
                // This ensures PDF shows orders in the order they were first created, not edited
                orders = [...orders].sort((a, b) => {
                    const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
                    const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
                    return timeA - timeB; // Ascending order (earliest first)
                });

                console.log(`üïê Orders sorted by creation time (earliest first)`);
                console.log(`üìã Orders:`, orders.map(o => ({
                    orderId: o.orderId,
                    clientName: o.clientName,
                    createdAt: o.createdAt,
                    isMultiDay: o.isMultiDay,
                    hasDayWiseData: !!(o.dayWiseData && o.dayWiseData.length > 0),
                    dayWiseDataCount: o.dayWiseData ? o.dayWiseData.length : 0,
                    hasItems: !!(o.items && o.items.length > 0),
                    itemsCount: o.items ? o.items.length : 0
                })));
                console.log(`========================================\n`);

                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? `Generating PDF (mobile mode, ${orders.length} orders)...` : 'Generating multi-page PDF...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    // Smart quality adjustment for multi-order images to prevent memory issues
                    let baseQualityScale = this.data.settings.imageQuality || 2;

                    // Apply mobile optimizations first
                    let qualityScale = Utils.getOptimalCanvasScale(baseQualityScale);

                    // Further reduce quality based on number of orders
                    if (orders.length > 5) {
                        qualityScale = Math.min(qualityScale, 2); // Limit to scale 2 for more than 5 orders
                        console.log('‚ö†Ô∏è Quality reduced to scale 2 due to multiple orders to prevent memory issues');
                    }
                    if (orders.length > 10) {
                        qualityScale = Math.min(qualityScale, 1.5); // Further reduce for very large sets
                        console.log('‚ö†Ô∏è Quality further reduced to scale 1.5 for large order set');
                    }

                    // Extra reduction for mobile with many orders
                    if (isMobile) {
                        if (orders.length > 3) {
                            qualityScale = Math.min(qualityScale, 1);
                            console.log(`üì± Mobile with ${orders.length} orders: Quality capped at scale 1`);
                        }
                        if (orders.length > 10) {
                            this.hideLoading(loading);
                            this.showToast(`‚ö†Ô∏è ${orders.length} orders may be too many for mobile device. Consider downloading fewer orders at once.`, 'error');
                            return;
                        }
                    }

                    if (isMobile && qualityScale < baseQualityScale) {
                        console.log(`üì± ${deviceType}: Quality auto-adjusted from ${baseQualityScale} to ${qualityScale}`);
                    }

                    // Use fontSize from settings, but slightly smaller for compact multi-order view
                    const compactFontSize = Math.max(16, fontSize - 6);

                    console.log(`üöÄ Starting PDF generation for ${orders.length} orders`);

                    // Calculate grand totals for all orders (needed early for page height calculations)
                    let grandTotalDryIce = 0;
                    let grandTotalFlowers = 0;
                    let grandTotalElectricity = 0;
                    let grandTotalDryMachines = 0;
                    let grandTotalFlowerMachines = 0;

                    orders.forEach(order => {
                        const requirements = Orders.calculateOrderRequirements(order);
                        console.log(`  ‚Üí Order ${order.orderId} requirements:`, requirements);
                        grandTotalDryIce += requirements.dryIceNeeded;
                        grandTotalFlowers += requirements.flowersNeeded;
                        grandTotalElectricity += requirements.totalElectricityKV;
                        grandTotalDryMachines += requirements.dryMachines;
                        grandTotalFlowerMachines += requirements.flowerShowerMachines;
                    });

                    console.log(`\nüìä Grand Totals Calculated: DryIce=${grandTotalDryIce}kg, Flowers=${grandTotalFlowers}kg, Electricity=${grandTotalElectricity}KV, DryMachines=${grandTotalDryMachines}, FlowerMachines=${grandTotalFlowerMachines}\n`);

                    // NEW ALGORITHM: Dynamic page building with actual measurements
                    // This ensures ALL orders are included and pages are packed optimally

                    // CRITICAL: Use 'static' positioning for accurate measurements
                    // Using 'absolute' causes grid/flexbox layouts to collapse and gives wrong scrollHeight
                    template.style.height = 'auto';
                    template.style.minHeight = '0';
                    template.style.maxHeight = 'none';
                    template.style.overflow = 'visible';
                    template.style.display = 'block';
                    template.style.visibility = 'hidden'; // Hidden but still in document flow
                    template.style.position = 'static'; // Keep in document flow for accurate measurement
                    template.style.opacity = '0'; // Extra insurance it's not visible

                    const headerHeight = 75; // Header height for date (reduced for better space utilization)
                    const separatorHeight = 15; // Space between orders (reduced for better space utilization)
                    const bottomMargin = 10; // Bottom margin for page (optimized for space utilization)
                    const safetyMargin = 15; // Safety buffer for rendering differences (optimized for maximum space usage)

                    // Measure the actual grand total summary height instead of estimating
                    const hasGrandTotalSummary = (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0);
                    let grandTotalSummaryHeight = 0;

                    if (hasGrandTotalSummary) {
                        // Render the actual summary to measure its real height
                        const summaryHtml = `
                            <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">üìä Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                    ${grandTotalDryIce > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">‚ùÑÔ∏è</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalFlowers > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">üå∏</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalElectricity > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">‚ö°</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;

                        // Temporarily render to measure (use static positioning for accurate height)
                        template.innerHTML = summaryHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Increased wait for layout calculation
                        grandTotalSummaryHeight = template.scrollHeight;
                        console.log(`üìä Measured grand total summary height: ${grandTotalSummaryHeight}px`);
                        template.style.display = 'none';
                        template.style.opacity = '1';
                    }

                    const maxContentHeightFirstPage = paperDimensions.height - headerHeight - bottomMargin - safetyMargin - grandTotalSummaryHeight;
                    const maxContentHeightOtherPages = paperDimensions.height - headerHeight - bottomMargin - safetyMargin;

                    console.log(`üìê Page constraints: Paper=${paperDimensions.height}px, Header=${headerHeight}px, Margins=${bottomMargin + safetyMargin}px, GrandTotal=${grandTotalSummaryHeight}px`);
                    console.log(`üìä Max content: First page=${maxContentHeightFirstPage}px, Other pages=${maxContentHeightOtherPages}px`);

                    const pages = [];
                    let processedOrders = new Set(); // Track which orders we've added

                    // Helper function to check if a single order fits on a page
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const checkSingleOrderFits = async (order, maxHeight) => {
                        const testHtml = Orders.buildOrderHTML(this, order, compactFontSize, colors, true, bgColor, textColor);
                        template.innerHTML = testHtml;
                        // Ensure template is visible for measurement (but hidden from user)
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Wait for layout
                        const height = template.scrollHeight;
                        return { fits: height <= maxHeight, height: height };
                    };

                    // Helper function to measure multiple orders together
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const measureOrdersHeight = async (ordersList) => {
                        let testHtml = '';
                        ordersList.forEach((o, idx) => {
                            testHtml += Orders.buildOrderHTML(this, o, compactFontSize, colors, true, bgColor, textColor);
                            if (idx < ordersList.length - 1) {
                                testHtml += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });
                        template.innerHTML = testHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100));
                        return template.scrollHeight;
                    };

                    // STEP 1: Measure all orders individually first
                    console.log('üìè Measuring all orders for optimal packing...');
                    const orderHeights = [];
                    for (let i = 0; i < orders.length; i++) {
                        const check = await checkSingleOrderFits(orders[i], maxContentHeightOtherPages);
                        orderHeights.push({
                            order: orders[i],
                            height: check.height,
                            originalIndex: i
                        });
                    }

                    // STEP 2: Sort orders by height (descending) - First Fit Decreasing algorithm
                    orderHeights.sort((a, b) => b.height - a.height);
                    console.log('üìä Order heights (sorted descending):', orderHeights.map(oh => `${oh.order.clientName || oh.order.orderId}: ${oh.height}px`).join(', '));

                    // STEP 3: Use First Fit Decreasing bin-packing algorithm
                    for (let i = 0; i < orderHeights.length; i++) {
                        const { order, height, originalIndex } = orderHeights[i];

                        // Check if this single order is too large for any page by itself
                        const fitsOnFirstPage = height <= maxContentHeightFirstPage;
                        const fitsOnOtherPage = height <= maxContentHeightOtherPages;

                        // If order doesn't fit on any page by itself, handle special case
                        if (!fitsOnOtherPage) {
                            // Check if this is a multifunction/multiday order that can be split
                            if (order.dayWiseData && order.dayWiseData.length > 0) {
                                // Try to split by function groups
                                let remainingFunctions = [];
                                order.dayWiseData.forEach(day => {
                                    if (day.functions && day.functions.length > 0) {
                                        day.functions.forEach((func, funcIdx) => {
                                            remainingFunctions.push({
                                                dayNumber: day.dayNumber,
                                                date: day.date,
                                                function: func,
                                                functionIndex: funcIdx
                                            });
                                        });
                                    }
                                });

                                // Split functions across multiple pages
                                while (remainingFunctions.length > 0) {
                                    let currentFunctionSet = [];

                                    for (let f = 0; f < remainingFunctions.length; f++) {
                                        const testFunctions = [...currentFunctionSet, remainingFunctions[f]];

                                        // Create a partial order with only these functions
                                        const partialOrder = {
                                            ...order,
                                            dayWiseData: testFunctions.map(tf => ({
                                                dayNumber: tf.dayNumber,
                                                date: tf.date,
                                                functions: [tf.function]
                                            }))
                                        };

                                        // Test if it fits
                                        const partialCheck = await checkSingleOrderFits(partialOrder, maxContentHeightOtherPages);

                                        if (partialCheck.fits) {
                                            currentFunctionSet.push(remainingFunctions[f]);
                                        } else {
                                            // Can't add more functions, save current set
                                            break;
                                        }
                                    }

                                    // If we couldn't fit even one function, we need to add it anyway
                                    if (currentFunctionSet.length === 0 && remainingFunctions.length > 0) {
                                        currentFunctionSet.push(remainingFunctions[0]);
                                    }

                                    // Create page with current function set
                                    const pageOrder = {
                                        ...order,
                                        orderId: `${order.orderId} (Part ${pages.length + 1})`,
                                        dayWiseData: currentFunctionSet.map(tf => ({
                                            dayNumber: tf.dayNumber,
                                            date: tf.date,
                                            functions: [tf.function]
                                        }))
                                    };

                                    pages.push([pageOrder]);

                                    // Remove processed functions
                                    remainingFunctions = remainingFunctions.slice(currentFunctionSet.length);
                                }

                                processedOrders.add(originalIndex);
                                continue;
                            } else {
                                // Not a multifunction order, add it anyway and let it scale or overflow
                                pages.push([order]);
                                processedOrders.add(originalIndex);
                                continue;
                            }
                        }

                        // FIRST FIT: Try to fit this order in existing pages
                        let placed = false;
                        for (let pageIdx = 0; pageIdx < pages.length; pageIdx++) {
                            const pageOrders = pages[pageIdx];
                            const isFirstPage = pageIdx === 0;
                            const maxHeight = isFirstPage ? maxContentHeightFirstPage : maxContentHeightOtherPages;

                            // Measure current page content
                            const currentHeight = pageOrders.length > 0 ? await measureOrdersHeight(pageOrders) : 0;
                            const availableSpace = maxHeight - currentHeight;

                            // Try adding this order to this page
                            const testOrders = [...pageOrders, order];
                            const testHeight = await measureOrdersHeight(testOrders);
                            const willFit = testHeight <= maxHeight;

                            console.log(`üìè Page ${pageIdx + 1} (${isFirstPage ? 'FIRST' : 'other'}): has ${pageOrders.length} order(s), used ${currentHeight}px, available ${availableSpace}px/${maxHeight}px`);
                            console.log(`   ‚Üí Testing "${order.clientName || order.orderId}" (${height}px): total would be ${testHeight}px, fits = ${willFit}`);

                            if (willFit) {
                                // Fits! Add to this page
                                pages[pageIdx].push(order);
                                processedOrders.add(originalIndex);
                                placed = true;
                                console.log(`‚úÖ Placed order "${order.clientName || order.orderId}" on page ${pageIdx + 1}`);
                                break;
                            }
                        }

                        // If didn't fit in any existing page, create a new page
                        if (!placed) {
                            pages.push([order]);
                            processedOrders.add(originalIndex);
                            console.log(`üìÑ Created new page ${pages.length} for order "${order.clientName || order.orderId}"`);
                        }
                    }

                    // Reset template to normal state
                    template.style.display = 'none';
                    template.style.visibility = 'visible';
                    template.style.position = 'static';
                    template.style.opacity = '1';

                    // VERIFICATION: Check all orders were processed
                    // Note: totalOrdersInPages may be > orders.length due to split multifunction orders
                    if (processedOrders.size !== orders.length) {
                        throw new Error(`Missing orders in PDF! Expected ${orders.length}, but only ${processedOrders.size} were processed.`);
                    }

                    const totalPages = pages.length;
                    console.log(`‚úÖ Generated ${totalPages} pages for ${orders.length} orders`);

                    // STEP 3: Generate multi-page PDF
                    this.updateLoadingMessage(loading, 'Creating PDF document...');

                    // Initialize jsPDF with exact dimensions matching our measurements (300 DPI)
                    const { jsPDF } = window.jspdf;

                    // CRITICAL FIX: Use the same paperDimensions we used for measurement
                    // This ensures content measured to fit will actually fit in the PDF
                    const pdf = new jsPDF({
                        orientation: 'p', // We handle orientation in paperDimensions
                        unit: 'px',
                        format: [paperDimensions.width, paperDimensions.height], // Use exact dimensions at 300 DPI
                        compress: true
                    });

                    // Get PDF page dimensions (should match paperDimensions)
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    console.log(`üìè PDF dimensions: ${pdfWidth} x ${pdfHeight} px (should match measurement dimensions)`);
                    console.log(`üìê Paper dimensions used for measurement: ${paperDimensions.width} x ${paperDimensions.height} px`);

                    // Generate each page and add to PDF
                    for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                        this.updateLoadingMessage(loading, `Adding page ${pageNum + 1} of ${totalPages} to PDF...`);

                        const pageOrders = pages[pageNum];

                        // Build HTML for this page
                        let html = `
                            <div style="text-align: center; margin-bottom: 15px; padding: 8px 0;">
                                <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 10px; margin: 0; font-size: 24px;">
                                    Orders for <span style="font-size: 60px;">${Utils.formatDate(date)}</span> - Page ${pageNum + 1} of ${totalPages}
                                </h1>
                            </div>
                        `;

                        // Add summary section on first page only
                        console.log(`üîç Page ${pageNum}: Checking grand total condition - DryIce=${grandTotalDryIce}, Flowers=${grandTotalFlowers}, Electricity=${grandTotalElectricity}`);
                        if (pageNum === 0 && (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0)) {
                            console.log(`‚úÖ Adding grand total summary to first page`);
                            html += `
                                <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                    <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">üìä Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                        ${grandTotalDryIce > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">‚ùÑÔ∏è</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalFlowers > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">üå∏</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalElectricity > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">‚ö°</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }

                        // Calculate global order number
                        let globalOrderNum = 1;
                        for (let p = 0; p < pageNum; p++) {
                            globalOrderNum += pages[p].length;
                        }

                        pageOrders.forEach((order, i) => {
                            html += Orders.buildOrderHTML(this, order, compactFontSize, colors, true, bgColor, textColor, globalOrderNum + i);
                            if (i < pageOrders.length - 1) {
                                html += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });

                        template.innerHTML = html;
                        template.style.display = 'block';
                        template.style.visibility = 'visible';
                        template.style.position = 'static';
                        template.style.height = 'auto';

                        // Increased wait time for mobile devices
                        await new Promise(r => setTimeout(r, isMobile ? 500 : 200));

                        // Validate canvas dimensions before creation
                        const expectedWidth = Math.round(paperDimensions.width * qualityScale);
                        const expectedHeight = Math.round(paperDimensions.height * qualityScale);
                        const validation = Utils.validateCanvasDimensions(expectedWidth, expectedHeight);

                        if (!validation.valid) {
                            throw new Error(`Page ${pageNum + 1}: ${validation.reason}`);
                        }

                        // Convert HTML to canvas with error handling
                        let canvas;
                        try {
                            canvas = await html2canvas(template, {
                                scale: qualityScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        } catch (canvasError) {
                            console.error('Canvas generation failed, retrying with lower quality:', canvasError);

                            // Retry with lower quality scale
                            const retryScale = isMobile ? 0.75 : 1;
                            console.log(`‚ö†Ô∏è Retrying page ${pageNum + 1} with scale ${retryScale}...`);

                            canvas = await html2canvas(template, {
                                scale: retryScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        }

                        template.style.display = 'none';

                        // Convert canvas to image and add to PDF with error handling
                        let imgData;
                        try {
                            imgData = canvas.toDataURL('image/png', 0.92);
                        } catch (pngError) {
                            console.error('PNG conversion failed, retrying with JPEG:', pngError);
                            // Fallback to JPEG if PNG fails
                            try {
                                imgData = canvas.toDataURL('image/jpeg', 0.85);
                            } catch (jpegError) {
                                console.error('JPEG conversion also failed:', jpegError);
                                if (isMobile) {
                                    throw new Error('Canvas conversion failed on mobile device. Try reducing image quality or downloading fewer orders.');
                                } else {
                                    throw jpegError;
                                }
                            }
                        }

                        // Check data URL size for mobile
                        if (isMobile && imgData.length > 10 * 1024 * 1024) {
                            console.warn(`‚ö†Ô∏è Page ${pageNum + 1} is large (${(imgData.length / 1024 / 1024).toFixed(2)} MB)`);
                        }
                        let imgWidth = pdfWidth;
                        let imgHeight = (canvas.height * pdfWidth) / canvas.width;

                        // Add new page if not first page
                        if (pageNum > 0) {
                            pdf.addPage();
                        }

                        // Check if image is too tall - if so, add it without scaling to preserve quality
                        // The content should have been properly split in the page allocation phase
                        if (imgHeight > pdfHeight) {
                            console.warn(`‚ö†Ô∏è Page ${pageNum + 1} image height (${imgHeight}px) exceeds PDF height (${pdfHeight}px)`);
                            console.warn(`   This should not happen - the page allocation should have split the content properly`);

                            // Calculate scale factor needed
                            const scaleFactor = pdfHeight / imgHeight;
                            console.warn(`   Content will be scaled down to ${(scaleFactor * 100).toFixed(1)}% to fit the page`);

                            // Scale to fit as last resort
                            imgHeight = pdfHeight;
                            imgWidth = (canvas.width * pdfHeight) / canvas.height;
                        }

                        // Add image to PDF page (centered if scaled down)
                        const xOffset = (pdfWidth - imgWidth) / 2;
                        pdf.addImage(imgData, 'PNG', xOffset, 0, imgWidth, imgHeight, undefined, 'FAST');
                    }

                    // Save the PDF
                    this.updateLoadingMessage(loading, 'Saving PDF...');
                    pdf.save(`Orders_${date}.pdf`);

                    this.hideLoading(loading);
                    this.showToast(`‚úÖ PDF generated with ${totalPages} page(s)! (${orders.length} orders)`);

                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Error generating multi-order images:', error);

                    // Mobile-friendly error messages
                    if (isMobile) {
                        this.showToast(`‚ùå Failed on ${deviceType}: ${error.message}. Try reducing quality in settings or downloading fewer orders.`, 'error');
                    } else {
                        this.showToast('‚ùå Error: ' + error.message, 'error');
                    }
                }
            },

            // Helper to update loading message dynamically
            updateLoadingMessage(loadingElement, message) {
                if (loadingElement && loadingElement.querySelector('.loading-text')) {
                    loadingElement.querySelector('.loading-text').textContent = message;
                }
            },

            // Get paper dimensions based on format and orientation
            getPaperDimensions() {
                const format = this.data.settings.paperFormat || 'A4';
                const orientation = this.data.settings.paperOrientation || 'portrait';

                // Paper dimensions in pixels (at 300 DPI)
                const formats = {
                    'A4': { width: 2480, height: 3508 },
                    'Legal': { width: 2550, height: 4200 },
                    'Letter': { width: 2550, height: 3300 },
                    'A3': { width: 3508, height: 4960 },
                    'A5': { width: 1748, height: 2480 },
                    'Tabloid': { width: 3300, height: 5100 }
                };

                let dimensions = formats[format] || formats['A4'];

                // Swap dimensions for landscape
                if (orientation === 'landscape') {
                    return {
                        width: dimensions.height,
                        height: dimensions.width
                    };
                }

                return dimensions;
            },

            // Calculate dry ice, flowers, and electricity requirements for a single order
            calculateOrderRequirements(order) {
                const items = [];

                // Collect all items from the order
                // Check for dayWiseData first (handles both multiday and filtered single-day orders)
                if (order.dayWiseData && Array.isArray(order.dayWiseData) && order.dayWiseData.length > 0) {
                    console.log(`üìã Order ${order.orderId || order.clientName}: Processing dayWiseData (${order.dayWiseData.length} days)`);
                    order.dayWiseData.forEach(day => {
                        if (day.functions && Array.isArray(day.functions)) {
                            day.functions.forEach(func => {
                                if (func.items && Array.isArray(func.items)) {
                                    const funcName = func.functionName || func.name || '(unnamed function)';
                                    console.log(`  ‚Üí Adding ${func.items.length} items from function "${funcName}"`);
                                    items.push(...func.items);
                                }
                            });
                        }
                    });
                } else if (order.items && Array.isArray(order.items)) {
                    console.log(`üìã Order ${order.orderId || order.clientName}: Processing items array (${order.items.length} items)`);
                    items.push(...order.items);
                }

                console.log(`  ‚Üí Total items collected: ${items.length}`);

                // DEBUG: Log all item names to understand what we're working with
                if (items.length > 0) {
                    console.log(`  ‚Üí Item details:`);
                    items.forEach((item, idx) => {
                        console.log(`     ${idx + 1}. Name: "${item.name}" | Pcs: ${item.quantity || 0}`);
                    });
                }

                // Calculate dry ice requirements
                const dryMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = name.includes('dry ice');
                    if (matches) {
                        console.log(`     ‚úÖ DRY ICE MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Calculate flower requirements
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                    if (matches) {
                        console.log(`     ‚úÖ FLOWER SHOWER MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name?.toLowerCase() || '';
                    const qty = item.quantity || 0;

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     ‚úÖ ELECTRICITY 3KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 3}KV)`);
                        totalElectricityKV += qty * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     ‚úÖ ELECTRICITY 1KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 1}KV)`);
                        totalElectricityKV += qty * 1;
                    }
                });

                const result = {
                    dryIceNeeded,
                    dryMachines,
                    flowersNeeded,
                    flowerShowerMachines,
                    totalElectricityKV,
                    items
                };

                // DEBUG: Log the calculated requirements
                console.log(`  ‚Üí üìä Calculated: DryIce=${dryIceNeeded}kg (${dryMachines} machines), Flowers=${flowersNeeded}kg (${flowerShowerMachines} machines), Electricity=${totalElectricityKV}KV`);

                return result;
            },

            buildOrderHTML(order, fontSize, colors, compact = false, bgColor = '#ffffff', textColor = '#000000', orderNumber = null) {
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                const functionColor = this.data.settings.functionColor || '#667eea';

                // Calculate requirements for this order
                const requirements = Orders.calculateOrderRequirements(order);

                return `
                    <div style="margin-bottom: ${compact ? '25px' : '60px'}; ${compact ? 'border: 3px solid #CC8800; box-shadow: inset 0 0 0 3px #CC0000; padding: 15px;' : ''}; color: ${textColor}; background: ${bgColor};">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px; color: ${textColor};">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : ''}

                        <!-- FP- Field at center/top (YELLOW BACKGROUND REMOVED) -->
                        <div style="text-align: center; margin-bottom: ${compact ? '15px' : '25px'}; margin-top: ${compact ? '10px' : '0'};">
                            ${orderNumber ? `<div style="display: inline-block; font-size: ${fontSize + 6}px; font-weight: bold; color: ${textColor}; margin-right: 15px; vertical-align: middle;">Order ${orderNumber}</div>` : ''}
                            <div style="display: inline-block; border: 2px solid ${textColor}; padding: 8px 25px; font-size: ${fontSize + 4}px; font-weight: bold; color: ${textColor}; vertical-align: middle;">
                                FP-<span style="display: inline-block; min-width: 150px; border-bottom: 2px solid ${textColor}; margin-left: 10px; white-space: nowrap;">${order.orderId && order.orderId.startsWith('FP') ? order.orderId.substring(2) : ''}</span>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ${compact ? '12px' : '20px'}; font-size: ${fontSize}px; margin-bottom: ${compact ? '12px' : '20px'}; color: ${textColor};">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong style="color: ${textColor};">Start Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.startDate) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">End Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.endDate) || 'N/A'}</span><br>
                                ` : `
                                    <strong style="color: ${textColor};">Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.date) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${order.readyTime || '-'}</span><br>
                                `}
                                <strong style="color: ${textColor};">Client:</strong> ${order.clientName || '-'}<br>
                                <strong style="color: ${textColor};">Contact:</strong> ${order.contact || '-'}<br>
                                <strong style="color: ${textColor};">Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Dry Ice: ${requirements.dryIceNeeded > 0 ? requirements.dryIceNeeded + ' kg (' + requirements.dryMachines + ' machine' + (requirements.dryMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Flowers: ${requirements.flowersNeeded > 0 ? requirements.flowersNeeded + ' kg (' + requirements.flowerShowerMachines + ' machine' + (requirements.flowerShowerMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Electricity: ${requirements.totalElectricityKV > 0 ? requirements.totalElectricityKV + ' KV' : ''}</div>
                                <strong style="color: ${textColor};">Transport:</strong> ${order.transport || '-'}<br>
                                <strong style="color: ${textColor};">Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong style="color: ${textColor};">Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong style="color: ${textColor};">Driver 2:</strong> ${order.driverName2}<br>` : ''}
                            </div>
                            <div>
                                <strong style="color: ${textColor};">Event:</strong> ${order.eventType || '-'}<br>
                                <strong style="color: ${textColor};">Operator:</strong> ${order.operator || '-'}<br>
                                <strong style="color: ${textColor};">Helper(s):</strong> ${order.helper || '-'}
                            </div>
                        </div>

                        <!-- Dividing line between top info and items -->
                        <div style="border-top: 3px solid ${textColor}; margin: ${compact ? '15px' : '25px'} 0;"></div>

                            ${order.dayWiseData && order.dayWiseData.length > 0 ?
                            '<div style="margin-top: ' + (compact ? '15px' : '30px') + ';">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: ' + (compact ? '10px' : '15px') + '; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) =>
                                    '<div style="margin-top: ' + (compact ? '12px' : '25px') + '; border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '10px' : '15px') + '; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: ' + (compact ? '8px' : '15px') + ';">Day ' + day.dayNumber + ' - <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + Utils.formatDate(day.date) + '</span></h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: ' + bgColor + '; padding: ' + (compact ? '10px' : '15px') + '; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? (compact ? '8px' : '15px') : '0') + '; color: ' + textColor + ';">' +
                                                    '<h5 style="color: ' + functionColor + '; margin-bottom: ' + (compact ? '6px' : '10px') + '; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ' + (compact ? '8px' : '12px') + '; font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + (func.timeSlot || '-') + '</span>' +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Operator:</strong> ' + (func.operator || '-') +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Helper:</strong> ' + (func.helper || '-') +
                                                        '</div>' +
                                                    '</div>' +
                                                    (func.notes ? '<div style="font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';"><strong style="color: ' + textColor + ';">Notes:</strong> ' + func.notes + '</div>' : '') +
                                                    (func.items && func.items.length > 0 ?
                                                        '<div style="font-size: ' + (fontSize - 4) + 'px; color: ' + textColor + '; margin-top: ' + (compact ? '8px' : '12px') + ';">' +
                                                            func.items.map((item, i) =>
                                                                '<div style="padding: ' + (compact ? '4px' : '6px') + ' 0; color: ' + textColor + ';">' +
                                                                    '<span style="color: ' + textColor + ';">' + (i + 1) + '. ' + item.name + ' - ' + item.quantity + (item.quantity == 1 ? ' Pc' : ' Pcs') + (item.remarks ? ' - Remarks: ' + item.remarks : '') + '</span>' +
                                                                '</div>'
                                                            ).join('') +
                                                        '</div>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '6px' : '10px') + ';">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <div style="font-size: ${fontSize - 4}px; margin-top: ${compact ? '12px' : '20px'}; color: ${textColor};">
                                ${order.items.map((item, i) => `
                                    <div style="padding: ${compact ? '4px' : '6px'} 0; color: ${textColor};">
                                        <span style="color: ${textColor};">${i + 1}. ${item.name} - ${item.quantity} ${item.quantity == 1 ? 'Pc' : 'Pcs'}${item.remarks ? ' - Remarks: ' + item.remarks : ''}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '12px' : '20px') + ';">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: ${compact ? '10px' : '20px'}; font-size: ${fontSize}px; color: ${textColor};">
                                <strong style="color: ${textColor};">Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: ${compact ? '10px' : '15px'}; border: 1px solid ${colors.tableBorder}; color: ${textColor};">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            renderCalendar(date = new Date()) {
                const year = date.getFullYear();
                const month = date.getMonth();

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                let html = `
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(-1)">${this.t('previousMonth')}</button>
                                <h3>${monthNames[month]} ${year}</h3>
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(1)">${this.t('nextMonth')}</button>
                            </div>
                            <button class="btn btn-secondary btn-small" onclick="OMS.showToday()">${this.t('today')}</button>
                        </div>
                        <div class="calendar-grid">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day =>
                                `<div class="calendar-day-header">${day}</div>`
                            ).join('')}
                            ${Array(firstDay).fill('').map(() => '<div class="calendar-day"></div>').join('')}
                            ${Array.from({length: daysInMonth}, (_, i) => {
                                const day = i + 1;
                                const dateStr = Utils.toDateString(new Date(year, month, day));
                                const today = Utils.toDateString(new Date());

                                // ENHANCED CALENDAR FILTERING with fuzzy date matching
                                const orders = this.data.orders.filter(o => {
                                    if (o.isMultiDay) {
                                        // Use fuzzy date matcher for multi-day range check
                                        if (o.startDate && o.endDate) {
                                            return fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate);
                                        }
                                    }
                                    // Use fuzzy date matcher for single-day check
                                    return o.date && fuzzyDateMatcher.matches(o.date, dateStr);
                                });
                                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                                const festival = this.festivals[dateStr];

                                let classes = 'calendar-day';
                                if (dateStr === today) classes += ' today';
                                if (orders.length) classes += ' has-orders';
                                if (tasks.length) classes += ' has-tasks';
                                if (festival) classes += ' has-festival';

                                // Get color indicators for this day's orders
                                const orderColorDots = orders.slice(0, 3).map(o => {
                                    const color = this.getOrderColor(o);
                                    return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin:0 2px;"></span>`;
                                }).join('');

                                return `
                                    <div class="${classes}" onclick="OMS.showDayDetails('${dateStr}')">
                                        <div class="calendar-day-number">${day}</div>
                                        ${festival ? `<div class="festival-text">${festival[1]}</div>` : ''}
                                        ${orders.length ? `<div class="order-count" title="${orders.length} ${this.t('ordersText')}">${orderColorDots}${orders.length > 3 ? '+' : ''}</div>` : ''}
                                        ${tasks.length ? `<div class="calendar-day-content">${tasks.length} ${tasks.length > 1 ? this.t('ordersText') : this.t('order')}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="card">
                        <h3 class="card-title">${this.t('calendar')}</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <input type="date" id="taskDate" class="form-input" value="${Utils.toDateString(new Date())}">
                            </div>
                            <div class="form-group">
                                <input type="text" id="taskDescription" class="form-input" placeholder="${this.t('enterNotes')}">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-primary" onclick="OMS.addTask()">${this.t('add')}</button>
                            </div>
                        </div>
                    </div>
                `;

                return html;
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const date = Utils.getLocalDate(dateStr);

                // ============ ENHANCED FILTERING WITH LOGGING ============
                const startTime = performance.now();
                const normalizedDate = fuzzyDateMatcher.normalize(dateStr);

                filterLogger.log('showDayDetails_started', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                const matchedOrders = [];
                const orders = this.data.orders.filter(o => {
                    if (o.isMultiDay) {
                        // Use fuzzy date matcher for multi-day range check
                        if (o.startDate && o.endDate && fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    // Use fuzzy date matcher for single-day check
                    if (o.date && fuzzyDateMatcher.matches(o.date, dateStr)) {
                        matchedOrders.push(o);
                        return true;
                    }
                    return false;
                });

                const filterTime = (performance.now() - startTime).toFixed(2);

                // Log and learn from this filter
                filterLogger.log('showDayDetails_completed', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    matchedCount: orders.length,
                    filterTimeMs: filterTime
                });

                patternLearner.recordFilterResult(normalizedDate, orders.length, this.data.orders.length, 'showDayDetails');

                // Validate and alert if needed
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders,
                    allOrders: this.data.orders
                });

                if (validationResult.some(a => a.level === 'error' || a.level === 'warning')) {
                    orderValidator.showAlerts(validationResult, dateStr);
                }
                // ============ END ENHANCED FILTERING ============

                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                const festival = this.festivals[dateStr];

                let content = `<h3>${this.t('details')} ${this.t('for')} ${Utils.formatDate(dateStr)}</h3>`;

                if (festival) {
                    content += `<div class="festival-text" style="font-size: 1.2rem; margin: 1rem 0;">üéâ ${festival[1]} (${festival[0]})</div>`;
                }

                if (orders.length > 0) {
                    content += `<h4>${this.t('orders')} (${orders.length})</h4>`;
                    orders.forEach(o => {
                        const color = this.getOrderColor(o);
                        let dateInfo = '';
                        if (o.isMultiDay) {
                            dateInfo = `<br><small style="color:#666;">${this.t('multiDayOrder')}: ${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}</small>`;
                        }
                        content += `
                            <div style="padding:10px;margin:8px 0;border-left:4px solid ${color};background:#f9f9f9;border-radius:4px;">
                                <strong>${o.orderId || '[No ID]'}</strong> - ${o.clientName}
                                <br>
                                <span style="color:${color};font-weight:bold;">${o.eventType || this.t('event')}</span> |
                                <span style="background:${color};color:white;padding:2px 6px;border-radius:3px;font-size:12px;">${this.t(o.status.toLowerCase())}</span>
                                ${dateInfo}
                            </div>
                        `;
                    });
                }

                if (tasks.length > 0) {
                    content += `<h4>${this.t('calendar')} (${tasks.length})</h4><ul>`;
                    tasks.forEach(t => {
                        content += `<li>
                            ${t.description}
                            <button class="btn btn-secondary btn-small" data-action="edit" data-type="task" data-id="${t.id}">${this.t('edit')}</button>
                            <button class="btn btn-danger btn-small" data-action="delete" data-type="task" data-id="${t.id}">${this.t('delete')}</button>
                        </li>`;
                    });
                    content += '</ul>';
                }

                content += `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.addTaskForDate('${dateStr}')">${this.t('add')}</button>
                        <button class="btn btn-secondary" onclick="OMS.createOrderForDate('${dateStr}')">${this.t('orders')}</button>
                    </div>
                `;

                this.showModal(this.t('details'), content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders with ALL items and quantities as CSV
                        const headers = ['Order ID', 'Order Date', 'Client Name', 'Contact', 'Venue', 'Status', 'Order Type', 'Event Day', 'Function Name', 'Item Name', 'Item Quantity', 'Item Category', 'Total Amount'];
                        const rows = [];

                        this.data.orders.forEach(order => {
                            const baseInfo = [
                                order.orderId || '',
                                order.date || order.startDate || '',
                                (order.clientName || '').replace(/,/g, ' '),
                                order.contact || '',
                                (order.venue || '').replace(/,/g, ' '),
                                order.status || 'pending',
                                order.totalAmount || '0'
                            ];

                            // Handle single-day orders
                            if (order.items && order.items.length > 0) {
                                order.items.forEach(item => {
                                    rows.push([
                                        ...baseInfo.slice(0, 6),
                                        'Single Day',
                                        order.date || '',
                                        'Main Event',
                                        (item.name || 'Unknown Item').replace(/,/g, ' '),
                                        item.quantity || 0,
                                        item.category || 'other',
                                        baseInfo[6]
                                    ]);
                                });
                            }

                            // Handle multi-day orders
                            if (order.dayWiseData && order.dayWiseData.length > 0) {
                                order.dayWiseData.forEach(day => {
                                    if (day.functions && day.functions.length > 0) {
                                        day.functions.forEach(func => {
                                            if (func.items && func.items.length > 0) {
                                                func.items.forEach(item => {
                                                    rows.push([
                                                        ...baseInfo.slice(0, 6),
                                                        'Multi-Day',
                                                        day.date || '',
                                                        (func.name || 'Unnamed Function').replace(/,/g, ' '),
                                                        (item.name || 'Unknown Item').replace(/,/g, ' '),
                                                        item.quantity || 0,
                                                        item.category || 'other',
                                                        baseInfo[6]
                                                    ]);
                                                });
                                            }
                                        });
                                    }
                                });
                            }

                            // If order has no items at all, add a single row with order info
                            if ((!order.items || order.items.length === 0) && (!order.dayWiseData || order.dayWiseData.length === 0)) {
                                rows.push([
                                    ...baseInfo.slice(0, 6),
                                    'No Items',
                                    '',
                                    '',
                                    'No items',
                                    '0',
                                    '',
                                    baseInfo[6]
                                ]);
                            }
                        });

                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_detailed_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();

                // Create close button
                const closeBtn = Utils.elem('button', { class: 'modal-close' }, ['√ó']);
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeModal();
                });

                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        closeBtn,
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);

                document.getElementById('modalsContainer').appendChild(modal);

                // Also allow closing by clicking the backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal();
                    }
                });

                // Add keyboard handler for Escape key
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

                // Store handler to remove later
                modal._escapeHandler = escapeHandler;
            },

            showToast(message, type = 'success', actions = []) {
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let topOffset = 20; // Initial top position

                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    topOffset = Math.max(topOffset, rect.bottom - document.documentElement.scrollTop + 10);
                });

                // Create action buttons if provided
                const actionButtons = actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' },
                    actions.map(a => {
                        const btn = Utils.elem('button', { class: 'toast-btn' }, [a.label]);
                        btn.addEventListener('click', a.handler);
                        return btn;
                    })
                ) : null;

                const toast = Utils.elem('div', {
                    class: `toast show ${type === 'error' ? 'error' : ''} ${type === 'warning' ? 'warning' : ''}`,
                    style: { top: `${topOffset}px` }
                }, [
                    Utils.elem('div', {}, [message]),
                    actionButtons
                ].filter(Boolean));

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },

            repositionToasts() {
                const toasts = document.querySelectorAll('.toast');
                let topOffset = 20;

                toasts.forEach(toast => {
                    toast.style.top = `${topOffset}px`;
                    const rect = toast.getBoundingClientRect();
                    topOffset = rect.bottom - document.documentElement.scrollTop + 10;
                });
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', { class: 'loading-text' }, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ RBAC NAVIGATION ============
            async applyRBACToNavigation() {
                const canViewFinancials = await this.canViewFinancials();
                const financialsTab = document.querySelector('[data-tab="financials"]');
                const user = await this.getCurrentUser();

                console.log('üîê RBAC Check:', {
                    userRole: user?.role,
                    canViewFinancials: canViewFinancials,
                    tabExists: !!financialsTab
                });

                if (financialsTab) {
                    if (canViewFinancials) {
                        // Show financials tab for admin/owner users
                        financialsTab.style.display = '';
                        console.log('‚úÖ Financials tab VISIBLE for admin/owner user');
                    } else {
                        // Hide financials tab for non-admin/owner users
                        financialsTab.style.display = 'none';
                        console.log('üîí Financials tab HIDDEN for non-admin/owner user');
                    }
                }

                // Display current user role in header
                if (user) {
                    const userInfoDiv = document.createElement('div');
                    userInfoDiv.id = 'userRoleInfo';
                    userInfoDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: rgba(0,0,0,0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; white-space: nowrap; margin-right: 0.5rem;';
                    userInfoDiv.innerHTML = `
                        <span style="opacity: 0.7; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${user.email}</span>
                        <span style="padding: 0.25rem 0.5rem; background: ${user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3'}; color: white; border-radius: 0.25rem; font-weight: bold; text-transform: uppercase; font-size: 0.75rem;">
                            ${user.role}
                        </span>
                    `;

                    // Add to header-controls instead of directly to header
                    const headerControls = document.querySelector('.header-controls');
                    if (headerControls && !document.getElementById('userRoleInfo')) {
                        // Insert at the beginning of header-controls
                        headerControls.insertBefore(userInfoDiv, headerControls.firstChild);
                    }
                }
            },

            // ============ NAVIGATION ============
            async switchTab(tabName) {
                // Check permissions for financial tab
                if (tabName === 'financials') {
                    const canView = await this.canViewFinancials();
                    if (!canView) {
                        this.showToast('‚õî Access Denied: Only Admin and Owner can view Financials', 'error');
                        return;
                    }
                }

                // Clean up preparation weather interval when leaving preparation tab
                if (this.currentTab === 'preparation' && tabName !== 'preparation') {
                    if (this.preparationWeatherInterval) {
                        clearInterval(this.preparationWeatherInterval);
                        this.preparationWeatherInterval = null;
                    }
                }

                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                document.querySelector(`[data-tab="${tabName}"]`)?.classList.add('active');
                document.getElementById(tabName)?.classList.add('active');

                this.currentTab = tabName;

                // Render tab content (with lazy loading support)
                setTimeout(async () => {
                    // Check if tab needs lazy loading
                    if (window.LazyLoader && window.LazyLoader.needsLoading(tabName)) {
                        await window.LazyLoader.load(tabName);
                        // Module loaded and render function attached to OMS by lazy-loader
                    }

                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') Inventory.renderInventory(this);
                    else if (tabName === 'productPhotos') Inventory.renderProductPhotos(this);
                    else if (tabName === 'itemHistory') Inventory.renderItemHistory(this);
                    else if (tabName === 'preparation') Preparation.renderPreparation(this);
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'quotations') Quotations.renderQuotations(this);
                    else if (tabName === 'team') Team.renderTeam(this);
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'financials') this.renderFinancials();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') {
                        this.initItemSearch();
                        // Always populate events dropdown when orders tab is opened
                        console.log('üìã Orders tab opened - populating events dropdown');
                        this.populateEventsDatalist();
                        // Driver and operator dropdowns are populated when form is rendered
                    }
                }, 50);
            },

            // ============ TAB RENDERERS ============
            renderDashboard() {
                // Wrapper function - delegates to Dashboard module if loaded
                if (window.Dashboard && typeof window.Dashboard.render === 'function') {
                    window.Dashboard.render(this);
                } else {
                    // Module not loaded yet - skip or show placeholder
                    console.log('Dashboard module not loaded yet');
                }
            },

            // Destroy existing charts to prevent memory leaks
            destroyChart(chartId) {
                if (this.charts && this.charts[chartId]) {
                    this.charts[chartId].destroy();
                    delete this.charts[chartId];
                }
            },

            renderAnalyticsCharts() {
                // Initialize charts storage
                if (!this.charts) this.charts = {};

                const activeOrders = this.data.orders.filter(o => !o.isMerged);

                // 1. Revenue Trend Chart (Last 6 Months)
                this.renderRevenueTrendChart(activeOrders);

                // 2. Orders by Status Chart (Pie)
                this.renderOrdersByStatusChart(activeOrders);

                // 3. Monthly Orders Chart (Bar)
                this.renderMonthlyOrdersChart(activeOrders);

                // 4. Top Items Chart (Horizontal Bar)
                this.renderTopItemsChart(activeOrders);
            },

            renderRevenueTrendChart(orders) {
                this.destroyChart('revenueTrend');

                const ctx = document.getElementById('revenueTrendChart');
                if (!ctx) return;

                // Calculate last 6 months revenue
                const monthsData = {};
                const today = new Date();

                // Initialize last 6 months
                for (let i = 5; i >= 0; i--) {
                    const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    monthsData[monthKey] = { revenue: 0, label: date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }) };
                }

                // Calculate revenue per month (only completed orders)
                orders.filter(o => o.status && o.status.toLowerCase() === 'completed').forEach(order => {
                    const orderDate = order.date || order.startDate;
                    if (orderDate) {
                        const monthKey = orderDate.substring(0, 7);
                        if (monthsData[monthKey]) {
                            const revenue = order.totalAmount || 0;
                            monthsData[monthKey].revenue += parseFloat(revenue);
                        }
                    }
                });

                const labels = Object.values(monthsData).map(m => m.label);
                const data = Object.values(monthsData).map(m => m.revenue);

                this.charts.revenueTrend = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Revenue (‚Çπ)',
                            data: data,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `Revenue: ‚Çπ${context.parsed.y.toLocaleString('en-IN')}`
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: (value) => `‚Çπ${value.toLocaleString('en-IN')}`
                                }
                            }
                        }
                    }
                });
            },

            renderOrdersByStatusChart(orders) {
                this.destroyChart('ordersByStatus');

                const ctx = document.getElementById('ordersByStatusChart');
                if (!ctx) return;

                // Count orders by status
                const statusCounts = {
                    'Confirmed': orders.filter(o => o.status && o.status.toLowerCase() === 'confirmed').length,
                    'Completed': orders.filter(o => o.status && o.status.toLowerCase() === 'completed').length,
                    'Cancelled': orders.filter(o => o.status && o.status.toLowerCase() === 'cancelled').length,
                    'Pending': orders.filter(o => !o.status || o.status.toLowerCase() === 'pending').length
                };

                this.charts.ordersByStatus = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(statusCounts),
                        datasets: [{
                            data: Object.values(statusCounts),
                            backgroundColor: [
                                '#f59e0b',  // Confirmed - warning
                                '#10b981',  // Completed - success
                                '#ef4444',  // Cancelled - danger
                                '#6b7280'   // Pending - gray
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { position: 'bottom' }
                        }
                    }
                });
            },

            renderMonthlyOrdersChart(orders) {
                this.destroyChart('monthlyOrders');

                const ctx = document.getElementById('monthlyOrdersChart');
                if (!ctx) return;

                // Calculate last 6 months orders count
                const monthsData = {};
                const today = new Date();

                for (let i = 5; i >= 0; i--) {
                    const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    monthsData[monthKey] = { count: 0, label: date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }) };
                }

                orders.forEach(order => {
                    const orderDate = order.date || order.startDate;
                    if (orderDate) {
                        const monthKey = orderDate.substring(0, 7);
                        if (monthsData[monthKey]) {
                            monthsData[monthKey].count++;
                        }
                    }
                });

                const labels = Object.values(monthsData).map(m => m.label);
                const data = Object.values(monthsData).map(m => m.count);

                this.charts.monthlyOrders = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Orders',
                            data: data,
                            backgroundColor: '#667eea'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 1
                                }
                            }
                        }
                    }
                });
            },

            renderTopItemsChart(orders) {
                this.destroyChart('topItems');

                const ctx = document.getElementById('topItemsChart');
                if (!ctx) return;

                // Count item usage across all completed orders
                const itemCounts = {};

                orders.filter(o => o.status && o.status.toLowerCase() === 'completed').forEach(order => {
                    // Single day orders
                    if (order.items && order.items.length > 0) {
                        order.items.forEach(item => {
                            const itemName = item.name || 'Unknown';
                            itemCounts[itemName] = (itemCounts[itemName] || 0) + (item.quantity || 0);
                        });
                    }

                    // Multi-day orders
                    if (order.dayWiseData && order.dayWiseData.length > 0) {
                        order.dayWiseData.forEach(day => {
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        func.items.forEach(item => {
                                            const itemName = item.name || 'Unknown';
                                            itemCounts[itemName] = (itemCounts[itemName] || 0) + (item.quantity || 0);
                                        });
                                    }
                                });
                            }
                        });
                    }
                });

                // Sort and get top 10
                const sortedItems = Object.entries(itemCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);

                const labels = sortedItems.map(item => item[0]);
                const data = sortedItems.map(item => item[1]);

                this.charts.topItems = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Usage Count',
                            data: data,
                            backgroundColor: '#10b981'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('inventoryManagement')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">${this.t('batchUpdate')}</button>
                        </div>
                        <div class="card">
                            <h3>${this.t('categories')}</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="${this.t('enterCategoryName')}">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">${this.t('add')}</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>${this.t('items')}</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="${this.t('enterItemName')}">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="${this.t('quantity')}" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">${this.t('add')}</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;

                this.updateInventoryDisplay();
            },

            renderProductPhotos() {
                const container = document.getElementById('productPhotos');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üì∏ Product Photos Management</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">
                                Upload product photos to display on quotation website. Click any product to upload/change its image.
                            </p>
                        </div>
                        <div id="productPhotosGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1.5rem; padding: 1.5rem;">
                            ${this.data.inventory.items.map(item => {
                                const category = this.data.inventory.categories.find(c => c.id === item.categoryId);
                                const imageUrl = item.imageUrl;

                                return `
                                    <div class="product-photo-card" style="border: 1px solid #e0e0e0; border-radius: 12px; overflow: hidden; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.08); transition: transform 0.2s; cursor: pointer;" onclick="OMS.uploadProductPhoto('${item.id}')">
                                        <div style="position: relative; padding-top: 66.67%; background: ${item.imageUrl ? '#f5f5f5' : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'};">
                                            ${item.imageUrl ? `
                                                <img src="${imageUrl}" alt="${item.name}"
                                                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;"
                                                    onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; font-size: 14px; font-weight: 600;\\'>No Image<br/>Click to Upload</div>';">
                                            ` : `
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; font-size: 16px; font-weight: 600;">
                                                    üì∏<br/>No Image<br/><span style="font-size: 12px; font-weight: 400;">Click to Upload</span>
                                                </div>
                                            `}
                                            <div style="position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">
                                                ${category?.name || 'No Category'}
                                            </div>
                                        </div>
                                        <div style="padding: 1rem;">
                                            <h4 style="margin: 0 0 0.5rem 0; font-size: 15px; font-weight: 600; color: #1a1a1a;">${item.name}</h4>
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.75rem;">
                                                <span style="font-size: 12px; color: #666;">Stock: ${item.quantity}</span>
                                                <button class="btn btn-primary btn-small" style="font-size: 12px; padding: 6px 12px;" onclick="event.stopPropagation(); OMS.uploadProductPhoto('${item.id}')">
                                                    üì§ ${item.imageUrl ? 'Change' : 'Upload'} Photo
                                                </button>
                                            </div>
                                            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0; display: flex; align-items: center; justify-content: space-between;">
                                                <span style="font-size: 13px; color: #333; font-weight: 500;">üëÅÔ∏è Show on Website</span>
                                                <label class="visibility-toggle" style="position: relative; display: inline-block; width: 48px; height: 24px; cursor: pointer;" onclick="event.stopPropagation();">
                                                    <input type="checkbox" ${item.visibleOnWebsite !== false ? 'checked' : ''} onchange="event.stopPropagation(); OMS.toggleItemVisibility('${item.id}', this.checked)" style="opacity: 0; width: 0; height: 0;">
                                                    <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: ${item.visibleOnWebsite !== false ? '#4CAF50' : '#ccc'}; border-radius: 24px; transition: 0.3s;"></span>
                                                    <span style="position: absolute; content: ''; height: 18px; width: 18px; left: ${item.visibleOnWebsite !== false ? '27px' : '3px'}; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <input type="file" id="productPhotoInput" accept="image/*" style="display: none;" onchange="OMS.handleProductPhotoSelect(event)">
                `;

                // Add hover effect with CSS
                const style = document.createElement('style');
                style.textContent = `
                    .product-photo-card:hover {
                        transform: translateY(-4px);
                        box-shadow: 0 4px 16px rgba(0,0,0,0.12) !important;
                    }
                `;
                document.head.appendChild(style);
            },

            currentProductItemId: null,

            uploadProductPhoto(itemId) {
                this.currentProductItemId = itemId;
                document.getElementById('productPhotoInput').click();
            },

            async handleProductPhotoSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Validate file type
                if (!file.type.startsWith('image/')) {
                    this.showToast('‚ùå Please select an image file', 'error');
                    return;
                }

                // Validate file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    this.showToast('‚ùå Image size must be less than 5MB', 'error');
                    return;
                }

                const itemId = this.currentProductItemId;
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) {
                    this.showToast('‚ùå Item not found', 'error');
                    return;
                }

                const loading = this.showLoading('Uploading image...');

                try {
                    // Use the old Firebase SDK (not modular)
                    const storage = firebase.storage();

                    // Create filename: products/{itemId}_{timestamp}.jpg
                    const timestamp = Date.now();
                    const extension = file.name.split('.').pop();
                    const filename = `products/${itemId}_${timestamp}.${extension}`;

                    // Upload to Firebase Storage
                    const storageRef = storage.ref(filename);
                    const uploadTask = await storageRef.put(file);

                    // Get download URL
                    const imageUrl = await uploadTask.ref.getDownloadURL();

                    // Update item in local data
                    item.imageUrl = imageUrl;
                    item.updatedAt = new Date().toISOString();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    // Save to localStorage
                    this.saveToStorage();

                    this.hideLoading(loading);
                    this.showToast(`‚úÖ Photo uploaded successfully for ${item.name}!`, 'success');

                    // Re-render to show new image
                    this.renderProductPhotos();

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    console.error('‚ùå Error uploading photo:', error);
                    this.hideLoading(loading);
                    this.showToast('‚ùå Upload failed: ' + error.message, 'error');
                }
            },

            async toggleItemVisibility(itemId, isVisible) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) {
                    this.showToast('‚ùå Item not found', 'error');
                    return;
                }

                const loading = this.showLoading(isVisible ? 'Showing on website...' : 'Hiding from website...');

                try {
                    // Update item in local data
                    item.visibleOnWebsite = isVisible;
                    item.updatedAt = new Date().toISOString();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    // Save to localStorage
                    this.saveToStorage();

                    this.hideLoading(loading);
                    this.showToast(
                        isVisible
                            ? `‚úÖ "${item.name}" is now visible on quotation website`
                            : `üîí "${item.name}" is now hidden from quotation website`,
                        'success'
                    );

                    // Re-render to update toggle state
                    this.renderProductPhotos();

                } catch (error) {
                    console.error('‚ùå Error toggling visibility:', error);
                    this.hideLoading(loading);
                    this.showToast('‚ùå Failed to update visibility: ' + error.message, 'error');
                }
            },

            renderItemHistory() {
                const container = document.getElementById('itemHistory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìú Item Usage History</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">
                                Track which items were used in which completed orders
                            </p>
                        </div>
                        <div class="form-row" style="margin-bottom: 1rem;">
                            <input type="text" id="itemHistorySearch" class="form-input" placeholder="Search by item name, order ID, or client...">
                            <select id="itemHistoryFilter" class="form-select">
                                <option value="all">All Items</option>
                                ${[...new Set(this.data.itemHistory.map(h => h.itemName))].sort().map(name =>
                                    `<option value="${name}">${name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div id="itemHistoryContainer"></div>
                    </div>
                `;

                this.renderItemHistoryTable();

                // Add search and filter handlers
                document.getElementById('itemHistorySearch')?.addEventListener('input', () => this.renderItemHistoryTable());
                document.getElementById('itemHistoryFilter')?.addEventListener('change', () => this.renderItemHistoryTable());
            },

            renderItemHistoryTable() {
                const searchTerm = document.getElementById('itemHistorySearch')?.value.toLowerCase() || '';
                const filterItem = document.getElementById('itemHistoryFilter')?.value || 'all';

                // Filter history
                let filteredHistory = this.data.itemHistory;

                if (filterItem !== 'all') {
                    filteredHistory = filteredHistory.filter(h => h.itemName === filterItem);
                }

                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(h =>
                        h.itemName.toLowerCase().includes(searchTerm) ||
                        h.orderId.toLowerCase().includes(searchTerm) ||
                        h.clientName.toLowerCase().includes(searchTerm) ||
                        (h.venue && h.venue.toLowerCase().includes(searchTerm))
                    );
                }

                // Sort by most recent first
                filteredHistory.sort((a, b) => new Date(b.usedAt) - new Date(a.usedAt));

                // Render table
                this.renderTable('itemHistoryContainer', [
                    { key: 'itemName', label: 'Item Name' },
                    { key: 'quantity', label: 'Pcs' },
                    { key: 'orderId', label: 'Order ID', render: h => `<span class="order-id-highlight">${h.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'venue', label: 'Venue', render: h => h.venue || 'N/A' },
                    { key: 'eventDate', label: 'Event Date', render: h => Utils.formatDate(h.eventDate) },
                    { key: 'functionType', label: 'Function', render: h => h.functionType || 'N/A' },
                    { key: 'usedAt', label: 'Recorded On', render: h => new Date(h.usedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }) }
                ], filteredHistory, (row) => ``);
            },

            updateInventoryDisplay() {
                // Populate category dropdown
                const select = document.getElementById('itemCategory');
                if (select) {
                    select.innerHTML = `<option value="">${this.t('selectCategory')}</option>` +
                        this.data.inventory.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
                }

                // Render categories table
                this.renderTable('categoriesContainer', [
                    { key: 'name', label: this.t('category') },
                    { key: 'id', label: this.t('items'), render: c => this.data.inventory.items.filter(i => i.categoryId === c.id).length }
                ], this.data.inventory.categories, (row) => `
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="category" data-id="${row.id}">${this.t('delete')}</button>
                `);

                // Render items table
                this.renderTable('itemsContainer', [
                    { key: 'name', label: this.t('item') },
                    { key: 'categoryId', label: this.t('category'), render: i => this.data.inventory.categories.find(c => c.id === i.categoryId)?.name || this.t('na') },
                    { key: 'quantity', label: this.t('stock') }
                ], this.data.inventory.items, (row) => `
                    <button class="btn btn-success btn-small" onclick="OMS.increaseItemQuantity('${row.id}')">+</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.decreaseItemQuantity('${row.id}')">-</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.editInventoryItem('${row.id}')">‚úèÔ∏è ${this.t('edit')}</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="item" data-id="${row.id}">üóëÔ∏è ${this.t('delete')}</button>
                `);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Pieces</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION MODULE ============
            // Loaded lazily from /admin/js/features/preparation.js

            // Helper function used by Preparation module
            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            // Quick forecast wrapper function used by Preparation module
            quickForecast(period) {
                // Lazy load preparation module if not already loaded
                if (window.Preparation && typeof window.Preparation.quickForecast === 'function') {
                    window.Preparation.quickForecast(this, period);
                } else {
                    console.error('Preparation module not loaded yet');
                    this.showToast('Loading preparation module, please try again', 'warning');
                }
            },

            // Generate forecast wrapper function used by Preparation module
            generateForecast() {
                // Lazy load preparation module if not already loaded
                if (window.Preparation && typeof window.Preparation.generateForecast === 'function') {
                    window.Preparation.generateForecast(this);
                } else {
                    console.error('Preparation module not loaded yet');
                    this.showToast('Loading preparation module, please try again', 'warning');
                }
            },

            // Render forecast results - displays material requirements
            renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate, weatherData) {
                const container = document.getElementById('forecastResults');
                if (!container) return;

                // Calculate total materials needed using same logic as PDF generation
                let totalDryIce = 0;
                let totalFlowers = 0;
                let totalElectricity = 0;
                let totalDryMachines = 0;
                let totalFlowerMachines = 0;

                ordersInRange.forEach(order => {
                    const requirements = Orders.calculateOrderRequirements(order);
                    totalDryIce += requirements.dryIceNeeded;
                    totalFlowers += requirements.flowersNeeded;
                    totalElectricity += requirements.totalElectricityKV;
                    totalDryMachines += requirements.dryMachines;
                    totalFlowerMachines += requirements.flowerShowerMachines;
                });

                container.innerHTML = `
                    <div class="card" style="margin-top: 2rem;">
                        <div class="card-header">
                            <h3>üìä Preparation Report: ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</h3>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${ordersInRange.length} order(s) found</p>
                        </div>

                        ${weatherData ? `
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem; color: white;">
                                <div style="display: flex; align-items: center; gap: 1rem;">
                                    <div style="font-size: 3rem;">${Utils.getWeatherEmoji(weatherData.condition)}</div>
                                    <div>
                                        <div style="font-size: 2rem; font-weight: bold;">${weatherData.temp}¬∞C</div>
                                        <div style="font-size: 1.125rem; opacity: 0.9;">${weatherData.condition}</div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}

                        <div style="background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%); padding: 2rem; border-radius: 12px; margin-bottom: 2rem; color: white; box-shadow: 0 4px 12px rgba(255,107,107,0.3);">
                            <h3 style="margin: 0 0 1.5rem 0; font-size: 1.5rem; color: white;">üî• Raw Materials Required</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
                                ${totalDryIce > 0 ? `
                                    <div style="background: rgba(255,255,255,0.15); padding: 1.5rem; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 0.5rem;">${totalDryIce} kg</div>
                                        <div style="font-size: 1rem; opacity: 0.9;">Dry Ice</div>
                                        <div style="font-size: 0.875rem; opacity: 0.7; margin-top: 0.25rem;">(${totalDryMachines} machine${totalDryMachines !== 1 ? 's' : ''})</div>
                                    </div>
                                ` : ''}
                                ${totalFlowers > 0 ? `
                                    <div style="background: rgba(255,255,255,0.15); padding: 1.5rem; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 0.5rem;">${totalFlowers} kg</div>
                                        <div style="font-size: 1rem; opacity: 0.9;">Flowers</div>
                                        <div style="font-size: 0.875rem; opacity: 0.7; margin-top: 0.25rem;">(${totalFlowerMachines} machine${totalFlowerMachines !== 1 ? 's' : ''})</div>
                                    </div>
                                ` : ''}
                                ${totalElectricity > 0 ? `
                                    <div style="background: rgba(255,255,255,0.15); padding: 1.5rem; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 0.5rem;">${totalElectricity} KV</div>
                                        <div style="font-size: 1rem; opacity: 0.9;">Electricity</div>
                                        <div style="font-size: 0.875rem; opacity: 0.7; margin-top: 0.25rem;">Required Power</div>
                                    </div>
                                ` : ''}
                                ${totalDryIce === 0 && totalFlowers === 0 && totalElectricity === 0 ? `
                                    <div style="padding: 2rem; text-align: center; grid-column: 1 / -1;">
                                        <div style="font-size: 1.25rem; opacity: 0.8;">No raw materials required for selected date range</div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>

                        ${aggregatedItems.length > 0 ? `
                            <div class="card">
                                <h3>üì¶ Items Breakdown</h3>
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>${this.t('item')}</th>
                                            <th style="text-align: center;">${this.t('required')}</th>
                                            <th style="text-align: center;">${this.t('inStock')}</th>
                                            <th style="text-align: center;">${this.t('difference')}</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${aggregatedItems.map(item => {
                                            const diffColor = item.difference >= 0 ? 'var(--success)' : 'var(--danger)';
                                            const diffIcon = item.difference >= 0 ? '‚úÖ' : '‚ö†Ô∏è';
                                            return `
                                                <tr>
                                                    <td>
                                                        <strong>${item.name}</strong>
                                                        ${item.orders.length > 0 ? `
                                                            <div style="font-size: 0.875rem; color: var(--text-gray); margin-top: 0.25rem;">
                                                                ${item.orders.slice(0, 3).map(o => `${o.orderId} (${o.quantity})`).join(', ')}
                                                                ${item.orders.length > 3 ? ` +${item.orders.length - 3} more` : ''}
                                                            </div>
                                                        ` : ''}
                                                    </td>
                                                    <td style="text-align: center; font-weight: bold; font-size: 1.125rem;">${item.required}</td>
                                                    <td style="text-align: center;">${item.inStock}</td>
                                                    <td style="text-align: center; color: ${diffColor}; font-weight: 600;">
                                                        ${diffIcon} ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                    </td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                        ` : `
                            <div class="card" style="text-align: center; padding: 3rem;">
                                <div style="font-size: 3rem; margin-bottom: 1rem;">üì≠</div>
                                <h3>No Items Found</h3>
                                <p style="color: var(--text-gray);">No orders or items in the selected date range</p>
                            </div>
                        `}

                        ${ordersInRange.length > 0 ? `
                            <div class="card">
                                <h3>üìã Orders in Range (${ordersInRange.length})</h3>
                                <div style="display: grid; gap: 1rem;">
                                    ${ordersInRange.map(order => `
                                        <div style="background: var(--bg-hover); padding: 1rem; border-radius: 8px; border-left: 4px solid var(--primary);">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <div>
                                                    <strong style="font-size: 1.125rem;">${order.orderId}</strong>
                                                    <div style="color: var(--text-gray); font-size: 0.875rem; margin-top: 0.25rem;">
                                                        ${order.clientName} ‚Ä¢ ${Utils.formatDate(order.date || order.startDate)} ‚Ä¢ ${order.venue || 'N/A'}
                                                    </div>
                                                </div>
                                                <div style="text-align: right;">
                                                    ${order.items ? `<div style="font-size: 0.875rem; color: var(--text-gray);">${order.items.length} items</div>` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            renderCustomers() {
                // Wrapper function - delegates to Customers module if loaded
                if (window.Customers && typeof window.Customers.render === 'function') {
                    window.Customers.render(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Customers module not loaded yet');
                }
            },

            renderAnalytics() {
                // Wrapper function - delegates to Analytics module if loaded
                if (window.Analytics && typeof window.Analytics.renderAnalytics === 'function') {
                    window.Analytics.renderAnalytics(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Analytics module not loaded yet');
                }
            },

            filterAndDisplayCustomers(searchQuery) {
                // Filter customers based on search query
                let filteredCustomers = this.data.customers;
                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredCustomers = this.data.customers.filter(customer => {
                        return (
                            (customer.name && customer.name.toLowerCase().includes(query)) ||
                            (customer.contact && customer.contact.toLowerCase().includes(query)) ||
                            (customer.email && customer.email.toLowerCase().includes(query))
                        );
                    });
                }

                // Only re-render the table, not the entire page
                this.renderTable('customersContainer', [
                    { key: 'name', label: this.t('customerName') },
                    { key: 'contact', label: this.t('contact') },
                    { key: 'totalOrders', label: this.t('totalOrdersCount') },
                    { key: 'lastOrderDate', label: this.t('lastOrder'), render: c => Utils.formatDate(c.lastOrderDate) }
                ], filteredCustomers, (row) => `
                    <button class="btn btn-secondary btn-small" onclick="OMS.viewCustomerOrders('${row.id}')">${this.t('viewOrders')}</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.createOrderForCustomer('${row.id}')">${this.t('orders')}</button>
                `);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            async viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) {
                    this.showToast('Customer not found!', 'error');
                    return;
                }

                // Get all orders for this customer
                const customerOrders = this.data.orders.filter(o =>
                    o.clientName === customer.name || o.contact === customer.contact
                ).sort((a, b) => {
                    // Sort by date, newest first
                    const dateA = new Date(a.orderDate || a.createdAt || 0);
                    const dateB = new Date(b.orderDate || b.createdAt || 0);
                    return dateB - dateA;
                });

                // Calculate customer lifetime stats
                const totalSpent = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.grandTotal || o.totalAmount || 0), 0);
                const totalPaid = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.advancePaid || 0), 0);
                const totalPending = totalSpent - totalPaid;
                const fullyPaidOrders = customerOrders.filter(o => parseFloat(o.financials?.balanceDue || 0) === 0).length;

                // Check if user can view financials
                const canViewFinancials = await this.canViewFinancials();

                const modalHTML = `
                    <div class="modal show" id="customerProfileModal" onclick="if(event.target === this) OMS.closeModal('customerProfileModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('customerProfileModal')">√ó</button>
                            <h2>üë§ Customer Profile</h2>

                            <!-- Customer Info -->
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h3 style="margin: 0 0 0.5rem 0; font-size: 1.75rem;">${customer.name}</h3>
                                        <p style="margin: 0.25rem 0; opacity: 0.9;">üìû ${customer.contact || 'N/A'}</p>
                                        ${customer.email ? `<p style="margin: 0.25rem 0; opacity: 0.9;">üìß ${customer.email}</p>` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 1.25rem; font-weight: bold;">Total Orders: ${customerOrders.length}</div>
                                        ${canViewFinancials ? `<div style="font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem;">Lifetime Value: ‚Çπ${totalSpent.toLocaleString('en-IN')}</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            ${canViewFinancials ? `
                                <!-- Lifetime Stats -->
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                                    <div style="background: #e8f5e9; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #4caf50;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #2e7d32;">‚Çπ${totalSpent.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Spent</div>
                                    </div>
                                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #2196f3;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #1565c0;">‚Çπ${totalPaid.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Paid</div>
                                    </div>
                                    <div style="background: #ffebee; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #f44336;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #c62828;">‚Çπ${totalPending.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Pending</div>
                                    </div>
                                    <div style="background: #f3e5f5; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #9c27b0;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #6a1b9a;">${fullyPaidOrders}/${customerOrders.length}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Fully Paid</div>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- All Orders -->
                            <div>
                                <h3 style="margin: 0 0 1rem 0;">üìã All Orders</h3>
                                ${customerOrders.length === 0 ? '<p style="text-align: center; color: #999; padding: 2rem;">No orders found for this customer.</p>' : customerOrders.map(order => {
                                    const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                                    const totalPaid = parseFloat(order.financials?.advancePaid || 0);
                                    const balanceDue = parseFloat(order.financials?.balanceDue || 0);
                                    const paymentProgress = orderTotal > 0 ? (totalPaid / orderTotal) * 100 : 0;
                                    const paymentStatus = order.financials?.paymentStatus || 'pending';

                                    // Get payment history for this order
                                    const orderPayments = this.data.payments.filter(p => p.orderDocId === order.docId || p.orderId === order.orderId);

                                    // Get items
                                    let items = [];
                                    if (order.isMultiDay && order.dayWiseData) {
                                        order.dayWiseData.forEach(day => {
                                            if (day.functions) {
                                                day.functions.forEach(func => {
                                                    if (func.items) {
                                                        items.push(...func.items);
                                                    }
                                                });
                                            }
                                        });
                                    } else if (order.items) {
                                        items = order.items;
                                    }

                                    const statusColors = {
                                        'confirmed': '#2196f3',
                                        'pending': '#ff9800',
                                        'completed': '#4caf50',
                                        'cancelled': '#f44336'
                                    };
                                    const statusColor = statusColors[order.status?.toLowerCase()] || '#9e9e9e';

                                    return `
                                        <div style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem; background: white;">
                                            <!-- Order Header -->
                                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                                                <div>
                                                    <h4 style="margin: 0 0 0.5rem 0; color: #667eea; font-size: 1.1rem;">${order.orderId || 'Pending'}</h4>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        üìÖ ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}
                                                    </p>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        üìç ${order.venue || 'N/A'}
                                                    </p>
                                                </div>
                                                <div style="text-align: right;">
                                                    <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${order.status || 'Pending'}</span>
                                                    ${canViewFinancials ? `
                                                        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                                                            Total: <strong style="color: #667eea;">‚Çπ${orderTotal.toLocaleString('en-IN')}</strong>
                                                        </div>
                                                    ` : ''}
                                                </div>
                                            </div>

                                            ${canViewFinancials ? `
                                                <!-- Payment Progress -->
                                                <div style="background: #f5f5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                                        <span style="font-size: 0.9rem; font-weight: 600;">Payment Status</span>
                                                        <span style="font-size: 0.9rem; font-weight: bold; color: ${paymentProgress === 100 ? '#4caf50' : '#667eea'};">
                                                            ${paymentProgress.toFixed(0)}% (‚Çπ${totalPaid.toLocaleString('en-IN')} / ‚Çπ${orderTotal.toLocaleString('en-IN')})
                                                        </span>
                                                    </div>
                                                    <div style="width: 100%; height: 10px; background: #e0e0e0; border-radius: 5px; overflow: hidden;">
                                                        <div style="width: ${paymentProgress}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                                                    </div>
                                                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                                                        <span>‚úÖ Paid: ‚Çπ${totalPaid.toLocaleString('en-IN')}</span>
                                                        <span>‚è≥ Due: ‚Çπ${balanceDue.toLocaleString('en-IN')}</span>
                                                    </div>
                                                </div>

                                                <!-- Payment History -->
                                                ${orderPayments.length > 0 ? `
                                                    <details style="margin-bottom: 1rem;">
                                                        <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">üí≥ Payment History (${orderPayments.length} payments)</summary>
                                                        <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                            ${orderPayments.map(payment => `
                                                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #eee;">
                                                                    <div>
                                                                        <div style="font-weight: 600; color: #333;">${payment.paymentType || 'Payment'}</div>
                                                                        <div style="font-size: 0.85rem; color: #666;">${Utils.formatDate(payment.paymentDate || payment.timestamp?.toDate?.())} ‚Ä¢ ${payment.paymentMethod}</div>
                                                                    </div>
                                                                    <div style="font-weight: bold; color: #4caf50;">‚Çπ${parseFloat(payment.amount).toLocaleString('en-IN')}</div>
                                                                </div>
                                                            `).join('')}
                                                        </div>
                                                    </details>
                                                ` : '<p style="font-size: 0.85rem; color: #999; margin-bottom: 1rem;">No payments recorded yet.</p>'}
                                            ` : ''}

                                            <!-- Order Items -->
                                            <details>
                                                <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">üì¶ Items (${items.length})</summary>
                                                <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                    ${items.map(item => `
                                                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0;">
                                                            <span style="color: #333;">${item.name}</span>
                                                            <span style="font-weight: 600; color: #667eea;">x${item.quantity}</span>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </details>
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid #e0e0e0;">
                                <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('customerProfileModal')">Close</button>
                                <button type="button" class="btn btn-primary" onclick="OMS.createOrderForCustomer('${customerId}'); OMS.closeModal('customerProfileModal');">‚ûï New Order</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ QUOTATIONS MANAGEMENT ============

            renderQuotations() {
                const container = document.getElementById('quotations');

                // Initialize quotations data if not exists
                if (!this.data.quotations) {
                    this.data.quotations = [];
                }

                const viewMode = this.quotationViewMode || 'list'; // 'list' or 'create'

                if (viewMode === 'create' || viewMode === 'edit') {
                    this.renderQuotationForm();
                } else {
                    this.renderQuotationsList();
                }
            },

            renderQuotationsList() {
                const container = document.getElementById('quotations');
                const quotations = this.data.quotations || [];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìÑ Quotations</h2>
                            <button class="btn btn-success" onclick="OMS.createNewQuotation()">‚ûï Create New Quotation</button>
                        </div>

                        <div class="form-row">
                            <input type="text" id="quotationSearch" class="form-input" placeholder="Search quotations by customer, date...">
                        </div>

                        <div id="quotationsListContainer">
                            ${quotations.length === 0 ? `
                                <div style="text-align: center; padding: 3rem; color: #999;">
                                    <h3>üìÑ No Quotations Yet</h3>
                                    <p>Create your first quotation to get started</p>
                                    <button class="btn btn-primary" onclick="OMS.createNewQuotation()">Create Quotation</button>
                                </div>
                            ` : this.renderQuotationsTable(quotations)}
                        </div>
                    </div>
                `;

                // Add search listener
                setTimeout(() => {
                    const searchInput = document.getElementById('quotationSearch');
                    if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                            this.filterQuotations(e.target.value);
                        });
                    }
                }, 100);
            },

            renderQuotationsTable(quotations) {
                const sortedQuotations = quotations.sort((a, b) =>
                    new Date(b.createdAt) - new Date(a.createdAt)
                );

                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Customer</th>
                                    <th>Event Date</th>
                                    <th>Amount</th>
                                    <th>Status</th>
                                    <th>Created</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedQuotations.map(q => `
                                    <tr>
                                        <td>
                                            <strong>${q.customer.name}</strong><br>
                                            <small>${q.customer.contact}</small>
                                        </td>
                                        <td>${Utils.formatDate(q.customer.eventDate)}</td>
                                        <td><strong>‚Çπ${q.financials.grandTotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <span class="status-badge ${q.status === 'converted' ? 'success' : q.status === 'sent' ? 'info' : 'warning'}">
                                                ${q.status === 'converted' ? '‚úì Converted' : q.status === 'sent' ? 'üì§ Sent' : 'üìù Draft'}
                                            </span>
                                        </td>
                                        <td><small>${Utils.formatDate(q.createdAt)}</small></td>
                                        <td>
                                            <div class="btn-group">
                                                <button class="btn btn-info btn-small" onclick="OMS.viewQuotationPDF('${q.id}')" title="View PDF">üëÅÔ∏è</button>
                                                <button class="btn btn-primary btn-small" onclick="OMS.editQuotation('${q.id}')" title="Edit">‚úèÔ∏è</button>
                                                ${q.status !== 'converted' ? `<button class="btn btn-warning btn-small" onclick="OMS.convertQuotationToOrder('${q.id}')" title="Convert to Order">üîÑ</button>` : ''}
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteQuotation('${q.id}')" title="Delete">üóëÔ∏è</button>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            filterQuotations(searchQuery) {
                const quotations = this.data.quotations || [];
                let filteredQuotations = quotations;

                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredQuotations = quotations.filter(q => {
                        return (
                            (q.customer.name && q.customer.name.toLowerCase().includes(query)) ||
                            (q.customer.contact && q.customer.contact.includes(query)) ||
                            (q.customer.eventVenue && q.customer.eventVenue.toLowerCase().includes(query)) ||
                            (q.quotationNumber && q.quotationNumber.toLowerCase().includes(query))
                        );
                    });
                }

                document.getElementById('quotationsListContainer').innerHTML = this.renderQuotationsTable(filteredQuotations);
            },

            createNewQuotation() {
                this.editingQuotationId = null;
                this.currentQuotation = {
                    orderType: 'single', // 'single', 'multifunction', 'multiday'
                    items: [],
                    functions: [], // For multifunction single day
                    days: [], // For multiday orders
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                this.quotationViewMode = 'create';
                Quotations.renderQuotations(this);
            },

            renderQuotationForm() {
                const container = document.getElementById('quotations');
                const q = this.currentQuotation || {
                    items: [],
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                const isEditing = !!this.editingQuotationId;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h2 class="card-title">üìù ${isEditing ? 'Edit' : 'Create'} Quotation</h2>
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">‚Üê Back to List</button>
                            </div>
                        </div>

                        <!-- Order Type Selection -->
                        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h3 style="color: white; margin: 0 0 1rem 0;">üìã Order Type</h3>
                            <p style="color: rgba(255,255,255,0.9); margin-bottom: 1rem; font-size: 0.9rem;">Select the type of quotation you want to create</p>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                                <button type="button" class="order-type-btn ${!q.orderType || q.orderType === 'single' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('single')" style="padding: 1.5rem; background: ${!q.orderType || q.orderType === 'single' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${!q.orderType || q.orderType === 'single' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìù</div>
                                    <div>Single Function</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">One event, one day</div>
                                </button>
                                <button type="button" class="order-type-btn ${q.orderType === 'multifunction' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('multifunction')" style="padding: 1.5rem; background: ${q.orderType === 'multifunction' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${q.orderType === 'multifunction' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìã</div>
                                    <div>Multiple Functions</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">Same day, different events</div>
                                </button>
                                <button type="button" class="order-type-btn ${q.orderType === 'multiday' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('multiday')" style="padding: 1.5rem; background: ${q.orderType === 'multiday' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${q.orderType === 'multiday' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìÖ</div>
                                    <div>Multiple Days</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">Multiple days & functions</div>
                                </button>
                            </div>
                        </div>

                        <div class="card" style="background: #f9f9f9;">
                            <!-- Customer Details -->
                            <h3 style="margin: 0 0 1rem 0;">üë§ Customer Details</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label required">Customer Name</label>
                                    <input type="text" id="quotCustomerName" class="form-input" value="${q.customer.name || ''}" required placeholder="Enter customer name" list="customerNamesList" oninput="OMS.autoFillQuotationCustomer(this.value)">
                                    <datalist id="customerNamesList">
                                        ${this.data.customers.map(c => `<option value="${c.name}" data-contact="${c.contact}">`).join('')}
                                    </datalist>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Contact Number (Optional)</label>
                                    <input type="tel" id="quotCustomerContact" class="form-input" value="${q.customer.contact || ''}" placeholder="Enter contact number (optional)">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Email (Optional)</label>
                                    <input type="email" id="quotCustomerEmail" class="form-input" value="${q.customer.email || ''}" placeholder="Enter email">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Event Date</label>
                                    <input type="date" id="quotEventDate" class="form-input" value="${q.customer.eventDate || ''}" required>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Event Venue (Live Location Search)</label>
                                <input type="text" id="quotEventVenue" class="form-input" value="${q.customer.eventVenue || ''}" placeholder="üîç Search for venue location...">
                                <div id="quotSelectedVenueDisplay" style="display: ${q.customer.eventVenue ? 'block' : 'none'}; margin-top: 0.5rem; padding: 0.75rem; background: white; border-radius: 8px; border: 1px solid #e0e0e0;">
                                    <div style="display: flex; align-items: start; gap: 0.5rem;">
                                        <div style="font-size: 1.5rem;">üìç</div>
                                        <div style="flex: 1;">
                                            <div style="font-weight: 600; color: #1976D2;">${q.customer.eventVenueName || q.customer.eventVenue || ''}</div>
                                            <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">${q.customer.eventVenue || ''}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Notes (Optional)</label>
                                <textarea id="quotNotes" class="form-input" rows="3" placeholder="Add any special notes, requests, or instructions for this quotation...">${q.notes || ''}</textarea>
                            </div>
                        </div>

                        <!-- Items/Functions Section - Conditional based on order type -->
                        ${!q.orderType || q.orderType === 'single' ? `
                        <!-- Single Function Items -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">üì¶ Items</h3>
                            <div class="form-group" style="position: relative;">
                                <input type="text" id="quotItemSearch" class="form-input quotItemSearch" data-context="single" placeholder="üîç Search items from inventory or add custom...">
                                <div id="quotItemSearchResults" class="search-dropdown" style="display: none;"></div>
                            </div>

                            <div id="quotationItemsContainer">
                                ${q.items && q.items.length === 0 ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No items added yet. Search and add items above.</p>
                                    </div>
                                ` : this.renderQuotationItems(q.items || [])}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addCustomQuotationItem()">‚ûï Add Custom Item</button>
                        </div>
                        ` : ''}

                        ${q.orderType === 'multifunction' ? `
                        <!-- Multiple Functions - Same Day -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">üìã Functions</h3>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">Add multiple functions for the same day event</p>

                            <div id="quotMultiFunctionsContainer">
                                ${(q.functions || []).map((func, idx) => this.renderQuotationFunction(func, idx)).join('')}
                                ${(!q.functions || q.functions.length === 0) ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No functions added yet. Click below to add your first function.</p>
                                    </div>
                                ` : ''}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addQuotationFunction()">‚ûï Add Function</button>
                        </div>
                        ` : ''}

                        ${q.orderType === 'multiday' ? `
                        <!-- Multiple Days -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">üìÖ Days & Functions</h3>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">Add days with functions and items for each day</p>

                            <div id="quotMultiDaysContainer">
                                ${(q.days || []).map((day, idx) => this.renderQuotationDay(day, idx)).join('')}
                                ${(!q.days || q.days.length === 0) ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No days added yet. Click below to add your first day.</p>
                                    </div>
                                ` : ''}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addQuotationDay()">‚ûï Add Day</button>
                        </div>
                        ` : ''}

                        <!-- Discount Section -->
                        <div class="card" style="background: #fff3cd;">
                            <h3 style="margin: 0 0 1rem 0;">üí∞ Discount</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Discount Type</label>
                                    <select id="quotDiscountType" class="form-select" onchange="OMS.updateQuotationDiscount()">
                                        <option value="percentage" ${q.discount.type === 'percentage' ? 'selected' : ''}>Percentage (%)</option>
                                        <option value="fixed" ${q.discount.type === 'fixed' ? 'selected' : ''}>Fixed Amount (‚Çπ)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Discount Value</label>
                                    <input type="number" id="quotDiscountValue" class="form-input" value="${q.discount.value || 0}" min="0" step="0.01" oninput="OMS.updateQuotationDiscount()">
                                </div>
                            </div>
                        </div>

                        <!-- Financial Summary -->
                        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h3 style="color: white; margin: 0 0 1.5rem 0;">üíµ Financial Summary</h3>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Subtotal:</span>
                                    <strong id="quotSubtotal">‚Çπ0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Discount:</span>
                                    <strong id="quotDiscountAmount">- ‚Çπ0</strong>
                                </div>
                                <hr style="border-color: rgba(255,255,255,0.3);">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; font-size: 1.25rem;">
                                    <span><strong>Grand Total:</strong></span>
                                    <strong id="quotGrandTotal">‚Çπ0</strong>
                                </div>
                            </div>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px;">
                                <h4 style="color: white; margin: 0 0 1rem 0; font-size: 1rem;">Payment Schedule:</h4>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Booking Amount (50%):</span>
                                    <strong id="quotBooking50">‚Çπ0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Before Event (50%):</span>
                                    <strong id="quotBeforeEvent50">‚Çπ0</strong>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div class="card">
                            <div class="btn-group">
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">Cancel</button>
                                <button class="btn btn-info" onclick="OMS.previewQuotationPDF()">üëÅÔ∏è Preview PDF</button>
                                <button class="btn btn-primary" onclick="OMS.saveQuotation('draft')">üíæ Save as Draft</button>
                                <button class="btn btn-success" onclick="OMS.saveQuotation('sent')">üíæ Save Quotation</button>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize item search and Google Maps autocomplete after render
                setTimeout(() => {
                    this.initQuotationItemSearch();
                    this.initQuotationVenueAutocomplete();
                    this.recalculateQuotation();
                }, 100);
            },

            renderQuotationItems(items) {
                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th style="width: 4%;">#</th>
                                    <th style="width: 20%;">Item Name</th>
                                    <th style="width: 25%;">Notes/Description</th>
                                    <th style="width: 10%;">Quantity</th>
                                    <th style="width: 15%;">Rate (‚Çπ)</th>
                                    <th style="width: 15%;">Subtotal</th>
                                    <th style="width: 4%;"></th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>
                                            <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationItem(${index}, 'name', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <textarea class="form-input" onchange="OMS.updateQuotationItem(${index}, 'notes', this.value)" placeholder="Add description..." style="width: 100%; min-height: 60px; resize: vertical;">${item.notes || ''}</textarea>
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.quantity}" min="1" onchange="OMS.updateQuotationItem(${index}, 'quantity', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.rate}" min="0" step="0.01" onchange="OMS.updateQuotationItem(${index}, 'rate', this.value)" style="width: 100%;">
                                        </td>
                                        <td><strong>‚Çπ${item.subtotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <button class="btn btn-danger btn-small" onclick="OMS.removeQuotationItem(${index})" title="Remove">√ó</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            initQuotationItemSearch() {
                // Setup search for all quotItemSearch inputs using event delegation
                const container = document.getElementById('quotations');
                if (!container) return;

                // Remove old listeners
                const oldSearchInputs = container.querySelectorAll('.quotItemSearch');
                oldSearchInputs.forEach(input => {
                    const clone = input.cloneNode(true);
                    input.parentNode.replaceChild(clone, input);
                });

                // Add listeners to all search inputs
                container.addEventListener('input', (e) => {
                    if (!e.target.classList.contains('quotItemSearch')) return;

                    const searchInput = e.target;
                    const query = searchInput.value.toLowerCase().trim();
                    const context = searchInput.dataset.context;
                    const funcIndex = searchInput.dataset.funcIndex;
                    const dayIndex = searchInput.dataset.dayIndex;

                    // Create or get dropdown
                    let dropdown = searchInput.parentElement.querySelector('.search-dropdown');
                    if (!dropdown) {
                        dropdown = document.createElement('div');
                        dropdown.className = 'search-dropdown';
                        dropdown.style.cssText = 'position: absolute; top: 100%; left: 0; right: 0; margin-top: 4px; z-index: 1000; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-height: 250px; overflow-y: auto; display: none;';
                        searchInput.parentElement.style.position = 'relative';
                        searchInput.parentElement.appendChild(dropdown);
                    }

                    if (query.length < 2) {
                        dropdown.style.display = 'none';
                        return;
                    }

                    // Search from inventory
                    const items = this.data.inventory?.items || [];
                    const matches = items.filter(item =>
                        item.name.toLowerCase().includes(query)
                    ).slice(0, 10);

                    if (matches.length > 0) {
                        dropdown.innerHTML = matches.map(item => {
                            const onclickHandler = context === 'single'
                                ? `OMS.selectQuotationItem('${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`
                                : context === 'multifunction'
                                ? `OMS.selectQuotationFunctionItem(${funcIndex}, '${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`
                                : `OMS.selectQuotationDayFunctionItem(${dayIndex}, ${funcIndex}, '${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`;

                            return `
                                <div onclick="${onclickHandler}"
                                     style="padding: 0.75rem 1rem; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s;"
                                     onmouseover="this.style.background='#f5f5f5'"
                                     onmouseout="this.style.background='white'">
                                    <div style="font-weight: 500;">${item.name}</div>
                                    <div style="font-size: 0.85rem; color: #666;">
                                        ${item.category ? `Category: ${item.category} ‚Ä¢ ` : ''}
                                        Price: ‚Çπ${(item.defaultPrice || 0).toLocaleString('en-IN')}
                                    </div>
                                </div>
                            `;
                        }).join('');
                        dropdown.style.display = 'block';
                    } else {
                        dropdown.style.display = 'none';
                    }
                });

                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('quotItemSearch')) {
                        container.querySelectorAll('.search-dropdown').forEach(d => d.style.display = 'none');
                    }
                });
            },

            initQuotationVenueAutocomplete() {
                if (typeof google === 'undefined' || !google.maps) {
                    console.log('‚è≥ Google Maps not loaded yet for quotation, retrying...');
                    setTimeout(() => this.initQuotationVenueAutocomplete(), 500);
                    return;
                }

                const venueInput = document.getElementById('quotEventVenue');
                if (!venueInput) {
                    console.log('Quotation venue input not found');
                    return;
                }

                try {
                    const autocomplete = new google.maps.places.Autocomplete(venueInput, {
                        componentRestrictions: { country: 'in' },
                        fields: ['name', 'formatted_address', 'geometry', 'place_id']
                    });

                    autocomplete.addListener('place_changed', () => {
                        const place = autocomplete.getPlace();
                        if (!place.geometry) return;

                        // Update current quotation with venue data
                        if (!this.currentQuotation.customer) {
                            this.currentQuotation.customer = {};
                        }
                        this.currentQuotation.customer.eventVenue = place.formatted_address;
                        this.currentQuotation.customer.eventVenueName = place.name;
                        this.currentQuotation.customer.eventVenueCoordinates = {
                            lat: place.geometry.location.lat(),
                            lng: place.geometry.location.lng()
                        };

                        // Update input value
                        venueInput.value = place.formatted_address;

                        // Show selected venue
                        const display = document.getElementById('quotSelectedVenueDisplay');
                        if (display) {
                            display.innerHTML = `
                                <div style="display: flex; align-items: start; gap: 0.5rem;">
                                    <div style="font-size: 1.5rem;">üìç</div>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; color: #1976D2;">${place.name}</div>
                                        <div style="font-size: 0.875rem; color: #666; margin-top: 0.25rem;">${place.formatted_address}</div>
                                    </div>
                                </div>
                            `;
                            display.style.display = 'block';
                        }

                        console.log('‚úÖ Quotation venue selected:', place.name);
                    });

                    console.log('‚úÖ Quotation venue autocomplete initialized');
                } catch (error) {
                    console.error('Error initializing quotation venue autocomplete:', error);
                }
            },

            selectQuotationFunctionItem(funcIndex, itemName, price) {
                if (!this.currentQuotation.functions[funcIndex].items) {
                    this.currentQuotation.functions[funcIndex].items = [];
                }
                this.currentQuotation.functions[funcIndex].items.push({
                    name: itemName,
                    quantity: 1,
                    price: price || 0
                });
                Quotations.renderQuotations(this);
            },

            selectQuotationDayFunctionItem(dayIndex, funcIndex, itemName, price) {
                if (!this.currentQuotation.days[dayIndex].functions[funcIndex].items) {
                    this.currentQuotation.days[dayIndex].functions[funcIndex].items = [];
                }
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.push({
                    name: itemName,
                    quantity: 1,
                    price: price || 0
                });
                Quotations.renderQuotations(this);
            },

            selectQuotationItem(itemName, price) {
                const dropdown = document.getElementById('quotItemSearchDropdown');
                const searchInput = document.getElementById('quotItemSearch');

                if (dropdown) dropdown.style.display = 'none';
                if (searchInput) searchInput.value = '';

                // Add item with price from inventory
                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: price || 0,
                    subtotal: price || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addQuotationItemByName(itemName) {
                // Search in inventory first
                const inventoryItem = this.data.inventory?.items?.find(i =>
                    i.name.toLowerCase() === itemName.toLowerCase()
                );

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: inventoryItem?.defaultPrice || 0,
                    subtotal: inventoryItem?.defaultPrice || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addCustomQuotationItem() {
                const itemName = prompt('Enter item name:');
                if (!itemName) return;

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: 0,
                    subtotal: 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            updateQuotationItem(index, field, value) {
                if (!this.currentQuotation.items[index]) return;

                // Validation for price and quantity fields
                if (field === 'quantity' || field === 'rate') {
                    const numValue = parseFloat(value) || 0;

                    // Prevent negative values
                    if (numValue < 0) {
                        this.showToast(`${field === 'quantity' ? 'Quantity' : 'Price'} cannot be negative`, 'error');
                        return;
                    }

                    // Warn about very large values
                    if (numValue > 10000000) { // 1 crore
                        if (!confirm(`${field === 'quantity' ? 'Quantity' : 'Price'} is very large (${numValue.toLocaleString('en-IN')}). Continue?`)) {
                            return;
                        }
                    }

                    this.currentQuotation.items[index][field] = numValue;
                } else {
                    // Name field - trim whitespace
                    this.currentQuotation.items[index][field] = value.trim();
                }

                // Recalculate subtotal
                const item = this.currentQuotation.items[index];
                item.subtotal = item.quantity * item.rate;

                this.recalculateQuotation();
                this.updateQuotationDisplay();
            },

            removeQuotationItem(index) {
                this.currentQuotation.items.splice(index, 1);
                this.updateQuotationDisplay();
            },

            updateQuotationDiscount() {
                const type = Utils.get('quotDiscountType');
                let value = parseFloat(Utils.get('quotDiscountValue')) || 0;

                // Validate discount value
                if (value < 0) {
                    this.showToast('Discount cannot be negative', 'error');
                    Utils.set('quotDiscountValue', 0);
                    return;
                }

                // Prevent percentage discount > 100%
                if (type === 'percentage' && value > 100) {
                    this.showToast('Discount percentage cannot exceed 100%', 'error');
                    Utils.set('quotDiscountValue', 100);
                    value = 100;
                }

                // Warn if fixed discount exceeds subtotal (will be checked during recalculation)
                if (type === 'fixed' && value > this.currentQuotation.financials.subtotal) {
                    this.showToast('Warning: Discount exceeds subtotal. Grand total will be ‚Çπ0.', 'warning');
                }

                this.currentQuotation.discount = { type, value, amount: 0 };
                this.recalculateQuotation();
            },

            recalculateQuotation() {
                const q = this.currentQuotation;
                if (!q) return;

                let totalSubtotal = 0;

                // Calculate based on order type
                if (!q.orderType || q.orderType === 'single') {
                    // Single function order - calculate from q.items
                    // Note: Single function uses 'rate' field, not 'price'
                    if (q.items && q.items.length > 0) {
                        q.items.forEach(item => {
                            const price = parseFloat(item.rate || item.price) || 0;
                            const quantity = parseFloat(item.quantity) || 0;
                            item.subtotal = price * quantity;
                            totalSubtotal += item.subtotal;
                        });
                    }
                } else if (q.orderType === 'multifunction') {
                    // Multifunction order - calculate from q.functions
                    if (q.functions && q.functions.length > 0) {
                        q.functions.forEach(func => {
                            let functionSubtotal = 0;
                            if (func.items && func.items.length > 0) {
                                func.items.forEach(item => {
                                    const price = parseFloat(item.price) || 0;
                                    const quantity = parseFloat(item.quantity) || 0;
                                    item.subtotal = price * quantity;
                                    functionSubtotal += item.subtotal;
                                });
                            }
                            func.subtotal = functionSubtotal;
                            totalSubtotal += functionSubtotal;
                        });
                    }
                } else if (q.orderType === 'multiday') {
                    // Multiday order - calculate from q.days
                    if (q.days && q.days.length > 0) {
                        q.days.forEach(day => {
                            let daySubtotal = 0;
                            if (day.functions && day.functions.length > 0) {
                                day.functions.forEach(func => {
                                    let functionSubtotal = 0;
                                    if (func.items && func.items.length > 0) {
                                        func.items.forEach(item => {
                                            const price = parseFloat(item.price) || 0;
                                            const quantity = parseFloat(item.quantity) || 0;
                                            item.subtotal = price * quantity;
                                            functionSubtotal += item.subtotal;
                                        });
                                    }
                                    func.subtotal = functionSubtotal;
                                    daySubtotal += functionSubtotal;
                                });
                            }
                            day.subtotal = daySubtotal;
                            totalSubtotal += daySubtotal;
                        });
                    }
                }

                // Update quotation financials
                q.financials.subtotal = totalSubtotal;

                // Calculate discount
                if (q.discount.type === 'percentage') {
                    q.financials.discountAmount = (q.financials.subtotal * q.discount.value) / 100;
                } else {
                    q.financials.discountAmount = parseFloat(q.discount.value) || 0;
                }

                // Calculate grand total
                q.financials.grandTotal = Math.max(0, q.financials.subtotal - q.financials.discountAmount);

                // Calculate payment schedule (50/50 split)
                q.financials.booking50 = (q.financials.grandTotal * 0.5).toFixed(2);
                q.financials.beforeEvent50 = (q.financials.grandTotal * 0.5).toFixed(2);

                // Update display
                this.updateFinancialDisplay();
            },

            updateFinancialDisplay() {
                const q = this.currentQuotation;
                if (!q) return;

                const subtotalEl = document.getElementById('quotSubtotal');
                const discountEl = document.getElementById('quotDiscountAmount');
                const grandTotalEl = document.getElementById('quotGrandTotal');
                const booking50El = document.getElementById('quotBooking50');
                const beforeEvent50El = document.getElementById('quotBeforeEvent50');

                if (subtotalEl) subtotalEl.textContent = `‚Çπ${q.financials.subtotal.toLocaleString('en-IN')}`;
                if (discountEl) discountEl.textContent = `- ‚Çπ${q.financials.discountAmount.toLocaleString('en-IN')}`;
                if (grandTotalEl) grandTotalEl.textContent = `‚Çπ${q.financials.grandTotal.toLocaleString('en-IN')}`;
                if (booking50El) booking50El.textContent = `‚Çπ${parseFloat(q.financials.booking50).toLocaleString('en-IN')}`;
                if (beforeEvent50El) beforeEvent50El.textContent = `‚Çπ${parseFloat(q.financials.beforeEvent50).toLocaleString('en-IN')}`;
            },

            updateQuotationDisplay() {
                const container = document.getElementById('quotationItemsContainer');
                if (container && this.currentQuotation) {
                    container.innerHTML = this.currentQuotation.items.length === 0 ?
                        `<div style="text-align: center; padding: 2rem; color: #999;"><p>No items added yet. Search and add items above.</p></div>` :
                        this.renderQuotationItems(this.currentQuotation.items);
                }
                this.recalculateQuotation();
            },

            autoFillQuotationCustomer(customerName) {
                // Find customer by name and auto-fill contact
                const customer = this.data.customers.find(c => c.name === customerName);
                if (customer) {
                    document.getElementById('quotCustomerContact').value = customer.contact || '';
                    if (customer.email) {
                        document.getElementById('quotCustomerEmail').value = customer.email;
                    }
                }
            },

            // CRITICAL FIX: Helper to save customer data from form fields before re-rendering
            saveQuotationCustomerData() {
                if (!this.currentQuotation) {
                    console.warn('‚ö†Ô∏è saveQuotationCustomerData: No currentQuotation');
                    return;
                }

                console.log('üíæ saveQuotationCustomerData: Reading form fields...');

                const customerName = Utils.get('quotCustomerName');
                const customerContact = Utils.get('quotCustomerContact');
                const customerEmail = Utils.get('quotCustomerEmail');
                const eventDate = Utils.get('quotEventDate');
                const eventVenue = Utils.get('quotEventVenue');
                const notes = Utils.get('quotNotes');

                console.log('üìù Form field values:');
                console.log('  - Name:', customerName);
                console.log('  - Contact:', customerContact);
                console.log('  - Email:', customerEmail);
                console.log('  - Date:', eventDate);
                console.log('  - Venue:', eventVenue);
                console.log('  - Notes:', notes);

                // Initialize customer object if it doesn't exist
                if (!this.currentQuotation.customer) {
                    console.log('‚öôÔ∏è Initializing customer object');
                    this.currentQuotation.customer = {};
                }

                // Update customer data from form fields
                this.currentQuotation.customer = {
                    ...this.currentQuotation.customer,
                    name: customerName || this.currentQuotation.customer.name || '',
                    contact: customerContact || this.currentQuotation.customer.contact || '',
                    email: customerEmail || this.currentQuotation.customer.email || '',
                    eventDate: eventDate || this.currentQuotation.customer.eventDate || '',
                    eventVenue: eventVenue || this.currentQuotation.customer.eventVenue || ''
                };

                this.currentQuotation.notes = notes || this.currentQuotation.notes || '';

                console.log('‚úÖ Updated customer data:', this.currentQuotation.customer);
            },

            setQuotationOrderType(type) {
                if (!this.currentQuotation) return;

                // Save customer data BEFORE re-rendering to prevent data loss
                this.saveQuotationCustomerData();

                this.currentQuotation.orderType = type;

                // Initialize appropriate data structures
                if (type === 'single') {
                    if (!this.currentQuotation.items) this.currentQuotation.items = [];
                } else if (type === 'multifunction') {
                    if (!this.currentQuotation.functions) this.currentQuotation.functions = [];
                } else if (type === 'multiday') {
                    if (!this.currentQuotation.days) this.currentQuotation.days = [];
                }

                Quotations.renderQuotations(this);
            },

            renderQuotationFunction(func, index) {
                const items = func.items || [];
                return `
                    <div class="card" style="background: #f9f9f9; margin-bottom: 1rem; border-left: 4px solid var(--primary);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0;">Function ${index + 1}: ${func.name || 'Unnamed Function'}</h4>
                            <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationFunction(${index})">üóëÔ∏è Remove</button>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Function Type</label>
                            <input type="text" class="form-input" value="${func.name || ''}" list="quotFunctionsList"
                                   onchange="OMS.updateQuotationFunctionName(${index}, this.value)"
                                   placeholder="e.g., Sangeet, Reception, Haldi">
                            <datalist id="quotFunctionsList">
                                ${this.data.eventsList.map(event => `<option value="${event}">`).join('')}
                            </datalist>
                        </div>
                        <div class="form-group">
                            <label class="form-label">üìç Venue/Location (for this function)</label>
                            <input type="text" id="quotFunc_${index}_venue" class="form-input" value="${func.venue || ''}"
                                   onchange="OMS.updateQuotationFunctionField(${index}, 'venue', this.value)"
                                   placeholder="üîç Enter venue/location for this function...">
                        </div>
                        <div class="form-group">
                            <label class="form-label">üìù Notes (for this function)</label>
                            <textarea id="quotFunc_${index}_notes" class="form-input" rows="2"
                                      onchange="OMS.updateQuotationFunctionField(${index}, 'notes', this.value)"
                                      placeholder="Add notes specific to this function...">${func.notes || ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Items</label>
                            <div style="position: relative; margin-bottom: 0.5rem;">
                                <input type="text" class="form-input quotItemSearch" data-func-index="${index}" data-context="multifunction" placeholder="üîç Search items from inventory...">
                            </div>
                            <div id="quotFunctionItems_${index}">
                                ${items.map((item, itemIdx) => {
                                    const subtotal = (parseFloat(item.price) || 0) * (parseFloat(item.quantity) || 0);
                                    return `
                                    <div style="display: grid; grid-template-columns: 1.5fr 2fr 0.8fr 1fr 1fr auto; gap: 0.5rem; margin-bottom: 0.5rem; align-items: start;">
                                        <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'name', this.value)" placeholder="Item name">
                                        <textarea class="form-input" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'notes', this.value)" placeholder="Add notes/description..." style="min-height: 50px; resize: vertical;">${item.notes || ''}</textarea>
                                        <input type="number" class="form-input" value="${item.quantity}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'quantity', this.value)" placeholder="Qty">
                                        <input type="number" class="form-input" value="${item.price}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'price', this.value)" placeholder="Price">
                                        <div style="font-weight: 600; color: #2196F3;">‚Çπ${subtotal.toLocaleString('en-IN')}</div>
                                        <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationFunctionItem(${index}, ${itemIdx})">√ó</button>
                                    </div>
                                `;}).join('')}
                            </div>
                            ${items.length > 0 ? `<div style="text-align: right; font-weight: 700; color: #2196F3; margin-top: 0.5rem; padding: 0.5rem; background: #e3f2fd; border-radius: 4px;">Function Total: ‚Çπ${(func.subtotal || 0).toLocaleString('en-IN')}</div>` : ''}
                            <button type="button" class="btn btn-secondary btn-small" onclick="OMS.addQuotationFunctionItem(${index})">+ Add Item</button>
                        </div>
                    </div>
                `;
            },

            renderQuotationDay(day, dayIndex) {
                const functions = day.functions || [];
                return `
                    <div class="card" style="background: #e8f4f8; margin-bottom: 1rem; border-left: 4px solid #2196F3;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0;">üìÖ Day ${dayIndex + 1}: ${day.date || 'No date set'}</h4>
                            <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDay(${dayIndex})">üóëÔ∏è Remove Day</button>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Date</label>
                            <input type="date" class="form-input" value="${day.date || ''}" onchange="OMS.updateQuotationDayDate(${dayIndex}, this.value)">
                        </div>
                        <h5 style="margin: 1rem 0;">Functions for this day:</h5>
                        <div id="quotDayFunctions_${dayIndex}">
                            ${functions.map((func, funcIdx) => `
                                <div class="card" style="background: white; margin-bottom: 0.5rem;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <input type="text" class="form-input" style="flex: 1; margin-right: 0.5rem;" value="${func.name || ''}" list="quotFunctionsList_${dayIndex}_${funcIdx}"
                                               onchange="OMS.updateQuotationDayFunctionName(${dayIndex}, ${funcIdx}, this.value)"
                                               placeholder="Function type">
                                        <datalist id="quotFunctionsList_${dayIndex}_${funcIdx}">
                                            ${this.data.eventsList.map(event => `<option value="${event}">`).join('')}
                                        </datalist>
                                        <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDayFunction(${dayIndex}, ${funcIdx})">√ó</button>
                                    </div>
                                    <div style="margin-bottom: 0.5rem;">
                                        <label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; color: #666;">üìç Venue/Location</label>
                                        <input type="text" class="form-input" id="quotDayFunc_${dayIndex}_${funcIdx}_venue" value="${func.venue || ''}"
                                               onchange="OMS.updateQuotationDayFunctionField(${dayIndex}, ${funcIdx}, 'venue', this.value)"
                                               placeholder="Enter venue for this function...">
                                    </div>
                                    <div style="margin-bottom: 0.5rem;">
                                        <label style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; color: #666;">üìù Notes</label>
                                        <textarea class="form-input" id="quotDayFunc_${dayIndex}_${funcIdx}_notes" rows="2"
                                                  onchange="OMS.updateQuotationDayFunctionField(${dayIndex}, ${funcIdx}, 'notes', this.value)"
                                                  placeholder="Add notes for this function...">${func.notes || ''}</textarea>
                                    </div>
                                    <div style="position: relative; margin-bottom: 0.5rem;">
                                        <input type="text" class="form-input quotItemSearch" data-day-index="${dayIndex}" data-func-index="${funcIdx}" data-context="multiday" placeholder="üîç Search items...">
                                    </div>
                                    <div id="quotDayFunctionItems_${dayIndex}_${funcIdx}">
                                        ${(func.items || []).map((item, itemIdx) => {
                                            const subtotal = (parseFloat(item.price) || 0) * (parseFloat(item.quantity) || 0);
                                            return `
                                            <div style="display: grid; grid-template-columns: 1.5fr 2fr 0.8fr 1fr 1fr auto; gap: 0.5rem; margin-bottom: 0.5rem; align-items: start;">
                                                <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'name', this.value)" placeholder="Item">
                                                <textarea class="form-input" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'notes', this.value)" placeholder="Add notes/description..." style="min-height: 50px; resize: vertical;">${item.notes || ''}</textarea>
                                                <input type="number" class="form-input" value="${item.quantity}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'quantity', this.value)" placeholder="Qty">
                                                <input type="number" class="form-input" value="${item.price}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'price', this.value)" placeholder="Price">
                                                <div style="font-weight: 600; color: #2196F3;">‚Çπ${subtotal.toLocaleString('en-IN')}</div>
                                                <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx})">√ó</button>
                                            </div>
                                        `;}).join('')}
                                    </div>
                                    ${(func.items || []).length > 0 ? `<div style="text-align: right; font-weight: 700; color: #2196F3; margin-top: 0.5rem; padding: 0.5rem; background: #e3f2fd; border-radius: 4px;">Function Total: ‚Çπ${(func.subtotal || 0).toLocaleString('en-IN')}</div>` : ''}
                                    <button type="button" class="btn btn-secondary btn-small" onclick="OMS.addQuotationDayFunctionItem(${dayIndex}, ${funcIdx})">+ Add Item</button>
                                </div>
                            `).join('')}
                        </div>
                        ${functions.length > 0 ? `<div style="text-align: right; font-weight: 700; color: #1976D2; margin-top: 1rem; padding: 0.75rem; background: #bbdefb; border-radius: 4px; font-size: 1.1rem;">Day Total: ‚Çπ${(day.subtotal || 0).toLocaleString('en-IN')}</div>` : ''}
                        <button type="button" class="btn btn-primary btn-small" onclick="OMS.addQuotationDayFunction(${dayIndex})">+ Add Function</button>
                    </div>
                `;
            },

            addQuotationFunction() {
                this.saveQuotationCustomerData(); // Preserve customer data
                if (!this.currentQuotation.functions) this.currentQuotation.functions = [];
                this.currentQuotation.functions.push({ name: '', items: [] });
                Quotations.renderQuotations(this);
            },

            addQuotationDay() {
                this.saveQuotationCustomerData(); // Preserve customer data
                if (!this.currentQuotation.days) this.currentQuotation.days = [];
                this.currentQuotation.days.push({ date: '', functions: [] });
                Quotations.renderQuotations(this);
            },

            removeQuotationFunction(index) {
                if (confirm('Remove this function?')) {
                    this.saveQuotationCustomerData(); // Preserve customer data
                    this.currentQuotation.functions.splice(index, 1);
                    Quotations.renderQuotations(this);
                }
            },

            removeQuotationDay(index) {
                if (confirm('Remove this day?')) {
                    this.saveQuotationCustomerData(); // Preserve customer data
                    this.currentQuotation.days.splice(index, 1);
                    Quotations.renderQuotations(this);
                }
            },

            updateQuotationFunctionName(funcIndex, value) {
                this.currentQuotation.functions[funcIndex].name = value;
                this.recalculateQuotation();
            },

            updateQuotationFunctionField(funcIndex, field, value) {
                this.currentQuotation.functions[funcIndex][field] = value;
                // No need to recalculate for notes/venue fields
            },

            addQuotationFunctionItem(funcIndex) {
                if (!this.currentQuotation.functions[funcIndex].items) {
                    this.currentQuotation.functions[funcIndex].items = [];
                }
                this.currentQuotation.functions[funcIndex].items.push({ name: '', quantity: 1, price: 0 });
                Quotations.renderQuotations(this);
            },

            removeQuotationFunctionItem(funcIndex, itemIndex) {
                this.currentQuotation.functions[funcIndex].items.splice(itemIndex, 1);
                Quotations.renderQuotations(this);
            },

            updateQuotationFunctionItem(funcIndex, itemIndex, field, value) {
                // Validation for price and quantity fields
                if (field === 'quantity' || field === 'price') {
                    const numValue = parseFloat(value) || 0;

                    // Prevent negative values
                    if (numValue < 0) {
                        this.showToast(`${field === 'quantity' ? 'Quantity' : 'Price'} cannot be negative`, 'error');
                        return;
                    }

                    // Warn about very large values
                    if (numValue > 10000000) { // 1 crore
                        if (!confirm(`${field === 'quantity' ? 'Quantity' : 'Price'} is very large (${numValue.toLocaleString('en-IN')}). Continue?`)) {
                            return;
                        }
                    }

                    this.currentQuotation.functions[funcIndex].items[itemIndex][field] = numValue;
                } else {
                    // Name field - trim whitespace
                    this.currentQuotation.functions[funcIndex].items[itemIndex][field] = value.trim();
                }

                this.recalculateQuotation();
                Quotations.renderQuotations(this); // Re-render to show updated subtotals
            },

            updateQuotationDayDate(dayIndex, value) {
                this.currentQuotation.days[dayIndex].date = value;
            },

            addQuotationDayFunction(dayIndex) {
                if (!this.currentQuotation.days[dayIndex].functions) {
                    this.currentQuotation.days[dayIndex].functions = [];
                }
                this.currentQuotation.days[dayIndex].functions.push({ name: '', items: [] });
                Quotations.renderQuotations(this);
            },

            removeQuotationDayFunction(dayIndex, funcIndex) {
                this.currentQuotation.days[dayIndex].functions.splice(funcIndex, 1);
                Quotations.renderQuotations(this);
            },

            updateQuotationDayFunctionName(dayIndex, funcIndex, value) {
                this.currentQuotation.days[dayIndex].functions[funcIndex].name = value;
            },

            updateQuotationDayFunctionField(dayIndex, funcIndex, field, value) {
                this.currentQuotation.days[dayIndex].functions[funcIndex][field] = value;
                // No need to recalculate for notes/venue fields
            },

            addQuotationDayFunctionItem(dayIndex, funcIndex) {
                if (!this.currentQuotation.days[dayIndex].functions[funcIndex].items) {
                    this.currentQuotation.days[dayIndex].functions[funcIndex].items = [];
                }
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.push({ name: '', quantity: 1, price: 0 });
                Quotations.renderQuotations(this);
            },

            removeQuotationDayFunctionItem(dayIndex, funcIndex, itemIndex) {
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.splice(itemIndex, 1);
                Quotations.renderQuotations(this);
            },

            updateQuotationDayFunctionItem(dayIndex, funcIndex, itemIndex, field, value) {
                // Validation for price and quantity fields
                if (field === 'quantity' || field === 'price') {
                    const numValue = parseFloat(value) || 0;

                    // Prevent negative values
                    if (numValue < 0) {
                        this.showToast(`${field === 'quantity' ? 'Quantity' : 'Price'} cannot be negative`, 'error');
                        return;
                    }

                    // Warn about very large values
                    if (numValue > 10000000) { // 1 crore
                        if (!confirm(`${field === 'quantity' ? 'Quantity' : 'Price'} is very large (${numValue.toLocaleString('en-IN')}). Continue?`)) {
                            return;
                        }
                    }

                    this.currentQuotation.days[dayIndex].functions[funcIndex].items[itemIndex][field] = numValue;
                } else {
                    // Name field - trim whitespace
                    this.currentQuotation.days[dayIndex].functions[funcIndex].items[itemIndex][field] = value.trim();
                }

                this.recalculateQuotation();
                Quotations.renderQuotations(this); // Re-render to show updated subtotals
            },

            cancelQuotationEdit() {
                this.quotationViewMode = 'list';
                this.editingQuotationId = null;
                this.currentQuotation = null;
                Quotations.renderQuotations(this);
            },

            async saveQuotation(status = 'draft') {
                console.log('üîç DEBUG: saveQuotation called with status:', status);

                const q = this.currentQuotation;
                if (!q) {
                    console.error('‚ùå No currentQuotation object');
                    return;
                }

                console.log('üìã Current quotation object:', q);

                // CRITICAL: Save customer data from form fields FIRST before validation
                this.saveQuotationCustomerData();
                console.log('‚úÖ Saved customer data, updated quotation:', this.currentQuotation);

                // Validate - ONLY customer name and event date required (contact is optional)
                const customerName = this.currentQuotation.customer.name;
                const eventDate = this.currentQuotation.customer.eventDate;

                console.log('üîç Validation check:');
                console.log('  - Customer Name:', customerName);
                console.log('  - Event Date:', eventDate);

                if (!customerName || !eventDate) {
                    console.error('‚ùå Validation failed - missing required fields');
                    this.showToast('Please fill customer name and event date', 'error');
                    return;
                }

                console.log('‚úÖ Customer validation passed');

                // Validate items based on order type
                let hasItems = false;

                if (!q.orderType || q.orderType === 'single') {
                    // Single function - check q.items
                    hasItems = q.items && q.items.length > 0;
                    console.log('üì¶ Single order type - items count:', q.items?.length || 0);
                } else if (q.orderType === 'multifunction') {
                    // Multifunction - check if any function has items
                    hasItems = q.functions && q.functions.length > 0 &&
                               q.functions.some(func => func.items && func.items.length > 0);
                    console.log('üìã Multifunction order type - functions count:', q.functions?.length || 0);
                } else if (q.orderType === 'multiday') {
                    // Multiday - check if any day has functions with items
                    hasItems = q.days && q.days.length > 0 &&
                               q.days.some(day =>
                                   day.functions && day.functions.length > 0 &&
                                   day.functions.some(func => func.items && func.items.length > 0)
                               );
                    console.log('üìÖ Multiday order type - days count:', q.days?.length || 0);
                }

                console.log('üîç Has items?', hasItems);

                if (!hasItems) {
                    console.error('‚ùå No items found');
                    this.showToast('Please add at least one item to save quotation', 'error');
                    return;
                }

                console.log('‚úÖ Items validation passed');

                // Gather data - use the already saved customer data
                q.customer = {
                    name: customerName,
                    contact: this.currentQuotation.customer.contact || '', // Optional - can be empty
                    email: this.currentQuotation.customer.email || Utils.get('quotCustomerEmail'),
                    eventDate: eventDate,
                    eventVenue: this.currentQuotation.customer.eventVenue || Utils.get('quotEventVenue'),
                    eventVenueName: q.customer?.eventVenueName || '',
                    eventVenueCoordinates: q.customer?.eventVenueCoordinates || null
                };

                // Add notes field
                q.notes = this.currentQuotation.notes || Utils.get('quotNotes') || '';

                const quotationData = {
                    ...q,
                    status: status,
                    updatedAt: new Date().toISOString()
                };

                console.log('üíæ About to save quotation data:', quotationData);

                try {
                    if (this.editingQuotationId) {
                        // Update existing
                        quotationData.id = this.editingQuotationId;
                        quotationData.quotationNumber = q.quotationNumber;
                        quotationData.createdAt = q.createdAt;

                        await db.collection('quotations').doc(this.editingQuotationId).update(quotationData);
                        this.showToast('‚úÖ Quotation updated!', 'success');
                        console.log('‚úÖ Updated existing quotation:', this.editingQuotationId);
                    } else {
                        // Create new
                        quotationData.quotationNumber = await this.generateQuotationNumber();
                        quotationData.createdAt = new Date().toISOString();
                        quotationData.quotationDate = new Date().toISOString().split('T')[0];
                        quotationData.validUntil = this.calculateValidUntil();

                        const docRef = await db.collection('quotations').add(quotationData);
                        quotationData.id = docRef.id;

                        this.showToast('‚úÖ Quotation saved!', 'success');
                        console.log('‚úÖ Created new quotation:', docRef.id);
                    }

                    // Reload quotations
                    await Quotations.loadQuotationsFromFirestore(this);

                    // Return to list
                    this.quotationViewMode = 'list';
                    Quotations.renderQuotations(this);

                    return quotationData;
                } catch (error) {
                    console.error('‚ùå Error saving quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async generateQuotationNumber() {
                const year = new Date().getFullYear();
                const quotations = this.data.quotations || [];
                const thisYearQuotations = quotations.filter(q =>
                    q.quotationNumber && q.quotationNumber.startsWith(`QT-${year}`)
                );

                const nextNumber = thisYearQuotations.length + 1;
                return `QT-${year}-${String(nextNumber).padStart(3, '0')}`;
            },

            calculateValidUntil() {
                const date = new Date();
                date.setDate(date.getDate() + 15); // Valid for 15 days
                return date.toISOString().split('T')[0];
            },


            async editQuotation(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) {
                    this.showToast('Quotation not found', 'error');
                    return;
                }

                this.editingQuotationId = quotationId;
                this.currentQuotation = JSON.parse(JSON.stringify(quotation)); // Deep copy
                this.quotationViewMode = 'edit';
                Quotations.renderQuotations(this);
            },

            async deleteQuotation(quotationId) {
                if (!confirm('Delete this quotation?')) return;

                try {
                    await db.collection('quotations').doc(quotationId).delete();
                    this.showToast('‚úÖ Quotation deleted', 'success');

                    await Quotations.loadQuotationsFromFirestore(this);
                    Quotations.renderQuotations(this);
                } catch (error) {
                    console.error('Error deleting quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async loadQuotationsFromFirestore() {
                try {
                    const snapshot = await db.collection('quotations').orderBy('createdAt', 'desc').get();
                    const quotations = [];

                    snapshot.forEach(doc => {
                        quotations.push({ id: doc.id, ...doc.data() });
                    });

                    this.data.quotations = quotations;
                    console.log(`‚úÖ Loaded ${quotations.length} quotations`);
                } catch (error) {
                    console.error('Error loading quotations:', error);
                }
            },

            async viewQuotationPDF(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                this.generateAndShowPDF(quotation);
            },

            async previewQuotationPDF() {
                const q = this.currentQuotation;

                // Validate that quotation has items based on order type
                if (!q) {
                    this.showToast('No quotation found', 'error');
                    return;
                }

                let hasItems = false;

                if (!q.orderType || q.orderType === 'single') {
                    // Single function - check q.items
                    hasItems = q.items && q.items.length > 0;
                } else if (q.orderType === 'multifunction') {
                    // Multifunction - check if any function has items
                    hasItems = q.functions && q.functions.length > 0 &&
                               q.functions.some(func => func.items && func.items.length > 0);
                } else if (q.orderType === 'multiday') {
                    // Multiday - check if any day has functions with items
                    hasItems = q.days && q.days.length > 0 &&
                               q.days.some(day =>
                                   day.functions && day.functions.length > 0 &&
                                   day.functions.some(func => func.items && func.items.length > 0)
                               );
                }

                if (!hasItems) {
                    this.showToast('Add items first to preview quotation', 'error');
                    return;
                }

                // Create temporary quotation object for preview
                const tempQuotation = {
                    ...q,
                    customer: {
                        name: Utils.get('quotCustomerName') || 'Customer Name',
                        contact: Utils.get('quotCustomerContact') || '0000000000',
                        email: Utils.get('quotCustomerEmail') || '',
                        eventDate: Utils.get('quotEventDate') || '',
                        eventVenue: Utils.get('quotEventVenue') || ''
                    },
                    quotationDate: new Date().toISOString().split('T')[0],
                    validUntil: this.calculateValidUntil()
                };

                // Store temp quotation for preview actions
                this.previewQuotation = tempQuotation;

                this.generateAndShowPDF(tempQuotation);
            },

            generateAndShowPDF(quotation) {
                // Store quotation for download/actions
                this.previewQuotation = quotation;

                // This will use jsPDF or html2pdf - for now, show preview in modal
                const modalHTML = `
                    <div class="modal show" id="pdfPreviewModal" onclick="if(event.target === this) OMS.closeModal('pdfPreviewModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('pdfPreviewModal')">√ó</button>
                            <h2>üìÑ Quotation Preview</h2>

                            ${this.renderQuotationPDFContent(quotation)}

                            <div style="margin-top: 2rem; text-align: center;">
                                <button class="btn btn-primary" onclick="OMS.downloadPreviewPDF()">üì• Download PDF</button>
                                <button class="btn btn-secondary" onclick="OMS.closeModal('pdfPreviewModal')">Close</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async downloadPreviewPDF() {
                const quotation = this.previewQuotation;
                if (!quotation) {
                    this.showToast('No quotation data found', 'error');
                    return;
                }

                // Use the existing downloadQuotationPDF logic but with preview data
                await this.generatePDFFile(quotation);
            },


            async generatePDFFile(quotation) {
                const loading = this.showLoading('Generating quotation PDF...');

                try {
                    const element = document.getElementById('quotationPDFContent');
                    if (!element) {
                        this.hideLoading(loading);
                        this.showToast('PDF content not found', 'error');
                        return;
                    }

                    // Check if jsPDF is available
                    if (typeof window.jspdf === 'undefined') {
                        this.hideLoading(loading);
                        this.showToast('PDF library not loaded', 'error');
                        return;
                    }

                    const { jsPDF } = window.jspdf;

                    // Use A4 dimensions (210mm x 297mm at 96 DPI = 794px x 1123px)
                    const pageWidth = 794;
                    const pageHeight = 1123;
                    const margin = 40;
                    // Reduce content height to add buffer and prevent element splitting
                    const maxContentHeight = pageHeight - (margin * 2) - 60; // Extra 60px buffer

                    // Set element to fixed width for consistent rendering
                    element.style.width = (pageWidth - margin * 2) + 'px';
                    element.style.maxWidth = (pageWidth - margin * 2) + 'px';
                    element.style.display = 'block';
                    element.style.visibility = 'hidden';
                    element.style.position = 'static';
                    element.style.opacity = '0';

                    // Wait for layout to settle
                    await new Promise(r => setTimeout(r, 300));

                    // Get total content height
                    const totalHeight = element.scrollHeight;
                    console.log(`üìè Total quotation content height: ${totalHeight}px, max per page: ${maxContentHeight}px`);

                    // Calculate number of pages needed
                    const numPages = Math.ceil(totalHeight / maxContentHeight);
                    console.log(`üìÑ Will generate ${numPages} page(s) for quotation`);

                    // Initialize PDF
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'px',
                        format: [pageWidth, pageHeight],
                        compress: true
                    });

                    // Generate each page
                    for (let pageNum = 0; pageNum < numPages; pageNum++) {
                        this.updateLoadingMessage(loading, `Generating page ${pageNum + 1} of ${numPages}...`);

                        // Calculate the scroll position for this page
                        const scrollY = pageNum * maxContentHeight;

                        // Create a temporary container for this page's content
                        const pageContainer = document.createElement('div');
                        pageContainer.style.width = (pageWidth - margin * 2) + 'px';
                        pageContainer.style.height = maxContentHeight + 'px';
                        pageContainer.style.overflow = 'hidden';
                        pageContainer.style.position = 'absolute';
                        pageContainer.style.top = '-10000px';
                        pageContainer.style.left = '-10000px';
                        pageContainer.style.background = 'white';

                        // Clone the content
                        const clonedElement = element.cloneNode(true);
                        clonedElement.style.position = 'relative';
                        clonedElement.style.top = (-scrollY) + 'px';
                        clonedElement.style.display = 'block';
                        clonedElement.style.visibility = 'visible';
                        clonedElement.style.opacity = '1';

                        pageContainer.appendChild(clonedElement);
                        document.body.appendChild(pageContainer);

                        // Wait for rendering
                        await new Promise(r => setTimeout(r, 200));

                        // Convert to canvas
                        const canvas = await html2canvas(pageContainer, {
                            scale: 2,
                            useCORS: true,
                            allowTaint: false,
                            backgroundColor: '#ffffff',
                            width: pageWidth - margin * 2,
                            height: maxContentHeight,
                            windowWidth: pageWidth - margin * 2,
                            windowHeight: maxContentHeight,
                            x: 0,
                            y: 0
                        });

                        // Remove temporary container
                        document.body.removeChild(pageContainer);

                        // Convert canvas to image
                        const imgData = canvas.toDataURL('image/png', 0.95);

                        // Add page to PDF
                        if (pageNum > 0) {
                            pdf.addPage();
                        }

                        // Add image to PDF with margins
                        pdf.addImage(
                            imgData,
                            'PNG',
                            margin,
                            margin,
                            pageWidth - margin * 2,
                            maxContentHeight,
                            '',
                            'FAST'
                        );

                        // Add page number footer
                        if (numPages > 1) {
                            pdf.setFontSize(9);
                            pdf.setTextColor(128, 128, 128);
                            pdf.text(
                                `Page ${pageNum + 1} of ${numPages}`,
                                pageWidth / 2,
                                pageHeight - 20,
                                { align: 'center' }
                            );
                        }

                        console.log(`‚úÖ Added page ${pageNum + 1} of ${numPages} to PDF`);
                    }

                    // Reset element styles
                    element.style.display = 'none';
                    element.style.visibility = 'visible';
                    element.style.position = 'static';
                    element.style.opacity = '1';
                    element.style.width = '';
                    element.style.maxWidth = '';

                    // Save the PDF
                    this.updateLoadingMessage(loading, 'Saving PDF...');
                    const filename = `Quotation_${quotation.customer.name.replace(/[^a-z0-9]/gi, '_')}_${quotation.quotationDate}.pdf`;
                    pdf.save(filename);

                    this.hideLoading(loading);
                    this.showToast(`‚úÖ PDF downloaded successfully! (${numPages} page${numPages > 1 ? 's' : ''})`, 'success');

                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Error generating PDF:', error);
                    this.showToast('Error generating PDF: ' + error.message, 'error');
                }
            },

            renderQuotationPDFContent(q) {
                // Helper function to get item category icon
                const getCategoryIcon = (category) => {
                    const icons = {
                        'dry-ice': '‚ùÑÔ∏è',
                        'flowers': 'üå∏',
                        'pyro': 'üéÜ',
                        'effects': '‚ú®',
                        'smoke': 'üí®',
                        'confetti': 'üéä',
                        'balloons': 'üéà'
                    };
                    return icons[category] || 'üì¶';
                };

                // Calculate statistics
                let totalItems = 0;
                if (q.orderType === 'single' || !q.orderType) {
                    totalItems = (q.items || []).length;
                } else if (q.orderType === 'multifunction') {
                    totalItems = (q.functions || []).reduce((sum, f) => sum + (f.items?.length || 0), 0);
                } else if (q.orderType === 'multiday') {
                    totalItems = (q.days || []).reduce((sum, d) => {
                        return sum + (d.functions || []).reduce((s, f) => s + (f.items?.length || 0), 0);
                    }, 0);
                }
                const totalDays = q.orderType === 'multiday' ? (q.days?.length || 1) : 1;

                return `
                    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
                    <style>
                        /* Prevent elements from breaking across pages */
                        #quotationPDFContent * {
                            page-break-inside: avoid;
                            break-inside: avoid;
                        }
                        #quotationPDFContent table {
                            page-break-inside: auto;
                            break-inside: auto;
                        }
                        #quotationPDFContent tr {
                            page-break-inside: avoid !important;
                            break-inside: avoid !important;
                        }
                        #quotationPDFContent td, #quotationPDFContent th {
                            word-wrap: break-word;
                            overflow-wrap: break-word;
                            word-break: break-word;
                        }
                        /* Prevent breaking inside major sections */
                        #quotationPDFContent > div {
                            page-break-inside: avoid;
                            break-inside: avoid;
                        }
                    </style>

                    <div id="quotationPDFContent" style="background: white; padding: 0; font-family: Arial, sans-serif; max-width: 100%; margin: 0; border: 2px solid #000;">

                        <!-- Clean Professional Header -->
                        <div style="padding: 16px; border-bottom: 2px solid #000;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <div style="font-size: 11px; color: #000; line-height: 1.6; font-weight: 600;">
                                        <div><strong>Date:</strong> ${Utils.formatDate(q.quotationDate || new Date().toISOString().split('T')[0])}</div>
                                        <div><strong>Valid Until:</strong> ${Utils.formatDate(q.validUntil || this.calculateValidUntil())}</div>
                                    </div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="background: linear-gradient(135deg, #E1306C 0%, #C13584 50%, #833AB4 100%); padding: 12px 50px; display: inline-block; border-radius: 10px; font-size: 32px; font-weight: bold; color: white; font-family: Arial, Helvetica, sans-serif;">
                                        QUOTATION
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Customer Details -->
                        <div style="padding: 15px; border-bottom: 1px solid #ddd;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px; font-weight: 600; color: #000;">
                                <tr>
                                    <td style="padding: 4px 0; width: 25%; vertical-align: top;"><strong>TO</strong></td>
                                    <td style="padding: 4px 0; width: 75%; vertical-align: top;">${q.customer.name}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px 0; vertical-align: top;"><strong>Mobile No.</strong></td>
                                    <td style="padding: 4px 0; vertical-align: top;">: ${q.customer.contact}</td>
                                </tr>
                                ${q.customer.email ? `
                                <tr>
                                    <td style="padding: 4px 0; vertical-align: top;"><strong>Email</strong></td>
                                    <td style="padding: 4px 0; vertical-align: top;">: ${q.customer.email}</td>
                                </tr>
                                ` : ''}
                                <tr>
                                    <td style="padding: 4px 0; vertical-align: top;"><strong>Event Date</strong></td>
                                    <td style="padding: 4px 0; vertical-align: top;">: ${Utils.formatDate(q.customer.eventDate)}</td>
                                </tr>
                                ${q.customer.eventVenue ? `
                                <tr>
                                    <td style="padding: 4px 0; vertical-align: top;"><strong>Venue</strong></td>
                                    <td style="padding: 4px 0; vertical-align: top;">: ${q.customer.eventVenue}</td>
                                </tr>
                                ` : ''}
                            </table>
                        </div>

                        <!-- Items Table -->
                        <div style="padding: 15px; margin-bottom: 20px;">
                            ${!q.orderType || q.orderType === 'single' ? `
                                <table style="width: 100%; border-collapse: collapse; border: 1px solid #000; font-size: 12px;">
                                    <thead>
                                        <tr style="background: #f5f5f5; border: 1px solid #000;">
                                            <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 50px;">Sr.</th>
                                            <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 25%;">Product</th>
                                            <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 30%;">Notes/Description</th>
                                            <th style="padding: 10px; text-align: center; border: 1px solid #000; font-weight: bold; width: 80px;">Qty</th>
                                            <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 100px;">Rate</th>
                                            <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 110px;">Price</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${(q.items || []).map((item, index) => `
                                            <tr style="border: 1px solid #000;">
                                                <td style="padding: 10px; border: 1px solid #000; text-align: center;">${index + 1}</td>
                                                <td style="padding: 10px; border: 1px solid #000; color: #1976D2; font-weight: 500;">${item.name}</td>
                                                <td style="padding: 10px; border: 1px solid #000; color: #666; font-size: 11px; line-height: 1.4;">${item.notes ? item.notes.replace(/\n/g, '<br>') : '-'}</td>
                                                <td style="padding: 10px; border: 1px solid #000; text-align: center;">${Math.round(item.quantity)}</td>
                                                <td style="padding: 10px; border: 1px solid #000; text-align: right;">‚Çπ${(item.rate || item.price || 0).toLocaleString('en-IN')}</td>
                                                <td style="padding: 10px; border: 1px solid #000; text-align: right; color: #D84315; font-weight: 600;">‚Çπ${(item.subtotal || 0).toLocaleString('en-IN')}</td>
                                            </tr>
                                        `).join('')}
                                        <tr style="border: 1px solid #000; background: #f5f5f5;">
                                            <td colspan="5" style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; font-size: 14px;">Total</td>
                                            <td style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; color: #D84315; font-size: 15px;">‚Çπ${q.financials.grandTotal.toLocaleString('en-IN')}/-</td>
                                        </tr>
                                    </tbody>
                                </table>
                            ` : ''}

                            ${q.orderType === 'multifunction' ? (q.functions || []).map((func, funcIdx) => `
                                <div style="margin-bottom: 25px; margin-top: 15px;">
                                    <div style="background: #f5f5f5; padding: 12px; border: 1px solid #000; font-weight: bold; font-size: 13px; color: #1976D2;">
                                        Function ${funcIdx + 1}: ${func.name || 'Unnamed'}
                                    </div>
                                    ${func.venue ? `
                                    <div style="padding: 10px; border-left: 1px solid #000; border-right: 1px solid #000; background: #fff; font-size: 11px;">
                                        <strong style="color: #1976D2;">üìç Venue:</strong> ${func.venue}
                                    </div>
                                    ` : ''}
                                    ${func.notes ? `
                                    <div style="padding: 10px; border-left: 1px solid #000; border-right: 1px solid #000; background: #fffbf0; font-size: 11px; border-top: ${func.venue ? '0' : '1px solid #ddd'};">
                                        <strong style="color: #F57C00;">üìù Notes:</strong> ${func.notes.replace(/\n/g, '<br>')}
                                    </div>
                                    ` : ''}
                                    <table style="width: 100%; border-collapse: collapse; border: 1px solid #000; font-size: 12px; ${func.venue || func.notes ? 'border-top: 0;' : ''}"
                                        <thead>
                                            <tr style="background: #f5f5f5; border: 1px solid #000;">
                                                <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 50px;">Sr.</th>
                                                <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 25%;">Product</th>
                                                <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 30%;">Notes/Description</th>
                                                <th style="padding: 10px; text-align: center; border: 1px solid #000; font-weight: bold; width: 80px;">Qty</th>
                                                <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 100px;">Rate</th>
                                                <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 110px;">Price</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${(func.items || []).map((item, itemIdx) => `
                                                <tr style="border: 1px solid #000;">
                                                    <td style="padding: 10px; border: 1px solid #000; text-align: center;">${itemIdx + 1}</td>
                                                    <td style="padding: 10px; border: 1px solid #000; color: #1976D2; font-weight: 500;">${item.name}</td>
                                                    <td style="padding: 10px; border: 1px solid #000; color: #666; font-size: 11px; line-height: 1.4;">${item.notes ? item.notes.replace(/\n/g, '<br>') : '-'}</td>
                                                    <td style="padding: 10px; border: 1px solid #000; text-align: center;">${Math.round(item.quantity)}</td>
                                                    <td style="padding: 10px; border: 1px solid #000; text-align: right;">‚Çπ${(item.price || 0).toLocaleString('en-IN')}</td>
                                                    <td style="padding: 10px; border: 1px solid #000; text-align: right; color: #D84315; font-weight: 600;">‚Çπ${(item.subtotal || 0).toLocaleString('en-IN')}</td>
                                                </tr>
                                            `).join('')}
                                            <tr style="border: 1px solid #000; background: #f5f5f5;">
                                                <td colspan="5" style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; font-size: 14px;">Function Total</td>
                                                <td style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; color: #D84315; font-size: 15px;">‚Çπ${(func.subtotal || 0).toLocaleString('en-IN')}/-</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            `).join('') : ''}

                            ${q.orderType === 'multifunction' && (q.functions || []).length > 0 ? `
                                <!-- Grand Total for Multifunction -->
                                <div style="margin-top: 20px; padding: 15px; border: 2px solid #000; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); text-align: right;">
                                    <div style="font-size: 18px; font-weight: bold; color: white;">
                                        GRAND TOTAL: ‚Çπ${q.financials.grandTotal.toLocaleString('en-IN')}/-
                                    </div>
                                </div>
                            ` : ''}

                            ${q.orderType === 'multiday' ? (q.days || []).map((day, dayIdx) => `
                                <div style="margin-bottom: 35px; margin-top: 20px;">
                                    <div style="background: #e3f2fd; padding: 14px; border: 1px solid #000; font-weight: bold; font-size: 14px; color: #0d47a1; margin-bottom: 15px;">
                                        Day ${dayIdx + 1}: ${day.date ? Utils.formatDate(day.date) : 'No date set'}
                                    </div>

                                    ${(day.functions || []).map((func, funcIdx) => `
                                        <div style="margin-bottom: 20px; margin-top: 10px;">
                                            <div style="background: #f5f5f5; padding: 10px; border: 1px solid #000; font-weight: bold; font-size: 12px; color: #1976D2;">
                                                ${func.name || 'Unnamed Function'}
                                            </div>
                                            ${func.venue ? `
                                            <div style="padding: 10px; border-left: 1px solid #000; border-right: 1px solid #000; background: #fff; font-size: 11px;">
                                                <strong style="color: #1976D2;">üìç Venue:</strong> ${func.venue}
                                            </div>
                                            ` : ''}
                                            ${func.notes ? `
                                            <div style="padding: 10px; border-left: 1px solid #000; border-right: 1px solid #000; background: #fffbf0; font-size: 11px; border-top: ${func.venue ? '0' : '1px solid #ddd'};">
                                                <strong style="color: #F57C00;">üìù Notes:</strong> ${func.notes.replace(/\n/g, '<br>')}
                                            </div>
                                            ` : ''}
                                            <table style="width: 100%; border-collapse: collapse; border: 1px solid #000; font-size: 12px; ${func.venue || func.notes ? 'border-top: 0;' : ''}"
                                                <thead>
                                                    <tr style="background: #f5f5f5; border: 1px solid #000;">
                                                        <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 50px;">Sr.</th>
                                                        <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 25%;">Product</th>
                                                        <th style="padding: 10px; text-align: left; border: 1px solid #000; font-weight: bold; width: 30%;">Notes/Description</th>
                                                        <th style="padding: 10px; text-align: center; border: 1px solid #000; font-weight: bold; width: 80px;">Qty</th>
                                                        <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 100px;">Rate</th>
                                                        <th style="padding: 10px; text-align: right; border: 1px solid #000; font-weight: bold; width: 110px;">Price</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    ${(func.items || []).map((item, itemIdx) => `
                                                        <tr style="border: 1px solid #000;">
                                                            <td style="padding: 10px; border: 1px solid #000; text-align: center;">${itemIdx + 1}</td>
                                                            <td style="padding: 10px; border: 1px solid #000; color: #1976D2; font-weight: 500;">${item.name}</td>
                                                            <td style="padding: 10px; border: 1px solid #000; color: #666; font-size: 11px; line-height: 1.4;">${item.notes ? item.notes.replace(/\n/g, '<br>') : '-'}</td>
                                                            <td style="padding: 10px; border: 1px solid #000; text-align: center;">${Math.round(item.quantity)}</td>
                                                            <td style="padding: 10px; border: 1px solid #000; text-align: right;">‚Çπ${(item.price || 0).toLocaleString('en-IN')}</td>
                                                            <td style="padding: 10px; border: 1px solid #000; text-align: right; color: #D84315; font-weight: 600;">‚Çπ${(item.subtotal || 0).toLocaleString('en-IN')}</td>
                                                        </tr>
                                                    `).join('')}
                                                    <tr style="border: 1px solid #000; background: #f5f5f5;">
                                                        <td colspan="5" style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; font-size: 14px;">Function Total</td>
                                                        <td style="padding: 12px; border: 1px solid #000; text-align: right; font-weight: bold; color: #D84315; font-size: 15px;">‚Çπ${(func.subtotal || 0).toLocaleString('en-IN')}/-</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    `).join('')}

                                    <div style="background: #e3f2fd; padding: 14px; border: 1px solid #000; text-align: right; font-weight: bold; color: #0d47a1; font-size: 15px; margin-top: 10px;">
                                        Day ${dayIdx + 1} Total: ‚Çπ${(day.subtotal || 0).toLocaleString('en-IN')}/-
                                    </div>
                                </div>
                            `).join('') : ''}

                            ${q.orderType === 'multiday' && (q.days || []).length > 0 ? `
                                <!-- Grand Total for Multiday -->
                                <div style="margin-top: 20px; padding: 15px; border: 2px solid #000; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); text-align: right;">
                                    <div style="font-size: 18px; font-weight: bold; color: white;">
                                        GRAND TOTAL: ‚Çπ${q.financials.grandTotal.toLocaleString('en-IN')}/-
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Notes Section (if exists) -->
                        ${q.notes ? `
                        <div style="padding: 15px; border-top: 2px solid #000; margin-top: 25px;">
                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 10px; color: #000;">üìù Notes:</div>
                            <div style="font-size: 11px; line-height: 1.7; color: #000; background: #fffbf0; padding: 12px; border-left: 4px solid #F57C00; border-radius: 4px;">
                                ${q.notes.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                        ` : ''}

                        <!-- Terms & Conditions Section -->
                        <div style="padding: 15px; border-top: 2px solid #000; margin-top: 25px;">
                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 10px; color: #000;">Terms & Conditions:</div>
                            <div style="font-size: 11px; line-height: 1.7; color: #000; font-weight: 500;">
                                <div style="margin-bottom: 5px;"><strong style="color: #1976D2;">Payment Terms:</strong></div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ 50% booking required to confirm</div>
                                <div style="margin-bottom: 8px; padding-left: 20px;">‚Ä¢ 50% before event starts</div>

                                <div style="margin-bottom: 5px;"><strong style="color: #2E7D32;">Inclusions:</strong></div>
                                <div style="margin-bottom: 8px; padding-left: 20px;">‚Ä¢ Generator for electricity provision</div>

                                <div style="margin-bottom: 5px;"><strong style="color: #D84315;">Customer Responsibilities:</strong></div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ Fire safety permissions & Fire NOC</div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ Venue/ground permissions</div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ AMC permissions</div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ First aid provision</div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ Resource manager approval</div>
                                <div style="margin-bottom: 3px; padding-left: 20px;">‚Ä¢ Contractor competence proof</div>
                                <div style="margin-bottom: 8px; padding-left: 20px;">‚Ä¢ Security clearance for restricted materials</div>

                                <div style="margin-top: 10px; padding: 10px; background: #fff9c4; border-left: 4px solid #F57C00; font-weight: bold; color: #e65100;">
                                    ‚ö†Ô∏è IMPORTANT: Quotation valid for 15 days from quotation date
                                </div>
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="text-align: center; padding: 15px; border-top: 1px solid #ddd; background: #f9f9f9; font-size: 11px; color: #666;">
                            Thank you for choosing our services! We look forward to making your event spectacular. ‚ú®
                        </div>
                    </div>
                `;
            },

            async downloadQuotationPDF(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                try {
                    // Access jsPDF from global window object
                    const { jsPDF } = window.jspdf;
                    // PORTRAIT orientation for better readability
                    const doc = new jsPDF('portrait', 'mm', 'a4');

                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 12; // Reduced from 15 to save space
                    let yPos = 12;

                    // DARK BLACK colors for ultra quality
                    const black = [0, 0, 0];
                    const blue = [25, 118, 210]; // Product names
                    const red = [216, 67, 21]; // Prices
                    const instagramPink = [225, 48, 108]; // Instagram gradient color #E1306C
                    const white = [255, 255, 255];

                    // === HEADER WITH BORDER ===
                    doc.setDrawColor(...black);
                    doc.setLineWidth(0.5);
                    doc.rect(margin, margin, pageWidth - 2 * margin, 22); // Reduced from 25 to 22

                    // Quotation details - LEFT
                    doc.setFontSize(9); // Reduced from 10
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...black);
                    doc.text('Quotation No:', margin + 3, yPos + 3);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.quotationNumber || 'N/A', margin + 32, yPos + 3);

                    doc.setFont('helvetica', 'bold');
                    doc.text('Date:', margin + 3, yPos + 8);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.quotationDate || new Date().toISOString().split('T')[0]), margin + 18, yPos + 8);

                    doc.setFont('helvetica', 'bold');
                    doc.text('Valid Until:', margin + 3, yPos + 13);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.validUntil || this.calculateValidUntil()), margin + 28, yPos + 13);

                    // QUOTATION - CENTER with Instagram gradient background
                    const quotationBoxWidth = 65;
                    const quotationBoxHeight = 12;
                    const quotationBoxX = (pageWidth - quotationBoxWidth) / 2;
                    const quotationBoxY = yPos + 3;

                    // Draw Instagram gradient background (solid pink color)
                    doc.setFillColor(...instagramPink);
                    doc.roundedRect(quotationBoxX, quotationBoxY, quotationBoxWidth, quotationBoxHeight, 2, 2, 'F');

                    // Draw WHITE text on top
                    doc.setFontSize(20); // Reduced from 24 but still prominent
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...white);
                    doc.text('QUOTATION', pageWidth / 2, quotationBoxY + 8.5, { align: 'center' });

                    yPos += 26; // Reduced from 30

                    // === CUSTOMER DETAILS ===
                    doc.setDrawColor(...black);
                    doc.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 4; // Reduced from 5

                    doc.setFontSize(10); // Reduced from 11
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...black);
                    doc.text('TO:', margin, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.name, margin + 28, yPos);

                    yPos += 6; // Reduced from 7
                    doc.setFont('helvetica', 'bold');
                    doc.text('Mobile No.:', margin, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.contact, margin + 28, yPos);

                    yPos += 6; // Reduced from 7
                    if (quotation.customer.email) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Email:', margin, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(quotation.customer.email, margin + 28, yPos);
                        yPos += 6;
                    }

                    doc.setFont('helvetica', 'bold');
                    doc.text('Event Date:', margin, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.customer.eventDate), margin + 28, yPos);

                    yPos += 6; // Reduced from 7
                    if (quotation.customer.eventVenue) {
                        doc.setFont('helvetica', 'bold');
                        doc.text('Venue:', margin, yPos);
                        doc.setFont('helvetica', 'normal');
                        doc.text(quotation.customer.eventVenue, margin + 28, yPos);
                        yPos += 6;
                    }

                    doc.setDrawColor(...black);
                    doc.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 8; // Reduced from 10

                    // === ITEMS TABLE ===
                    const colWidths = [12, 35, 50, 20, 25, 30]; // Sr, Product, Notes, Qty, Rate, Price
                    const startX = margin;
                    let currentX = startX;

                    // Table header
                    doc.setFillColor(245, 245, 245);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 8, 'FD');

                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...black);

                    doc.text('Sr.', currentX + 2, yPos + 5.5);
                    currentX += colWidths[0];
                    doc.text('Product', currentX + 2, yPos + 5.5);
                    currentX += colWidths[1];
                    doc.text('Notes', currentX + 2, yPos + 5.5);
                    currentX += colWidths[2];
                    doc.text('Qty', currentX + 2, yPos + 5.5);
                    currentX += colWidths[3];
                    doc.text('Rate', currentX + 2, yPos + 5.5);
                    currentX += colWidths[4];
                    doc.text('Price', currentX + 2, yPos + 5.5);

                    yPos += 8;

                    // Table rows - Handle all quotation types
                    doc.setFontSize(8);
                    let itemIndex = 0;

                    // Helper function to render an item row with notes
                    const renderItemRow = (item, index) => {
                        currentX = startX;

                        // Calculate row height based on notes (if present)
                        const notes = item.notes || '';
                        const notesLines = notes ? doc.splitTextToSize(notes, colWidths[2] - 4) : [];
                        const rowHeight = Math.max(7, notesLines.length * 4 + 3);

                        // Check if we need a new page
                        if (yPos + rowHeight > pageHeight - 20) {
                            doc.addPage();
                            yPos = margin;
                        }

                        // Draw row border
                        doc.setDrawColor(...black);
                        doc.rect(margin, yPos, pageWidth - 2 * margin, rowHeight, 'S');

                        // Serial number
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(...black);
                        doc.text((index + 1).toString(), currentX + 2, yPos + 5);
                        currentX += colWidths[0];

                        // Product name
                        doc.setTextColor(...blue);
                        doc.setFont('helvetica', 'bold');
                        const itemName = item.name.length > 20 ? item.name.substring(0, 18) + '...' : item.name;
                        doc.text(itemName, currentX + 2, yPos + 5);
                        currentX += colWidths[1];

                        // Notes (multi-line support)
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(7);
                        doc.setTextColor(80, 80, 80);
                        if (notesLines.length > 0) {
                            notesLines.forEach((line, idx) => {
                                doc.text(line, currentX + 2, yPos + 4 + (idx * 3.5));
                            });
                        }
                        doc.setFontSize(8);
                        currentX += colWidths[2];

                        // Quantity
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(...black);
                        doc.text(Math.round(item.quantity).toString(), currentX + 2, yPos + 5);
                        currentX += colWidths[3];

                        // Rate
                        doc.text(`‚Çπ${(item.rate || item.price || 0).toLocaleString('en-IN')}`, currentX + 2, yPos + 5);
                        currentX += colWidths[4];

                        // Subtotal/Price
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(...red);
                        doc.text(`‚Çπ${item.subtotal.toLocaleString('en-IN')}`, currentX + 2, yPos + 5);

                        yPos += rowHeight;
                    };

                    // Helper function to render section header (for multifunction/multiday)
                    const renderSectionHeader = (title) => {
                        // Check if we need a new page
                        if (yPos + 8 > pageHeight - 20) {
                            doc.addPage();
                            yPos = margin;
                        }

                        doc.setFillColor(240, 248, 255); // Light blue background
                        doc.rect(margin, yPos, pageWidth - 2 * margin, 7, 'FD');
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(...blue);
                        doc.text(title, margin + 3, yPos + 5);
                        yPos += 7;
                    };

                    // Process items based on quotation type
                    if (!quotation.orderType || quotation.orderType === 'single') {
                        // Single-day quotation
                        (quotation.items || []).forEach((item, index) => {
                            renderItemRow(item, itemIndex);
                            itemIndex++;
                        });
                    } else if (quotation.orderType === 'multifunction') {
                        // Multifunction quotation (same day, multiple functions)
                        (quotation.functions || []).forEach((func, funcIdx) => {
                            // Render function header
                            renderSectionHeader(`Function ${funcIdx + 1}: ${func.name || 'Unnamed Function'}`);

                            // Render items for this function
                            (func.items || []).forEach((item) => {
                                renderItemRow(item, itemIndex);
                                itemIndex++;
                            });
                        });
                    } else if (quotation.orderType === 'multiday') {
                        // Multiday quotation (multiple days, multiple functions per day)
                        (quotation.days || []).forEach((day, dayIdx) => {
                            // Render day header
                            const dayDate = day.date ? Utils.formatDate(day.date) : `Day ${dayIdx + 1}`;
                            renderSectionHeader(`üìÖ ${dayDate}`);

                            // Render functions for this day
                            (day.functions || []).forEach((func, funcIdx) => {
                                // Render function header (indented under day)
                                renderSectionHeader(`  Function ${funcIdx + 1}: ${func.name || 'Unnamed Function'}`);

                                // Render items for this function
                                (func.items || []).forEach((item) => {
                                    renderItemRow(item, itemIndex);
                                    itemIndex++;
                                });
                            });
                        });
                    }

                    // Total row
                    doc.setFillColor(245, 245, 245);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 9, 'FD'); // Reduced from 10 to 9

                    doc.setFontSize(11); // Reduced from 12
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...black);
                    doc.text('Total', margin + 100, yPos + 6);

                    doc.setFontSize(12); // Reduced from 13
                    doc.setTextColor(...red);
                    doc.text(`‚Çπ${quotation.financials.grandTotal.toLocaleString('en-IN')}/-`, pageWidth - margin - 5, yPos + 6, { align: 'right' });

                    yPos += 13; // Reduced from 15

                    // === TERMS & CONDITIONS ===
                    doc.setDrawColor(...black);
                    doc.setLineWidth(0.5);
                    doc.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 5; // Reduced from 7

                    doc.setFontSize(11); // Reduced from 12
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...black);
                    doc.text('Terms & Conditions:', margin, yPos);
                    yPos += 6; // Reduced from 8

                    doc.setFontSize(9.5); // Reduced from 10
                    doc.setTextColor(...blue);
                    doc.text('Payment Terms:', margin, yPos);
                    yPos += 4.5; // Reduced from 5

                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...black);
                    doc.text('‚Ä¢ 50% booking required to confirm', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ 50% before event starts', margin + 5, yPos);
                    yPos += 6; // Reduced from 8

                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(46, 125, 50);
                    doc.text('Inclusions:', margin, yPos);
                    yPos += 4.5; // Reduced from 5

                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...black);
                    doc.text('‚Ä¢ Generator for electricity provision', margin + 5, yPos);
                    yPos += 6; // Reduced from 8

                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...red);
                    doc.text('Customer Responsibilities:', margin, yPos);
                    yPos += 4.5; // Reduced from 5

                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...black);
                    doc.text('‚Ä¢ Fire safety permissions & Fire NOC', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ Venue/ground permissions', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ AMC permissions', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ First aid provision', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ Resource manager approval', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ Contractor competence proof', margin + 5, yPos);
                    yPos += 4.5; // Reduced from 5
                    doc.text('‚Ä¢ Security clearance for restricted materials', margin + 5, yPos);
                    yPos += 6; // Reduced from 8

                    // IMPORTANT box
                    doc.setFillColor(255, 249, 196);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 8, 'FD'); // Reduced from 10 to 8
                    doc.setFontSize(10); // Reduced from 11
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(230, 81, 0);
                    doc.text('‚ö†Ô∏è IMPORTANT: Quotation valid for 15 days from quotation date', margin + 5, yPos + 5.5);

                    yPos += 12; // Reduced from 15

                    // === FOOTER ===
                    doc.setDrawColor(...black);
                    doc.line(margin, yPos, pageWidth - margin, yPos);
                    yPos += 4; // Reduced from 5

                    doc.setFontSize(9); // Reduced from 10
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...black);
                    doc.text('Thank you for choosing our services! We look forward to making your event spectacular. ‚ú®', pageWidth / 2, yPos, { align: 'center' });

                    // Save PDF with high quality
                    const fileName = `Quotation_${quotation.customer.name.replace(/\s+/g, '_')}_${quotation.quotationDate || 'draft'}.pdf`;
                    doc.save(fileName);

                    this.showToast('‚úÖ PDF downloaded successfully!', 'success');
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    this.showToast('Error generating PDF: ' + error.message, 'error');
                }
            },


            async convertQuotationToOrder(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                if (!confirm(`Convert quotation to order for ${quotation.customer.name}?`)) return;

                // Switch to orders tab and prefill with quotation data
                this.switchTab('orders');

                setTimeout(() => {
                    // Fill customer details
                    Utils.set('clientName', quotation.customer.name);
                    Utils.set('contact', quotation.customer.contact);
                    if (quotation.customer.eventVenue) Utils.set('venue', quotation.customer.eventVenue);
                    if (quotation.customer.eventDate) {
                        Utils.set('date', quotation.customer.eventDate);
                        Utils.set('startDate', quotation.customer.eventDate);
                    }

                    // TODO: Add items to order (requires integration with order form)
                    // For now, just navigate to orders tab with customer info prefilled

                    this.showToast('‚úÖ Order form prefilled with quotation data', 'success');
                }, 200);

                // Mark quotation as converted
                try {
                    await db.collection('quotations').doc(quotationId).update({
                        status: 'converted',
                        convertedAt: new Date().toISOString()
                    });

                    await Quotations.loadQuotationsFromFirestore(this);
                } catch (error) {
                    console.error('Error updating quotation status:', error);
                }
            },

            // ============ TEAM MANAGEMENT ============

            // ============ TEAM MODULE (including RBAC) ============
            // Loaded lazily from /admin/js/features/team.js


            // Generate individual WhatsApp message for a single order
            generateWhatsAppSingleOrderMessage(order, orderNumber, selectedDate) {
                if (!order) return '';

                let message = `Order ${orderNumber}\n`;
                message += `Date: ${Utils.formatDate(selectedDate)}\n\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `${order.clientName || 'N/A'}\n`;
                message += `Contact: ${order.contact || 'N/A'}\n`;

                // Venue with location combined
                if (order.venue && order.venue !== 'N/A') {
                    message += `Venue: ${order.venue}`;

                    // Add Google Maps location link - check all possible sources
                    let mapsUrl = null;

                    // Priority 1: venueLocation with coordinates
                    if (order.venueLocation && order.venueLocation.lat && order.venueLocation.lng) {
                        if (order.venueLocation.place_id) {
                            mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}&query_place_id=${order.venueLocation.place_id}`;
                        } else {
                            mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}+${order.venueLocation.lat},${order.venueLocation.lng}`;
                        }
                    }
                    // Priority 2: venueMapLink (stored link)
                    else if (order.venueMapLink && order.venueMapLink.trim()) {
                        mapsUrl = order.venueMapLink;
                    }

                    if (mapsUrl) {
                        message += `\nLocation: ${mapsUrl}`;
                    }
                    message += `\n`;
                }

                message += `Time: ${order.readyTime || ''}\n\n`;

                // Find specific day data for multi-day orders
                let specificDayData = null;
                if (order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0) {
                    specificDayData = order.dayWiseData.find(dayData => dayData.date === selectedDate);
                }

                // Collect items for this order
                let orderItems = [];

                // Functions and items (compact format - no "Items:" label)
                if (specificDayData && specificDayData.functions) {
                    specificDayData.functions.forEach((func, funcIdx) => {
                        if (func.items && func.items.length > 0) {
                            // Function name
                            if (func.functionType) {
                                message += `Function - ${func.functionType}`;
                                if (func.timeSlot) message += ` (${func.timeSlot})`;
                                message += `\n`;
                            } else if (specificDayData.functions.length > 1) {
                                message += `Function ${funcIdx + 1}`;
                                if (func.timeSlot) message += ` (${func.timeSlot})`;
                                message += `\n`;
                            }

                            // Items directly (no "Items:" label)
                            func.items.forEach(item => {
                                message += `${item.name} ${item.quantity}`;
                                if (item.remarks) message += ` (${item.remarks})`;
                                message += `\n`;
                                orderItems.push(item);
                            });
                        }
                    });
                } else if (order.items && order.items.length > 0) {
                    // Single-day order items
                    order.items.forEach(item => {
                        message += `${item.name} ${item.quantity}`;
                        if (item.remarks) message += ` (${item.remarks})`;
                        message += `\n`;
                        orderItems.push(item);
                    });
                }

                // Calculate RAW MATERIALS for this order only
                let dryIceMachines = 0;
                let flowerShowerMachines = 0;
                let electricityKV = 0;

                orderItems.forEach(item => {
                    const itemNameLower = item.name?.toLowerCase() || '';
                    const qty = item.quantity || 0;

                    // Dry ice machines
                    if (itemNameLower.includes('dry ice')) {
                        dryIceMachines += qty;
                    }

                    // Flower shower machines
                    if ((itemNameLower.includes('flower') && itemNameLower.includes('shower')) ||
                        itemNameLower.includes('flower shower machine')) {
                        flowerShowerMachines += qty;
                    }

                    // Electricity - 3KV machines
                    const electricity3KV = ['showven sonic boom (co2 jet)', 'sonic boom', 'dry ice machine', '5 head flame'];
                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        electricityKV += qty * 3;
                    }
                    // Electricity - 1KV machines
                    else {
                        const electricity1KV = ['sparkular', 'spinner', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];
                        if (electricity1KV.some(name => itemNameLower.includes(name))) {
                            electricityKV += qty * 1;
                        }
                    }
                });

                // Add raw materials for this order
                if (dryIceMachines > 0) {
                    const dryIceNeeded = dryIceMachines * 20; // 20kg per machine
                    message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                    message += `DRY ICE: ${dryIceNeeded}kg\n`;
                    message += `(${dryIceMachines} machine${dryIceMachines !== 1 ? 's' : ''} x 20kg)\n`;
                }

                if (flowerShowerMachines > 0) {
                    const flowersNeeded = flowerShowerMachines * 20; // 20kg per machine
                    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                    message += `FLOWERS: ${flowersNeeded}kg\n`;
                    message += `(${flowerShowerMachines} machine${flowerShowerMachines !== 1 ? 's' : ''} x 20kg)\n`;
                }

                if (electricityKV > 0) {
                    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                    message += `ELECTRICITY: ${electricityKV}KV\n`;
                }

                message += `\nFirepowerSFX Order Management`;

                return message;
            },

            filterOrdersByDate(date) {
                // Filter orders that match the given date
                return this.data.orders.filter(o => {
                    // Case 1: Single-day order with matching date
                    if (!o.isMultiDay && o.date) {
                        // Compare dates (handle different formats)
                        const orderDate = new Date(o.date).toISOString().split('T')[0];
                        const targetDate = new Date(date).toISOString().split('T')[0];
                        if (orderDate === targetDate) {
                            return true;
                        }
                    }

                    // Case 2: Multi-day order WITH dayWiseData - check specific day functions
                    if (o.isMultiDay && o.dayWiseData && Array.isArray(o.dayWiseData) && o.dayWiseData.length > 0) {
                        const hasMatch = o.dayWiseData.some(day => {
                            const dayDate = new Date(day.date).toISOString().split('T')[0];
                            const targetDate = new Date(date).toISOString().split('T')[0];
                            return dayDate === targetDate;
                        });
                        if (hasMatch) {
                            return true;
                        }
                        // If order has dayWiseData but no match, skip it
                        return false;
                    }

                    // Case 3: Multi-day order WITHOUT dayWiseData - fallback to range check
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        const targetDate = new Date(date);
                        const start = new Date(o.startDate);
                        const end = new Date(o.endDate);
                        if (targetDate >= start && targetDate <= end) {
                            return true;
                        }
                    }

                    return false;
                });
            },

            updateWhatsAppDateFilter() {
                const dateInput = document.getElementById('whatsappFilterDate');
                const previewDiv = document.getElementById('whatsappOrdersPreview');
                const noOrdersDiv = document.getElementById('whatsappNoOrders');
                const ordersListDiv = document.getElementById('whatsappOrdersList');
                const orderCountSpan = document.getElementById('whatsappOrderCount');

                if (!dateInput || !dateInput.value) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'none';
                    return;
                }

                const selectedDate = dateInput.value;
                const filteredOrders = Orders.filterOrdersByDate(this, selectedDate);

                if (filteredOrders.length === 0) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'block';
                    return;
                }

                // Show preview
                noOrdersDiv.style.display = 'none';
                previewDiv.style.display = 'block';
                orderCountSpan.textContent = filteredOrders.length;

                // Generate individual message cards for each order
                ordersListDiv.innerHTML = '';

                filteredOrders.forEach((order, index) => {
                    const orderNumber = index + 1;
                    const message = Orders.generateWhatsAppSingleOrderMessage(this, order, orderNumber, selectedDate);

                    // Create card for this order
                    const orderCard = document.createElement('div');
                    orderCard.style.cssText = 'background: var(--bg-card); border: 2px solid var(--border); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;';

                    orderCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                            <h4 style="margin: 0; color: var(--primary);">üìã Order ${orderNumber}</h4>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn btn-primary btn-small" onclick="OMS.copyOrderMessage(${index})" title="Copy Message">
                                    üìã Copy
                                </button>
                                <button class="btn btn-success btn-small" onclick="OMS.sendSingleOrderWhatsApp(${index})" title="Send WhatsApp">
                                    üì± Send
                                </button>
                            </div>
                        </div>
                        <div style="font-size: 0.9rem; white-space: pre-wrap; font-family: monospace; background: var(--bg-hover); padding: 0.75rem; border-radius: 4px; max-height: 250px; overflow-y: auto;">
                            ${message}
                        </div>
                    `;

                    ordersListDiv.appendChild(orderCard);
                });

                // Store orders and date for message operations
                this.whatsappCurrentOrders = filteredOrders;
                this.whatsappCurrentDate = selectedDate;
            },

            copyOrderMessage(orderIndex) {
                const order = this.whatsappCurrentOrders[orderIndex];
                const orderNumber = orderIndex + 1;
                const message = Orders.generateWhatsAppSingleOrderMessage(this, order, orderNumber, this.whatsappCurrentDate);

                // Copy to clipboard
                navigator.clipboard.writeText(message).then(() => {
                    this.showToast(`‚úÖ Order ${orderNumber} message copied to clipboard!`, 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.showToast('Failed to copy message', 'error');
                });
            },

            sendSingleOrderWhatsApp(orderIndex) {
                const order = this.whatsappCurrentOrders[orderIndex];
                const orderNumber = orderIndex + 1;
                const message = Orders.generateWhatsAppSingleOrderMessage(this, order, orderNumber, this.whatsappCurrentDate);

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast(`üì± Opening WhatsApp for Order ${orderNumber}...`, 'success');
            },

            sendWhatsAppOrdersReport() {
                if (!this.whatsappCurrentMessage) {
                    this.showToast('Please select a date first', 'warning');
                    return;
                }

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(this.whatsappCurrentMessage);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCalendarTab() {
                // Wrapper function - delegates to Calendar module if loaded
                if (window.Calendar && typeof window.Calendar.renderCalendarTab === 'function') {
                    window.Calendar.renderCalendarTab(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Calendar module not loaded yet');
                }
            },

            async renderHistory() {
                // Wrapper function - delegates to History module if loaded
                if (window.History && typeof window.History.renderHistory === 'function') {
                    await window.History.renderHistory(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('History module not loaded yet');
                }
            },

            async renderFinancials() {
                // Wrapper function - delegates to Financials module if loaded
                if (window.Financials && typeof window.Financials.renderFinancials === 'function') {
                    await window.Financials.renderFinancials(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Financials module not loaded yet');
                }
            },

            renderSettings() {
                // Wrapper function - delegates to Settings module if loaded
                if (window.Settings && typeof window.Settings.renderSettings === 'function') {
                    window.Settings.renderSettings(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Settings module not loaded yet');
                }
            },

            async saveSettings() {
                // Wrapper function - delegates to Settings module if loaded
                if (window.Settings && typeof window.Settings.saveSettings === 'function') {
                    await window.Settings.saveSettings(this);
                } else {
                    console.log('Settings module not loaded yet');
                }
            },

            resetSettings() {
                // Wrapper function - delegates to Settings module if loaded
                if (window.Settings && typeof window.Settings.resetSettings === 'function') {
                    window.Settings.resetSettings(this);
                } else {
                    console.log('Settings module not loaded yet');
                }
            },

            resetAllData() {
                // Wrapper function - delegates to Settings module if loaded
                if (window.Settings && typeof window.Settings.resetAllData === 'function') {
                    window.Settings.resetAllData(this);
                } else {
                    console.log('Settings module not loaded yet');
                }
            },

            async _oldRenderHistory_REMOVE() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('orderHistory')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">${this.t('export')}</button>
                        </div>
                        <!-- Floating Merge Button -->
                        <button class="btn btn-primary" id="mergeSelectedBtn"
                            style="display: none; position: fixed; bottom: 30px; right: 30px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); padding: 15px 25px; font-size: 16px;"
                            onclick="OMS.showMergeModal()">
                            üîó Merge Selected Orders (<span id="mergeCount">0</span>)
                        </button>
                        <div class="form-group" style="margin: 20px 0; position: relative;">
                            <label class="form-label">üîç Search Orders</label>
                            <input type="text" id="historySearch" class="form-input" placeholder="Search by client name, order ID, date, or venue...">
                            <div id="historySearchResults" class="search-dropdown"></div>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;

                // Add search functionality
                this.setupHistorySearch();

                // Initialize selected orders array
                this.selectedOrdersForMerge = [];

                // Check if user can manage financials
                const canManageFinancials = await this.canViewFinancials();

                // IMPORTANT: Filter out orders that have been merged into other orders
                // Only show orders that are NOT marked as isMerged
                const visibleOrders = this.data.orders.filter(o => !o.isMerged);
                console.log(`üìã History: Showing ${visibleOrders.length} orders (filtered out ${this.data.orders.length - visibleOrders.length} merged orders)`);

                this.renderTable('historyContainer', [
                    { key: 'select', label: '‚òëÔ∏è', render: o => {
                        const isMergedOrder = o.mergedFrom && o.mergedFrom.length > 0;
                        return `<input type="checkbox" class="order-select-checkbox" data-order-id="${o.docId || o.orderId}" ${isMergedOrder ? 'disabled' : ''} onchange="OMS.toggleOrderSelection('${o.docId || o.orderId}')">`;
                    }},
                    { key: 'orderId', label: this.t('orderId'), render: o => {
                        const mergeStatus = o.mergedFrom && o.mergedFrom.length > 0
                            ? `<span style="color: #667eea; font-weight: bold;">üîó MERGED (${o.mergedFrom.length} orders)</span>`
                            : '';
                        return `<span class="order-id-highlight">${o.orderId}</span> ${mergeStatus}`;
                    }},
                    { key: 'clientName', label: this.t('client') },
                    { key: 'venue', label: this.t('venue') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${this.t(o.status.toLowerCase())}</span>` }
                ], visibleOrders, (row) => {
                    const isMergedOrder = row.mergedFrom && row.mergedFrom.length > 0;
                    const unmergeBtn = isMergedOrder ? `<button class="btn btn-info btn-small" onclick="OMS.unmergeOrder('${row.docId || row.orderId}')">üîì Unmerge</button>` : '';
                    const paymentExpenseButtons = canManageFinancials ? `
                        <button class="btn btn-primary btn-small" onclick="OMS.addPaymentForOrder('${row.docId || row.orderId}')">üíµ Payment</button>
                        <button class="btn btn-warning btn-small" onclick="OMS.addExpenseForOrder('${row.docId || row.orderId}')">üí∏ Expense</button>
                    ` : '';
                    return `
                        <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('edit')}</button>
                        <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                        ${paymentExpenseButtons}
                        ${unmergeBtn}
                        <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.docId || row.orderId}">${this.t('delete')}</button>
                    `;
                });
            },

            setupHistorySearch() {
                const searchInput = document.getElementById('historySearch');
                const searchResults = document.getElementById('historySearchResults');

                if (!searchInput || !searchResults) return;

                let searchTimeout;

                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim().toLowerCase();

                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        searchResults.innerHTML = '';
                        return;
                    }

                    searchTimeout = setTimeout(() => {
                        // Search through all orders
                        const results = this.data.orders.filter(order => {
                            const clientName = (order.clientName || '').toLowerCase();
                            const orderId = (order.orderId || '').toLowerCase();
                            const venue = (order.venue || '').toLowerCase();
                            const date = order.isMultiDay
                                ? `${Utils.formatDate(order.startDate)} ${Utils.formatDate(order.endDate)}`.toLowerCase()
                                : Utils.formatDate(order.date).toLowerCase();

                            return clientName.includes(query) ||
                                   orderId.includes(query) ||
                                   venue.includes(query) ||
                                   date.includes(query);
                        }); // Show all matching results (no limit)

                        if (results.length === 0) {
                            searchResults.innerHTML = '<div class="search-dropdown-item">No orders found</div>';
                            searchResults.style.display = 'block';
                        } else {
                            searchResults.innerHTML = results.map(order => {
                                const dateDisplay = order.isMultiDay
                                    ? `${Utils.formatDate(order.startDate)} - ${Utils.formatDate(order.endDate)}`
                                    : Utils.formatDate(order.date);
                                const statusClass = `status-${order.status.toLowerCase()}`;

                                return `
                                    <div class="search-dropdown-item" data-order-id="${order.docId || order.orderId}" style="cursor: pointer; padding: 10px; border-bottom: 1px solid var(--border-color);">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <strong>${order.orderId || '[No ID]'}</strong> - ${order.clientName}
                                                <br>
                                                <small style="color: var(--text-gray);">
                                                    üìÖ ${dateDisplay} | üìç ${order.venue || 'N/A'}
                                                </small>
                                            </div>
                                            <span class="status-badge ${statusClass}">${order.status}</span>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            searchResults.style.display = 'block';

                            // Add click handlers to search results
                            searchResults.querySelectorAll('.search-dropdown-item').forEach(item => {
                                const orderId = item.getAttribute('data-order-id');
                                if (orderId && orderId !== 'null') {
                                    item.addEventListener('click', () => {
                                        // Find the order
                                        const order = this.data.orders.find(o =>
                                            o.docId === orderId || o.orderId === orderId
                                        );

                                        if (order) {
                                            // Switch to orders tab
                                            this.switchTab('orders');
                                            // Load order into form for editing
                                            Orders.loadOrderToForm(this, order);
                                            // Clear search
                                            searchInput.value = '';
                                            searchResults.style.display = 'none';
                                        }
                                    });
                                }
                            });
                        }
                    }, 300); // Debounce 300ms
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            },

            // ============ MERGE/UNMERGE ORDERS ============
            toggleOrderSelection(orderId) {
                const checkbox = document.querySelector(`.order-select-checkbox[data-order-id="${orderId}"]`);
                if (!checkbox) return;

                if (checkbox.checked) {
                    if (!this.selectedOrdersForMerge.includes(orderId)) {
                        this.selectedOrdersForMerge.push(orderId);
                    }
                } else {
                    this.selectedOrdersForMerge = this.selectedOrdersForMerge.filter(id => id !== orderId);
                }

                // Show/hide merge button based on selection count
                const mergeBtn = document.getElementById('mergeSelectedBtn');
                const mergeCount = document.getElementById('mergeCount');
                if (mergeBtn) {
                    mergeBtn.style.display = this.selectedOrdersForMerge.length >= 2 ? 'block' : 'none';
                    if (mergeCount) {
                        mergeCount.textContent = this.selectedOrdersForMerge.length;
                    }
                }
            },

            showMergeModal() {
                if (this.selectedOrdersForMerge.length < 2) {
                    alert('Please select at least 2 orders to merge');
                    return;
                }

                // Get selected orders
                const selectedOrders = this.selectedOrdersForMerge.map(id =>
                    this.data.orders.find(o => (o.docId || o.orderId) === id)
                ).filter(o => o);

                if (selectedOrders.length < 2) {
                    alert('Error: Could not find selected orders');
                    return;
                }

                // Create modal HTML
                const modalHTML = `
                    <div class="modal show" id="mergeModalOverlay" onclick="if(event.target === this) document.getElementById('mergeModalOverlay').remove();">
                        <div class="modal-content" style="max-width: 600px;">
                            <div class="modal-header">
                                <h2>üîó Merge Orders</h2>
                            </div>
                            <div class="modal-body">
                                <p style="margin-bottom: 1rem; color: #666;">Select which order to keep as the base. All other orders' content will be merged into it.</p>

                                <div class="form-group">
                                    <label class="form-label">Select Base Order:</label>
                                    <select id="mergeBaseOrder" class="form-select" onchange="OMS.updateMergeOrderId()">
                                        ${selectedOrders.map(order => `
                                            <option value="${order.docId || order.orderId}">
                                                ${order.orderId} - ${order.clientName} (${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)})
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Merged Order ID (editable):</label>
                                    <input type="text" id="mergedOrderId" class="form-input" value="${selectedOrders[0].orderId}">
                                    <small style="color: #666;">You can change the Order ID for the merged order</small>
                                </div>

                                <div style="background: #f0f0f0; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                                    <h4 style="margin: 0 0 0.5rem 0;">Orders to be merged:</h4>
                                    <ul style="margin: 0; padding-left: 1.5rem;">
                                        ${selectedOrders.map(order => `
                                            <li>${order.orderId} - ${order.clientName}</li>
                                        `).join('')}
                                    </ul>
                                    <p style="margin-top: 0.5rem; font-size: 0.9em; color: #666;">
                                        Original orders will be marked as "merged" and can be unmerged later.
                                    </p>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" onclick="document.getElementById('mergeModalOverlay').remove()">Cancel</button>
                                <button class="btn btn-primary" onclick="OMS.performMerge()">üîó Merge Orders</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', modalHTML);
            },

            updateMergeOrderId() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');
                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const baseOrder = this.data.orders.find(o => (o.docId || o.orderId) === baseOrderId);
                if (baseOrder) {
                    orderIdInput.value = baseOrder.orderId;
                }
            },

            async performMerge() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');

                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const newOrderId = orderIdInput.value.trim();

                if (!newOrderId) {
                    alert('Please enter an Order ID for the merged order');
                    return;
                }

                try {
                    // Get all selected orders
                    const ordersToMerge = this.selectedOrdersForMerge.map(id =>
                        this.data.orders.find(o => (o.docId || o.orderId) === id)
                    ).filter(o => o);

                    // Get base order
                    const baseOrder = ordersToMerge.find(o => (o.docId || o.orderId) === baseOrderId);
                    const otherOrders = ordersToMerge.filter(o => (o.docId || o.orderId) !== baseOrderId);

                    if (!baseOrder) {
                        alert('Error: Base order not found');
                        return;
                    }

                    // Store original orders data for unmerge
                    const mergedFromData = ordersToMerge.map(order => ({
                        docId: order.docId,
                        orderId: order.orderId,
                        orderData: JSON.parse(JSON.stringify(order)) // Deep copy
                    }));

                    // Create merged order by combining content
                    const mergedOrder = JSON.parse(JSON.stringify(baseOrder)); // Deep copy
                    mergedOrder.orderId = newOrderId;
                    mergedOrder.mergedFrom = mergedFromData;
                    mergedOrder.mergedAt = new Date().toISOString();

                    // Merge items from other orders (for single-day orders)
                    if (!mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (!order.isMultiDay && order.items && order.items.length > 0) {
                                mergedOrder.items = [...(mergedOrder.items || []), ...order.items];
                            }
                        });
                    }

                    // Merge day-wise data for multi-day orders
                    if (mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (order.isMultiDay && order.dayWiseData) {
                                // Merge dayWiseData intelligently
                                order.dayWiseData.forEach(dayData => {
                                    const existingDayIndex = mergedOrder.dayWiseData.findIndex(d => d.date === dayData.date);
                                    if (existingDayIndex >= 0) {
                                        // Merge functions for same date
                                        mergedOrder.dayWiseData[existingDayIndex].functions = [
                                            ...(mergedOrder.dayWiseData[existingDayIndex].functions || []),
                                            ...(dayData.functions || [])
                                        ];
                                    } else {
                                        // Add new date
                                        mergedOrder.dayWiseData.push(dayData);
                                    }
                                });
                            }
                        });
                    }

                    // Merge notes
                    const allNotes = ordersToMerge.map(o => o.notes).filter(n => n && n.trim()).join('\n---\n');
                    if (allNotes) {
                        mergedOrder.notes = allNotes;
                    }

                    // Update merged order in Firebase
                    await this.updateOrderInFirebase(mergedOrder, baseOrder.docId);

                    // Mark other orders as merged
                    for (const order of otherOrders) {
                        const updatedOrder = { ...order, isMerged: true, mergedInto: newOrderId };
                        await this.updateOrderInFirebase(updatedOrder, order.docId);
                    }

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Close modal
                    document.getElementById('mergeModalOverlay')?.remove();

                    // Clear selection
                    this.selectedOrdersForMerge = [];

                    // Refresh history view
                    this.renderHistory();

                    alert(`‚úÖ Successfully merged ${ordersToMerge.length} orders into ${newOrderId}`);

                } catch (error) {
                    console.error('Error merging orders:', error);
                    alert('Error merging orders: ' + error.message);
                }
            },

            async unmergeOrder(orderId) {
                if (!confirm('Are you sure you want to unmerge this order? This will restore all original separate orders.')) {
                    return;
                }

                try {
                    // Find the merged order
                    const mergedOrder = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                    if (!mergedOrder || !mergedOrder.mergedFrom) {
                        alert('Error: This is not a merged order');
                        return;
                    }

                    console.log(`üîì Unmerging order ${orderId}. Will restore ${mergedOrder.mergedFrom.length} original orders:`,
                        mergedOrder.mergedFrom.map(o => `${o.orderId} (docId: ${o.docId})`));

                    // Restore all original orders
                    for (const originalData of mergedOrder.mergedFrom) {
                        const restoredOrder = originalData.orderData;

                        // Explicitly remove merge-related fields from Firestore
                        restoredOrder.isMerged = firebase.firestore.FieldValue.delete();
                        restoredOrder.mergedInto = firebase.firestore.FieldValue.delete();
                        restoredOrder.mergedFrom = firebase.firestore.FieldValue.delete();
                        restoredOrder.mergedAt = firebase.firestore.FieldValue.delete();

                        console.log(`üìù Restoring order ${originalData.orderId} to docId ${originalData.docId}`);
                        await this.updateOrderInFirebase(restoredOrder, originalData.docId);
                    }

                    // NOTE: We DON'T delete the merged order document because:
                    // - The merged order's docId is the same as the base order's docId
                    // - Restoring the base order already overwrites the merged order data
                    // - Deleting it would delete the restored base order!

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Refresh history view
                    this.renderHistory();

                    alert(`‚úÖ Successfully unmerged order. ${mergedOrder.mergedFrom.length} original orders restored.`);

                } catch (error) {
                    console.error('Error unmerging order:', error);
                    alert('Error unmerging order: ' + error.message);
                }
            },

            async updateOrderInFirebase(orderData, docId) {
                if (!docId) {
                    throw new Error('Document ID is required for update');
                }

                const orderRef = firebase.firestore().collection('orders').doc(docId);
                await orderRef.update(orderData);

                console.log(`Order ${docId} updated in Firebase`);
            },

            // ============ ANALYTICS MODULE ============
            // Loaded lazily from /admin/js/features/analytics.js

            // ============ FINANCIALS MODULE ============
            // Loaded lazily from /admin/js/features/financials.js


            renderAdvertisements() {
                const container = document.getElementById('advertisements');
                const ads = this.data.advertisements || [];

                // Filter stats
                const activeAds = ads.filter(ad => ad.status === 'active').length;
                const scheduledAds = ads.filter(ad => ad.status === 'scheduled').length;
                const inactiveAds = ads.filter(ad => ad.status === 'inactive').length;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üì¢ Ad Manager</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage advertisements displayed on your quotation website</p>
                            <button class="btn btn-primary" onclick="OMS.showCreateAdModal()">‚ûï Create New Ad</button>
                        </div>

                        <!-- Stats Cards -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                            <div class="stat-card" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${activeAds}</div>
                                <div style="opacity: 0.9;">Active Ads</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${scheduledAds}</div>
                                <div style="opacity: 0.9;">Scheduled</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${inactiveAds}</div>
                                <div style="opacity: 0.9;">Inactive</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${ads.length}</div>
                                <div style="opacity: 0.9;">Total Ads</div>
                            </div>
                        </div>

                        <!-- Ads List -->
                        <div class="table-container">
                            ${ads.length === 0 ? `
                                <div style="text-align: center; padding: 3rem;">
                                    <div style="font-size: 4rem; margin-bottom: 1rem;">üì¢</div>
                                    <h3>No Advertisements Yet</h3>
                                    <p style="color: var(--text-gray); margin-bottom: 1.5rem;">Create your first ad to display on your quotation website</p>
                                    <button class="btn btn-primary" onclick="OMS.showCreateAdModal()">Create First Ad</button>
                                </div>
                            ` : `
                                <table class="data-table">
                                    <thead>
                                        <tr>
                                            <th>Title</th>
                                            <th>Type</th>
                                            <th>Animation</th>
                                            <th>Position</th>
                                            <th>Status</th>
                                            <th>Views</th>
                                            <th>Clicks</th>
                                            <th>CTR</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${ads.map((ad, index) => {
                                            const views = ad.analytics?.views || 0;
                                            const clicks = ad.analytics?.clicks || 0;
                                            const ctr = views > 0 ? ((clicks / views) * 100).toFixed(1) : 0;
                                            const statusColors = {
                                                active: '#10b981',
                                                scheduled: '#f59e0b',
                                                inactive: '#6b7280'
                                            };
                                            const typeIcons = {
                                                image: 'üñºÔ∏è',
                                                text: 'üìù',
                                                video: 'üé•'
                                            };

                                            return `
                                                <tr>
                                                    <td><strong>${ad.title}</strong></td>
                                                    <td>${typeIcons[ad.type]} ${ad.type.charAt(0).toUpperCase() + ad.type.slice(1)}</td>
                                                    <td>${ad.type === 'text' && ad.content?.animation ? `<span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 4px 10px; border-radius: 8px; font-size: 0.8rem;">‚ú® ${ad.content.animation}</span>` : '<span style="color: var(--text-gray);">‚Äî</span>'}</td>
                                                    <td>${ad.placement?.position || 'header'}</td>
                                                    <td>
                                                        <span style="background: ${statusColors[ad.status]}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.85rem;">
                                                            ${ad.status.charAt(0).toUpperCase() + ad.status.slice(1)}
                                                        </span>
                                                    </td>
                                                    <td>${views}</td>
                                                    <td>${clicks}</td>
                                                    <td>${ctr}%</td>
                                                    <td>
                                                        <button class="btn btn-sm" onclick="OMS.toggleAdStatus('${ad.id}', ${index})" style="background: ${ad.status === 'active' ? '#f59e0b' : '#10b981'}; color: white; margin-right: 0.5rem;">
                                                            ${ad.status === 'active' ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                                                        </button>
                                                        <button class="btn btn-sm btn-secondary" onclick="OMS.editAd(${index})" style="margin-right: 0.5rem;">‚úèÔ∏è</button>
                                                        <button class="btn btn-sm" onclick="OMS.deleteAd('${ad.id}', ${index})" style="background: var(--danger); color: white;">üóëÔ∏è</button>
                                                    </td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            `}
                        </div>
                    </div>
                `;
            },

            showCreateAdModal() {
                const modalHtml = `
                    <div class="modal-overlay" onclick="OMS.closeAdModal()"></div>
                    <div class="modal-dialog" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>‚ûï Create New Advertisement</h3>
                            <button class="modal-close" onclick="OMS.closeAdModal()">‚úï</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Ad Type *</label>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem;">
                                    <button type="button" class="type-btn active" data-type="image" onclick="OMS.selectAdType('image')" style="padding: 1rem; border: 2px solid var(--primary); background: var(--primary); color: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        üñºÔ∏è Image
                                    </button>
                                    <button type="button" class="type-btn" data-type="text" onclick="OMS.selectAdType('text')" style="padding: 1rem; border: 2px solid var(--border); background: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        üìù Text
                                    </button>
                                    <button type="button" class="type-btn" data-type="video" onclick="OMS.selectAdType('video')" style="padding: 1rem; border: 2px solid var(--border); background: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        üé• Video
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Ad Title *</label>
                                <input type="text" id="adTitle" class="form-control" placeholder="e.g., Summer Special Offer">
                            </div>

                            <!-- Image Ad Fields -->
                            <div id="imageAdFields" class="ad-type-fields">
                                <div class="form-group">
                                    <label>Image URL *</label>
                                    <input type="url" id="adImageUrl" class="form-control" placeholder="https://example.com/image.jpg">
                                    <small style="color: var(--text-gray);">Enter the full URL of your image (must be publicly accessible)</small>
                                </div>
                                <div class="form-group">
                                    <label>Link URL</label>
                                    <input type="url" id="adImageLink" class="form-control" placeholder="https://example.com">
                                </div>
                                <div class="form-group">
                                    <label>Alt Text</label>
                                    <input type="text" id="adImageAlt" class="form-control" placeholder="Promotional banner">
                                </div>

                                <!-- Image Style Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">üé® Image Style Settings</h4>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Max Width: <span id="imageWidthValue">100</span>%</label>
                                            <input type="range" id="adImageWidth" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('imageWidthValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Border Radius: <span id="imageBorderRadiusValue">12</span>px</label>
                                            <input type="range" id="adImageBorderRadius" class="form-control" min="0" max="50" step="2" value="12"
                                                   oninput="document.getElementById('imageBorderRadiusValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Opacity: <span id="imageOpacityValue">100</span>%</label>
                                            <input type="range" id="adImageOpacity" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('imageOpacityValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Shadow Intensity</label>
                                            <select id="adImageShadow" class="form-control">
                                                <option value="none">None</option>
                                                <option value="sm">Small</option>
                                                <option value="md" selected>Medium</option>
                                                <option value="lg">Large</option>
                                                <option value="xl">Extra Large</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div class="form-group">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <input type="checkbox" id="adImageHoverEffect" checked>
                                            Enable Hover Effect (scale on hover)
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- Text Ad Fields -->
                            <div id="textAdFields" class="ad-type-fields" style="display: none;">
                                <div class="form-group">
                                    <label>Headline *</label>
                                    <input type="text" id="adTextHeadline" class="form-control" placeholder="Get 20% Off!">
                                </div>
                                <div class="form-group">
                                    <label>Description</label>
                                    <textarea id="adTextDescription" class="form-control" rows="3" placeholder="Limited time offer..."></textarea>
                                </div>
                                <div class="form-group">
                                    <label>Button Text</label>
                                    <input type="text" id="adTextButton" class="form-control" placeholder="Learn More">
                                </div>
                                <div class="form-group">
                                    <label>Button Link</label>
                                    <input type="url" id="adTextLink" class="form-control" placeholder="https://example.com">
                                </div>
                                <div class="form-group">
                                    <label>üé® Text Color (for all text elements)</label>
                                    <input type="color" id="adTextColor" class="form-control" value="#ffffff">
                                </div>
                                <div class="form-group">
                                    <label>‚ú® Animation Effect</label>
                                    <select id="adTextAnimation" class="form-control">
                                        <option value="none">None</option>
                                        <optgroup label="üé® Fade Effects">
                                            <option value="fadeIn">Fade In</option>
                                            <option value="fadeOut">Fade Out</option>
                                        </optgroup>
                                        <optgroup label="üìä Slide Effects">
                                            <option value="slideInLeft">Slide In from Left</option>
                                            <option value="slideInRight">Slide In from Right</option>
                                            <option value="slideInTop">Slide In from Top</option>
                                            <option value="slideInBottom">Slide In from Bottom</option>
                                        </optgroup>
                                        <optgroup label="üåü Zoom Effects">
                                            <option value="zoomIn">Zoom In</option>
                                            <option value="zoomOut">Zoom Out</option>
                                        </optgroup>
                                        <optgroup label="üîÑ Rotation Effects">
                                            <option value="rotateIn">Rotate In</option>
                                            <option value="swing">Swing</option>
                                        </optgroup>
                                        <optgroup label="üí´ Motion Effects">
                                            <option value="bounce">Bounce</option>
                                            <option value="shake">Shake</option>
                                            <option value="wave">Wave</option>
                                            <option value="rubberBand">Rubber Band</option>
                                        </optgroup>
                                        <optgroup label="‚ú® Special Effects">
                                            <option value="pulse">Pulse</option>
                                            <option value="glow">Glow</option>
                                            <option value="sparkle">Sparkle</option>
                                            <option value="flipIn">Flip In</option>
                                            <option value="flipX">Flip X</option>
                                        </optgroup>
                                    </select>
                                    <small style="color: var(--text-gray); margin-top: 0.5rem; display: block;">Choose an animation effect for your text ad</small>
                                </div>

                                <!-- Typography Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">üî§ Typography Settings</h4>

                                    <div class="form-group">
                                        <label>Headline Font Size: <span id="headlineSizeValue">2</span>rem</label>
                                        <input type="range" id="adTextHeadlineSize" class="form-control" min="1" max="6" step="0.1" value="2"
                                               oninput="document.getElementById('headlineSizeValue').textContent = this.value"
                                               style="width: 100%;">
                                        <small style="color: var(--text-gray);">Adjust headline text size</small>
                                    </div>

                                    <div class="form-group">
                                        <label>Description Font Size: <span id="descSizeValue">1.1</span>rem</label>
                                        <input type="range" id="adTextDescSize" class="form-control" min="0.5" max="3" step="0.1" value="1.1"
                                               oninput="document.getElementById('descSizeValue').textContent = this.value"
                                               style="width: 100%;">
                                        <small style="color: var(--text-gray);">Adjust description text size</small>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Font Weight</label>
                                            <select id="adTextFontWeight" class="form-control">
                                                <option value="300">Light (300)</option>
                                                <option value="400">Normal (400)</option>
                                                <option value="500">Medium (500)</option>
                                                <option value="600">Semi-Bold (600)</option>
                                                <option value="700" selected>Bold (700)</option>
                                                <option value="800">Extra-Bold (800)</option>
                                                <option value="900">Black (900)</option>
                                            </select>
                                        </div>

                                        <div class="form-group">
                                            <label>Text Alignment</label>
                                            <select id="adTextAlign" class="form-control">
                                                <option value="left">Left</option>
                                                <option value="center" selected>Center</option>
                                                <option value="right">Right</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Letter Spacing: <span id="letterSpaceValue">0</span>px</label>
                                            <input type="range" id="adTextLetterSpacing" class="form-control" min="-2" max="10" step="0.5" value="0"
                                                   oninput="document.getElementById('letterSpaceValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Line Height: <span id="lineHeightValue">1.5</span></label>
                                            <input type="range" id="adTextLineHeight" class="form-control" min="1" max="3" step="0.1" value="1.5"
                                                   oninput="document.getElementById('lineHeightValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div class="form-group">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <input type="checkbox" id="adTextShadow">
                                            Add Text Shadow (improves readability)
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- Video Ad Fields -->
                            <div id="videoAdFields" class="ad-type-fields" style="display: none;">
                                <div class="form-group">
                                    <label>Video URL *</label>
                                    <input type="url" id="adVideoUrl" class="form-control" placeholder="YouTube or Instagram URL">
                                    <small style="color: var(--text-gray);">Paste a YouTube or Instagram video URL</small>
                                </div>
                                <div class="form-group">
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="adVideoAutoplay" checked>
                                        Autoplay video
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                                        <input type="checkbox" id="adVideoMuted" checked>
                                        Muted by default
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                                        <input type="checkbox" id="adVideoLoop">
                                        Loop video continuously
                                    </label>
                                </div>

                                <!-- Video Style Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">üé¨ Video Style Settings</h4>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Max Width: <span id="videoWidthValue">100</span>%</label>
                                            <input type="range" id="adVideoWidth" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('videoWidthValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Border Radius: <span id="videoBorderRadiusValue">12</span>px</label>
                                            <input type="range" id="adVideoBorderRadius" class="form-control" min="0" max="50" step="2" value="12"
                                                   oninput="document.getElementById('videoBorderRadiusValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Aspect Ratio</label>
                                            <select id="adVideoAspectRatio" class="form-control">
                                                <option value="16/9" selected>16:9 (Widescreen)</option>
                                                <option value="9/16">9:16 (Vertical)</option>
                                                <option value="4/3">4:3 (Standard)</option>
                                                <option value="1/1">1:1 (Square)</option>
                                            </select>
                                        </div>

                                        <div class="form-group">
                                            <label>Shadow Intensity</label>
                                            <select id="adVideoShadow" class="form-control">
                                                <option value="none">None</option>
                                                <option value="sm">Small</option>
                                                <option value="md" selected>Medium</option>
                                                <option value="lg">Large</option>
                                                <option value="xl">Extra Large</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Placement -->
                            <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1.5rem;">
                                <h4 style="margin-bottom: 1rem;">üìç Placement Settings</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div class="form-group">
                                        <label>Position *</label>
                                        <select id="adPosition" class="form-control">
                                            <option value="header">Header Banner</option>
                                            <option value="sidebar">Sidebar</option>
                                            <option value="footer">Footer</option>
                                            <option value="popup">Popup/Modal</option>
                                            <option value="between-sections">Between Sections</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Display On *</label>
                                        <select id="adPage" class="form-control">
                                            <option value="all">All Pages</option>
                                            <option value="home">Home Page Only</option>
                                            <option value="quotation">Quotation Page Only</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Schedule -->
                            <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                <h4 style="margin-bottom: 1rem;">‚è∞ Schedule Settings</h4>
                                <div class="form-group">
                                    <label>Status *</label>
                                    <select id="adStatus" class="form-control" onchange="OMS.toggleScheduleFields()">
                                        <option value="active">Active Now</option>
                                        <option value="scheduled">Schedule for Later</option>
                                        <option value="inactive">Inactive (Draft)</option>
                                    </select>
                                </div>
                                <div id="scheduleFields" style="display: none;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Start Date</label>
                                            <input type="datetime-local" id="adStartDate" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label>End Date</label>
                                            <input type="datetime-local" id="adEndDate" class="form-control">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group" style="margin-top: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <input type="checkbox" id="adVisible" checked>
                                    Show ad on website
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="OMS.closeAdModal()">Cancel</button>
                            <button class="btn btn-primary" onclick="OMS.saveAd()" id="saveAdBtn">Create Ad</button>
                        </div>
                    </div>
                `;

                const existing = document.querySelector('.modal-overlay');
                if (existing) existing.remove();

                document.body.insertAdjacentHTML('beforeend', modalHtml);
            },

            selectAdType(type) {
                document.querySelectorAll('.type-btn').forEach(btn => {
                    if (btn.dataset.type === type) {
                        btn.style.background = 'var(--primary)';
                        btn.style.borderColor = 'var(--primary)';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.borderColor = 'var(--border)';
                        btn.style.color = 'var(--text-dark)';
                    }
                });

                document.getElementById('imageAdFields').style.display = type === 'image' ? 'block' : 'none';
                document.getElementById('textAdFields').style.display = type === 'text' ? 'block' : 'none';
                document.getElementById('videoAdFields').style.display = type === 'video' ? 'block' : 'none';
            },

            toggleScheduleFields() {
                const status = document.getElementById('adStatus').value;
                document.getElementById('scheduleFields').style.display = status === 'scheduled' ? 'block' : 'none';
            },

            closeAdModal() {
                const overlay = document.querySelector('.modal-overlay');
                const dialog = document.querySelector('.modal-dialog');
                if (overlay) overlay.remove();
                if (dialog) dialog.remove();
            },

            async saveAd() {
                try {
                    console.log('üíæ saveAd() called');

                    const activeTypeBtn = document.querySelector('.type-btn[style*="rgb(102, 126, 234)"], .type-btn[style*="#667eea"]') ||
                                        document.querySelector('.type-btn[style*="--primary"]') ||
                                        document.querySelector('.type-btn');
                    const adType = activeTypeBtn?.dataset.type || 'image';

                    console.log('üìù Ad type:', adType);

                    const title = document.getElementById('adTitle').value.trim();
                    if (!title) {
                        alert('Please enter an ad title');
                        return;
                    }

                    console.log('üìù Ad title:', title);

                    let content = {};

                    if (adType === 'image') {
                        const imageUrl = document.getElementById('adImageUrl').value.trim();
                        if (!imageUrl) {
                            alert('Please enter an image URL');
                            return;
                        }
                        content = {
                            imageUrl,
                            link: document.getElementById('adImageLink').value.trim(),
                            altText: document.getElementById('adImageAlt').value.trim(),
                            width: document.getElementById('adImageWidth').value,
                            borderRadius: document.getElementById('adImageBorderRadius').value,
                            opacity: document.getElementById('adImageOpacity').value,
                            shadow: document.getElementById('adImageShadow').value,
                            hoverEffect: document.getElementById('adImageHoverEffect').checked
                        };
                    } else if (adType === 'text') {
                        const headline = document.getElementById('adTextHeadline').value.trim();
                        if (!headline) {
                            alert('Please enter a headline');
                            return;
                        }
                        content = {
                            headline,
                            description: document.getElementById('adTextDescription').value.trim(),
                            buttonText: document.getElementById('adTextButton').value.trim(),
                            buttonLink: document.getElementById('adTextLink').value.trim(),
                            backgroundColor: 'transparent',
                            textColor: document.getElementById('adTextColor').value,
                            animation: document.getElementById('adTextAnimation').value || 'none',
                            headlineSize: document.getElementById('adTextHeadlineSize').value,
                            descSize: document.getElementById('adTextDescSize').value,
                            fontWeight: document.getElementById('adTextFontWeight').value,
                            textAlign: document.getElementById('adTextAlign').value,
                            letterSpacing: document.getElementById('adTextLetterSpacing').value,
                            lineHeight: document.getElementById('adTextLineHeight').value,
                            textShadow: document.getElementById('adTextShadow').checked
                        };
                    } else if (adType === 'video') {
                        const videoUrl = document.getElementById('adVideoUrl').value.trim();
                        if (!videoUrl) {
                            alert('Please enter a video URL');
                            return;
                        }
                        content = {
                            videoUrl,
                            platform: videoUrl.includes('youtube') ? 'youtube' : 'instagram',
                            autoplay: document.getElementById('adVideoAutoplay').checked,
                            muted: document.getElementById('adVideoMuted').checked,
                            loop: document.getElementById('adVideoLoop').checked,
                            width: document.getElementById('adVideoWidth').value,
                            borderRadius: document.getElementById('adVideoBorderRadius').value,
                            aspectRatio: document.getElementById('adVideoAspectRatio').value,
                            shadow: document.getElementById('adVideoShadow').value
                        };
                    }

                    console.log('üìù Ad content:', content);

                    const status = document.getElementById('adStatus').value;
                    const schedule = {};
                    if (status === 'scheduled') {
                        schedule.startDate = document.getElementById('adStartDate').value;
                        schedule.endDate = document.getElementById('adEndDate').value;
                    }

                    const ad = {
                        id: 'ad_' + Date.now(),
                        type: adType,
                        title,
                        status,
                        content,
                        placement: {
                            position: document.getElementById('adPosition').value,
                            page: document.getElementById('adPage').value,
                            displayOrder: 1
                        },
                        schedule,
                        analytics: {
                            views: 0,
                            clicks: 0,
                            impressions: 0
                        },
                        isVisible: document.getElementById('adVisible').checked,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        createdBy: this.currentUser?.email || 'admin'
                    };

                    console.log('üì¶ Complete ad object:', ad);

                    if (!this.data.advertisements) {
                        console.log('‚ö†Ô∏è Initializing advertisements array');
                        this.data.advertisements = [];
                    }

                    console.log('üìä Current advertisements count:', this.data.advertisements.length);
                    this.data.advertisements.push(ad);
                    console.log('üìä New advertisements count:', this.data.advertisements.length);

                    console.log('üíæ Calling saveAdsToFirestore...');
                    await this.saveAdsToFirestore();
                    console.log('‚úÖ Save completed successfully');

                    this.closeAdModal();
                    this.renderAdvertisements();
                    this.showToast('‚úÖ Advertisement created successfully!');
                } catch (error) {
                    console.error('‚ùå Error in saveAd():', error);
                    console.error('Error stack:', error.stack);
                    this.showToast('‚ùå Error creating advertisement. Check console for details.', 'error');
                }
            },

            async editAd(index) {
                const ad = this.data.advertisements[index];
                this.showCreateAdModal();

                setTimeout(() => {
                    document.getElementById('adTitle').value = ad.title || '';
                    document.getElementById('adStatus').value = ad.status || 'active';
                    document.getElementById('adPosition').value = ad.placement?.position || 'header';
                    document.getElementById('adPage').value = ad.placement?.page || 'all';
                    document.getElementById('adVisible').checked = ad.isVisible !== false;

                    this.selectAdType(ad.type);

                    if (ad.type === 'image') {
                        document.getElementById('adImageUrl').value = ad.content.imageUrl || '';
                        document.getElementById('adImageLink').value = ad.content.link || '';
                        document.getElementById('adImageAlt').value = ad.content.altText || '';
                        document.getElementById('adImageWidth').value = ad.content.width || '100';
                        document.getElementById('adImageBorderRadius').value = ad.content.borderRadius || '12';
                        document.getElementById('adImageOpacity').value = ad.content.opacity || '100';
                        document.getElementById('adImageShadow').value = ad.content.shadow || 'md';
                        document.getElementById('adImageHoverEffect').checked = ad.content.hoverEffect !== false;
                        // Update display values
                        document.getElementById('imageWidthValue').textContent = ad.content.width || '100';
                        document.getElementById('imageBorderRadiusValue').textContent = ad.content.borderRadius || '12';
                        document.getElementById('imageOpacityValue').textContent = ad.content.opacity || '100';
                    } else if (ad.type === 'text') {
                        document.getElementById('adTextHeadline').value = ad.content.headline || '';
                        document.getElementById('adTextDescription').value = ad.content.description || '';
                        document.getElementById('adTextButton').value = ad.content.buttonText || '';
                        document.getElementById('adTextLink').value = ad.content.buttonLink || '';
                        document.getElementById('adTextColor').value = ad.content.textColor || '#ffffff';
                        document.getElementById('adTextAnimation').value = ad.content.animation || 'none';
                        document.getElementById('adTextHeadlineSize').value = ad.content.headlineSize || '2';
                        document.getElementById('adTextDescSize').value = ad.content.descSize || '1.1';
                        document.getElementById('adTextFontWeight').value = ad.content.fontWeight || '700';
                        document.getElementById('adTextAlign').value = ad.content.textAlign || 'center';
                        document.getElementById('adTextLetterSpacing').value = ad.content.letterSpacing || '0';
                        document.getElementById('adTextLineHeight').value = ad.content.lineHeight || '1.5';
                        document.getElementById('adTextShadow').checked = ad.content.textShadow || false;
                        // Update display values
                        document.getElementById('headlineSizeValue').textContent = ad.content.headlineSize || '2';
                        document.getElementById('descSizeValue').textContent = ad.content.descSize || '1.1';
                        document.getElementById('letterSpaceValue').textContent = ad.content.letterSpacing || '0';
                        document.getElementById('lineHeightValue').textContent = ad.content.lineHeight || '1.5';
                    } else if (ad.type === 'video') {
                        document.getElementById('adVideoUrl').value = ad.content.videoUrl || '';
                        document.getElementById('adVideoAutoplay').checked = ad.content.autoplay !== false;
                        document.getElementById('adVideoMuted').checked = ad.content.muted !== false;
                        document.getElementById('adVideoLoop').checked = ad.content.loop || false;
                        document.getElementById('adVideoWidth').value = ad.content.width || '100';
                        document.getElementById('adVideoBorderRadius').value = ad.content.borderRadius || '12';
                        document.getElementById('adVideoAspectRatio').value = ad.content.aspectRatio || '16/9';
                        document.getElementById('adVideoShadow').value = ad.content.shadow || 'md';
                        // Update display values
                        document.getElementById('videoWidthValue').textContent = ad.content.width || '100';
                        document.getElementById('videoBorderRadiusValue').textContent = ad.content.borderRadius || '12';
                    }

                    if (ad.schedule?.startDate) {
                        document.getElementById('adStartDate').value = ad.schedule.startDate;
                    }
                    if (ad.schedule?.endDate) {
                        document.getElementById('adEndDate').value = ad.schedule.endDate;
                    }

                    this.toggleScheduleFields();

                    const saveBtn = document.getElementById('saveAdBtn');
                    saveBtn.textContent = 'Update Ad';
                    saveBtn.onclick = () => this.updateAd(index);
                }, 100);
            },

            async updateAd(index) {
                try {
                    const ad = this.data.advertisements[index];
                    const activeTypeBtn = document.querySelector('.type-btn[style*="rgb(102, 126, 234)"], .type-btn[style*="#667eea"]') ||
                                        document.querySelector('.type-btn[style*="--primary"]') ||
                                        document.querySelector('.type-btn');
                    const adType = activeTypeBtn?.dataset.type || ad.type;

                    ad.title = document.getElementById('adTitle').value.trim();
                    ad.status = document.getElementById('adStatus').value;
                    ad.placement.position = document.getElementById('adPosition').value;
                    ad.placement.page = document.getElementById('adPage').value;
                    ad.isVisible = document.getElementById('adVisible').checked;
                    ad.updatedAt = new Date().toISOString();

                    if (ad.type === 'image') {
                        ad.content.imageUrl = document.getElementById('adImageUrl').value.trim();
                        ad.content.link = document.getElementById('adImageLink').value.trim();
                        ad.content.altText = document.getElementById('adImageAlt').value.trim();
                        ad.content.width = document.getElementById('adImageWidth').value;
                        ad.content.borderRadius = document.getElementById('adImageBorderRadius').value;
                        ad.content.opacity = document.getElementById('adImageOpacity').value;
                        ad.content.shadow = document.getElementById('adImageShadow').value;
                        ad.content.hoverEffect = document.getElementById('adImageHoverEffect').checked;
                    } else if (ad.type === 'text') {
                        ad.content.headline = document.getElementById('adTextHeadline').value.trim();
                        ad.content.description = document.getElementById('adTextDescription').value.trim();
                        ad.content.buttonText = document.getElementById('adTextButton').value.trim();
                        ad.content.buttonLink = document.getElementById('adTextLink').value.trim();
                        ad.content.backgroundColor = 'transparent';
                        ad.content.textColor = document.getElementById('adTextColor').value;
                        ad.content.animation = document.getElementById('adTextAnimation').value || 'none';
                        ad.content.headlineSize = document.getElementById('adTextHeadlineSize').value;
                        ad.content.descSize = document.getElementById('adTextDescSize').value;
                        ad.content.fontWeight = document.getElementById('adTextFontWeight').value;
                        ad.content.textAlign = document.getElementById('adTextAlign').value;
                        ad.content.letterSpacing = document.getElementById('adTextLetterSpacing').value;
                        ad.content.lineHeight = document.getElementById('adTextLineHeight').value;
                        ad.content.textShadow = document.getElementById('adTextShadow').checked;
                    } else if (ad.type === 'video') {
                        ad.content.videoUrl = document.getElementById('adVideoUrl').value.trim();
                        ad.content.autoplay = document.getElementById('adVideoAutoplay').checked;
                        ad.content.muted = document.getElementById('adVideoMuted').checked;
                        ad.content.loop = document.getElementById('adVideoLoop').checked;
                        ad.content.width = document.getElementById('adVideoWidth').value;
                        ad.content.borderRadius = document.getElementById('adVideoBorderRadius').value;
                        ad.content.aspectRatio = document.getElementById('adVideoAspectRatio').value;
                        ad.content.shadow = document.getElementById('adVideoShadow').value;
                    }

                    if (ad.status === 'scheduled') {
                        ad.schedule = {
                            startDate: document.getElementById('adStartDate').value,
                            endDate: document.getElementById('adEndDate').value
                        };
                    }

                    await this.saveAdsToFirestore();
                    this.closeAdModal();
                    this.renderAdvertisements();
                    this.showToast('‚úÖ Advertisement updated successfully!');
                } catch (error) {
                    console.error('Error updating ad:', error);
                    this.showToast('‚ùå Error updating advertisement. Please try again.', 'error');
                }
            },

            async toggleAdStatus(adId, index) {
                try {
                    const ad = this.data.advertisements[index];
                    ad.status = ad.status === 'active' ? 'inactive' : 'active';
                    ad.updatedAt = new Date().toISOString();

                    await this.saveAdsToFirestore();
                    this.renderAdvertisements();

                    const statusText = ad.status === 'active' ? 'activated' : 'paused';
                    this.showToast(`‚úÖ Ad ${statusText} successfully!`);
                } catch (error) {
                    console.error('Error toggling ad status:', error);
                    this.showToast('‚ùå Error updating ad status. Please try again.', 'error');
                }
            },

            async deleteAd(adId, index) {
                if (!confirm('Are you sure you want to delete this advertisement? This action cannot be undone.')) {
                    return;
                }

                try {
                    this.data.advertisements.splice(index, 1);
                    await this.saveAdsToFirestore();
                    this.renderAdvertisements();
                    this.showToast('‚úÖ Advertisement deleted successfully!');
                } catch (error) {
                    console.error('Error deleting ad:', error);
                    this.showToast('‚ùå Error deleting advertisement. Please try again.', 'error');
                }
            },

            async saveAdsToFirestore() {
                const database = window.db || this.db;
                if (!database) {
                    console.error('‚ùå Database not initialized');
                    console.error('window.db:', window.db);
                    console.error('this.db:', this.db);
                    return;
                }

                try {
                    console.log('üíæ Starting to save ads to Firestore...');
                    console.log('‚úÖ Using database:', database ? 'Connected' : 'Not connected');
                    console.log('üìä Ads to save:', this.data.advertisements);

                    const adsRef = database.collection('advertisements');

                    // Delete all existing ads
                    console.log('üóëÔ∏è Deleting existing ads...');
                    const snapshot = await adsRef.get();
                    console.log('üì¶ Found', snapshot.size, 'existing ads to delete');

                    const batch = database.batch();
                    snapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    console.log('‚úÖ Existing ads deleted');

                    // Add all current ads
                    console.log('üíæ Adding', this.data.advertisements.length, 'new ads...');
                    const newBatch = database.batch();
                    this.data.advertisements.forEach(ad => {
                        console.log('üìù Adding ad:', ad.id, ad.title);
                        const docRef = adsRef.doc(ad.id);
                        newBatch.set(docRef, ad);
                    });
                    await newBatch.commit();

                    console.log('‚úÖ Advertisements saved to Firestore successfully!');
                } catch (error) {
                    console.error('‚ùå Error saving ads to Firestore:', error);
                    console.error('Error details:', error.message, error.code);
                    throw error;
                }
            },

            async loadAdsFromFirestore() {
                const database = window.db || this.db;
                if (!database) {
                    console.error('‚ùå Database not initialized for loading ads');
                    return;
                }

                try {
                    console.log('üì• Loading advertisements from Firestore...');
                    const snapshot = await database.collection('advertisements').get();
                    this.data.advertisements = snapshot.docs.map(doc => doc.data());
                    console.log('‚úÖ Advertisements loaded from Firestore:', this.data.advertisements.length);
                    console.log('üìã Loaded ads:', this.data.advertisements);
                } catch (error) {
                    console.error('‚ùå Error loading ads from Firestore:', error);
                    console.error('Error details:', error.message, error.code);
                    this.data.advertisements = [];
                }
            },

            // ============ ITEM SEARCH & ORDER MANAGEMENT ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Prevent duplicate event listener registration
                if (itemSearch.dataset.searchInitialized === 'true') return;
                itemSearch.dataset.searchInitialized = 'true';

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                // Capture OMS context
                const self = this;

                const handleSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const items = self.data.inventory.items.filter(i =>
                            i.name.toLowerCase().includes(query)
                        );

                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                itemSearch.addEventListener('input', Utils.debounce(handleSearch, 300));

                // Initialize client name search with autocomplete
                this.initClientSearch();
            },

            initClientSearch() {
                const clientInput = document.getElementById('clientName');
                const dropdown = document.getElementById('clientSearchDropdown');

                if (!clientInput || !dropdown) return;

                // Prevent duplicate event listener registration
                if (clientInput.dataset.searchInitialized === 'true') return;
                clientInput.dataset.searchInitialized = 'true';

                // Capture OMS context
                const self = this;

                const handleClientSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const customers = self.data.customers.filter(c =>
                            c.name.toLowerCase().includes(query)
                        );

                        if (customers.length > 0) {
                            dropdown.innerHTML = customers.map(c => `
                                <div class="search-item" onclick="OMS.selectCustomer('${c.id}')">
                                    <span>${c.name}</span>
                                    <span style="color: var(--text-gray);">${c.contact}</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                clientInput.addEventListener('input', Utils.debounce(handleClientSearch, 300));

                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!clientInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            },

            selectCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                // Auto-fill customer name and contact
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);

                // Hide dropdown
                document.getElementById('clientSearchDropdown').classList.remove('show');
                this.showToast(`Selected: ${customer.name}`, 'success');
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;

                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }

                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;

                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }

                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)"
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}"
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ TEAM DROPDOWN POPULATION ============
            populateTeamDropdowns() {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');

                // Populate Driver dropdown
                const driverSelect = document.getElementById('driverName');
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Driver 2 dropdown
                const driver2Select = document.getElementById('driverName2');
                if (driver2Select) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driver2Select.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown
                const operatorSelect = document.getElementById('operator');
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}">‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');
                const functionId = `day${dayIndex}func${functionIndex}`;

                // Populate Driver multi-select for this function
                const driverSelect = document.getElementById(`${functionId}Driver`);
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    const currentValues = Array.from(driverSelect.selectedOptions).map(opt => opt.value);
                    driverSelect.innerHTML = drivers.map(d =>
                        `<option value="${d.name}" data-id="${d.id}" ${currentValues.includes(d.name) ? 'selected' : ''}>üöó ${d.name}</option>`
                    ).join('');
                }

                // Populate Operator dropdown for this function
                const operatorSelect = document.getElementById(`${functionId}Operator`);
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    const currentValue = operatorSelect.value;
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}" ${o.name === currentValue ? 'selected' : ''}>‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            updateTeamDropdowns() {
                // Update single-day order form dropdowns
                this.populateTeamDropdowns();

                // Update multiday function dropdowns if they exist
                const multidayData = this.data.multidayOrders || [];
                multidayData.forEach((day, dayIndex) => {
                    if (day.functions) {
                        day.functions.forEach((func, functionIndex) => {
                            this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
                        });
                    }
                });
            },

            renderTeamTable() {
                // Wrapper function - delegates to Team module if loaded
                if (window.Team && typeof window.Team.renderTeamTable === 'function') {
                    window.Team.renderTeamTable(this);
                } else {
                    // Module not loaded yet - skip
                    console.log('Team module not loaded yet');
                }
            },

            closeModal(modalId = 'dynamicModal') {
                const modal = document.getElementById(modalId);
                if (modal) {
                    // Remove escape handler if it exists (for dynamicModal)
                    if (modal._escapeHandler) {
                        document.removeEventListener('keydown', modal._escapeHandler);
                    }
                    modal.remove();
                }
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('üì• Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                itemHistory: [], // Will load from Firestore
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        // Check if user has permission to load financial data
        const canViewFinancials = await this.canViewFinancials();

        const loadPromises = [
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadItemHistoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore(),
            this.loadQuotationsFromFirestore()
        ];

        // Only load financial data if user has permission
        if (canViewFinancials) {
            loadPromises.push(this.loadPaymentsFromFirestore());
            loadPromises.push(this.loadExpensesFromFirestore());
        } else {
            console.log('‚ÑπÔ∏è Skipping financial data - user does not have admin/owner role');
        }

        await Promise.all(loadPromises);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('‚úÖ All data loaded from Firestore successfully!');

        // Update all displays after data is loaded to ensure dashboard and other tabs show fresh data
        this.updateAllDisplays();

    } catch (error) {
        console.error('‚ùå Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('üì• Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`‚ö†Ô∏è Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                console.warn(`   Customer: ${customer.name}, Date: ${customer.dates}`);
                skippedDeleted++;
                return;
            }

            // IMPORTANT: Include ALL fields from Firestore
            const loadedOrder = {
                ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                // Legacy field mappings for backwards compatibility
                date: orderData.date || Utils.convertDateFormat(customer.dates) || '',
                readyTime: orderData.readyTime || customer.timeSlot || '',
                clientName: orderData.clientName || customer.name || '',
                contact: orderData.contact || customer.phone || '',
                venue: orderData.venue || customer.venue || '',
                eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                // Normalize items to use consistent field names
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.quantity || item.qty || 0,
                    remarks: item.remarks || item.desc || '',
                    price: item.price || 0
                }))
            };

            // Debug log multi-day and merged orders
            if (orderData.isMultiDay) {
                console.log(`üìÖ Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }
            if (orderData.isMerged) {
                console.log(`üîó Loaded merged order ${orderId}:`, {
                    isMerged: loadedOrder.isMerged,
                    mergedInto: loadedOrder.mergedInto
                });
            }
            if (orderData.mergedFrom) {
                console.log(`üîó Loaded MERGED result order ${orderId}:`, {
                    mergedFrom: loadedOrder.mergedFrom?.length || 0,
                    mergedAt: loadedOrder.mergedAt
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`‚úÖ Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('‚ùå Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('üìä Loading tracking data from Firestore...');

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('‚ö†Ô∏è Not authenticated yet - skipping tracking data load');
            this.data.trackingData = [];
            return;
        }

        // Load without orderBy to avoid index requirement
        // We'll sort in JavaScript instead
        const trackingSnapshot = await db.collection('tracking')
            .limit(500)  // Get more data, will sort client-side
            .get();

        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });

        // Sort by timestamp in JavaScript (newest first)
        this.data.trackingData.sort((a, b) => b.timestamp - a.timestamp);

        console.log(`‚úÖ Loaded ${this.data.trackingData.length} tracking events from website`);
        console.log(`üìç Sample data:`, this.data.trackingData.slice(0, 3));

    } catch (error) {
        console.error('‚ùå Error loading tracking data:', error);
        console.error('Error details:', error.code, error.message);

        // If permissions error, log it but don't retry
        // (retrying won't help if Firestore rules don't allow access)
        if (error.code === 'permission-denied') {
            console.warn('‚ö†Ô∏è Insufficient permissions to access tracking data. Please check Firestore security rules.');
        }

        this.data.trackingData = [];
    }
},

async loadEventsListFromFirestore() {
    try {
        console.log('üìã Loading events list from Firestore...');

        // Ensure eventsList has a default value if not already set
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            console.log('üìù Initializing default events list');
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
            console.log('‚úÖ Default events list initialized with', this.data.eventsList.length, 'events');
        }

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('‚ö†Ô∏è Not authenticated yet - using default events list');
            return;
        }

        const eventsDoc = await db.collection('settings').doc('eventsList').get();

        if (eventsDoc.exists) {
            const data = eventsDoc.data();
            if (data.events && Array.isArray(data.events)) {
                this.data.eventsList = data.events;
                console.log(`‚úÖ Loaded ${this.data.eventsList.length} events from Firestore`);
            }
        } else {
            console.log('üìù No events list in Firestore yet - saving default list');
            // Save the default list to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                createdAt: new Date().toISOString()
            });
            console.log('‚úÖ Saved default events list to Firestore');
        }

    } catch (error) {
        console.error('‚ùå Error loading events list:', error);
        console.warn('‚ö†Ô∏è Using default events list');
        // Ensure default list is available even on error
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
        }
    }
},

// ============ TEAM FIRESTORE SYNC ============

async saveTeamMemberToFirestore(teamMember) {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('‚ùå No user logged in');
            return false;
        }

        await db.collection('team').doc(teamMember.id).set({
            ...teamMember,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Team member saved to Firestore:', teamMember.name);
        return true;
    } catch (error) {
        console.error('‚ùå Error saving team member to Firestore:', error);
        this.showToast('Failed to sync team member: ' + error.message, 'error');
        return false;
    }
},

async loadTeamFromFirestore() {
    try {
        console.log('üë∑ Loading team from Firestore...');

        const teamSnapshot = await db.collection('team')
            .orderBy('createdAt', 'desc')
            .get();

        this.data.team = [];
        teamSnapshot.forEach(doc => {
            this.data.team.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`‚úÖ Loaded ${this.data.team.length} team members from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading team from Firestore:', error);
        // Try to load from localStorage as fallback
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data.team = parsed.team || [];
            console.log('üì¶ Loaded team from localStorage backup');
        }
        return false;
    }
},

async deleteTeamMemberFromFirestore(teamMemberId) {
    try {
        await db.collection('team').doc(teamMemberId).delete();
        console.log('‚úÖ Team member deleted from Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting team member from Firestore:', error);
        return false;
    }
},

// ============ VIDEOS FIRESTORE SYNC ============

async saveVideosToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('‚ùå No user logged in');
            return false;
        }

        // Save videos to admin/data document
        await db.collection('admin').doc('data').set({
            videos: this.data.videos || [],
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('‚úÖ Videos saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving videos to Firestore:', error);
        return false;
    }
},

async loadVideosFromFirestore() {
    try {
        console.log('üé• Loading videos from Firestore...');

        const dataDoc = await db.collection('admin').doc('data').get();

        if (dataDoc.exists) {
            const data = dataDoc.data();
            this.data.videos = data.videos || [];
            console.log(`‚úÖ Loaded ${this.data.videos.length} videos from Firestore`);
        } else {
            this.data.videos = [];
            console.log('üìù No videos found in Firestore - initialized empty array');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Error loading videos from Firestore:', error);
        this.data.videos = [];
        return false;
    }
},

// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('üì¶ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`üì¶ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`üì¶ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`‚úÖ Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`‚úÖ Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`‚ö†Ô∏è Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('üîÑ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('‚úÖ Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('‚ö†Ô∏è‚ö†Ô∏è Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('‚ùå‚ùå CRITICAL: Both Firestore AND local are empty!');
            console.error('‚ùå ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('‚ö†Ô∏è Keeping existing local inventory due to error');
        return false;
    }
},

async loadItemHistoryFromFirestore() {
    try {
        console.log('üìú Loading item history from Firestore...');

        const snapshot = await db.collection('itemHistory').orderBy('usedAt', 'desc').get();
        const history = [];
        snapshot.forEach(doc => {
            history.push({ id: doc.id, ...doc.data() });
        });

        this.data.itemHistory = history;
        console.log(`‚úÖ Loaded ${history.length} item history records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading item history from Firestore:', error);
        return false;
    }
},

async loadPaymentsFromFirestore() {
    try {
        console.log('üíµ Loading payments from Firestore...');

        const snapshot = await db.collection('payments').orderBy('timestamp', 'desc').get();
        const payments = [];
        snapshot.forEach(doc => {
            payments.push({ id: doc.id, ...doc.data() });
        });

        this.data.payments = payments;
        console.log(`‚úÖ Loaded ${payments.length} payment records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading payments from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('üîí Permission Denied: You need admin/owner role to access financial data');
            console.error('üí° Solution: Run the setup script or create your user_roles document manually');
            console.error('üìñ Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async loadExpensesFromFirestore() {
    try {
        console.log('üí∏ Loading expenses from Firestore...');

        const snapshot = await db.collection('expenses').orderBy('timestamp', 'desc').get();
        const expenses = [];
        snapshot.forEach(doc => {
            expenses.push({ id: doc.id, ...doc.data() });
        });

        this.data.expenses = expenses;
        console.log(`‚úÖ Loaded ${expenses.length} expense records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading expenses from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('üîí Permission Denied: You need admin/owner role to access financial data');
            console.error('üí° Solution: Run the setup script or create your user_roles document manually');
            console.error('üìñ Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('‚úÖ Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('‚úÖ Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('‚úÖ Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('üîî Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`‚úÖ Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ SETTINGS FIRESTORE SYNC ============

async saveSettingsToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) return false;

        await db.collection('settings').doc('app_settings').set({
            ...this.data.settings,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Settings saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving settings to Firestore:', error);
        return false;
    }
},

async loadSettingsFromFirestore() {
    try {
        console.log('‚öôÔ∏è Loading settings from Firestore...');

        const settingsDoc = await db.collection('settings').doc('app_settings').get();

        if (settingsDoc.exists) {
            const firestoreSettings = settingsDoc.data();
            // Merge with default settings
            this.data.settings = {
                ...this.data.settings,
                ...firestoreSettings
            };
            console.log('‚úÖ Settings loaded from Firestore');
            return true;
        } else {
            console.log('üìù No settings in Firestore, using defaults');
            // Save default settings to Firestore
            await this.saveSettingsToFirestore();
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error loading settings from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('‚ö†Ô∏è All listeners already active');
        return;
    }

    console.log('üîÑ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('üë∑ Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                    console.log('üë∑ Team member updated:', teamMember.name);
                }
                // Update UI in real-time - always render when data changes
                this.renderTeamTable();
                // Also update dropdowns in order form
                this.updateTeamDropdowns();
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('üë∑ Team member removed:', teamMember.name);
                    // Update UI in real-time
                    this.renderTeamTable();
                    this.updateTeamDropdowns();
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('üì¶ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if category was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedCategories &&
                                      this.data.inventory.deletedCategories.includes(category.id);
                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Category was previously deleted - ignoring:', category.name);
                        return;
                    }

                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`üìÅ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        // Track deleted categories to prevent re-addition
                        if (!this.data.inventory.deletedCategories) {
                            this.data.inventory.deletedCategories = [];
                        }
                        if (!this.data.inventory.deletedCategories.includes(category.id)) {
                            this.data.inventory.deletedCategories.push(category.id);
                        }
                        console.log(`üóëÔ∏è Category removed:`, category.name);
                    }
                }
            });

            console.log(`üì¶ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('üì¶ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if item was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedItems &&
                                      this.data.inventory.deletedItems.includes(item.id);
                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Inventory item was previously deleted - ignoring:', item.name);
                        return;
                    }

                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`üì¶ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        // Track deleted items to prevent re-addition
                        if (!this.data.inventory.deletedItems) {
                            this.data.inventory.deletedItems = [];
                        }
                        if (!this.data.inventory.deletedItems.includes(item.id)) {
                            this.data.inventory.deletedItems.push(item.id);
                        }
                        console.log(`üóëÔ∏è Item removed:`, item.name);
                    }
                }
            });

            console.log(`üì¶ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            } else if (this.currentTab === 'dashboard') {
                // Update dashboard in real-time when inventory changes (for low stock count)
                this.renderDashboard();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('‚öôÔ∏è Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    // Payments real-time listener
    this.paymentsUnsubscribe = db.collection('payments').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const payment = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index === -1) {
                    this.data.payments.push(payment);
                    console.log('üíµ Payment added:', payment.id);
                } else {
                    this.data.payments[index] = payment;
                    console.log('üíµ Payment updated:', payment.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index !== -1) {
                    this.data.payments.splice(index, 1);
                    console.log('üíµ Payment removed:', payment.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    // Expenses real-time listener
    this.expensesUnsubscribe = db.collection('expenses').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const expense = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index === -1) {
                    this.data.expenses.push(expense);
                    console.log('üí∏ Expense added:', expense.id);
                } else {
                    this.data.expenses[index] = expense;
                    console.log('üí∏ Expense updated:', expense.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index !== -1) {
                    this.data.expenses.splice(index, 1);
                    console.log('üí∏ Expense removed:', expense.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    console.log('‚úÖ All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('‚ö†Ô∏è Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('üõë Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('üîÑ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`üìã Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('üÜï New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    // IMPORTANT: Include ALL fields from Firestore
                    const newOrder = {
                        ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        // Legacy field mappings for backwards compatibility
                        date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
                        readyTime: orderData.readyTime || customer.timeSlot || '',
                        clientName: orderData.clientName || customer.name || '',
                        contact: orderData.contact || customer.phone || '',
                        venue: orderData.venue || customer.venue || '',
                        eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                        // Normalize items to use consistent field names
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.quantity || item.qty || 0,
                            remarks: item.remarks || item.desc || '',
                            price: item.price || 0
                        }))
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        // Update dashboard statistics in real-time
                        if (this.currentTab === 'dashboard') {
                            this.renderDashboard();
                        }
                        this.showToast(`üÜï New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('‚úèÔ∏è Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // IMPORTANT: Preserve ALL fields from Firebase including merged data and financials
        this.data.orders[index] = {
            ...orderData, // Include ALL fields from Firebase
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            // Legacy field mappings for backwards compatibility
            date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
            readyTime: orderData.readyTime || customer.timeSlot || '',
            clientName: orderData.clientName || customer.name || '',
            contact: orderData.contact || customer.phone || '',
            venue: orderData.venue || customer.venue || '',
            eventType: orderData.eventType || orderData.functionType || customer.functionType || ''
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();

        // Force update all tabs in real-time
        if (this.currentTab === 'dashboard') {
            this.renderDashboard();
        } else if (this.currentTab === 'history') {
            this.renderHistory();
        } else if (this.currentTab === 'calendar') {
            this.renderCalendarTab();
        } else if (this.currentTab === 'financials') {
            this.renderFinancials();
        }

        console.log('‚úÖ Real-time update applied successfully');
        this.showToast(`‚úèÔ∏è Order updated: ${this.data.orders[index].clientName}`, 'info', 3000);
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('‚ö†Ô∏è Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('‚ö†Ô∏è Modified order not found locally - checking for duplicates before adding');

        // CRITICAL FIX: Check if order already exists by any identifier before adding
        const alreadyExists = this.data.orders.some(o =>
            o.docId === docId ||
            (orderId && o.orderId === orderId) ||
            (orderData.clientName && o.clientName === customer.name && o.date === (orderData.isMultiDay ? '' : Utils.convertDateFormat(customer.dates)))
        );

        if (alreadyExists) {
            console.warn('‚ö†Ô∏è Order already exists in local array - skipping duplicate add');
            return;
        }

        console.log('‚úÖ Order genuinely missing - adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';
                console.log('üóëÔ∏è Order removed from Firestore:', orderId || `[docId: ${docId}]`);

                // FIXED: Find by docId OR orderId (same pattern as 'added' and 'modified')
                const index = this.data.orders.findIndex(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();

                    // Update dashboard in real-time when order is deleted
                    if (this.currentTab === 'dashboard') {
                        this.renderDashboard();
                    }

                    this.showToast(`üóëÔ∏è Order deleted: ${deleted.orderId || deleted.docId}`, 'success');
                } else {
                    console.warn('‚ö†Ô∏è Could not find order to remove:', orderId || docId);
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`‚úÖ Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('‚úÖ Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('üìã Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('‚ö†Ô∏è Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('‚ö†Ô∏è Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('üìã No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('‚úÖ Demo data loaded for first-time user');
    } else {
        console.log('‚úÖ Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') Inventory.updateInventoryDisplay(this);
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();
        else if (this.currentTab === 'financials') this.renderFinancials();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `‚ö†Ô∏è OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'üî• TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = '‚ö° TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `‚è∞ In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `üìÖ In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    ‚úì Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            Orders.loadOrderToForm(this, order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('‚úÖ Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('‚ùå Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('‚ùå Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // Expose OMS globally for console access and backward compatibility
        window.OMS = OMS;
        window.appManager = OMS;

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`‚úÖ Cleared ${count} entries from deletedOrders list`);
                console.log('üîÑ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('‚úÖ Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('üîÑ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('‚úÖ Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`‚úÖ Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('‚úÖ No demo orders found!');
                        return [];
                    }

                    console.log(`‚ö†Ô∏è Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`‚úÖ Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('‚ùå Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('‚úÖ Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`üìã Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Restore a specific order (remove from deletedOrders list)
            async restoreDeletedOrder(orderId) {
                console.log(`üîÑ Attempting to restore order: ${orderId}`);

                // Find the order in deletedOrders list
                const deletedOrder = OMS.data.deletedOrders.find(o => o.orderId === orderId || o.docId === orderId);

                if (!deletedOrder) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in deletedOrders list`);
                    console.log('üí° Run AdminUtils.viewDeletedOrders() to see all deleted orders');
                    return false;
                }

                console.log(`‚úÖ Found deleted order: ${deletedOrder.orderId || orderId}`);
                console.log(`   Client: ${deletedOrder.clientName || 'N/A'}`);
                console.log(`   Deleted at: ${deletedOrder.deletedAt || 'N/A'}`);

                // Remove from deletedOrders list
                const beforeCount = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o =>
                    o.orderId !== orderId && o.docId !== orderId
                );
                const afterCount = OMS.data.deletedOrders.length;

                // Save to localStorage
                OMS.saveToStorage();
                console.log(`‚úÖ Removed from deletedOrders list (${beforeCount} ‚Üí ${afterCount})`);

                // Reload orders from Firestore
                console.log('üîÑ Reloading orders from Firestore...');
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();

                // Check if order is now visible
                const restoredOrder = OMS.data.orders.find(o => o.orderId === orderId || o.docId === orderId);
                if (restoredOrder) {
                    console.log(`‚úÖ‚úÖ SUCCESS! Order ${orderId} has been restored and is now visible!`);
                    console.log(`   Client: ${restoredOrder.clientName}`);
                    console.log(`   Status: ${restoredOrder.status}`);
                    return true;
                } else {
                    console.warn(`‚ö†Ô∏è Order removed from block list, but not found in Firestore.`);
                    console.log(`üí° The order may have been permanently deleted from Firestore.`);
                    console.log(`üí° If you saved it again, try refreshing the page or run:`);
                    console.log(`   await AdminUtils.forceFullSync()`);
                    return false;
                }
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('üîÑ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('üì¶ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('‚ùå Firestore inventory is empty! Nothing to recover.');
                        console.log('üí° Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('‚ùå No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('‚ùå No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('üì¶ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('üì¶ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('üîç Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`üìÅ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`üì¶ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('‚ùå Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`‚úÖ Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('üëª Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('‚úÖ No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`üëª Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nüí° These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('‚ùå Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('‚ö†Ô∏è This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('‚ùå Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('‚úÖ Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`üóëÔ∏è Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('üîç Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`üî• Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('‚úÖ Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('‚úÖ Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('‚ö†Ô∏è Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('‚úÖ Added to deletedOrders block list');
                } else {
                    console.log('‚ÑπÔ∏è Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\n‚úÖ Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  ‚úì Firestore database');
                console.log('  ‚úì Local data');
                console.log('  ‚úì Added to block list (deletedOrders)');
                console.log('  ‚úì Saved to localStorage');
                console.log('\nüõ°Ô∏è This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('üîç Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('üìä ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`‚ö†Ô∏è Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('‚úÖ Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nüì¶ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('‚ùå CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('üßπ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`‚ö†Ô∏è Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`‚úÖ Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`üìã Deleted orders list: ${before} ‚Üí ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('‚úÖ No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('üîçüîçüîç COMPREHENSIVE SYSTEM DIAGNOSTIC üîçüîçüîç\n');

                // 1. Check localStorage
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('1Ô∏è‚É£ LOCALSTORAGE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('‚úÖ localStorage exists');
                    console.log(`  üì¶ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  üì¶ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  üìã Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  üóëÔ∏è Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('‚ùå NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('2Ô∏è‚É£ CURRENT MEMORY (OMS.data)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  üì¶ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  üì¶ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  üìã Orders: ${OMS.data.orders.length}`);
                console.log(`  üóëÔ∏è Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('3Ô∏è‚É£ FIRESTORE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  üìã Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  üì¶ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  üì¶ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('4Ô∏è‚É£ MISMATCH ANALYSIS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  ‚ö†Ô∏è Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  ‚ùå DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  ‚úÖ ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  ‚ö†Ô∏è Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('5Ô∏è‚É£ RECOMMENDATIONS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  üí° Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN MEMORY!');
                    console.log('  üí° Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  üí° Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\n‚úÖ Diagnostic complete!\n');
            },

            // ============ FILTERING DIAGNOSTICS ============

            // View filter logs
            viewFilterLogs(count = 50) {
                const logs = filterLogger.getRecentLogs(count);
                console.group(`üìä Recent Filter Logs (${logs.length})`);
                console.table(logs.map(log => ({
                    Time: new Date(log.timestamp).toLocaleString(),
                    Operation: log.operation,
                    Date: log.filterDate,
                    Matched: log.matchedCount,
                    Total: log.totalAvailable,
                    Time_ms: log.filterTimeMs
                })));
                console.groupEnd();
                return logs;
            },

            // View learned patterns
            viewLearnedPatterns() {
                const patterns = patternLearner.patterns;
                console.group('üß† Learned Patterns');

                console.log('\nüìÖ Date-specific patterns:');
                const datePatterns = Object.entries(patterns.datePatterns)
                    .sort((a, b) => new Date(b[0]) - new Date(a[0]))
                    .slice(0, 20);
                console.table(datePatterns.map(([date, data]) => ({
                    Date: date,
                    AvgOrders: data.avgCount.toFixed(1),
                    Observations: data.counts.length,
                    LastSeen: new Date(data.lastSeen).toLocaleDateString()
                })));

                console.log('\nüìä Typical order counts:');
                console.table({
                    Weekday: {
                        Min: patterns.typicalOrderCounts.weekday.min,
                        Avg: patterns.typicalOrderCounts.weekday.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekday.max,
                        Samples: patterns.typicalOrderCounts.weekday.samples
                    },
                    Weekend: {
                        Min: patterns.typicalOrderCounts.weekend.min,
                        Avg: patterns.typicalOrderCounts.weekend.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekend.max,
                        Samples: patterns.typicalOrderCounts.weekend.samples
                    }
                });

                console.log('\nüîÑ Learned date formats:');
                const dateFormats = Object.entries(patterns.dateFormats).slice(0, 10);
                if (dateFormats.length > 0) {
                    console.table(dateFormats.map(([original, data]) => ({
                        Original: original,
                        Normalized: data.normalized,
                        Count: data.count
                    })));
                } else {
                    console.log('  No custom date formats learned yet');
                }

                console.groupEnd();
                return patterns;
            },

            // Clear all filter logs
            clearFilterLogs() {
                const count = filterLogger.logs.length;
                filterLogger.logs = [];
                filterLogger.saveLogs();
                console.log(`‚úÖ Cleared ${count} filter logs`);
            },

            // Reset learned patterns
            resetLearnedPatterns() {
                const confirmed = confirm('Reset all learned patterns? This cannot be undone.');
                if (confirmed) {
                    localStorage.removeItem('oms_filter_patterns');
                    location.reload();
                    console.log('‚úÖ Patterns reset. Page reloading...');
                }
            },

            // Test filter accuracy for a specific date
            async testFilterAccuracy(date) {
                console.group(`üß™ Testing Filter Accuracy for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                console.log(`üìÖ Normalized date: ${normalizedDate}`);

                // Test all date variations
                const variations = fuzzyDateMatcher.getVariations(date);
                console.log(`üîÑ Testing ${variations.length} date variations:`, variations);

                // Run the actual filter
                const startTime = performance.now();
                const matchedOrders = [];
                const orders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    return false;
                });
                const filterTime = (performance.now() - startTime).toFixed(2);

                console.log(`‚úÖ Found ${orders.length} orders in ${filterTime}ms`);

                // Show expected count
                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`üß† Expected based on learning: ~${expectedCount} orders`);
                    const deviation = Math.abs(orders.length - expectedCount);
                    if (deviation > 0) {
                        console.log(`üìä Deviation: ${deviation} orders (${((deviation / Math.max(expectedCount, 1)) * 100).toFixed(1)}%)`);
                    }
                }

                // Run validation
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: OMS.data.orders.length,
                    matchedOrders,
                    allOrders: OMS.data.orders
                });

                if (validationResult.length > 0) {
                    console.log(`\n‚ö†Ô∏è Validation Issues (${validationResult.length}):`);
                    validationResult.forEach(alert => {
                        console.log(`  ${alert.level.toUpperCase()}: ${alert.message}`);
                    });
                } else {
                    console.log('\n‚úÖ No validation issues detected');
                }

                console.log(`\nüìã Matched orders:`);
                console.table(orders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    Date: o.date || `${o.startDate} to ${o.endDate}`,
                    Status: o.status,
                    MultiDay: o.isMultiDay ? 'Yes' : 'No'
                })));

                console.groupEnd();
                return { orders, validationResult, filterTime };
            },

            // Show filtering statistics
            showFilteringStats() {
                console.group('üìä Filtering System Statistics');

                const logs = filterLogger.logs;
                const patterns = patternLearner.patterns;

                console.log(`üìù Total filter operations logged: ${logs.length}`);
                console.log(`üß† Patterns learned for ${Object.keys(patterns.datePatterns).length} dates`);
                console.log(`üìÖ Date formats learned: ${Object.keys(patterns.dateFormats).length}`);
                console.log(`üìà Filter results history: ${patterns.filterResults.length} entries`);

                if (logs.length > 0) {
                    const avgTime = logs
                        .filter(l => l.filterTimeMs)
                        .reduce((sum, l) => sum + parseFloat(l.filterTimeMs), 0) / logs.filter(l => l.filterTimeMs).length;
                    console.log(`‚ö° Average filter time: ${avgTime.toFixed(2)}ms`);
                }

                console.log('\nüí° Available commands:');
                console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
                console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
                console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a date');
                console.log('  - AdminUtils.clearFilterLogs() - Clear all logs');
                console.log('  - AdminUtils.resetLearnedPatterns() - Reset all patterns');

                console.groupEnd();
            },

            // ============ RATING & LEARNING UTILITIES ============

            // Show rating UI for last filter result
            rateLastFilter() {
                if (!filterRatingSystem.currentFilterContext) {
                    console.warn('‚ö†Ô∏è No filter result available to rate. Run a filter first.');
                    return;
                }
                filterRatingSystem.showRatingUI(OMS);
            },

            // View all ratings
            viewRatings(count = 20) {
                const ratings = filterRatingSystem.ratings.slice(-count);
                if (ratings.length === 0) {
                    console.log('üì≠ No ratings yet. Use AdminUtils.rateLastFilter() after filtering orders.');
                    return;
                }

                console.group(`‚≠ê Recent Ratings (${ratings.length})`);
                console.table(ratings.map(r => ({
                    Date: r.date,
                    Rating: typeof r.rating === 'number' ? '‚≠ê'.repeat(r.rating) : r.rating,
                    Matched: r.matchedOrders.length,
                    WrongIncluded: r.feedback.incorrectlyIncluded.length,
                    WrongExcluded: r.feedback.incorrectlyExcluded.length,
                    Tags: r.feedback.tags.join(', '),
                    RatedAt: new Date(r.ratedAt).toLocaleString()
                })));

                const stats = filterRatingSystem.getStats();
                console.log(`\nüìä Overall Statistics:`);
                console.log(`  Average Rating: ${stats.avgRating} / 5`);
                console.log(`  Total Ratings: ${stats.totalRatings}`);
                console.log(`  Sentiment Trend: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' ‚Üí ')}`);

                console.groupEnd();
            },

            // View learning rules
            viewLearningRules(date = null) {
                const rules = date
                    ? filterRatingSystem.getLearningRules(date)
                    : JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (rules.length === 0) {
                    console.log(`üì≠ No learning rules${date ? ' for ' + date : ''}.`);
                    return;
                }

                console.group(`üß† Learning Rules${date ? ' for ' + date : ''} (${rules.length})`);
                console.table(rules.map(r => ({
                    Type: r.type,
                    Date: r.targetDate,
                    OrderID: r.orderId || 'N/A',
                    Reason: r.reason,
                    Weight: r.weight
                })));
                console.groupEnd();
            },

            // View rating statistics
            getRatingStats() {
                const stats = filterRatingSystem.getStats();
                console.group('üìä Rating System Statistics');
                console.log(`Average Rating: ${stats.avgRating} / 5`);
                console.log(`Total Ratings: ${stats.totalRatings}`);
                console.log(`Recent Sentiment: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' ‚Üí ')}`);

                const learningRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                console.log(`\nLearning Rules: ${learningRules.length}`);
                console.log(`  - Exclusions: ${learningRules.filter(r => r.type === 'exclusion').length}`);
                console.log(`  - Inclusions: ${learningRules.filter(r => r.type === 'inclusion').length}`);
                console.log(`  - Anomalies: ${learningRules.filter(r => r.type === 'anomaly').length}`);

                console.log('\nüí° Available commands:');
                console.log('  - AdminUtils.rateLastFilter() - Rate the last filter result');
                console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
                console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
                console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
                console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');

                console.groupEnd();
            },

            // Test learning corrections for a date
            testLearning(date) {
                console.group(`üß™ Testing Learning Corrections for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                const learningRules = filterRatingSystem.getLearningRules(normalizedDate);

                if (learningRules.length === 0) {
                    console.log('üì≠ No learning rules for this date yet. Rate a filter result first.');
                    console.groupEnd();
                    return;
                }

                console.log(`üß† Found ${learningRules.length} learning rules`);
                console.table(learningRules);

                // Run filter without corrections
                const originalOrders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) return true;
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) return true;
                    }
                    return false;
                });

                console.log(`\nüìã Original filter: ${originalOrders.length} orders`);

                // Apply learning corrections
                const result = filterRatingSystem.applyLearningRules(normalizedDate, originalOrders, OMS.data.orders);

                console.log(`üß† After learning: ${result.orders.length} orders`);
                console.log(`‚úÖ Corrections applied: ${result.corrections.length}`);

                if (result.corrections.length > 0) {
                    console.log('\nüìù Corrections:');
                    console.table(result.corrections.map(c => ({
                        Type: c.type,
                        OrderID: c.order.orderId,
                        Client: c.order.clientName,
                        Reason: c.reason
                    })));
                }

                console.groupEnd();
                return result;
            },

            // Clear all ratings and learning rules
            clearAllRatings() {
                const confirmed = confirm('Clear all ratings and learning rules? This cannot be undone.');
                if (confirmed) {
                    filterRatingSystem.clearAllRatings();
                    console.log('‚úÖ All ratings and learning rules cleared');
                }
            },

            // Export ratings and learning data
            exportLearningData() {
                const data = {
                    ratings: filterRatingSystem.ratings,
                    learningRules: JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]'),
                    patterns: patternLearner.patterns,
                    exportedAt: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `filter-learning-data-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                console.log('‚úÖ Learning data exported');
            },

            // Import ratings and learning data
            async importLearningData() {
                return new Promise((resolve, reject) => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';

                    input.onchange = async (e) => {
                        try {
                            const file = e.target.files[0];
                            const text = await file.text();
                            const data = JSON.parse(text);

                            if (data.ratings) {
                                filterRatingSystem.ratings = data.ratings;
                                filterRatingSystem.saveRatings();
                            }

                            if (data.learningRules) {
                                localStorage.setItem('oms_filter_learning_rules', JSON.stringify(data.learningRules));
                            }

                            if (data.patterns) {
                                localStorage.setItem('oms_filter_patterns', JSON.stringify(data.patterns));
                            }

                            console.log('‚úÖ Learning data imported successfully');
                            console.log(`  - Ratings: ${data.ratings?.length || 0}`);
                            console.log(`  - Learning Rules: ${data.learningRules?.length || 0}`);

                            resolve(data);
                        } catch (error) {
                            console.error('‚ùå Failed to import learning data:', error);
                            reject(error);
                        }
                    };

                    input.click();
                });
            },

            // Enable ML corrections
            enableML() {
                localStorage.setItem('oms_ml_enabled', 'true');
                console.log('‚úÖ ML Corrections ENABLED');
                console.log('üß† The system will now apply learned corrections from previous ratings');
                console.log('üí° To disable: AdminUtils.disableML()');
                console.log('üí° To clear learned rules: AdminUtils.clearAllRatings()');
                return true;
            },

            // Disable ML corrections
            disableML() {
                localStorage.setItem('oms_ml_enabled', 'false');
                console.log('‚úÖ ML Corrections DISABLED');
                console.log('üìä Filter will now use ONLY the original logic (no ML modifications)');
                console.log('üí° To enable: AdminUtils.enableML()');
                console.log('‚ö†Ô∏è Note: This does NOT clear learned rules, just stops applying them');
                return true;
            },

            // Check ML status
            checkMLStatus() {
                const enabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const ratings = JSON.parse(localStorage.getItem('oms_filter_ratings') || '[]');
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                console.log('ü§ñ ML System Status:');
                console.log(`  Status: ${enabled ? '‚úÖ ENABLED' : 'üîá DISABLED'}`);
                console.log(`  Ratings stored: ${ratings.length}`);
                console.log(`  Learning rules: ${rules.length}`);

                if (enabled && rules.length > 0) {
                    console.log('\n‚ö†Ô∏è WARNING: ML is ACTIVE and will modify filter results');
                    console.log('üí° To disable: AdminUtils.disableML()');
                    console.log('üí° To clear rules: AdminUtils.clearAllRatings()');
                } else if (!enabled) {
                    console.log('\n‚úÖ ML is disabled - using original filter logic only');
                } else {
                    console.log('\nüìã ML is enabled but no learning rules stored yet');
                }

                return { enabled, ratingsCount: ratings.length, rulesCount: rules.length };
            },

            // Quick fix: Disable ML and clear all learned rules
            resetMLSystem() {
                const confirmed = confirm('This will:\n1. Disable ML corrections\n2. Clear all ratings and learning rules\n\nContinue?');
                if (confirmed) {
                    this.disableML();
                    filterRatingSystem.clearAllRatings();
                    console.log('\n‚úÖ ML System Reset Complete!');
                    console.log('üìä Filter will now use ONLY original logic');
                    console.log('üí° To re-enable: AdminUtils.enableML()');
                    return true;
                }
                return false;
            }
        };

        console.log('üõ†Ô∏è Admin utilities loaded. Available commands:');
        console.log('\nüìã ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - ‚≠ê PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nüì¶ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - ‚≠ê LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nüîç DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - ‚≠ê FULL SYSTEM DIAGNOSTIC (find all bugs)');
        console.log('\nüéØ FILTERING DIAGNOSTICS:');
        console.log('  - AdminUtils.showFilteringStats() - Show filtering system overview');
        console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
        console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
        console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a specific date');
        console.log('  - AdminUtils.clearFilterLogs() - Clear all filter logs');
        console.log('  - AdminUtils.resetLearnedPatterns() - Reset learned patterns');
        console.log('\n‚≠ê RATING & LEARNING SYSTEM:');
        console.log('  - AdminUtils.rateLastFilter() - ‚≠ê Rate the last filter result');
        console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
        console.log('  - AdminUtils.getRatingStats() - View rating statistics and trends');
        console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
        console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');
        console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
        console.log('  - AdminUtils.exportLearningData() - Export learning data to JSON');
        console.log('  - await AdminUtils.importLearningData() - Import learning data from JSON');
        console.log('\nü§ñ ML SYSTEM CONTROLS:');
        console.log('  - AdminUtils.checkMLStatus() - ‚≠ê Check if ML is enabled/disabled and view stats');
        console.log('  - AdminUtils.disableML() - ‚≠ê DISABLE ML corrections (use original filter only)');
        console.log('  - AdminUtils.enableML() - Enable ML corrections');
        console.log('  - AdminUtils.resetMLSystem() - ‚≠ê DISABLE ML + clear all learned rules');

        // ============ GOOGLE MAPS INITIALIZATION ============
        // Global variable to store selected place from autocomplete
        let selectedPlaceData = null;

        // This function is called when Google Maps API finishes loading
        function initGoogleMaps() {
            console.log('Google Maps API loaded successfully');

            const venueInput = document.getElementById('venue');
            const mapLinkInput = document.getElementById('venueMapLink');

            if (!venueInput) {
                console.error('Venue input field not found');
                return;
            }

            try {
                // Initialize Autocomplete with new Places API
                const autocomplete = new google.maps.places.Autocomplete(venueInput, {
                    componentRestrictions: { country: 'in' },
                    fields: ['name', 'formatted_address', 'geometry', 'place_id'],
                    types: ['establishment', 'geocode']
                });

                // Listen for place selection
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace();

                    if (!place.geometry || !place.geometry.location) {
                        console.warn('No location details available for selected place');
                        selectedPlaceData = null;
                        return;
                    }

                    // Store place data globally
                    selectedPlaceData = {
                        name: place.name || place.formatted_address || venueInput.value,
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        formatted_address: place.formatted_address || '',
                        place_id: place.place_id || '',
                        source: 'google_autocomplete'
                    };

                    console.log('Place selected from autocomplete:', selectedPlaceData);

                    // Update venue input with selected place name
                    venueInput.value = selectedPlaceData.name;

                    // Auto-fill the venueMapLink field with Google Maps URL
                    if (mapLinkInput && selectedPlaceData.lat && selectedPlaceData.lng) {
                        const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${selectedPlaceData.lat},${selectedPlaceData.lng}&query_place_id=${selectedPlaceData.place_id}`;
                        mapLinkInput.value = mapsUrl;
                    }
                });

                console.log('Google Maps Autocomplete initialized successfully');
            } catch (error) {
                console.error('Error initializing Google Maps Autocomplete:', error);
            }
        }

        // Make function globally accessible
        window.initGoogleMaps = initGoogleMaps;

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Check ML status on page load
            setTimeout(() => {
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (mlEnabled && rules.length > 0) {
                    console.warn('‚ö†Ô∏è ML SYSTEM IS ACTIVE! The filter may automatically modify results based on previous feedback.');
                    console.warn(`üìä ${rules.length} learning rules are stored and will be applied.`);
                    console.warn('üí° To disable: AdminUtils.disableML()');
                    console.warn('üí° To check status: AdminUtils.checkMLStatus()');
                    console.warn('üí° To reset everything: AdminUtils.resetMLSystem()');
                } else if (!mlEnabled) {
                    console.log('‚úÖ ML corrections are DISABLED - using original filter logic only');
                    console.log('üí° To enable: AdminUtils.enableML()');
                }
            }, 1000);

            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'grid';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Set required fields for single day
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;

            // Show event type field for single-day
            document.getElementById('eventType').parentElement.style.display = 'block';

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Set required fields for multi-day
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;

            // Show event type field for multi-day
            document.getElementById('eventType').parentElement.style.display = 'block';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });

        // Initialize required attributes based on default state (single day)
        if (eventTypeSelect && eventTypeSelect.value === 'single') {
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;
        } else if (eventTypeSelect && eventTypeSelect.value === 'multi') {
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;
        }
    }

    // WhatsApp Date Filter Event Listeners
    const whatsappFilterDate = document.getElementById('whatsappFilterDate');
    const sendWhatsAppOrdersBtn = document.getElementById('sendWhatsAppOrdersBtn');

    if (whatsappFilterDate) {
        whatsappFilterDate.addEventListener('change', () => {
            OMS.updateWhatsAppDateFilter();
        });
    }

    if (sendWhatsAppOrdersBtn) {
        sendWhatsAppOrdersBtn.addEventListener('click', () => {
            OMS.sendWhatsAppOrdersReport();
        });
    }

    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // ============ FIREBASE INITIALIZATION ============
            // Firebase now initialized via /js/core/firebase.js module
            // Module sets window.auth and window.db globally
            // Token monitoring is handled in the Firebase module

            // Initialize Firebase when page loads
            import('./js/core/firebase.js').then(({ initializeFirebase }) => {
                const { auth, db } = initializeFirebase();
                console.log('‚úÖ Firebase module loaded and initialized');

                // Check if user is logged in (set up auth listener after Firebase is ready)
                window.auth.onAuthStateChanged((user) => {
                    if (user) {
                        // User is logged in
                        console.log('‚úÖ User logged in:', user.email);
                        document.getElementById('loginScreen').style.display = 'none';
                        document.querySelector('.app-container').style.display = 'flex';
                        OMS.init().then(() => {
                            OMS.updateAllDisplays();

                            // Dispatch OMSReady event for Package and Leads managers
                            console.log('üì¢ Dispatching OMSReady event...');
                            window.dispatchEvent(new CustomEvent('OMSReady'));
                        });
                    } else {
                        // User is logged out
                        console.log('‚ùå User not logged in');
                        document.getElementById('loginScreen').style.display = 'flex';
                        document.querySelector('.app-container').style.display = 'none';
                    }
                });
            }).catch(error => {
                console.error('‚ùå Failed to initialize Firebase:', error);
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();

                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');

                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';

                try {
                    await window.auth.signInWithEmailAndPassword(email, password);
                    console.log('‚úÖ Login successful!');

                    // üéÜ FIREPOWER SFX LOGIN SUCCESS!
                    loginBtn.textContent = '‚úÖ Success!';
                    loginBtn.style.background = 'linear-gradient(135deg, #00c853 0%, #00e676 100%)';

                    // Confetti Blast!
                    if (typeof confetti !== 'undefined') {
                        const count = 200;
                        const defaults = {
                            origin: { y: 0.7 },
                            colors: ['#FFD700', '#FFA500', '#FF6347', '#8B00FF', '#00BFFF']
                        };

                        function fire(particleRatio, opts) {
                            confetti(Object.assign({}, defaults, opts, {
                                particleCount: Math.floor(count * particleRatio)
                            }));
                        }

                        fire(0.25, { spread: 26, startVelocity: 55 });
                        fire(0.2, { spread: 60 });
                        fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8 });
                        fire(0.1, { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2 });
                        fire(0.1, { spread: 120, startVelocity: 45 });
                    }
                } catch (error) {
                    console.error('‚ùå Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

            // Transport 2 custom field
            document.getElementById('transport2').addEventListener('change', (e) => {
                const group = document.getElementById('customTransport2Group');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('‚úÖ Date restrictions removed - can add orders from any date');

    // ============ FIREPOWER SFX LOGIN THEME ANIMATIONS ============

    // Floating Particles Background
    const canvas = document.getElementById('particles-canvas');
    const ctx = canvas ? canvas.getContext('2d') : null;

    if (canvas && ctx) {
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const particles = [];
        const particleCount = 50;

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.speedX = Math.random() * 0.5 - 0.25;
                this.speedY = Math.random() * -1 - 0.5;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = ['#ffd700', '#ffa500', '#ff6347'][Math.floor(Math.random() * 3)];
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.y < 0 || this.x < 0 || this.x > canvas.width) {
                    this.reset();
                    this.y = canvas.height;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Create particles
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animateParticles() {
            if (loginScreen.style.display === 'flex') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animateParticles);
            } else {
                // Clear canvas when login screen hidden
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Start animation when login screen is visible
        const particleObserver = new MutationObserver(() => {
            if (loginScreen.style.display === 'flex') {
                animateParticles();
            }
        });

        particleObserver.observe(loginScreen, { attributes: true, attributeFilter: ['style'] });
    }

    // Login Background Slideshow with 3-second timing
    const slides = document.querySelectorAll('.login-slideshow-slide');
    let currentSlide = 0;
    let slideshowInterval;

    function showNextSlide() {
        // Remove active class from current slide
        slides[currentSlide].classList.remove('active');

        // Move to next slide
        currentSlide = (currentSlide + 1) % slides.length;

        // Add active class to next slide
        slides[currentSlide].classList.add('active');
    }

    // Start slideshow when login screen is visible
    const slideshowObserver = new MutationObserver(() => {
        if (loginScreen.style.display === 'flex') {
            // Start slideshow
            if (!slideshowInterval) {
                slideshowInterval = setInterval(showNextSlide, 3000); // 3 seconds
            }
        } else {
            // Stop slideshow when login screen is hidden
            if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
        }
    });

    slideshowObserver.observe(loginScreen, { attributes: true, attributeFilter: ['style'] });

    console.log('üéÜ Firepower SFX Login Theme Activated!');

        });

    </script>

    <!-- Package Modal -->
    <div id="package-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3 id="package-modal-title">Create Package</h3>
                <button class="modal-close" id="cancel-package-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-field">
                    <label>Package Name *</label>
                    <input type="text" id="package-name" placeholder="e.g. Premium Wedding Package">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-field">
                        <label>Type *</label>
                        <select id="package-type">
                            <option value="basic">‚≠ê Basic</option>
                            <option value="premium">üíé Premium</option>
                        </select>
                    </div>

                    <div class="form-field">
                        <label>Event Type *</label>
                        <select id="package-event-type">
                            <option value="wedding">üíç Wedding</option>
                            <option value="corporate">üè¢ Corporate</option>
                            <option value="birthday">üéÇ Birthday</option>
                            <option value="anniversary">üéä Anniversary</option>
                            <option value="other">üéâ Other</option>
                        </select>
                    </div>
                </div>

                <div class="form-field">
                    <label>Description</label>
                    <textarea id="package-description" rows="3" placeholder="Describe what makes this package special..."></textarea>
                </div>

                <div class="form-field">
                    <label>Add Items</label>
                    <div class="search-container">
                        <input type="text" id="package-item-search" class="form-input" placeholder="üîç Search items to add..." autocomplete="off">
                        <div id="package-item-search-dropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="package-items-list" style="margin-top: 1rem; max-height: 300px; overflow-y: auto;">
                    <!-- Package items will be rendered here -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancel-package-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-package-btn" class="btn btn-primary">Save Package</button>
            </div>
        </div>
    </div>

    <!-- Lead Details Modal -->
    <div id="lead-details-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3>Lead Details</h3>
                <button class="modal-close" id="close-lead-details-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div id="lead-details-content">
                    <!-- Lead details will be rendered here -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="close-lead-details-btn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Lead Modal -->
    <div id="edit-lead-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h3>Edit Lead</h3>
                <button class="modal-close" id="close-edit-lead-modal-btn">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <div id="edit-lead-content">
                    <!-- Edit form will be rendered here -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="close-edit-lead-modal-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-lead-btn" class="btn btn-primary">üíæ Save Lead</button>
            </div>
        </div>
    </div>

    <!-- Additional CSS for Packages and Leads -->
    <style>
        /* Package Admin Cards */
        .package-admin-card {
            background: white;
            border: 2px solid #E2E8F0;
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .package-admin-card:hover {
            border-color: #8B5CF6;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
        }

        .package-admin-header {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .package-admin-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: #F8FAFC;
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #8B5CF6;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #64748B;
            text-transform: uppercase;
        }

        .package-admin-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .package-item-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .package-item-info {
            flex: 1;
        }

        .package-item-name {
            font-weight: 600;
            color: #1E293B;
        }

        .package-item-category {
            font-size: 0.75rem;
            color: #64748B;
        }

        .package-item-qty-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .package-item-qty-decrease,
        .package-item-qty-increase {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid #8B5CF6;
            background: #8B5CF6;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .package-item-qty-decrease:hover,
        .package-item-qty-increase:hover {
            background: #7C3AED;
            border-color: #7C3AED;
            transform: scale(1.05);
        }

        .package-item-qty-decrease:active,
        .package-item-qty-increase:active {
            transform: scale(0.95);
        }

        .package-item-qty-input {
            width: 60px;
            height: 32px;
            text-align: center;
            font-weight: 700;
            font-size: 1rem;
            border: 2px solid #E2E8F0;
            border-radius: 6px;
            padding: 0.25rem;
        }

        .package-item-qty-input:focus {
            outline: none;
            border-color: #8B5CF6;
        }

        .package-item-qty-value {
            min-width: 2rem;
            text-align: center;
            font-weight: 700;
        }

        /* Leads Styles */
        .leads-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .lead-card {
            background: white;
            border: 2px solid #E2E8F0;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .lead-card:hover {
            border-color: #8B5CF6;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
        }

        .lead-card-header {
            padding: 1rem 1.5rem;
            background: #F8FAFC;
            border-bottom: 1px solid #E2E8F0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .lead-card-body {
            padding: 1.5rem;
        }

        .lead-info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #F1F5F9;
        }

        .lead-info-row:last-child {
            border-bottom: none;
        }

        .lead-info-label {
            font-weight: 600;
            color: #64748B;
            font-size: 0.875rem;
        }

        .lead-info-value {
            color: #1E293B;
            font-size: 0.875rem;
            text-align: right;
        }

        .lead-card-actions {
            padding: 1rem 1.5rem;
            background: #F8FAFC;
            border-top: 1px solid #E2E8F0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .lead-filter-btn {
            padding: 0.5rem 1rem;
            background: #F1F5F9;
            border: 2px solid transparent;
            border-radius: 8px;
            color: #64748B;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lead-filter-btn:hover {
            background: #E2E8F0;
        }

        .lead-filter-btn.active {
            background: #8B5CF6;
            border-color: #8B5CF6;
            color: white;
        }

        .lead-details-section {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #E2E8F0;
        }

        .lead-details-section:last-child {
            border-bottom: none;
        }

        .lead-edit-section {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #E2E8F0;
        }

        .lead-edit-section:last-child {
            border-bottom: none;
        }

        .lead-edit-section h3 {
            font-size: 1.25rem;
            color: #1E293B;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .lead-details-section h3 {
            font-size: 1.125rem;
            font-weight: 700;
            color: #1E293B;
            margin-bottom: 1rem;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid #F1F5F9;
        }

        .detail-label {
            font-weight: 600;
            color: #64748B;
        }

        .detail-value {
            color: #1E293B;
            text-align: right;
            max-width: 60%;
        }
    </style>

    <!-- Initialize Packages and Leads Managers -->
    <script type="module">
        // Force reload - new timestamp
        const BUILD_VERSION = '2024-12-21-OMSREADY-EVENT-v9-FINAL';
        const BUILD_TIMESTAMP = Date.now(); // Always fresh

        // Log version for debugging - THIS MUST APPEAR IN CONSOLE
        console.log('%cüî• ADMIN PANEL VERSION CHECK üî•', 'background: #ef4444; color: white; padding: 10px; font-size: 16px; font-weight: bold;');
        console.log('%c‚úÖ Version: ' + BUILD_VERSION, 'background: #10b981; color: white; padding: 8px; font-size: 14px;');
        console.log('%c‚è∞ Loaded at: ' + new Date().toLocaleString(), 'background: #3b82f6; color: white; padding: 8px; font-size: 14px;');
        console.log('%cüéØ OMSReady event now fires - Package Manager will initialize!', 'background: #f59e0b; color: white; padding: 8px; font-size: 14px;');

        // Initialize when OMS loads
        window.addEventListener('OMSReady', async () => {
            console.log('üöÄ Initializing Packages and Leads managers...');

            try {
                // Import managers with dynamic import (fixes syntax error)
                // Use local paths from admin/js directory for Vercel compatibility
                const { PackageManager } = await import(`./js/packages/package-manager.js?v=${BUILD_TIMESTAMP}`);
                const { LeadsManager } = await import(`./js/leads/leads-manager.js?v=${BUILD_TIMESTAMP}`);
                const { Conversion } = await import(`./js/features/conversion.js?v=${BUILD_TIMESTAMP}`);
                const { Orders } = await import(`./js/features/orders.js?v=${BUILD_TIMESTAMP}`);
                const { Quotations } = await import(`./js/features/quotations.js?v=${BUILD_TIMESTAMP}`);
                const { Inventory } = await import(`./js/features/inventory.js?v=${BUILD_TIMESTAMP}`);
                const { Preparation } = await import(`./js/features/preparation.js?v=${BUILD_TIMESTAMP}`);
                const { Customers } = await import(`./js/features/customers.js?v=${BUILD_TIMESTAMP}`);
                const { Team } = await import(`./js/features/team.js?v=${BUILD_TIMESTAMP}`);
                const { Analytics } = await import(`./js/features/analytics.js?v=${BUILD_TIMESTAMP}`);
                const { Dashboard } = await import(`./js/features/dashboard.js?v=${BUILD_TIMESTAMP}`);
                const { History } = await import(`./js/features/history.js?v=${BUILD_TIMESTAMP}`);
                const { Calendar } = await import(`./js/features/calendar.js?v=${BUILD_TIMESTAMP}`);
                const { Financials } = await import(`./js/features/financials.js?v=${BUILD_TIMESTAMP}`);
                const { Settings } = await import(`./js/features/settings.js?v=${BUILD_TIMESTAMP}`);
                const { Print } = await import(`./js/features/print.js?v=${BUILD_TIMESTAMP}`);

                // Expose modules globally for onclick handlers
                window.Orders = Orders;
                window.Quotations = Quotations;
                window.Inventory = Inventory;
                window.Preparation = Preparation;
                window.Customers = Customers;
                window.Team = Team;
                window.Analytics = Analytics;
                window.Dashboard = Dashboard;
                window.History = History;
                window.Calendar = Calendar;
                window.Financials = Financials;
                window.Settings = Settings;
                window.Print = Print;

                console.log('‚úÖ All modules imported successfully (Package, Leads, Conversion, Orders, Quotations, Inventory, Preparation, Customers, Team, Analytics, Dashboard, History, Calendar, Financials, Settings, Print)');

                // Initialize Package Manager
                const packageManager = new PackageManager();

                // Initialize Leads Manager
                const leadsManager = new LeadsManager();

                // Initialize when respective tabs are opened
                const packagesTab = document.querySelector('[data-tab="packages"]');
                const leadsTab = document.querySelector('[data-tab="leads"]');

                console.log('üì¶ Packages tab found:', !!packagesTab);
                console.log('üéØ Leads tab found:', !!leadsTab);
                console.log('‚úÖ Marketing & Conversion module imported successfully');

                // Note: PackageManager and LeadsManager are now initialized
                // from within the Marketing > Packages and Marketing > Leads sub-tabs
                // (see conversion.js renderPackagesSection and renderLeadsSection)

                // Initialize Marketing & Conversion tab
            const conversionTab = document.querySelector('[data-tab="conversion"]');
            let conversionInitialized = false;

            conversionTab?.addEventListener('click', async () => {
                if (!conversionInitialized) {
                    console.log('üöÄ Initializing Conversion module...');
                    try {
                        // Render conversion interface
                        Conversion.renderConversion(window.OMS);
                        conversionInitialized = true;
                        console.log('‚úÖ Conversion module initialized');
                    } catch (error) {
                        console.error('‚ùå Failed to initialize Conversion module:', error);
                    }
                }
            });

            // Make Conversion module globally available
            window.Conversion = Conversion;

            console.log('‚úÖ Marketing & Conversion module ready');

            } catch (error) {
                console.error('‚ùå Failed to initialize Marketing module:', error);
                console.error('Error details:', error.message, error.stack);
            }
        });
    </script>

</body>
</html>
