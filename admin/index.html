<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 2025-11-21 - Materials Calculation & Details Fix -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System - Enhanced</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="shortcut icon" type="image/png" href="logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --light: #f8fafc;
            --white: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        /* Light Theme Variables */
        :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-hover: rgba(102, 126, 234, 0.05);
            --bg-input: #ffffff;
            --table-header-bg: #f8f9fa;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Noto Sans Gujarati', sans-serif;
            background: var(--bg-body);
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Layout */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        
        .app-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--white);
            padding: 1rem 0;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .company-name { font-size: 1.8rem; font-weight: 700; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #weatherMiniDashboard {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
            padding: 0.5rem 1rem;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.9rem;
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        #weatherMiniDashboard:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.3));
            border-color: rgba(59, 130, 246, 0.5);
        }

        .weather-mini-icon {
            font-size: 1.5rem;
            line-height: 1;
        }

        .weather-mini-info {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .weather-mini-temp {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .weather-mini-condition {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .search-global {
            position: relative;
            width: 300px;
        }

        .search-global input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        .search-global-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            margin-top: 0.25rem;
            box-shadow: var(--shadow-lg);
        }

        .search-results.show { display: block; }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-dark);
        }

        .search-result-item:hover { background: var(--bg-hover); }

        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-gray);
            text-transform: uppercase;
        }

        /* Navigation */
        .nav-tabs {
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            padding: 0 1rem;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-gray);
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tab:hover { color: var(--primary); background: var(--bg-hover); }
        .nav-tab.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg-hover); }

        .main-content {
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
            width: 100%;
        }

        .tab-content { display: none; animation: fadeIn 0.3s ease-in; }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .card-header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Forms */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        .form-label.required::after { content: ' *'; color: var(--danger); }

        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--bg-input);
            color: var(--text-dark);
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Highlighted Date & Time Fields */
        .highlight-datetime {
            background-color: #fef3c7 !important;
            font-weight: 500;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Noto Sans Gujarati', sans-serif;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: var(--white); }
        .btn-secondary { background: var(--white); color: var(--primary); border: 2px solid var(--primary); }
        .btn-success { background: var(--success); color: var(--white); }
        .btn-warning { background: var(--warning); color: var(--white); }
        .btn-danger { background: var(--danger); color: var(--white); }
        .btn-info { background: var(--info); color: var(--white); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.info { border-left-color: var(--info); }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-gray);
            font-weight: 500;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th, .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-dark);
        }

        .table tr:hover { background: var(--bg-hover); }
        .table tr:last-child td { border-bottom: none; }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-confirmed { background: rgba(16, 185, 129, 0.1); color: var(--success); }
        .status-completed { background: rgba(102, 126, 234, 0.1); color: var(--primary); }
        .status-cancelled { background: rgba(239, 68, 68, 0.1); color: var(--danger); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2000;
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-left: 4px solid var(--success);
            padding: 1rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            transform: translateX(400px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            color: var(--text-dark);
        }

        .toast.show { transform: translateX(0); }
        .toast.error { border-left-color: var(--danger); }
        .toast.warning { border-left-color: #ff9800; }
        .toast-actions { display: flex; gap: 0.5rem; }
        .toast-btn { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            text-align: center;
            color: var(--text-dark);
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Calendar */
        .calendar-container {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .calendar-day-header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .calendar-day {
            background: var(--bg-card);
            min-height: 100px;
            padding: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .calendar-day:hover { background: var(--bg-hover); }
        .calendar-day.today { background: rgba(102, 126, 234, 0.2); }
        .calendar-day.has-orders { border-left: 4px solid var(--success); }
        .calendar-day.has-tasks { border-right: 4px solid var(--warning); }
        .calendar-day.has-festival { border-top: 4px solid var(--danger); }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .calendar-day-content {
            font-size: 0.8rem;
            color: var(--text-gray);
        }

        .festival-text {
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .order-count {
            background: var(--success);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
        }

        /* Quantity Controls */
        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Search Dropdown */
        .search-container { position: relative; margin-bottom: 1rem; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-dropdown.show { display: block; }

        .search-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-dark);
        }

        .search-item:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.3s ease;
        }

        /* Order ID Highlight */
        .order-id-highlight {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }

        /* Print Template - Force Light Theme Colors */
        .print-template {
            display: none;
            width: 2480px;
            min-height: 3508px;
            background: white !important;
            color: #000000 !important;
            padding: 80px 80px 80px 590px;
            font-family: 'Noto Sans Gujarati', Arial, sans-serif;
            font-size: 32px;
            line-height: 1.4;
            /* Force light theme - prevent dark theme inheritance */
            --text-dark: #1f2937 !important;
            --text-gray: #6b7280 !important;
            --border: #e5e7eb !important;
        }

        /* Ensure all text within print template is black */
        .print-template * {
            color: inherit;
        }

        /* Undo Bar */
        .undo-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: transform 0.3s ease;
        }

        .undo-bar.show { transform: translateX(-50%) translateY(0); }

        .undo-btn {
            background: var(--white);
            color: var(--text-dark);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Quick Action Menu */
        .quick-menu {
            position: absolute;
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 0.5rem 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .quick-menu.show { display: block; }

        .quick-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quick-menu-item:hover { background: var(--light); }

        /* Keyboard Shortcuts Panel */
        .shortcuts-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2499;
            display: none;
        }

        .shortcuts-backdrop.show {
            display: block;
        }

        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 2500;
            max-width: 600px;
            display: none;
        }

        .shortcuts-panel.show { display: block; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-key {
            background: var(--light);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Drag Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .form-grid { grid-template-columns: 1fr; }
            .form-row { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: 1fr; }
            .calendar-day { min-height: 80px; }
            .search-global { width: 200px; }
            .header-content { flex-direction: column; gap: 1rem; }
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: 0.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }
    </style>
    <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
</head>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 3rem; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h1 style="text-align: center; color: #667eea; margin-bottom: 2rem; font-size: 2rem;">üîê Admin Login</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="üîç Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <div id="weatherMiniDashboard">
                        <span class="weather-mini-icon">üå§Ô∏è</span>
                        <div class="weather-mini-info">
                            <span class="weather-mini-temp">--¬∞C</span>
                            <span class="weather-mini-condition">Loading...</span>
                        </div>
                    </div>
                    <button class="btn btn-info btn-small" onclick="OMS.toggleLanguage()" id="languageToggle" title="Switch Language">
                        üåê EN
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">‚å®Ô∏è</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">üö™ Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">üìä Dashboard</button>
                <button class="nav-tab" data-tab="orders">üìù Orders</button>
                <button class="nav-tab" data-tab="inventory">üì¶ Inventory</button>
                <button class="nav-tab" data-tab="itemHistory">üìú Item History</button>
                <button class="nav-tab" data-tab="preparation">üìã Preparation</button>
                <button class="nav-tab" data-tab="customers">üë• Customers</button>
                <button class="nav-tab" data-tab="team">üë∑ Team</button>
                <button class="nav-tab" data-tab="calendar">üóìÔ∏è Calendar</button>
                <button class="nav-tab" data-tab="history">üìö History</button>
                <button class="nav-tab" data-tab="analytics">üìà Analytics</button>
                <button class="nav-tab" data-tab="financials">üí∞ Financials</button>
                <button class="nav-tab" data-tab="settings">‚öôÔ∏è Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">üîî Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üçï Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìù Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Event Type</label>
                                <select id="eventTypeSelect" class="form-select" required>
                                    <option value="single">Single Day Event</option>
                                    <option value="multi">Multi-Day Event</option>
                                </select>
                            </div>
                        </div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-grid">
    <div class="form-group">
        <label class="form-label required">Event Date</label>
        <input type="date" id="orderDate" name="orderDate" class="form-input highlight-datetime" required>
    </div>
    <div class="form-group">
        <label class="form-label required">Ready Time</label>
        <select id="readyTime" name="readyTime" class="form-select highlight-datetime" required></select>
    </div>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" name="startDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" name="endDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">üìÖ Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Contact</label>
                                <input type="tel" id="contact" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Venue</label>
                                <input type="text" id="venue" class="form-input" placeholder="Enter venue address">
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <input type="text" id="eventType" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Transport</label>
                                <select id="transport" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Transport 2 (Optional)</label>
                                <select id="transport2" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransport2Group">
                                <label class="form-label">Custom Transport 2</label>
                                <input type="text" id="customTransport2" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver 2 (Optional)</label>
                                <select id="driverName2" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper(s)</label>
                                <input type="text" id="helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)">
                                <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                            </div>
                        </div>

                        <div class="btn-group" style="margin-top: 0.5rem;">
                            <button type="button" class="btn btn-success" onclick="OMS.notifyAllocatedTeam()">üì± Notify Allocated Team</button>
                            <button type="button" class="btn btn-info" onclick="OMS.sendManagerReport()">üìä Send Manager Report</button>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">üì¶ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="üîç Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">üíæ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-success" onclick="OMS.quickAddPayment()">üíµ Quick Payment</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">üëÅÔ∏è Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">üìã Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">üìÖ Same Day</button>
                            <button type="button" class="btn btn-danger" data-action="clear">üóëÔ∏è Clear (Ctrl+D)</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="itemHistory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="financials" class="tab-content"></div>
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsBackdrop" class="shortcuts-backdrop" onclick="OMS.hideShortcuts()"></div>
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">√ó</button>
        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Clear Form</span>
                <span class="shortcut-key">Ctrl + D</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <script>
        
        // ============ UTILITIES ============
        const Utils = {
            get: (id, defaultValue = '') => {
                const el = document.getElementById(id);
                return el ? (el.value || '').toString().trim() : defaultValue;
            },

            set: (id, value) => {
                const el = document.getElementById(id);
                if (el) el.value = value;
            },

            elem: (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.entries(props).forEach(([key, val]) => {
                    if (key === 'class') el.className = val;
                    else if (key === 'style') Object.assign(el.style, val);
                    else if (key.startsWith('on')) el.addEventListener(key.slice(2).toLowerCase(), val);
                    else if (key.startsWith('data-')) el.dataset[key.slice(5)] = val;
                    else el[key] = val;
                });
                children.filter(child => child != null).forEach(child => {
                    el.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
                });
                return el;
            },

            formatDate: (dateStr) => {
    if (!dateStr) return 'N/A';
    try {
        const date = new Date(dateStr + 'T00:00:00');
        return date.toLocaleDateString('en-GB');
    } catch {
        return dateStr;
    }
},

convertDateFormat: (dateStr) => {
    if (!dateStr) return '';
    try {
        // Convert DD/MM/YYYY to YYYY-MM-DD
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            const day = parts[0].padStart(2, '0');
            const month = parts[1].padStart(2, '0');
            const year = parts[2];
            return `${year}-${month}-${day}`;
        }
        return dateStr;
    } catch {
        return dateStr;
    }
},

getLocalDate: (dateStr) => {
    if (!dateStr) return new Date();
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day);
},

toDateString: (date) => {
    const d = date instanceof Date ? date : new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
},

generateId: () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

debounce: (func, wait) => {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
},

            validateRequired: (fields) => {
                const errors = [];
                fields.forEach(field => {
                    const value = Utils.get(field);
                    if (!value) errors.push(field);
                });
                return errors;
            },

            // Mobile device detection
            isMobileDevice: () => {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            // Get device type for logging
            getDeviceType: () => {
                const ua = navigator.userAgent;
                if (/iPad/i.test(ua)) return 'iPad';
                if (/iPhone|iPod/i.test(ua)) return 'iPhone';
                if (/Android/i.test(ua)) return 'Android';
                return 'Desktop';
            },

            // Convert canvas.toBlob callback to Promise
            canvasToBlobPromise: (canvas, type = 'image/png', quality = 0.95) => {
                return new Promise((resolve, reject) => {
                    try {
                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas toBlob returned null - image may be too large for device memory'));
                            }
                        }, type, quality);
                    } catch (error) {
                        reject(error);
                    }
                });
            },

            // Get optimal canvas scale for device
            getOptimalCanvasScale: (baseScale) => {
                const isMobile = Utils.isMobileDevice();
                const deviceMemory = navigator.deviceMemory || 4; // Default to 4GB if not available

                if (!isMobile) {
                    return baseScale; // Desktop: use requested scale
                }

                // Mobile optimizations based on device memory
                if (deviceMemory <= 2) {
                    return Math.min(baseScale, 1); // Low memory: max scale 1
                } else if (deviceMemory <= 4) {
                    return Math.min(baseScale, 1.5); // Medium memory: max scale 1.5
                } else {
                    return Math.min(baseScale, 2); // Higher memory: max scale 2
                }
            },

            // Validate canvas dimensions for device
            validateCanvasDimensions: (width, height) => {
                const maxDimension = Utils.isMobileDevice() ? 4096 : 32767; // Mobile: 4096, Desktop: 32767
                const maxArea = Utils.isMobileDevice() ? 16777216 : 268435456; // Mobile: 16MP, Desktop: 256MP
                const area = width * height;

                if (width > maxDimension || height > maxDimension) {
                    return {
                        valid: false,
                        reason: `Canvas dimension exceeds maximum (${maxDimension}px) for this device`
                    };
                }

                if (area > maxArea) {
                    return {
                        valid: false,
                        reason: `Canvas area (${area}px) exceeds maximum (${maxArea}px) for this device`
                    };
                }

                return { valid: true };
            },

            // Weather API integration
            getWeather: async (city = 'Delhi', apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('‚ö†Ô∏è Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    // Using OpenWeatherMap free API
                    // Get your free API key from: https://openweathermap.org/api
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        // Fallback to mock data if API fails
                        console.error(`Weather API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather data unavailable'
                        };
                    }

                    const data = await response.json();
                    return {
                        temp: Math.round(data.main.temp),
                        humidity: data.main.humidity,
                        condition: data.weather[0].main,
                        description: data.weather[0].description,
                        icon: data.weather[0].icon
                    };
                } catch (error) {
                    console.error('Weather API error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather data unavailable'
                    };
                }
            },

            // Get weather by coordinates
            getWeatherByCoords: async (lat, lon, apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('‚ö†Ô∏è Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        console.error(`Weather API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather data unavailable'
                        };
                    }

                    const data = await response.json();
                    return {
                        temp: Math.round(data.main.temp),
                        humidity: data.main.humidity,
                        condition: data.weather[0].main,
                        description: data.weather[0].description,
                        icon: data.weather[0].icon,
                        city: data.name
                    };
                } catch (error) {
                    console.error('Weather API error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather data unavailable'
                    };
                }
            },

            // Get weather forecast for a specific date
            getWeatherForecast: async (city = 'Delhi', targetDate, apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('‚ö†Ô∏è Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const target = new Date(targetDate);
                    target.setHours(0, 0, 0, 0);

                    // If target date is today, use current weather API
                    if (target.getTime() === today.getTime()) {
                        return await Utils.getWeather(city, apiKey);
                    }

                    // For future dates (up to 5 days), use forecast API
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(city)}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        console.error(`Weather forecast API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather forecast unavailable'
                        };
                    }

                    const data = await response.json();

                    // Find forecast closest to noon on target date
                    const targetTime = new Date(target);
                    targetTime.setHours(12, 0, 0, 0);

                    let closestForecast = null;
                    let minDiff = Infinity;

                    data.list.forEach(forecast => {
                        const forecastTime = new Date(forecast.dt * 1000);
                        const diff = Math.abs(forecastTime - targetTime);

                        if (diff < minDiff) {
                            minDiff = diff;
                            closestForecast = forecast;
                        }
                    });

                    if (!closestForecast) {
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Forecast not available for this date'
                        };
                    }

                    return {
                        temp: Math.round(closestForecast.main.temp),
                        tempMin: Math.round(closestForecast.main.temp_min),
                        tempMax: Math.round(closestForecast.main.temp_max),
                        humidity: closestForecast.main.humidity,
                        condition: closestForecast.weather[0].main,
                        description: closestForecast.weather[0].description,
                        icon: closestForecast.weather[0].icon
                    };
                } catch (error) {
                    console.error('Weather forecast error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather forecast unavailable'
                    };
                }
            },

            // Get weather icon emoji
            getWeatherEmoji: (condition) => {
                const conditionLower = condition.toLowerCase();
                if (conditionLower.includes('clear') || conditionLower.includes('sun')) return '‚òÄÔ∏è';
                if (conditionLower.includes('cloud')) return '‚òÅÔ∏è';
                if (conditionLower.includes('rain') || conditionLower.includes('drizzle')) return 'üåßÔ∏è';
                if (conditionLower.includes('thunder') || conditionLower.includes('storm')) return '‚õàÔ∏è';
                if (conditionLower.includes('snow')) return '‚ùÑÔ∏è';
                if (conditionLower.includes('mist') || conditionLower.includes('fog') || conditionLower.includes('haze')) return 'üå´Ô∏è';
                return 'üå§Ô∏è';
            }
        };

        // ============ TRANSLATIONS ============
        const translations = {
            en: {
                // Header
                companyName: 'Order Management System',
                searchPlaceholder: 'üîç Search everything...',
                next: 'Next',
                logout: 'üö™ Logout',

                // Tabs
                dashboard: 'üìä Dashboard',
                orders: 'üìã Orders',
                inventory: 'üì¶ Inventory',
                itemHistory: 'üìú Item History',
                preparation: 'üç≥ Preparation',
                customers: 'üë• Customers',
                team: 'üë®‚Äçüíº Team',
                calendar: 'üìÖ Calendar',
                history: 'üïí History',
                analytics: 'üìà Analytics',
                financials: 'üí∞ Financials',
                settings: '‚öôÔ∏è Settings',

                // Common Buttons
                save: 'Save',
                cancel: 'Cancel',
                edit: 'Edit',
                delete: 'Delete',
                add: 'Add',
                close: 'Close',
                confirm: 'Confirm',
                clear: 'Clear',
                preview: 'Preview',
                duplicate: 'Duplicate',
                export: 'Export',
                import: 'Import',
                reset: 'Reset',
                search: 'Search',
                download: 'Download',
                upload: 'Upload',
                filter: 'Filter',
                print: 'Print',

                // Order Form
                orderDetails: 'Order Details',
                clientName: 'Client Name',
                contact: 'Contact',
                venue: 'Venue',
                orderDate: 'Order Date',
                readyTime: 'Ready Time',
                eventType: 'Event Type',
                transport: 'Transport',
                customTransport: 'Custom Transport',
                driverName: 'Driver Name',
                operator: 'Operator',
                helpers: 'Helper(s)',
                helperPlaceholder: 'Enter helper name(s), separate multiple with commas',
                orderStatus: 'Order Status',
                notes: 'Notes',
                items: 'Items',
                addItem: 'Add Item',
                itemName: 'Item Name',
                quantity: 'Quantity',
                remarks: 'Remarks',
                serialNumber: 'Sr. No.',

                // Status
                confirmed: 'Confirmed',
                completed: 'Completed',
                cancelled: 'Cancelled',
                pending: 'Pending',
                active: 'Active',
                inactive: 'Inactive',

                // Actions
                saveOrder: 'üíæ Save Order',
                saveOrderShortcut: 'üíæ Save Order (Ctrl+S)',
                duplicateLast: 'üìã Duplicate Last',
                sameDay: 'üìÖ Same Day',
                clearForm: 'üóëÔ∏è Clear',
                clearFormShortcut: 'üóëÔ∏è Clear (Ctrl+D)',
                notifyTeam: 'üì± Notify Allocated Team',
                sendReport: 'üìä Send Manager Report',

                // Settings
                systemSettings: '‚öôÔ∏è System Settings',
                printSettings: 'üñ®Ô∏è Print Settings',
                tableLayoutSettings: 'üìã Table Layout Settings',
                colorCustomization: 'üé® Color Customization',
                systemPreferences: 'üîß System Preferences',
                dataManagement: 'üìä Data Management',

                fontSize: 'Default Font Size',
                paperFormat: 'Paper Format',
                pageOrientation: 'Page Orientation',
                imageQuality: 'Image Quality',
                functionColor: 'Function Slot Color',
                portrait: 'üìÑ Portrait',
                landscape: 'üìÉ Landscape',
                low: 'Low',
                medium: 'Medium',
                high: 'High',
                ultra: 'Ultra',
                faster: 'Faster',
                balanced: 'Balanced',
                betterQuality: 'Better Quality',
                bestQuality: 'Best Quality',

                srColumnWidth: 'Sr.No Column Width',
                itemColumnWidth: 'Item Name Width',
                qtyColumnWidth: 'Quantity Width',
                remarksColumnWidth: 'Remarks Width',
                leftMarginFiling: 'Left Margin (filing)',

                headerBackground: 'Header Background',
                headerText: 'Header Text',
                orderIdBackground: 'Order ID Background',
                orderIdText: 'Order ID Text',
                tableHeaderBackground: 'Table Header Background',
                tableHeaderText: 'Table Header Text',
                tableBorder: 'Table Border',
                notesBackground: 'Notes Background',

                defaultOrderStatus: 'Default Order Status',
                lowStockThreshold: 'Low Stock Threshold',
                language: 'Language',
                invoiceFormat: 'Invoice Number Format',

                saveAllSettings: 'üíæ Save All Settings',
                resetToDefaults: 'üîÑ Reset to Defaults',
                exportJSON: 'üì§ Export JSON',
                exportCSV: 'üìä Export CSV',
                importBackup: 'üì• Import Backup',
                resetAllData: 'üóëÔ∏è Reset All Data',

                // Multi-day
                multiDayOrder: 'Multi-day Order',
                singleDayOrder: 'Single-day Order',
                startDate: 'Start Date',
                endDate: 'End Date',
                addDay: '‚ûï Add Day',
                addFunction: '‚ûï Add Function',
                removeDay: 'üóëÔ∏è Remove Day',
                removeFunction: 'üóëÔ∏è Remove Function',
                dayNumber: 'Day',
                functionNumber: 'Function',
                functionType: 'Function Type',
                timeSlot: 'Time Slot',
                driver: 'Driver',

                // Dashboard
                totalOrders: 'Total Orders',
                confirmedOrders: 'Confirmed',
                completedOrders: 'Completed',
                cancelledOrders: 'Cancelled',
                pendingOrders: 'Pending',
                recentOrders: 'Recent Orders',
                quickStats: 'Quick Stats',
                thisMonth: 'This Month',
                thisWeek: 'This Week',
                today: 'Today',

                // Team
                teamManagement: 'Team Management',
                addTeamMember: 'Add Team Member',
                memberName: 'Member Name',
                role: 'Role',
                roles: 'Roles',
                phoneNumber: 'Phone Number',
                email: 'Email',
                status: 'Status',
                actions: 'Actions',

                // Inventory
                inventoryManagement: 'Inventory Management',
                addCategory: 'Add Category',
                addInventoryItem: 'Add Inventory Item',
                categoryName: 'Category Name',
                currentStock: 'Current Stock',
                unit: 'Unit',
                reorderLevel: 'Reorder Level',

                // Calendar
                month: 'Month',
                week: 'Week',
                day: 'Day',
                ordersFor: 'Orders for',
                noOrders: 'No orders for this date',

                // History
                orderHistory: 'Order History',
                deletedOrders: 'Deleted Orders',
                restore: 'Restore',
                permanentlyDelete: 'Permanently Delete',

                // Analytics
                analyticsReport: 'Analytics Report',
                dateRange: 'Date Range',
                from: 'From',
                to: 'To',
                generateReport: 'Generate Report',
                topItems: 'Top Items',
                orderTrends: 'Order Trends',

                // Messages
                orderSaved: 'Order saved successfully!',
                orderDeleted: 'Order deleted!',
                settingsSaved: 'All settings saved successfully!',
                itemAdded: 'Item added!',
                itemRemoved: 'Item removed!',
                error: 'Error',
                success: 'Success',
                warning: 'Warning',
                info: 'Info',
                loading: 'Loading...',
                generatingImage: 'Generating image...',
                downloadComplete: 'Download complete!',

                // Placeholders
                enterClientName: 'Enter client name',
                enterContact: 'Enter contact number',
                enterVenue: 'Enter venue',
                selectDate: 'Select date',
                selectTime: 'Select time',
                selectEventType: 'Select event type',
                selectTransport: 'Select transport',
                selectDriver: 'Select Driver',
                selectOperator: 'Select Operator',
                selectHelper: 'Select Helper',
                enterNotes: 'Enter notes...',
                searchItem: 'Search item...',

                // Confirmations
                confirmDelete: 'Are you sure you want to delete?',
                confirmReset: 'Reset all settings?',
                confirmClear: 'Clear form?',
                cannotUndo: 'This action cannot be undone.',

                // Info messages
                multiOrderNote: 'Note: Multi-order images use smart auto-sizing',
                higherQualityNote: 'Higher quality = larger file size',
                multipleHelpersNote: 'You can add multiple helpers separated by commas (e.g., John, Mary, David)',
                chooseFormat: 'Choose paper size for print layout',
                portraitOrLandscape: 'Portrait or landscape mode',
                customColorNote: 'Custom color for function slots',

                // Additional translations for complete coverage
                lowStock: 'Low Stock',
                orderId: 'Order ID',
                client: 'Client',
                event: 'Event',
                date: 'Date',
                view: 'View',
                ordersText: 'orders',
                batchUpdate: '‚ö° Batch Update',
                categories: 'Categories',
                enterCategoryName: 'Category name',
                enterItemName: 'Item name',
                selectCategory: 'Select category',
                category: 'Category',
                item: 'Item',
                stock: 'Stock',
                topCustomer: 'Top Customer',
                preparationForecast: 'Preparation Forecast',
                selectDateRange: 'Select Date Range',
                generate: 'Generate',
                aggregatedItems: 'Aggregated Items for Date Range',
                forecastSummary: 'Forecast Summary',
                totalItems: 'Total Items',
                ordersInRange: 'Orders in Range',
                itemsToPrep: 'Items to Prepare',
                noOrdersFound: 'No orders found in the selected date range',
                customers: 'Customers',
                addCustomer: 'Add Customer',
                customerName: 'Customer Name',
                totalOrdersCount: 'Total Orders',
                lastOrder: 'Last Order',
                never: 'Never',
                na: 'N/A',
                viewOrders: 'View Orders',
                editTeamMember: 'Edit Team Member',
                addThisDay: '‚ûï Add to This Day',
                removeThisDay: 'üóëÔ∏è Remove',
                functionColor: 'Function Slot Color',
                addFunctionToThisDay: 'Add Function to This Day',
                selectOperatorPlaceholder: 'Select Operator',
                selectHelperPlaceholder: 'Select Helper',
                functionNotes: 'Special requirements for this function...',
                searchItems: 'üîç Search items...',
                noItemsAdded: 'No items added yet',
                calendarView: 'Calendar View',
                previousMonth: '‚Äπ Previous',
                nextMonth: 'Next ‚Ä∫',
                ordersScheduled: 'orders scheduled',
                noOrdersForDate: 'No orders for this date',
                viewOrderDetails: 'View details',
                restoreOrder: 'Restore',
                permanentDelete: 'Permanently Delete',
                ordersInHistory: 'orders in history',
                deletedOrdersCount: 'deleted orders',
                chartPlaceholder: 'Chart will appear here',
                noDataForRange: 'No data available for selected range',
                multiDayToggle: 'Multi-day Order',
                singleDay: 'Single Day',
                multiDay: 'Multi Day',
                transportOptions: 'Transport',
                customTransportOption: 'Custom',
                enterCustomTransport: 'Enter custom transport',
                selectStatus: 'Select Status',
                switchToEnglish: 'Switch to English',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: 'Preparation',
                forecast: 'Forecast',
                selectOperatorDropdown: 'Select Operator',
                noSelection: '',
                multiDayFormLabel: 'Multi-day Order?',
                enterFunctionType: 'e.g., Sangeet, Reception',
                enterTimeSlot: 'e.g., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: 'You can add multiple helpers separated by commas',
                tomorrow: 'Tomorrow',
                next7Days: 'Next 7 Days',
                next30Days: 'Next 30 Days',
                noOrdersFoundShort: 'No Orders Found',
                noOrdersScheduledBetween: 'No orders scheduled between',
                summary: 'Summary',
                uniqueItems: 'Unique Items',
                totalQuantity: 'Total Quantity',
                shortages: 'Shortages',
                sufficient: 'Sufficient',
                itemsPreparationList: 'Items Preparation List',
                sr: 'Sr',
                required: 'Required',
                inStock: 'In Stock',
                difference: 'Difference',
                usedInOrders: 'Used In Orders',
                ok: 'OK',
                short: 'SHORT',
                more: 'more',
                details: 'Details',
                grandTotal: 'GRAND TOTAL',
                orderDetailsBreakdown: 'Order Details Breakdown',
                shareWhatsApp: 'üì± Share WhatsApp',
                exportPDF: 'üìÑ Export PDF'
            },
            gu: {
                // Header
                companyName: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ',
                searchPlaceholder: 'üîç ‡™¨‡™ß‡´Å‡™Ç ‡™∂‡´ã‡™ß‡´ã...',
                next: '‡™Ü‡™ó‡™≥',
                logout: 'üö™ ‡™≤‡´ã‡™ó‡™Ü‡™â‡™ü',

                // Tabs
                dashboard: 'üìä ‡™°‡´á‡™∂‡™¨‡´ã‡™∞‡´ç‡™°',
                orders: 'üìã ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                inventory: 'üì¶ ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä',
                itemHistory: 'üìú ‡™Ü‡™á‡™ü‡™Æ ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                preparation: 'üç≥ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                customers: 'üë• ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                team: 'üë®‚Äçüíº ‡™ü‡´Ä‡™Æ',
                calendar: 'üìÖ ‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞',
                history: 'üïí ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                analytics: 'üìà ‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£',
                financials: 'üí∞ ‡™®‡™æ‡™£‡™æ‡™ï‡´Ä‡™Ø',
                settings: '‚öôÔ∏è ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',

                // Common Buttons
                save: '‡™∏‡™æ‡™ö‡™µ‡´ã',
                cancel: '‡™∞‡™¶ ‡™ï‡™∞‡´ã',
                edit: '‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                delete: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                add: '‡™â‡™Æ‡´á‡™∞‡´ã',
                close: '‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã',
                confirm: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™ï‡™∞‡´ã',
                clear: '‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                preview: '‡™™‡´Ç‡™∞‡´ç‡™µ‡™æ‡™µ‡™≤‡´ã‡™ï‡™®',
                duplicate: '‡™®‡™ï‡™≤',
                export: '‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                import: '‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                reset: '‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                search: '‡™∂‡´ã‡™ß‡´ã',
                download: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                upload: '‡™Ö‡™™‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                filter: '‡™´‡™ø‡™≤‡´ç‡™ü‡™∞',
                print: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü',

                // Order Form
                orderDetails: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™µ‡™ø‡™ó‡™§‡´ã',
                clientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                contact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï',
                venue: '‡™∏‡´ç‡™•‡™≥',
                orderDate: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                readyTime: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™∏‡™Æ‡™Ø',
                eventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                transport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                driverName: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                operator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞',
                helpers: '‡™π‡´á‡™≤‡´ç‡™™‡™∞(‡™∏)',
                helperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞‡™®‡™æ ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã, ‡™µ‡™ß‡´Å ‡™Æ‡™æ‡™ü‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´ã',
                orderStatus: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                notes: '‡™®‡´ã‡™Ç‡™ß',
                items: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                addItem: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                itemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                quantity: '‡™ú‡™•‡´ç‡™•‡´ã',
                remarks: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä',
                serialNumber: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï',

                // Status
                confirmed: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completed: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelled: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pending: '‡™¨‡™æ‡™ï‡´Ä',
                active: '‡™∏‡™ï‡´ç‡™∞‡™ø‡™Ø',
                inactive: '‡™®‡™ø‡™∑‡´ç‡™ï‡´ç‡™∞‡™ø‡™Ø',

                // Actions
                saveOrder: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                saveOrderShortcut: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã (Ctrl+S)',
                duplicateLast: 'üìã ‡™õ‡´á‡™≤‡´ç‡™≤‡´Ä ‡™®‡™ï‡™≤',
                sameDay: 'üìÖ ‡™∏‡™Æ‡™æ‡™® ‡™¶‡™ø‡™µ‡™∏',
                clearForm: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                clearFormShortcut: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã (Ctrl+D)',
                notifyTeam: 'üì± ‡™ü‡´Ä‡™Æ‡™®‡´á ‡™∏‡´Ç‡™ö‡™®‡™æ',
                sendReport: 'üìä ‡™Æ‡´á‡™®‡´á‡™ú‡™∞ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™Æ‡´ã‡™ï‡™≤‡´ã',

                // Settings
                systemSettings: '‚öôÔ∏è ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                printSettings: 'üñ®Ô∏è ‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                tableLayoutSettings: 'üìã ‡™ü‡´á‡™¨‡™≤ ‡™≤‡´á‡™Ü‡™â‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                colorCustomization: 'üé® ‡™∞‡™Ç‡™ó ‡™ï‡™∏‡´ç‡™ü‡™Æ‡™æ‡™á‡™ù‡´á‡™∂‡™®',
                systemPreferences: 'üîß ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™™‡™∏‡™Ç‡™¶‡™ó‡´Ä‡™ì',
                dataManagement: 'üìä ‡™°‡´á‡™ü‡™æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',

                fontSize: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™´‡´ã‡™®‡´ç‡™ü ‡™∏‡™æ‡™á‡™ù',
                paperFormat: '‡™™‡´á‡™™‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',
                pageOrientation: '‡™™‡´á‡™ú ‡™ì‡™∞‡™ø‡™è‡™®‡´ç‡™ü‡´á‡™∂‡™®',
                imageQuality: '‡™á‡™Æ‡´á‡™ú ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                portrait: 'üìÑ ‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü',
                landscape: 'üìÉ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™',
                low: '‡™ì‡™õ‡´Ä',
                medium: '‡™Æ‡™ß‡´ç‡™Ø‡™Æ',
                high: '‡™â‡™ö‡´ç‡™ö',
                ultra: '‡™Ö‡™≤‡´ç‡™ü‡´ç‡™∞‡™æ',
                faster: '‡™ù‡™°‡™™‡´Ä',
                balanced: '‡™∏‡™Ç‡™§‡´Å‡™≤‡™ø‡™§',
                betterQuality: '‡™∏‡™æ‡™∞‡´Ä ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                bestQuality: '‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',

                srColumnWidth: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï ‡™ï‡´â‡™≤‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                itemColumnWidth: '‡™Ü‡™á‡™ü‡™Æ ‡™®‡™æ‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                qtyColumnWidth: '‡™ú‡™•‡´ç‡™•‡´ã ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                remarksColumnWidth: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                leftMarginFiling: '‡™°‡™æ‡™¨‡´ã ‡™Æ‡™æ‡™∞‡´ç‡™ú‡™ø‡™® (‡™´‡™æ‡™á‡™≤‡™ø‡™Ç‡™ó)',

                headerBackground: '‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                headerText: '‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                orderIdBackground: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                orderIdText: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableHeaderBackground: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                tableHeaderText: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableBorder: '‡™ü‡´á‡™¨‡™≤ ‡™¨‡´ã‡™∞‡´ç‡™°‡™∞',
                notesBackground: '‡™®‡´ã‡™Ç‡™ß ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',

                defaultOrderStatus: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                lowStockThreshold: '‡™ì‡™õ‡™æ ‡™∏‡´ç‡™ü‡´â‡™ï‡™®‡´Ä ‡™Æ‡™∞‡´ç‡™Ø‡™æ‡™¶‡™æ',
                language: '‡™≠‡™æ‡™∑‡™æ',
                invoiceFormat: '‡™á‡™®‡´ç‡™µ‡´â‡™á‡™∏ ‡™®‡™Ç‡™¨‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',

                saveAllSettings: 'üíæ ‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                resetToDefaults: 'üîÑ ‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™™‡™∞ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                exportJSON: 'üì§ JSON ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                exportCSV: 'üìä CSV ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                importBackup: 'üì• ‡™¨‡´á‡™ï‡™Ö‡™™ ‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                resetAllData: 'üóëÔ∏è ‡™¨‡™ß‡´ã ‡™°‡´á‡™ü‡™æ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',

                // Multi-day
                multiDayOrder: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDayOrder: '‡™∏‡™ø‡™Ç‡™ó‡™≤-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                startDate: '‡™∂‡™∞‡´Ç‡™Ü‡™§‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                endDate: '‡™Ö‡™Ç‡™§‡™ø‡™Æ ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                addDay: '‚ûï ‡™¶‡™ø‡™µ‡™∏ ‡™â‡™Æ‡´á‡™∞‡´ã',
                addFunction: '‚ûï ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeDay: 'üóëÔ∏è ‡™¶‡™ø‡™µ‡™∏ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                removeFunction: 'üóëÔ∏è ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                dayNumber: '‡™¶‡™ø‡™µ‡™∏',
                functionNumber: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®',
                functionType: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                timeSlot: '‡™∏‡™Æ‡™Ø',
                driver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞',

                // Dashboard
                totalOrders: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                confirmedOrders: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completedOrders: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelledOrders: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pendingOrders: '‡™¨‡™æ‡™ï‡´Ä',
                recentOrders: '‡™§‡™æ‡™ú‡´á‡™§‡™∞‡™®‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                quickStats: '‡™ù‡™°‡™™‡´Ä ‡™Ü‡™Ç‡™ï‡™°‡™æ',
                thisMonth: '‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á',
                thisWeek: '‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´á',
                today: '‡™Ü‡™ú‡´á',

                // Team
                teamManagement: '‡™ü‡´Ä‡™Æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™â‡™Æ‡´á‡™∞‡´ã',
                memberName: '‡™∏‡™≠‡´ç‡™Ø‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                role: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ',
                roles: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ‡™ì',
                phoneNumber: '‡™´‡´ã‡™® ‡™®‡™Ç‡™¨‡™∞',
                email: '‡™á‡™Æ‡´á‡™á‡™≤',
                status: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                actions: '‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ‡™ì',

                // Inventory
                inventoryManagement: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™â‡™Æ‡´á‡™∞‡´ã',
                addInventoryItem: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                categoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                currentStock: '‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™∏‡´ç‡™ü‡´â‡™ï',
                unit: '‡™è‡™ï‡™Æ',
                reorderLevel: '‡™´‡™∞‡´Ä‡™•‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™∏‡´ç‡™§‡™∞',

                // Calendar
                month: '‡™Æ‡™π‡™ø‡™®‡´ã',
                week: '‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´Å‡™Ç',
                day: '‡™¶‡™ø‡™µ‡™∏',
                ordersFor: '‡™Æ‡™æ‡™ü‡´á ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                noOrders: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',

                // History
                orderHistory: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                deletedOrders: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                restore: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentlyDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',

                // Analytics
                analyticsReport: '‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü',
                dateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä',
                from: '‡™•‡´Ä',
                to: '‡™∏‡´Å‡™ß‡´Ä',
                generateReport: '‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™¨‡™®‡™æ‡™µ‡´ã',
                topItems: '‡™ü‡´ã‡™™ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                orderTrends: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ü‡´ç‡™∞‡´á‡™®‡´ç‡™°‡´ç‡™∏',

                // Messages
                orderSaved: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´ç‡™Ø‡´ã!',
                orderDeleted: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ç‡™Ø‡´ã!',
                settingsSaved: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´Ä!',
                itemAdded: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                itemRemoved: '‡™Ü‡™á‡™ü‡™Æ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                error: '‡™≠‡´Ç‡™≤',
                success: '‡™∏‡™´‡™≥‡™§‡™æ',
                warning: '‡™ö‡´á‡™§‡™µ‡™£‡´Ä',
                info: '‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä',
                loading: '‡™≤‡´ã‡™° ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´Å‡™Ç ‡™õ‡´á...',
                generatingImage: '‡™á‡™Æ‡´á‡™ú ‡™¨‡™®‡™æ‡™µ‡´Ä ‡™∞‡™π‡´ç‡™Ø‡™æ ‡™õ‡´Ä‡™è...',
                downloadComplete: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™™‡´Ç‡™∞‡´ç‡™£!',

                // Placeholders
                enterClientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterContact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï ‡™®‡™Ç‡™¨‡™∞ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterVenue: '‡™∏‡´ç‡™•‡™≥ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectDate: '‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTime: '‡™∏‡™Æ‡™Ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectEventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTransport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectDriver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectOperator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelper: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                enterNotes: '‡™®‡´ã‡™Ç‡™ß ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã...',
                searchItem: '‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',

                // Confirmations
                confirmDelete: '‡™∂‡´Å‡™Ç ‡™§‡™Æ‡´á ‡™ñ‡™∞‡´á‡™ñ‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã?',
                confirmReset: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡™µ‡´Ä ‡™õ‡´á?',
                confirmClear: '‡™´‡´ã‡™∞‡´ç‡™Æ ‡™∏‡™æ‡™´ ‡™ï‡™∞‡™µ‡´Å‡™Ç ‡™õ‡´á?',
                cannotUndo: '‡™Ü ‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§‡´ç ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡™æ‡™§‡´Ä ‡™®‡™•‡´Ä.',

                // Info messages
                multiOrderNote: '‡™®‡´ã‡™Ç‡™ß: ‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™Æ‡´á‡™ú‡´Ä‡™∏ ‡™∏‡´ç‡™Æ‡™æ‡™∞‡´ç‡™ü ‡™ì‡™ü‡´ã-‡™∏‡™æ‡™á‡™ù‡™ø‡™Ç‡™ó ‡™µ‡™æ‡™™‡™∞‡´á ‡™õ‡´á',
                higherQualityNote: '‡™â‡™ö‡´ç‡™ö ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ = ‡™Æ‡´ã‡™ü‡´Ä ‡™´‡™æ‡™á‡™≤ ‡™∏‡™æ‡™á‡™ù',
                multipleHelpersNote: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã (‡™¶‡™æ.‡™§., ‡™ú‡´ã‡™®, ‡™Æ‡´á‡™∞‡´Ä, ‡™°‡´á‡™µ‡™ø‡™°)',
                chooseFormat: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™≤‡´á‡™Ü‡™â‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™™‡´á‡™™‡™∞ ‡™∏‡™æ‡™á‡™ù ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                portraitOrLandscape: '‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü ‡™Ö‡™•‡™µ‡™æ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™ ‡™Æ‡´ã‡™°',
                customColorNote: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™∞‡™Ç‡™ó',

                // Additional translations for complete coverage
                lowStock: '‡™ì‡™õ‡´ã ‡™∏‡´ç‡™ü‡´â‡™ï',
                orderId: '‡™ì‡™∞‡´ç‡™°‡™∞ ID',
                client: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                event: '‡™á‡™µ‡´á‡™®‡´ç‡™ü',
                date: '‡™§‡™æ‡™∞‡´Ä‡™ñ',
                view: '‡™ú‡´Å‡™ì',
                ordersText: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                batchUpdate: '‚ö° ‡™¨‡´á‡™ö ‡™Ö‡™™‡™°‡´á‡™ü',
                categories: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™ì',
                enterCategoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                enterItemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                selectCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                category: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä',
                item: '‡™Ü‡™á‡™ü‡™Æ',
                stock: '‡™∏‡´ç‡™ü‡´â‡™ï',
                topCustomer: '‡™ü‡´ã‡™™ ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                preparationForecast: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectDateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                generate: '‡™¨‡™®‡™æ‡™µ‡´ã',
                aggregatedItems: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™è‡™ï‡™§‡´ç‡™∞‡™ø‡™§ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                forecastSummary: '‡™Ö‡™Ç‡™¶‡™æ‡™ú ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                totalItems: '‡™ï‡´Å‡™≤ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                ordersInRange: '‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                itemsToPrep: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™ï‡™∞‡™µ‡™æ‡™®‡´Ä ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                noOrdersFound: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                customers: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                addCustomer: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï ‡™â‡™Æ‡´á‡™∞‡´ã',
                customerName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                totalOrdersCount: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                lastOrder: '‡™õ‡´á‡™≤‡´ç‡™≤‡´ã ‡™ì‡™∞‡´ç‡™°‡™∞',
                never: '‡™ï‡´ç‡™Ø‡™æ‡™∞‡´á‡™Ø ‡™®‡™π‡´Ä‡™Ç',
                na: '‡™≤‡™æ‡™ó‡´Å ‡™®‡™•‡´Ä',
                viewOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™ú‡´Å‡™ì',
                editTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                addThisDay: '‚ûï ‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeThisDay: 'üóëÔ∏è ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                addFunctionToThisDay: '‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                selectOperatorPlaceholder: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                functionNotes: '‡™Ü ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™Æ‡™æ‡™ü‡´á ‡™µ‡™ø‡™∂‡´á‡™∑ ‡™ú‡™∞‡´Ç‡™∞‡™ø‡™Ø‡™æ‡™§‡´ã...',
                searchItems: 'üîç ‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',
                noItemsAdded: '‡™π‡™ú‡´Å ‡™∏‡´Å‡™ß‡´Ä ‡™ï‡´ã‡™à ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                calendarView: '‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞ ‡™¶‡´É‡™∂‡´ç‡™Ø',
                previousMonth: '‚Äπ ‡™™‡™π‡´á‡™≤‡™æ‡™Ç',
                nextMonth: '‡™Ü‡™ó‡™≥ ‚Ä∫',
                ordersScheduled: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§',
                noOrdersForDate: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',
                viewOrderDetails: '‡™µ‡™ø‡™ó‡™§‡´ã ‡™ú‡´Å‡™ì',
                restoreOrder: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                ordersInHistory: '‡™á‡™§‡™ø‡™π‡™æ‡™∏‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                deletedOrdersCount: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                chartPlaceholder: '‡™ö‡™æ‡™∞‡´ç‡™ü ‡™Ö‡™π‡´Ä‡™Ç ‡™¶‡´á‡™ñ‡™æ‡™∂‡´á',
                noDataForRange: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™°‡´á‡™ü‡™æ ‡™â‡™™‡™≤‡™¨‡´ç‡™ß ‡™®‡™•‡´Ä',
                multiDayToggle: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDay: '‡™∏‡™ø‡™Ç‡™ó‡™≤ ‡™°‡´á',
                multiDay: '‡™Æ‡™≤‡´ç‡™ü‡™ø ‡™°‡´á',
                transportOptions: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransportOption: '‡™ï‡™∏‡´ç‡™ü‡™Æ',
                enterCustomTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectStatus: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                switchToEnglish: '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                forecast: '‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectOperatorDropdown: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                noSelection: '',
                multiDayFormLabel: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞?',
                enterFunctionType: '‡™¶‡™æ.‡™§., ‡™∏‡™Ç‡™ó‡´Ä‡™§, ‡™∞‡™ø‡™∏‡´á‡™™‡´ç‡™∂‡™®',
                enterTimeSlot: '‡™¶‡™æ.‡™§., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã',
                tomorrow: '‡™Ü‡™µ‡™§‡´Ä ‡™ï‡™æ‡™≤‡´á',
                next7Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 7 ‡™¶‡™ø‡™µ‡™∏',
                next30Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 30 ‡™¶‡™ø‡™µ‡™∏',
                noOrdersFoundShort: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                noOrdersScheduledBetween: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§ ‡™®‡™•‡´Ä',
                summary: '‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                uniqueItems: '‡™Ö‡™®‡™®‡´ç‡™Ø ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                totalQuantity: '‡™ï‡´Å‡™≤ ‡™ú‡™•‡´ç‡™•‡´ã',
                shortages: '‡™â‡™£‡™™',
                sufficient: '‡™™‡™∞‡´ç‡™Ø‡™æ‡™™‡´ç‡™§',
                itemsPreparationList: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ø‡™æ‡™¶‡´Ä',
                sr: '‡™ï‡´ç‡™∞‡™Æ',
                required: '‡™ú‡™∞‡´Ç‡™∞‡´Ä',
                inStock: '‡™∏‡´ç‡™ü‡´â‡™ï‡™Æ‡™æ‡™Ç',
                difference: '‡™§‡™´‡™æ‡™µ‡™§',
                usedInOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏‡™Æ‡™æ‡™Ç ‡™µ‡™™‡™∞‡™æ‡™Ø‡´á‡™≤',
                ok: '‡™¨‡™∞‡™æ‡™¨‡™∞',
                short: '‡™ì‡™õ‡´Å‡™Ç',
                more: '‡™µ‡™ß‡´Å',
                details: '‡™µ‡™ø‡™ó‡™§‡´ã',
                grandTotal: '‡™ï‡´Å‡™≤ ‡™∏‡™∞‡™µ‡™æ‡™≥‡´ã',
                orderDetailsBreakdown: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™µ‡™ø‡™ó‡™§ ‡™µ‡™ø‡™≠‡™æ‡™ú‡™®',
                shareWhatsApp: 'üì± WhatsApp ‡™∂‡´á‡™∞ ‡™ï‡™∞‡´ã',
                exportPDF: 'üìÑ PDF ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã'
            }
        };

        // ============ FILTERING INFRASTRUCTURE ============

        /**
         * FilterLogger - Detailed logging system for all filtering operations
         * Tracks every filter with timestamp, parameters, results, and performance metrics
         */
        class FilterLogger {
            constructor() {
                this.logs = this.loadLogs();
                this.maxLogs = 1000; // Keep last 1000 operations
            }

            loadLogs() {
                try {
                    const saved = localStorage.getItem('oms_filter_logs');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter logs:', error);
                    return [];
                }
            }

            saveLogs() {
                try {
                    // Keep only the most recent logs
                    if (this.logs.length > this.maxLogs) {
                        this.logs = this.logs.slice(-this.maxLogs);
                    }
                    localStorage.setItem('oms_filter_logs', JSON.stringify(this.logs));
                } catch (error) {
                    console.warn('Failed to save filter logs:', error);
                }
            }

            log(operation, details) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    operation,
                    ...details
                };

                this.logs.push(logEntry);
                this.saveLogs();

                // Also log to console for debugging
                console.log(`üîç [FilterLog] ${operation}:`, details);

                return logEntry;
            }

            getRecentLogs(count = 50) {
                return this.logs.slice(-count);
            }

            getLogsByDate(date) {
                return this.logs.filter(log => log.filterDate === date);
            }

            clearOldLogs(daysToKeep = 30) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - daysToKeep);
                const cutoffTime = cutoff.toISOString();

                this.logs = this.logs.filter(log => log.timestamp > cutoffTime);
                this.saveLogs();
            }
        }

        /**
         * PatternLearner - Machine learning-style pattern recognition system
         * Learns from filtering patterns to detect anomalies and improve accuracy
         */
        class PatternLearner {
            constructor() {
                this.patterns = this.loadPatterns();
                this.anomalyThreshold = 0.3; // 30% deviation triggers alert
            }

            loadPatterns() {
                try {
                    const saved = localStorage.getItem('oms_filter_patterns');
                    return saved ? JSON.parse(saved) : {
                        datePatterns: {}, // date -> expected order count
                        filterResults: [], // historical filter results
                        dateFormats: {}, // learned date format variations
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                } catch (error) {
                    console.warn('Failed to load patterns:', error);
                    return {
                        datePatterns: {},
                        filterResults: [],
                        dateFormats: {},
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                }
            }

            savePatterns() {
                try {
                    localStorage.setItem('oms_filter_patterns', JSON.stringify(this.patterns));
                } catch (error) {
                    console.warn('Failed to save patterns:', error);
                }
            }

            recordFilterResult(date, orderCount, totalAvailable, filterType = 'date') {
                // Update date-specific patterns
                if (!this.patterns.datePatterns[date]) {
                    this.patterns.datePatterns[date] = {
                        counts: [],
                        avgCount: 0,
                        lastSeen: new Date().toISOString()
                    };
                }

                const pattern = this.patterns.datePatterns[date];
                pattern.counts.push(orderCount);
                pattern.lastSeen = new Date().toISOString();

                // Keep only last 10 observations per date
                if (pattern.counts.length > 10) {
                    pattern.counts = pattern.counts.slice(-10);
                }

                // Calculate average
                pattern.avgCount = pattern.counts.reduce((sum, c) => sum + c, 0) / pattern.counts.length;

                // Update weekday/weekend patterns
                const dateObj = new Date(date);
                const dayOfWeek = dateObj.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                const key = isWeekend ? 'weekend' : 'weekday';
                const stats = this.patterns.typicalOrderCounts[key];

                if (stats.samples === 0) {
                    stats.min = orderCount;
                    stats.max = orderCount;
                    stats.avg = orderCount;
                    stats.samples = 1;
                } else {
                    stats.min = Math.min(stats.min, orderCount);
                    stats.max = Math.max(stats.max, orderCount);
                    stats.avg = (stats.avg * stats.samples + orderCount) / (stats.samples + 1);
                    stats.samples++;
                }

                // Record in filter results history
                this.patterns.filterResults.push({
                    timestamp: new Date().toISOString(),
                    date,
                    orderCount,
                    totalAvailable,
                    filterType,
                    dayOfWeek,
                    isWeekend
                });

                // Keep only last 500 results
                if (this.patterns.filterResults.length > 500) {
                    this.patterns.filterResults = this.patterns.filterResults.slice(-500);
                }

                this.savePatterns();
            }

            learnDateFormat(originalDate, normalizedDate) {
                if (!this.patterns.dateFormats[originalDate]) {
                    this.patterns.dateFormats[originalDate] = {
                        normalized: normalizedDate,
                        count: 1,
                        lastSeen: new Date().toISOString()
                    };
                } else {
                    this.patterns.dateFormats[originalDate].count++;
                    this.patterns.dateFormats[originalDate].lastSeen = new Date().toISOString();
                }
                this.savePatterns();
            }

            detectAnomaly(date, actualCount) {
                // Check if we have historical data for this date
                const pattern = this.patterns.datePatterns[date];

                if (pattern && pattern.counts.length >= 3) {
                    const expected = pattern.avgCount;
                    const deviation = Math.abs(actualCount - expected) / Math.max(expected, 1);

                    if (deviation > this.anomalyThreshold) {
                        return {
                            isAnomaly: true,
                            expected,
                            actual: actualCount,
                            deviation: (deviation * 100).toFixed(1) + '%',
                            message: `‚ö†Ô∏è Unusual order count! Expected ~${Math.round(expected)} orders, found ${actualCount}`
                        };
                    }
                }

                // Check against weekday/weekend patterns
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                if (stats.samples >= 10) {
                    if (actualCount < stats.min * 0.5 || actualCount > stats.max * 1.5) {
                        return {
                            isAnomaly: true,
                            expected: `${stats.min}-${stats.max}`,
                            actual: actualCount,
                            message: `‚ö†Ô∏è Order count outside normal range! Typical ${isWeekend ? 'weekend' : 'weekday'}: ${stats.min}-${stats.max}, found ${actualCount}`
                        };
                    }
                }

                return { isAnomaly: false };
            }

            getExpectedCount(date) {
                const pattern = this.patterns.datePatterns[date];
                if (pattern && pattern.counts.length > 0) {
                    return Math.round(pattern.avgCount);
                }

                // Fallback to weekday/weekend average
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                return stats.samples > 0 ? Math.round(stats.avg) : null;
            }
        }

        /**
         * FuzzyDateMatcher - Handles date format variations and near-matches
         * Provides error tolerance for date matching
         */
        class FuzzyDateMatcher {
            constructor() {
                this.dateFormats = [
                    'YYYY-MM-DD',
                    'DD-MM-YYYY',
                    'MM-DD-YYYY',
                    'DD/MM/YYYY',
                    'MM/DD/YYYY',
                    'YYYY/MM/DD'
                ];
            }

            // Normalize various date formats to YYYY-MM-DD
            normalize(dateStr) {
                if (!dateStr) return null;

                try {
                    // If already a Date object
                    if (dateStr instanceof Date) {
                        return this.toYYYYMMDD(dateStr);
                    }

                    // If ISO format
                    if (dateStr.includes('T') || dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const d = new Date(dateStr);
                        return this.toYYYYMMDD(d);
                    }

                    // Try different formats
                    const formats = [
                        // DD-MM-YYYY or DD/MM/YYYY
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // MM-DD-YYYY or MM/DD/YYYY (US format)
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // YYYY-MM-DD or YYYY/MM/DD
                        /^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/
                    ];

                    for (const format of formats) {
                        const match = dateStr.match(format);
                        if (match) {
                            let year, month, day;

                            if (match[1].length === 4) {
                                // YYYY-MM-DD format
                                [, year, month, day] = match;
                            } else {
                                // Assume DD-MM-YYYY (more common internationally)
                                [, day, month, year] = match;
                            }

                            const d = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                            if (!isNaN(d.getTime())) {
                                return this.toYYYYMMDD(d);
                            }
                        }
                    }

                    // Fallback: try native Date parsing
                    const d = new Date(dateStr);
                    if (!isNaN(d.getTime())) {
                        return this.toYYYYMMDD(d);
                    }

                } catch (error) {
                    console.warn('Failed to normalize date:', dateStr, error);
                }

                return null;
            }

            toYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Check if two dates are the same, handling various formats
            matches(date1, date2) {
                const norm1 = this.normalize(date1);
                const norm2 = this.normalize(date2);
                return norm1 && norm2 && norm1 === norm2;
            }

            // Check if date is within range (inclusive)
            isInRange(dateToCheck, startDate, endDate) {
                const check = new Date(this.normalize(dateToCheck));
                const start = new Date(this.normalize(startDate));
                const end = new Date(this.normalize(endDate));

                return check >= start && check <= end;
            }

            // Find near matches (within N days)
            findNearMatches(targetDate, dates, daysTolerance = 1) {
                const target = new Date(this.normalize(targetDate));
                const matches = [];

                for (const date of dates) {
                    const d = new Date(this.normalize(date));
                    const diffDays = Math.abs((d - target) / (1000 * 60 * 60 * 24));

                    if (diffDays <= daysTolerance) {
                        matches.push({
                            date,
                            daysAway: diffDays,
                            isExact: diffDays === 0
                        });
                    }
                }

                return matches.sort((a, b) => a.daysAway - b.daysAway);
            }

            // Get date variations that should be checked
            getVariations(dateStr) {
                const normalized = this.normalize(dateStr);
                if (!normalized) return [dateStr];

                const d = new Date(normalized);
                const variations = new Set();

                // Add normalized version
                variations.add(normalized);

                // Add original
                variations.add(dateStr);

                // Add common formats
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');

                variations.add(`${year}-${month}-${day}`);
                variations.add(`${day}-${month}-${year}`);
                variations.add(`${month}-${day}-${year}`);
                variations.add(`${day}/${month}/${year}`);
                variations.add(`${month}/${day}/${year}`);

                return Array.from(variations);
            }
        }

        /**
         * OrderValidator - Validation system to detect missing orders
         * Alerts when filtering results seem incomplete
         */
        class OrderValidator {
            constructor(patternLearner) {
                this.patternLearner = patternLearner;
            }

            validate(filterResult) {
                const alerts = [];
                const { date, orderCount, totalAvailable, matchedOrders, allOrders } = filterResult;

                // Alert 1: Check for anomalies based on learned patterns
                const anomaly = this.patternLearner.detectAnomaly(date, orderCount);
                if (anomaly.isAnomaly) {
                    alerts.push({
                        level: 'warning',
                        type: 'anomaly',
                        message: anomaly.message,
                        details: anomaly
                    });
                }

                // Alert 2: Check if there are orders with similar dates that weren't matched
                const targetDate = new Date(date);
                const nearbyOrders = allOrders.filter(order => {
                    if (matchedOrders.includes(order)) return false;

                    const orderDate = new Date(order.date || order.startDate);
                    const diffDays = Math.abs((orderDate - targetDate) / (1000 * 60 * 60 * 24));
                    return diffDays <= 2; // Within 2 days
                });

                if (nearbyOrders.length > 0) {
                    alerts.push({
                        level: 'info',
                        type: 'nearby_dates',
                        message: `‚ÑπÔ∏è Found ${nearbyOrders.length} order(s) within 2 days of ${date}`,
                        details: {
                            nearbyOrders: nearbyOrders.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                date: o.date || o.startDate
                            }))
                        }
                    });
                }

                // Alert 3: Check for orders with blank/missing dates
                const ordersWithoutDates = allOrders.filter(o =>
                    !o.date && !o.startDate && o.status !== 'Completed'
                );

                if (ordersWithoutDates.length > 0) {
                    alerts.push({
                        level: 'warning',
                        type: 'missing_dates',
                        message: `‚ö†Ô∏è Found ${ordersWithoutDates.length} order(s) without dates`,
                        details: {
                            orders: ordersWithoutDates.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                status: o.status
                            }))
                        }
                    });
                }

                // Alert 4: Check for multiday orders that might be partially matched
                const multidayOrders = allOrders.filter(o =>
                    o.isMultiDay && !matchedOrders.includes(o)
                );

                for (const order of multidayOrders) {
                    if (order.startDate && order.endDate) {
                        const checkDate = new Date(date);
                        const start = new Date(order.startDate);
                        const end = new Date(order.endDate);

                        // Check if date should fall in range but wasn't matched
                        if (checkDate >= start && checkDate <= end) {
                            alerts.push({
                                level: 'error',
                                type: 'missed_multiday',
                                message: `üö® Multi-day order "${order.orderId || order.clientName}" should include ${date} but wasn't matched!`,
                                details: {
                                    orderId: order.orderId,
                                    clientName: order.clientName,
                                    startDate: order.startDate,
                                    endDate: order.endDate
                                }
                            });
                        }
                    }
                }

                return alerts;
            }

            showAlerts(alerts, date) {
                if (alerts.length === 0) return;

                console.group(`üîî Validation Alerts for ${date}`);

                for (const alert of alerts) {
                    const emoji = alert.level === 'error' ? 'üö®' :
                                 alert.level === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                    console.log(`${emoji} [${alert.type}] ${alert.message}`);
                    if (alert.details) {
                        console.log('Details:', alert.details);
                    }
                }

                console.groupEnd();

                // Show toast for critical alerts
                const criticalAlerts = alerts.filter(a => a.level === 'error');
                if (criticalAlerts.length > 0 && window.OMS) {
                    window.OMS.showToast(
                        `${criticalAlerts.length} critical validation issue(s) detected!`,
                        'error'
                    );
                }
            }
        }

        /**
         * FilterRatingSystem - User feedback system for filter algorithm
         * Allows users to rate filtering results and helps system learn from mistakes
         */
        class FilterRatingSystem {
            constructor() {
                this.ratings = this.loadRatings();
                this.currentFilterContext = null;
                this.maxRatings = 500; // Keep last 500 ratings
            }

            loadRatings() {
                try {
                    const saved = localStorage.getItem('oms_filter_ratings');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter ratings:', error);
                    return [];
                }
            }

            saveRatings() {
                try {
                    if (this.ratings.length > this.maxRatings) {
                        this.ratings = this.ratings.slice(-this.maxRatings);
                    }
                    localStorage.setItem('oms_filter_ratings', JSON.stringify(this.ratings));
                } catch (error) {
                    console.warn('Failed to save filter ratings:', error);
                }
            }

            // Store context of current filter operation for rating
            setFilterContext(context) {
                this.currentFilterContext = {
                    timestamp: new Date().toISOString(),
                    date: context.date,
                    normalizedDate: context.normalizedDate,
                    matchedOrders: context.matchedOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    })),
                    totalOrders: context.totalOrders,
                    filterDetails: context.filterDetails,
                    allOrderIds: context.allOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    }))
                };
            }

            // Record user rating with feedback
            recordRating(rating, feedback = {}) {
                if (!this.currentFilterContext) {
                    console.warn('No filter context available for rating');
                    return;
                }

                const ratingEntry = {
                    ...this.currentFilterContext,
                    rating, // 1-5 stars or thumbs up/down
                    feedback: {
                        userComment: feedback.comment || '',
                        incorrectlyIncluded: feedback.incorrectlyIncluded || [], // Order IDs that shouldn't be there
                        incorrectlyExcluded: feedback.incorrectlyExcluded || [], // Order IDs that should be there
                        ratingType: feedback.ratingType || 'numeric', // 'numeric', 'thumbs', 'words'
                        sentimentScore: this.calculateSentiment(rating, feedback),
                        tags: feedback.tags || [] // ['wrong_date', 'missing_orders', 'extra_orders', 'perfect']
                    },
                    ratedAt: new Date().toISOString()
                };

                this.ratings.push(ratingEntry);
                this.saveRatings();

                console.log('‚ú® Rating recorded:', ratingEntry);

                // Learn from this feedback
                this.learnFromRating(ratingEntry);

                return ratingEntry;
            }

            // Calculate sentiment score from rating
            calculateSentiment(rating, feedback) {
                let score = 0;

                // Numeric rating (1-5 stars)
                if (typeof rating === 'number') {
                    score = (rating - 1) / 4; // Normalize to 0-1
                }
                // Thumbs up/down
                else if (rating === 'up') {
                    score = 1;
                } else if (rating === 'down') {
                    score = 0;
                }
                // Word-based rating
                else if (typeof rating === 'string') {
                    const wordScores = {
                        'perfect': 1.0,
                        'excellent': 1.0,
                        'good': 0.75,
                        'okay': 0.5,
                        'bad': 0.25,
                        'terrible': 0
                    };
                    score = wordScores[rating.toLowerCase()] || 0.5;
                }

                // Adjust based on specific feedback
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    score *= 0.5; // Penalty for wrong inclusions
                }
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    score *= 0.5; // Penalty for missing orders
                }

                return score;
            }

            // Learn from user rating
            learnFromRating(ratingEntry) {
                const { date, normalizedDate, feedback, rating } = ratingEntry;

                // Create learning rules based on feedback
                const learningRules = [];

                // Rule 1: Learn from incorrectly included orders
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    feedback.incorrectlyIncluded.forEach(badOrder => {
                        learningRules.push({
                            type: 'exclusion',
                            targetDate: normalizedDate,
                            orderId: badOrder.orderId,
                            reason: 'User marked as incorrectly included',
                            orderDate: badOrder.date || badOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 2: Learn from incorrectly excluded orders
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    feedback.incorrectlyExcluded.forEach(missedOrder => {
                        learningRules.push({
                            type: 'inclusion',
                            targetDate: normalizedDate,
                            orderId: missedOrder.orderId,
                            reason: 'User marked as incorrectly excluded',
                            orderDate: missedOrder.date || missedOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 3: Learn from overall sentiment
                if (feedback.sentimentScore < 0.5) {
                    learningRules.push({
                        type: 'anomaly',
                        targetDate: normalizedDate,
                        reason: 'Low user satisfaction',
                        sentimentScore: feedback.sentimentScore,
                        weight: 0.5
                    });
                }

                // Store learning rules
                if (learningRules.length > 0) {
                    this.storeLearningRules(learningRules);
                }

                console.log('üß† Learned from rating:', learningRules.length, 'new rules');
            }

            // Store learning rules for future use
            storeLearningRules(rules) {
                try {
                    let existingRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    existingRules = [...existingRules, ...rules];

                    // Keep only last 1000 rules
                    if (existingRules.length > 1000) {
                        existingRules = existingRules.slice(-1000);
                    }

                    localStorage.setItem('oms_filter_learning_rules', JSON.stringify(existingRules));
                } catch (error) {
                    console.warn('Failed to store learning rules:', error);
                }
            }

            // Get learning rules for a specific date
            getLearningRules(date) {
                try {
                    const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    return rules.filter(rule => rule.targetDate === date);
                } catch (error) {
                    console.warn('Failed to get learning rules:', error);
                    return [];
                }
            }

            // Apply learning rules to filter results
            applyLearningRules(date, orders, allOrders) {
                const rules = this.getLearningRules(date);
                if (rules.length === 0) return { orders, corrections: [] };

                console.log(`üß† Applying ${rules.length} learning rules for ${date}`);

                const corrections = [];
                let correctedOrders = [...orders];

                // Apply exclusion rules
                const exclusionRules = rules.filter(r => r.type === 'exclusion');
                exclusionRules.forEach(rule => {
                    const idx = correctedOrders.findIndex(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (idx !== -1) {
                        corrections.push({
                            type: 'removed',
                            order: correctedOrders[idx],
                            reason: rule.reason
                        });
                        correctedOrders.splice(idx, 1);
                    }
                });

                // Apply inclusion rules
                const inclusionRules = rules.filter(r => r.type === 'inclusion');
                inclusionRules.forEach(rule => {
                    const order = allOrders.find(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (order && !correctedOrders.find(o => o.orderId === order.orderId)) {
                        corrections.push({
                            type: 'added',
                            order: order,
                            reason: rule.reason
                        });
                        correctedOrders.push(order);
                    }
                });

                if (corrections.length > 0) {
                    console.log(`‚úÖ Applied ${corrections.length} corrections:`, corrections);
                }

                return { orders: correctedOrders, corrections };
            }

            // Show rating UI modal
            showRatingUI(OMS) {
                if (!this.currentFilterContext) return;

                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>‚≠ê Rate Filter Results</h3>
                            <button onclick="this.closest('.modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 20px; color: var(--text-secondary);">
                                Found <strong>${this.currentFilterContext.matchedOrders.length}</strong> orders for
                                <strong>${this.currentFilterContext.date}</strong>
                            </p>

                            <!-- Star Rating -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">How accurate was this filter?</label>
                                <div id="starRating" style="font-size: 36px; cursor: pointer;">
                                    ${[1, 2, 3, 4, 5].map(i => `<span data-rating="${i}" style="color: #ddd;">‚≠ê</span>`).join('')}
                                </div>
                                <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                                    <span id="ratingLabel">Click to rate</span>
                                </div>
                            </div>

                            <!-- Quick Feedback Buttons -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Quick Feedback:</label>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button class="btn btn-sm feedback-tag" data-tag="perfect">‚úÖ Perfect</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="missing_orders">‚ùå Missing Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="extra_orders">‚ûï Extra Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="wrong_date">üìÖ Wrong Date</button>
                                </div>
                            </div>

                            <!-- Matched Orders List -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                    Matched Orders (Click to mark as incorrect):
                                </label>
                                <div id="matchedOrdersList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 10px;">
                                    ${this.currentFilterContext.matchedOrders.map(o => `
                                        <div class="order-item" data-order-id="${o.orderId}" data-doc-id="${o.docId}" style="padding: 8px; margin: 5px 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                            <strong>${o.orderId || o.clientName}</strong>
                                            <span style="color: var(--text-secondary); margin-left: 10px; font-size: 12px;">
                                                ${o.date || o.startDate || 'No date'}
                                            </span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Comment -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Additional Comments (Optional):</label>
                                <textarea id="ratingComment" rows="3" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; resize: vertical;" placeholder="Tell us what went wrong or what was good..."></textarea>
                            </div>

                            <!-- Submit Buttons -->
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Skip</button>
                                <button id="submitRating" class="btn btn-primary">Submit Rating</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Star rating interaction
                let selectedRating = 0;
                const stars = modal.querySelectorAll('#starRating span');
                const ratingLabel = modal.querySelector('#ratingLabel');
                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Excellent'];

                stars.forEach(star => {
                    star.addEventListener('mouseenter', function() {
                        const rating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < rating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[rating - 1];
                    });

                    star.addEventListener('click', function() {
                        selectedRating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[selectedRating - 1] + ' ‚≠ê'.repeat(selectedRating);
                    });
                });

                modal.querySelector('#starRating').addEventListener('mouseleave', function() {
                    stars.forEach((s, i) => {
                        s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                    });
                    ratingLabel.textContent = selectedRating > 0 ? labels[selectedRating - 1] + ' ‚≠ê'.repeat(selectedRating) : 'Click to rate';
                });

                // Feedback tags interaction
                const selectedTags = new Set();
                modal.querySelectorAll('.feedback-tag').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (selectedTags.has(tag)) {
                            selectedTags.delete(tag);
                            this.style.background = '';
                            this.style.color = '';
                        } else {
                            selectedTags.add(tag);
                            this.style.background = 'var(--primary)';
                            this.style.color = 'white';
                        }
                    });
                });

                // Order selection interaction
                const incorrectOrders = new Set();
                modal.querySelectorAll('.order-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const orderId = this.dataset.orderId || this.dataset.docId;
                        if (incorrectOrders.has(orderId)) {
                            incorrectOrders.delete(orderId);
                            this.style.background = 'var(--bg-card)';
                            this.style.border = '1px solid var(--border)';
                        } else {
                            incorrectOrders.add(orderId);
                            this.style.background = '#ffebee';
                            this.style.border = '2px solid #f44336';
                        }
                    });
                });

                // Submit rating
                modal.querySelector('#submitRating').addEventListener('click', () => {
                    if (selectedRating === 0) {
                        OMS.showToast('Please select a rating', 'error');
                        return;
                    }

                    const incorrectlyIncluded = Array.from(incorrectOrders).map(orderId => {
                        return this.currentFilterContext.matchedOrders.find(o =>
                            o.orderId === orderId || o.docId === orderId
                        );
                    }).filter(Boolean);

                    this.recordRating(selectedRating, {
                        comment: modal.querySelector('#ratingComment').value,
                        incorrectlyIncluded,
                        incorrectlyExcluded: [], // Can be enhanced to allow selecting missing orders
                        ratingType: 'numeric',
                        tags: Array.from(selectedTags)
                    });

                    OMS.showToast('‚ú® Thank you! The system has learned from your feedback.', 'success');
                    modal.remove();
                });
            }

            // Get statistics about ratings
            getStats() {
                if (this.ratings.length === 0) {
                    return { avgRating: 0, totalRatings: 0, recentRatings: [] };
                }

                const numericRatings = this.ratings.filter(r => typeof r.rating === 'number');
                const avgRating = numericRatings.length > 0
                    ? numericRatings.reduce((sum, r) => sum + r.rating, 0) / numericRatings.length
                    : 0;

                return {
                    avgRating: avgRating.toFixed(2),
                    totalRatings: this.ratings.length,
                    recentRatings: this.ratings.slice(-10),
                    sentimentTrend: this.ratings.slice(-20).map(r => r.feedback.sentimentScore)
                };
            }

            // Clear all ratings
            clearAllRatings() {
                this.ratings = [];
                this.saveRatings();
                localStorage.removeItem('oms_filter_learning_rules');
                console.log('üóëÔ∏è All ratings and learning rules cleared');
            }
        }

        // Initialize global instances
        const filterLogger = new FilterLogger();
        const patternLearner = new PatternLearner();
        const fuzzyDateMatcher = new FuzzyDateMatcher();
        const orderValidator = new OrderValidator(patternLearner);
        const filterRatingSystem = new FilterRatingSystem();

        // Clean up old logs periodically (keep last 30 days)
        filterLogger.clearOldLogs(30);

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [], deletedItems: [], deletedCategories: [] },
                itemHistory: [],
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                payments: [],
                expenses: [],
                trackingData: [],
                settings: {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["‡§Æ‡§ï‡§∞ ‡§∏‡§Ç‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡§ø", "Makar Sankranti"],
                "2025-01-26": ["‡§ó‡§£‡§§‡§Ç‡§§‡•ç‡§∞ ‡§¶‡§ø‡§µ‡§∏", "Republic Day"],
                "2025-02-13": ["‡§Æ‡§π‡§æ ‡§∂‡§ø‡§µ‡§∞‡§æ‡§§‡•ç‡§∞‡§ø", "Maha Shivratri"],
                "2025-03-13": ["‡§π‡•ã‡§≤‡•Ä", "Holi"],
                "2025-03-14": ["‡§ß‡•Å‡§≤‡•á‡§ü‡•Ä", "Dhuleti"],
                "2025-04-06": ["‡§∞‡§æ‡§Æ ‡§®‡§µ‡§Æ‡•Ä", "Ram Navami"],
                "2025-08-15": ["‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞‡§§‡§æ ‡§¶‡§ø‡§µ‡§∏", "Independence Day"],
                "2025-08-19": ["‡§ú‡§®‡•ç‡§Æ‡§æ‡§∑‡•ç‡§ü‡§Æ‡•Ä", "Janmashtami"],
                "2025-10-02": ["‡§ó‡§æ‡§Ç‡§ß‡•Ä ‡§ú‡§Ø‡§Ç‡§§‡•Ä", "Gandhi Jayanti"],
                "2025-11-01": ["‡§ß‡§®‡§§‡•á‡§∞‡§∏", "Dhanteras"],
                "2025-11-02": ["‡§¶‡•Ä‡§µ‡§æ‡§≤‡•Ä", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('‚ö†Ô∏è Already initialized - skipping duplicate init');
        return;
    }

    console.log('üöÄ Initializing OMS...');
    this.initialized = true;

    // Load user role first
    await this.getCurrentUser();

    await this.loadFromStorage();
    await this.loadTrackingFromFirestore();
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();

    // Apply RBAC to navigation tabs
    await this.applyRBACToNavigation();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
                this.applyLanguage(); // Apply saved language

                // Initialize weather mini dashboard and set up auto-refresh
                this.updateWeatherMiniDashboard();
                setInterval(() => this.updateWeatherMiniDashboard(), 900000); // Refresh every 15 minutes

                // Check for draft order after initialization
                setTimeout(() => this.checkForDraft(), 1000);
            },

            // ============ LANGUAGE SWITCHING ============
            toggleLanguage() {
                const currentLang = this.data.settings.language || 'en';
                const newLang = currentLang === 'en' ? 'gu' : 'en';
                this.data.settings.language = newLang;
                this.saveToStorage();
                this.applyLanguage();
                this.showToast(newLang === 'en' ? 'Language switched to English' : '‡™≠‡™æ‡™∑‡™æ ‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡™æ‡™à ‡™ó‡™à', 'success');
            },

            applyLanguage() {
                const lang = this.data.settings.language || 'en';
                const t = translations[lang];

                // Update language toggle button
                const toggleBtn = document.getElementById('languageToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = lang === 'en' ? 'üåê EN' : 'üåê ‡™ó‡´Å';
                    toggleBtn.title = lang === 'en' ? 'Switch to Gujarati' : '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã';
                }

                // Update header
                const companyName = document.querySelector('.company-name');
                if (companyName) companyName.textContent = t.companyName;

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) searchInput.placeholder = t.searchPlaceholder;

                // Update tabs
                const tabs = document.querySelectorAll('.nav-tab');
                const tabKeys = ['dashboard', 'orders', 'inventory', 'itemHistory', 'preparation', 'customers', 'team', 'calendar', 'history', 'analytics', 'financials', 'settings'];
                tabs.forEach((tab, index) => {
                    if (tabKeys[index] && t[tabKeys[index]]) {
                        tab.textContent = t[tabKeys[index]];
                    }
                });

                // Update Orders tab static labels using data-translate attributes
                this.updateOrdersTabLabels();

                // Update action buttons
                this.updateActionButtons();

                // Re-render current tab to apply translations
                if (this.currentTab) {
                    this.switchTab(this.currentTab);
                }
            },

            updateOrdersTabLabels() {
                // Helper function to update label text
                const updateLabel = (selector, translationKey) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.textContent = this.t(translationKey);
                    });
                };

                // Update form labels by finding them with specific text patterns
                // This will update all label elements in the orders tab
                const labels = {
                    'Client Name': 'clientName',
                    'Contact': 'contact',
                    'Venue': 'venue',
                    'Ready Time': 'readyTime',
                    'Order Status': 'orderStatus',
                    'Notes': 'notes',
                    'Driver Name': 'driverName',
                    'Operator': 'operator',
                    'Helper(s)': 'helpers',
                    'Transport': 'transport'
                };

                document.querySelectorAll('.form-label').forEach(label => {
                    const text = label.textContent.trim();
                    Object.keys(labels).forEach(key => {
                        if (text.includes(key)) {
                            const translatedText = this.t(labels[key]);
                            label.textContent = label.textContent.replace(key, translatedText);
                        }
                    });
                });

                // Update helper placeholder
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.placeholder = this.t('helperPlaceholder');
                }

                // Update client name placeholder
                const clientInput = document.getElementById('clientName');
                if (clientInput) {
                    clientInput.placeholder = this.t('enterClientName');
                }
            },

            updateActionButtons() {
                // Update button texts by finding buttons with specific onclick handlers
                const updateButton = (selector, translationKey) => {
                    const btn = document.querySelector(selector);
                    if (btn) btn.textContent = this.t(translationKey);
                };

                // Update form action buttons
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    const text = btn.textContent.trim();
                    if (text.includes('Save Order')) btn.textContent = this.t('saveOrderShortcut');
                    else if (text.includes('Duplicate Last')) btn.textContent = this.t('duplicateLast');
                    else if (text.includes('Same Day')) btn.textContent = this.t('sameDay');
                    else if (text.includes('Clear') && text.includes('Ctrl')) btn.textContent = this.t('clearFormShortcut');
                    else if (text.includes('Preview')) btn.textContent = `üëÅÔ∏è ${this.t('preview')}`;
                    else if (text.includes('Notify')) btn.textContent = this.t('notifyTeam');
                    else if (text.includes('Send Manager')) btn.textContent = this.t('sendReport');
                });
            },

            // Helper function to get translations
            t(key) {
                const lang = this.data.settings.language || 'en';
                return translations[lang][key] || translations.en[key] || key;
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    // FIXED: Get all data attributes from the same element to avoid mismatched selections
                    const actionElement = e.target.closest('[data-action]');
                    if (!actionElement) return;

                    const action = actionElement.dataset.action;
                    const id = actionElement.dataset.id;
                    const type = actionElement.dataset.type;

                    // Log only relevant data for each action type
                    const actionsNeedingIdType = ['edit', 'delete', 'print', 'quickAction'];
                    if (actionsNeedingIdType.includes(action)) {
                        console.log('üñ±Ô∏è Button clicked - Action:', action, 'ID:', id, 'Type:', type);
                    } else {
                        console.log('üñ±Ô∏è Button clicked - Action:', action);
                    }

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;

        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            container.innerHTML = '';
            return;
        }

        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">${this.t('dayNumber')} ${i + 1} - ${dateStr}</h4>

                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>

                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ${this.t('addFunctionToThisDay')}
                    </button>
                </div>
            `;
        }

        container.innerHTML = html;

        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;

        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }

        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;

        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            venue: '',
            transport: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });

        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">${this.t('functionNumber')} ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">${this.t('removeFunction')}</button>` : ''}
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('functionType')}</label>
                        <input type="text" id="${functionId}Type" class="form-input"
                               placeholder="${this.t('enterFunctionType')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('timeSlot')}</label>
                        <input type="text" id="${functionId}Time" class="form-input highlight-datetime"
                               placeholder="${this.t('enterTimeSlot')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('venue')}</label>
                        <input type="text" id="${functionId}Venue" class="form-input"
                               placeholder="Enter venue address"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'venue', this.value)">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Transport (Multiple)</label>
                        <select id="${functionId}Transport" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'transport', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                            <option value="New Bolero">New Bolero</option>
                            <option value="Old Bolero">Old Bolero</option>
                            <option value="Isuzu">Isuzu</option>
                            <option value="Porter">Porter</option>
                            <option value="Other">Other</option>
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple transports</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('driver')} (Multiple)</label>
                        <select id="${functionId}Driver" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple drivers</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('operator')}</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">${this.t('selectOperator')}</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('helpers')}</label>
                        <input type="text" id="${functionId}Helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)"
                               oninput="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value.trim())">
                        <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('notes')}</label>
                    <textarea id="${functionId}Notes" class="form-textarea"
                              placeholder="${this.t('functionNotes')}"
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('items')}</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input"
                               placeholder="${this.t('searchItems')}" autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">${this.t('noItemsAdded')}</div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); this.saveOrder(); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); this.clearForm(); },
                            'd': () => { e.preventDefault(); this.clearForm(); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.add('show');
                backdrop.classList.add('show');

                // Add Escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideShortcuts();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                panel._escapeHandler = escapeHandler;
            },

            hideShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.remove('show');
                backdrop.classList.remove('show');

                // Remove escape handler
                if (panel._escapeHandler) {
                    document.removeEventListener('keydown', panel._escapeHandler);
                    panel._escapeHandler = null;
                }
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    const form = document.getElementById('orderForm');
                    if (form && this.hasUnsavedChanges()) {
                        localStorage.setItem('oms_draft', JSON.stringify(this.collectFormData()));
                        console.log('üìù Draft auto-saved');
                    }
                }, 2000); // Auto-save every 2 seconds
            },

            hasUnsavedChanges() {
                return Utils.get('clientName') || this.currentOrderItems.length > 0;
            },

            checkForDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        // Only show restore option if draft has meaningful data
                        if (draftData.clientName || (draftData.items && draftData.items.length > 0)) {
                            const draftDate = new Date(draftData.createdAt || Date.now()).toLocaleString();
                            const message = `
                                <div style="text-align: left;">
                                    <h3 style="margin-top: 0;">üìã Draft Order Found</h3>
                                    <p>You have an unsaved draft from: <strong>${draftDate}</strong></p>
                                    <p><strong>Client:</strong> ${draftData.clientName || 'Not specified'}</p>
                                    <p><strong>Items:</strong> ${draftData.items?.length || 0} items</p>
                                    <p>Would you like to restore this draft?</p>
                                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                                        <button class="btn btn-success" onclick="OMS.restoreDraft(); OMS.closeModal('draftModal');">‚úÖ Restore Draft</button>
                                        <button class="btn btn-danger" onclick="OMS.discardDraft(); OMS.closeModal('draftModal');">üóëÔ∏è Discard Draft</button>
                                        <button class="btn btn-secondary" onclick="OMS.closeModal('draftModal');">‚è≠Ô∏è Ignore for Now</button>
                                    </div>
                                </div>
                            `;

                            // Show modal with draft info
                            const modalHTML = `
                                <div class="modal-overlay" id="draftModal">
                                    <div class="modal-content" style="max-width: 500px;">
                                        ${message}
                                    </div>
                                </div>
                            `;
                            document.body.insertAdjacentHTML('beforeend', modalHTML);
                        }
                    } catch (error) {
                        console.error('Error checking draft:', error);
                    }
                }
            },

            restoreDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        console.log('üìã Restoring draft:', draftData);

                        // Switch to orders tab
                        this.switchTab('orders');

                        // Wait for tab to be visible
                        setTimeout(() => {
                            // Populate form fields
                            if (draftData.clientName) Utils.set('clientName', draftData.clientName);
                            if (draftData.contact) Utils.set('contact', draftData.contact);
                            if (draftData.venue) Utils.set('venue', draftData.venue);
                            if (draftData.eventType) Utils.set('eventType', draftData.eventType);
                            if (draftData.date) Utils.set('orderDate', draftData.date);
                            if (draftData.readyTime) Utils.set('readyTime', draftData.readyTime);
                            if (draftData.transport) Utils.set('transport', draftData.transport);
                            if (draftData.driverName) Utils.set('driverName', draftData.driverName);
                            if (draftData.operator) Utils.set('operator', draftData.operator);
                            if (draftData.status) Utils.set('orderStatus', draftData.status);
                            if (draftData.notes) Utils.set('notes', draftData.notes);

                            // Restore multiday data if exists
                            if (draftData.isMultiDay) {
                                Utils.set('eventTypeSelect', 'multi');
                                if (draftData.startDate) Utils.set('startDate', draftData.startDate);
                                if (draftData.endDate) Utils.set('endDate', draftData.endDate);

                                // Trigger multiday form generation
                                const event = new Event('change');
                                document.getElementById('eventTypeSelect')?.dispatchEvent(event);

                                // Restore day-wise data after form is generated
                                if (draftData.dayWiseData) {
                                    setTimeout(() => {
                                        window.dayFunctionsData = draftData.dayWiseData;
                                        console.log('üìÖ Restored multiday data with items');
                                    }, 500);
                                }
                            } else {
                                // Restore items for single-day events only
                                if (draftData.items && Array.isArray(draftData.items) && draftData.items.length > 0) {
                                    console.log('üì¶ Restoring items:', draftData.items);
                                    this.currentOrderItems = [...draftData.items];
                                    this.updateOrderItemsList();
                                }
                            }

                            this.showToast('‚úÖ Draft restored successfully!', 'success');
                        }, 100);

                    } catch (error) {
                        console.error('Error restoring draft:', error);
                        this.showToast('‚ùå Error restoring draft', 'error');
                    }
                }
            },

            discardDraft() {
                localStorage.removeItem('oms_draft');
                this.showToast('üóëÔ∏è Draft discarded', 'info');
                console.log('üóëÔ∏è Draft discarded by user');
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('‚úÖ Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('‚úÖ Auto-backup created successfully');
                    this.showToast('üì¶ Auto-backup created', 'success');
                } catch (error) {
                    console.error('‚ùå Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('üì• Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            initGlobalSearch() {
                const input = document.getElementById('globalSearch');
                const results = document.getElementById('globalSearchResults');

                input.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    if (query.length < 2) {
                        results.classList.remove('show');
                        return;
                    }

                    const searchResults = this.performGlobalSearch(query);
                    this.displayGlobalSearchResults(searchResults);
                }, 300));

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        results.classList.remove('show');
                        input.value = '';
                    }
                });
            },

            performGlobalSearch(query) {
                const results = [];

                // Search orders
                this.data.orders.forEach(order => {
                    if (order.orderId.toLowerCase().includes(query) ||
                        order.clientName.toLowerCase().includes(query) ||
                        order.venue.toLowerCase().includes(query)) {
                        results.push({ type: 'order', data: order });
                    }
                });

                // Search customers
                this.data.customers.forEach(customer => {
                    if (customer.name.toLowerCase().includes(query) ||
                        customer.contact.includes(query)) {
                        results.push({ type: 'customer', data: customer });
                    }
                });

                // Search inventory
                this.data.inventory.items.forEach(item => {
                    if (item.name.toLowerCase().includes(query)) {
                        results.push({ type: 'item', data: item });
                    }
                });

                return results.slice(0, 10);
            },

            displayGlobalSearchResults(results) {
                const container = document.getElementById('globalSearchResults');
                if (results.length === 0) {
                    container.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    container.innerHTML = results.map(r => `
                        <div class="search-result-item" onclick="OMS.navigateToResult('${r.type}', '${r.data.id || r.data.orderId}')">
                            <div>
                                <div class="search-result-type">${r.type}</div>
                                <div>${r.type === 'order' ? r.data.orderId + ' - ' + r.data.clientName : 
                                       r.type === 'customer' ? r.data.name : r.data.name}</div>
                            </div>
                        </div>
                    `).join('');
                }
                container.classList.add('show');
            },

            navigateToResult(type, id) {
                const tabMap = { order: 'history', customer: 'customers', item: 'inventory' };
                this.switchTab(tabMap[type]);
                document.getElementById('globalSearchResults').classList.remove('show');
                document.getElementById('globalSearch').value = '';
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('üî• Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`üî• Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('üß© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    // FIXED: Search by docId first (always unique), then orderId as fallback
    const index = this.data.orders.findIndex(o => o.docId === id || o.orderId === id);
    if (index === -1) {
        console.warn('‚ö†Ô∏è Order not found in local array:', id);
        return false;
    }

    try {
        console.log('üîÑ Attempting to delete orderId:', id);

        // Use the actual docId from the found order
        const orderToDelete = this.data.orders[index];
        const docRef = db.collection('orders').doc(orderToDelete.docId || id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('‚úÖ Deleted Firestore doc with ID:', id);
        } else {
            console.warn('‚ö†Ô∏è No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`üìù Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('‚ùå Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                // Track deleted category to prevent re-addition
                if (!this.data.inventory.deletedCategories) {
                    this.data.inventory.deletedCategories = [];
                }
                if (!this.data.inventory.deletedCategories.includes(id)) {
                    this.data.inventory.deletedCategories.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                // Track deleted item to prevent re-addition
                if (!this.data.inventory.deletedItems) {
                    this.data.inventory.deletedItems = [];
                }
                if (!this.data.inventory.deletedItems.includes(id)) {
                    this.data.inventory.deletedItems.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();
        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        console.log('üîç EditItem called with ID:', id);
                        console.log('üìã All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                        // FIXED: Search by docId first (always unique), then orderId as fallback
                        const order = this.data.orders.find(o => o.docId === id || o.orderId === id);
                        console.log('‚úÖ Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                        if (!order) return;
                        this.switchTab('orders');
                        this.loadOrderToForm(order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
},

            async updateWeatherMiniDashboard() {
                try {
                    const city = this.data.settings.city || 'Delhi';
                    const apiKey = this.data.settings.weatherApiKey || '';
                    const weather = await Utils.getWeather(city, apiKey);

                    const iconElement = document.querySelector('.weather-mini-icon');
                    const tempElement = document.querySelector('.weather-mini-temp');
                    const conditionElement = document.querySelector('.weather-mini-condition');

                    if (iconElement && tempElement && conditionElement) {
                        iconElement.textContent = Utils.getWeatherEmoji(weather.condition);
                        tempElement.textContent = weather.temp !== 'N/A' ? `${weather.temp}¬∞C` : '--¬∞C';
                        conditionElement.textContent = weather.condition !== 'N/A' ? weather.condition : 'Loading...';
                    }
                } catch (error) {
                    console.error('Error updating weather mini dashboard:', error);
                }
            },

            getNextOrderId() {
                const prefix = this.data.settings.invoicePrefix || 'FP';
                const counter = this.data.settings.orderIdCounter || 1;
                return `${prefix}${String(counter).padStart(3, '0')}`;
            },

            incrementOrderCounter() {
                this.data.settings.orderIdCounter = (this.data.settings.orderIdCounter || 1) + 1;
                this.refreshOrderId();
            },

   collectFormData() {

        const transport = Utils.get('transport');
        const eventType = Utils.get('eventTypeSelect');
        const isMultiDay = eventType === 'multi';

        // Get helper names from text input
        const helperInput = document.getElementById('helper');
        const selectedHelpers = helperInput ? helperInput.value.trim() : '';

        // Collect day-wise data for multi-day events
        let dayWiseData = [];
        if (isMultiDay) {
            const startDate = Utils.get('startDate');
            const endDate = Utils.get('endDate');
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

            for (let i = 0; i < diffDays; i++) {
                const currentDate = new Date(start);
                currentDate.setDate(start.getDate() + i);

                // Get functions for this day
                const dayFunctions = window.dayFunctionsData?.[i] || [];

                dayWiseData.push({
                    dayNumber: i + 1,
                    date: Utils.toDateString(currentDate),
                    functions: dayFunctions.map(func => ({
                        functionType: func.functionType || '',
                        timeSlot: func.timeSlot || '',
                        driver: func.driver || '',
                        operator: func.operator || '',
                        helper: func.helper || '',
                        notes: func.notes || '',
                        items: func.items || []
                    }))
                });
            }
        }

        const transport2 = Utils.get('transport2');
        return {
            orderId: Utils.get('orderId'),
            isMultiDay: isMultiDay,
            date: isMultiDay ? null : Utils.get('orderDate'),
            startDate: isMultiDay ? Utils.get('startDate') : null,
            endDate: isMultiDay ? Utils.get('endDate') : null,
            dayWiseData: dayWiseData,
            lastEventDate: isMultiDay ? Utils.get('endDate') : Utils.get('orderDate'),
            readyTime: Utils.get('readyTime'),
            clientName: Utils.get('clientName'),
            contact: Utils.get('contact'),
            venue: Utils.get('venue'),
            eventType: Utils.get('eventType'),
            transport: transport === 'Other' ? Utils.get('customTransport') : transport,
            driverName: Utils.get('driverName'),
            transport2: transport2 === 'Other' ? Utils.get('customTransport2') : transport2,
            driverName2: Utils.get('driverName2'),
            operator: Utils.get('operator'),
            helper: selectedHelpers,
            status: Utils.get('orderStatus'),
            notes: Utils.get('orderNotes'),
            items: isMultiDay ? [] : [...this.currentOrderItems],
            createdAt: new Date().toISOString()
        };
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate', 'readyTime');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('‚úÖ Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('‚ö†Ô∏è Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('‚è≥ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('üíæ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('‚úèÔ∏è Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('‚úèÔ∏è Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Calculate total amount from items
        const totalAmount = orderData.isMultiDay
            ? (orderData.dayWiseData || []).reduce((sum, day) => {
                const dayTotal = (day.functions || []).reduce((daySum, func) => {
                    const funcTotal = (func.items || []).reduce((itemSum, item) => {
                        return itemSum + ((item.price || 0) * (item.quantity || 0));
                    }, 0);
                    return daySum + funcTotal;
                }, 0);
                return sum + dayTotal;
            }, 0)
            : (orderData.items || []).reduce((sum, item) => {
                return sum + ((item.price || 0) * (item.quantity || 0));
            }, 0);

        console.log('üí∞ Calculated total amount:', totalAmount);

        // Fetch weather data for the order
        let weatherData = null;
        try {
            // Get weather API key from settings (if stored) or use default
            const weatherApiKey = this.data.settings?.weatherApiKey || '';
            const defaultCity = this.data.settings?.defaultCity || 'Delhi';

            // Fetch weather data
            weatherData = await Utils.getWeather(defaultCity, weatherApiKey);
            console.log('üå§Ô∏è Weather data fetched:', weatherData);
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not fetch weather data:', error);
        }

        // Add weather data to orderData
        orderData.weather = weatherData;

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    totalAmount: totalAmount,  // CRITICAL: Add totalAmount field
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    transport2: orderData.transport2 || '',
    driverName2: orderData.driverName2 || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    weather: weatherData,  // Add weather data
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('‚úèÔ∏è Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('üîÑ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('üóëÔ∏è Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('‚úÖ Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} ‚Üí ${finalOrderId} ‚úÖ`);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('‚úÖ Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            totalAmount: totalAmount  // Include totalAmount in local data
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        // ITEM HISTORY TRACKING (if order is now completed)
        if (status === 'completed') {
            if (orderData.items && orderData.items.length > 0) {
                this.recordItemHistory(orderData.items, orderData);
            }

            // For multi-day orders, track items from dayWiseData
            if (orderData.isMultiDay && orderData.dayWiseData) {
                orderData.dayWiseData.forEach(day => {
                    day.functions.forEach(func => {
                        if (func.items && func.items.length > 0) {
                            this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                        }
                    });
                });
            }
        }

        this.showToast('Order updated! ‚úèÔ∏è');
    }

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;
    
} else {
            // CREATE new order
            console.log('üÜï Creating new order');

            // Save to Firestore
            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('üìù Auto-generated docId:', docRef.id);
            }

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
    console.log('‚úÖ Order added to local array with totalAmount:', totalAmount);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION & ITEM HISTORY TRACKING (if order is completed)
                if (status === 'completed') {
                    if (orderData.items && orderData.items.length > 0) {
                        this.deductInventory(orderData.items, orderData.orderId);
                        this.recordItemHistory(orderData.items, orderData);
                    }

                    // For multi-day orders, track items from dayWiseData
                    if (orderData.isMultiDay && orderData.dayWiseData) {
                        orderData.dayWiseData.forEach(day => {
                            day.functions.forEach(func => {
                                if (func.items && func.items.length > 0) {
                                    this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                                }
                            });
                        });
                    }
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! üÜï`);
                this.refreshOrderId();
                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('‚ùå Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`üì¶ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} ‚Üí ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`‚ö†Ô∏è LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`üö® CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Item Usage History Tracking (for completed orders only)
async recordItemHistory(items, orderData, specificDate = null, functionType = null) {
    if (!items || items.length === 0) return;

    console.log(`üìú Recording item history for order ${orderData.orderId}`);

    const usedAt = new Date().toISOString();
    const eventDate = specificDate || orderData.date || orderData.startDate;

    for (const item of items) {
        const historyRecord = {
            itemName: item.name,
            quantity: item.quantity,
            orderId: orderData.orderId,
            clientName: orderData.clientName,
            venue: orderData.venue,
            eventDate: eventDate,
            functionType: functionType || orderData.eventType || '',
            usedAt: usedAt,
            remarks: item.remarks || ''
        };

        // Add to local array
        this.data.itemHistory.push(historyRecord);

        // Save to Firestore
        try {
            await db.collection('itemHistory').add(historyRecord);
            console.log(`‚úÖ Saved item history: ${item.name} x${item.quantity} for order ${orderData.orderId}`);
        } catch (error) {
            console.error('‚ùå Error saving item history to Firestore:', error);
        }
    }

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`üìù Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
async getCurrentUser() {
    // If already loaded, return cached user
    if (this.data.currentUser && this.data.currentUser.roleLoaded) {
        return this.data.currentUser;
    }

    // Get Firebase Auth user
    const authUser = auth.currentUser;
    if (!authUser) {
        console.warn('‚ö†Ô∏è No authenticated user found');
        return null;
    }

    try {
        // Fetch user role from Firestore
        const userRoleDoc = await db.collection('user_roles').doc(authUser.uid).get();

        let role = 'staff'; // Default role
        let email = authUser.email;
        let name = authUser.displayName || authUser.email;

        if (userRoleDoc.exists) {
            const roleData = userRoleDoc.data();
            role = roleData.role || 'staff';
            name = roleData.name || name;
            console.log('‚úÖ User role loaded from Firestore:', role, 'for', email);
        } else {
            // If no role exists, user defaults to 'staff' with limited access
            // Only admin/owner can create roles in Firestore via admin panel
            console.warn('‚ö†Ô∏è No role document found for:', email);
            console.warn('‚ö†Ô∏è User defaulted to "staff" role with limited access.');
            console.warn('‚ö†Ô∏è Admin must create role in Firestore: user_roles/' + authUser.uid);
        }

        this.data.currentUser = {
            id: authUser.uid,
            email: email,
            name: name,
            role: role,
            roleLoaded: true,
            permissions: this.getRolePermissions(role)
        };

        return this.data.currentUser;
    } catch (error) {
        console.error('‚ùå Error loading user role:', error);
        console.error('Full error:', error);
        // Fallback to staff role if error occurs
        this.data.currentUser = {
            id: authUser.uid,
            email: authUser.email,
            name: authUser.displayName || authUser.email,
            role: 'staff',
            roleLoaded: true,
            permissions: this.getRolePermissions('staff')
        };
        return this.data.currentUser;
    }
},

// Force refresh user role from Firestore (bypasses cache)
async refreshUserRole() {
    console.log('üîÑ Force refreshing user role from Firestore...');
    this.data.currentUser = null; // Clear cache
    const user = await this.getCurrentUser();
    console.log('‚úÖ User role refreshed:', user?.role);
    return user;
},

// Get permissions for a role
getRolePermissions(role) {
    const permissions = {
        admin: ['all'],
        owner: ['all'],
        staff: ['orders.view', 'orders.create', 'inventory.view', 'customers.view', 'team.view']
    };
    return permissions[role] || permissions.staff;
},

// Check if current user has permission
async hasPermission(permission) {
    const user = await this.getCurrentUser();
    if (!user) return false;

    // Admin and owner have all permissions
    if (user.role === 'admin' || user.role === 'owner') {
        return true;
    }

    // Check specific permission
    return user.permissions.includes(permission) || user.permissions.includes('all');
},

// Check if user can view financials
async canViewFinancials() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

// Check if user is admin or owner
async isAdminOrOwner() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Clear the form first to prevent data mixing between orders
        const wasCleared = !this.hasUnsavedChanges();
        if (!wasCleared) {
            // Clear without confirmation since we're loading a different order
            document.getElementById('orderForm').reset();
            this.currentOrderItems = [];
            this.updateOrderItemsTable();
            window.dayFunctionsData = {};

            // Clear multiday containers
            const multiDayContainer = document.getElementById('multiDayContainer');
            if (multiDayContainer) multiDayContainer.innerHTML = '';
            const functionsContainer = document.getElementById('functionsContainer');
            if (functionsContainer) functionsContainer.innerHTML = '';
        }

        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('üîç Loading order to form:', order);
        console.log('üîç Order status:', order.status);
        console.log('üîç Is Multi-Day:', order.isMultiDay);

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('üìÖ Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const venueInput = document.getElementById(`${functionId}Venue`);
                                        const transportSelect = document.getElementById(`${functionId}Transport`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (venueInput) venueInput.value = func.venue || '';

                                        // Handle multi-select fields (transport, driver, helper)
                                        if (transportSelect && func.transport) {
                                            const transports = func.transport.split(',').map(t => t.trim());
                                            Array.from(transportSelect.options).forEach(option => {
                                                option.selected = transports.includes(option.value);
                                            });
                                        }

                                        if (driverSelect && func.driver) {
                                            const drivers = func.driver.split(',').map(d => d.trim());
                                            Array.from(driverSelect.options).forEach(option => {
                                                option.selected = drivers.includes(option.value);
                                            });
                                        }

                                        if (operatorSelect) operatorSelect.value = func.operator || '';

                                        if (helperSelect && func.helper) {
                                            helperSelect.value = func.helper;
                                        }

                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'venue', func.venue || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'transport', func.transport || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            window.dayFunctionsData[dayIndex][funcIndex].items = [...func.items];
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('‚úÖ Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order
            // IMPORTANT: Set event type to single day first to ensure proper form display
            Utils.set('eventTypeSelect', 'single');

            // Show single day fields, hide multiday fields
            const singleDayFields = document.getElementById('singleDayFields');
            const multiDayFields = document.getElementById('multiDayFields');
            if (singleDayFields) singleDayFields.style.display = 'grid';
            if (multiDayFields) multiDayFields.style.display = 'none';

            // Trigger event type change to update required fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                transport2: order.transport2 && ['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : (order.transport2 ? 'Other' : ''),
                customTransport2: order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : '',
                driverName2: order.driverName2 || '',
                operator: order.operator,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Load helper names to text input
            if (order.helper) {
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.value = order.helper;
                }
            }

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            if (order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2)) {
                document.getElementById('customTransport2Group').classList.remove('hidden');
            }

            this.currentOrderItems = order.items ? [...order.items] : [];
            this.updateOrderItemsTable();
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            clearForm() {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');
                document.getElementById('customTransport2Group').classList.add('hidden');

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'grid';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Trigger event type change to update required fields
                const eventTypeSelect = document.getElementById('eventTypeSelect');
                if (eventTypeSelect) {
                    const event = new Event('change');
                    eventTypeSelect.dispatchEvent(event);
                }

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                // Clear functions container for multiday events
                const functionsContainer = document.getElementById('functionsContainer');
                if (functionsContainer) {
                    functionsContainer.innerHTML = '';
                }

                // Hide day-wise functions section
                const dayWiseFunctions = document.getElementById('dayWiseFunctions');
                if (dayWiseFunctions) {
                    dayWiseFunctions.style.display = 'none';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`‚úÖ Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                this.loadOrderToForm(lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                // Preview doesn't require validation - just show what's been filled
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }

                // ============ START ENHANCED FILTERING WITH LOGGING & VALIDATION ============
                const startTime = performance.now();

                // Normalize the target date using fuzzy matcher
                const normalizedDate = fuzzyDateMatcher.normalize(date);
                filterLogger.log('filter_started', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                // IMPROVED FILTER: Include ALL order types for selected date with fuzzy matching
                const matchedOrders = [];
                const filterDetails = {
                    singleDayMatches: 0,
                    multiDayRangeMatches: 0,
                    dayWiseDataMatches: 0,
                    fuzzyMatches: 0,
                    skipped: 0
                };

                let orders = this.data.orders.filter(o => {
                    // Case 1: Single-day order with matching date (use fuzzy matcher)
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            filterDetails.singleDayMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    // Case 2: Multi-day order WITH dayWiseData - check specific day functions (PRIORITY)
                    if (o.isMultiDay && o.dayWiseData && Array.isArray(o.dayWiseData) && o.dayWiseData.length > 0) {
                        const hasMatch = o.dayWiseData.some(day => fuzzyDateMatcher.matches(day.date, date));
                        if (hasMatch) {
                            filterDetails.dayWiseDataMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                        // If order has dayWiseData but no match, skip it (don't fall through to range check)
                        filterDetails.skipped++;
                        return false;
                    }

                    // Case 3: Multi-day order WITHOUT dayWiseData - fallback to range check
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            filterDetails.multiDayRangeMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    filterDetails.skipped++;
                    return false;
                });

                // Calculate performance metrics
                const endTime = performance.now();
                const filterTime = (endTime - startTime).toFixed(2);

                // Log detailed filter results
                filterLogger.log('filter_completed', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    matchedCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    filterTimeMs: filterTime,
                    breakdown: filterDetails,
                    matchedOrderIds: orders.map(o => o.orderId || o.docId)
                });

                // Record pattern for learning
                patternLearner.recordFilterResult(
                    normalizedDate,
                    orders.length,
                    this.data.orders.length,
                    'downloadSameDayOrders'
                );

                // APPLY LEARNING RULES FROM PREVIOUS USER FEEDBACK (if enabled)
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false'; // Default: enabled for backward compatibility
                let finalOrders = orders;
                let hasCorrections = false;

                if (mlEnabled) {
                    const learningResult = filterRatingSystem.applyLearningRules(
                        normalizedDate,
                        orders,
                        this.data.orders
                    );

                    finalOrders = learningResult.orders;
                    hasCorrections = learningResult.corrections.length > 0;

                    if (hasCorrections) {
                        console.log(`üß† Smart Learning Applied: ${learningResult.corrections.length} corrections made based on your previous feedback`);
                        learningResult.corrections.forEach(correction => {
                            if (correction.type === 'added') {
                                console.log(`  ‚úÖ Added: ${correction.order.orderId} - ${correction.reason}`);
                            } else if (correction.type === 'removed') {
                                console.log(`  ‚ùå Removed: ${correction.order.orderId} - ${correction.reason}`);
                            }
                        });
                        this.showToast(`üß† Smart filter applied ${learningResult.corrections.length} learned corrections`, 'info');
                    }
                } else {
                    console.log('üîá ML Corrections DISABLED - Using original filter results only');
                    console.log('üí° To enable: AdminUtils.enableML() or localStorage.setItem("oms_ml_enabled", "true")');
                }

                // STORE FILTER CONTEXT FOR RATING
                filterRatingSystem.setFilterContext({
                    date,
                    normalizedDate,
                    matchedOrders: finalOrders,
                    totalOrders: this.data.orders.length,
                    filterDetails,
                    allOrders: this.data.orders
                });

                // Validate results and show alerts
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: finalOrders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders: finalOrders,
                    allOrders: this.data.orders
                });
                orderValidator.showAlerts(validationResult, date);

                // Show enhanced console summary
                console.group(`üìä Filter Summary for ${date}`);
                console.log(`‚úÖ Matched: ${finalOrders.length} orders in ${filterTime}ms`);
                if (hasCorrections) {
                    console.log(`üß† Corrections: ${learningResult.corrections.length} (from your previous ratings)`);
                }
                console.log(`üìã Breakdown:`, filterDetails);
                console.log(`üéØ Match rate: ${((finalOrders.length / this.data.orders.length) * 100).toFixed(1)}%`);

                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`üß† Expected based on learning: ~${expectedCount} orders`);
                }

                if (validationResult.length > 0) {
                    console.log(`‚ö†Ô∏è Validation alerts: ${validationResult.length}`);
                }

                // Show rating option in console
                console.log(`‚≠ê To rate this filter result, use: AdminUtils.rateLastFilter()`);
                console.groupEnd();
                // ============ END ENHANCED FILTERING ============

                if (finalOrders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    // Still show rating UI for zero results (user can report this as wrong)
                    setTimeout(() => {
                        if (confirm('No orders found. Would you like to rate this filter result?')) {
                            filterRatingSystem.showRatingUI(this);
                        }
                    }, 500);
                    return;
                }

                // Replace orders with finalOrders for rest of the function
                orders = finalOrders;

                // FILTER MULTIDAY ORDERS TO ONLY INCLUDE SELECTED DATE'S DATA
                const filteredOrders = orders.map(order => {
                    // For single-day orders, return as is
                    if (!order.isMultiDay) {
                        return order;
                    }

                    // For multiday orders, create a filtered copy with only the selected date's data
                    const filteredOrder = { ...order };

                    // Filter dayWiseData to only include the selected date (use fuzzy matcher for better matching)
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        filteredOrder.dayWiseData = order.dayWiseData.filter(day => fuzzyDateMatcher.matches(day.date, date));
                        console.log(`üîç Multiday order ${order.orderId}: Filtered ${filteredOrder.dayWiseData.length}/${order.dayWiseData.length} days for date ${date}`);

                        // Log function and item counts for debugging
                        filteredOrder.dayWiseData.forEach((day, idx) => {
                            const funcCount = day.functions ? day.functions.length : 0;
                            const itemCount = day.functions ? day.functions.reduce((sum, f) => sum + (f.items?.length || 0), 0) : 0;
                            console.log(`  üìã Day ${day.dayNumber}: ${funcCount} functions, ${itemCount} total items`);
                        });
                    }

                    // Update the order to show only selected date info
                    filteredOrder.date = date;
                    filteredOrder.isMultiDay = false; // Treat as single day for display purposes

                    return filteredOrder;
                });

                console.log(`üìÖ Found ${filteredOrders.length} orders for ${date}:`, filteredOrders.map(o => o.orderId || o.clientName));
                console.log(`üí° To rate this filter result, use: AdminUtils.rateLastFilter() in console`);

                this.generateMultiOrderImage(filteredOrders, date);
            },

            downloadOrderImage(orderId) {
                // Search by docId first (always unique), then orderId as fallback
                const order = this.data.orders.find(o => o.docId === orderId || o.orderId === orderId);
                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }
                this.generateSingleOrderImage(order);
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? 'Generating image (mobile mode)...' : 'Generating image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Mobile optimization: Validate canvas dimensions before proceeding
                    const baseScale = this.data.settings.imageQuality || 2;
                    const optimizedScale = Utils.getOptimalCanvasScale(baseScale);

                    const canvasWidth = Math.round(paperDimensions.width * optimizedScale);
                    const canvasHeight = Math.round(paperDimensions.height * optimizedScale);

                    const validation = Utils.validateCanvasDimensions(canvasWidth, canvasHeight);
                    if (!validation.valid) {
                        this.hideLoading(loading);
                        this.showToast(`‚ö†Ô∏è ${validation.reason}. Please reduce image quality in settings.`, 'error');
                        console.error('Canvas validation failed:', validation.reason);
                        return;
                    }

                    if (isMobile && optimizedScale < baseScale) {
                        console.log(`üì± Mobile device detected (${deviceType}): Quality auto-reduced from ${baseScale} to ${optimizedScale} for better compatibility`);
                    }

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    template.innerHTML = this.buildOrderHTML(order, fontSize, colors, false, bgColor, textColor);
                    template.style.display = 'block';

                    // Increased wait time for mobile devices (they need more time for DOM to settle)
                    await new Promise(r => setTimeout(r, isMobile ? 500 : 300));

                    // Create canvas with optimized scale
                    let canvas;
                    try {
                        canvas = await html2canvas(template, {
                            scale: optimizedScale,
                            backgroundColor: bgColor,
                            width: paperDimensions.width,
                            logging: false,
                            useCORS: true,
                            allowTaint: false,
                            // Mobile-specific optimizations
                            removeContainer: true,
                            imageTimeout: isMobile ? 30000 : 15000
                        });
                    } catch (canvasError) {
                        console.error('html2canvas failed:', canvasError);

                        // Retry with even lower quality for mobile
                        if (isMobile && optimizedScale > 1) {
                            console.log('‚ö†Ô∏è Retrying with scale 1 for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Retrying with lower quality...');

                            canvas = await html2canvas(template, {
                                scale: 1,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: 30000
                            });
                        } else {
                            throw canvasError;
                        }
                    }

                    template.style.display = 'none';

                    // Use Promise-based blob creation with better error handling
                    this.updateLoadingMessage(loading, 'Creating download file...');

                    let blob;
                    try {
                        blob = await Utils.canvasToBlobPromise(canvas, 'image/png', 0.95);
                    } catch (blobError) {
                        console.error('PNG blob creation failed:', blobError);

                        // Fallback to JPEG with lower quality for mobile
                        if (isMobile) {
                            console.log('‚ö†Ô∏è Retrying with JPEG format for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Trying alternative format...');
                            blob = await Utils.canvasToBlobPromise(canvas, 'image/jpeg', 0.85);
                        } else {
                            throw blobError;
                        }
                    }

                    // Check blob size
                    const blobSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    console.log(`üìä Image size: ${blobSizeMB} MB`);

                    if (blob.size > 50 * 1024 * 1024 && isMobile) {
                        this.hideLoading(loading);
                        this.showToast('‚ö†Ô∏è Image too large for mobile device. Please reduce quality in settings.', 'error');
                        return;
                    }

                    // Create download
                    try {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        const fileExt = blob.type.includes('jpeg') ? 'jpg' : 'png';
                        link.download = `Order_${order.orderId}.${fileExt}`;

                        // Mobile-specific download handling
                        if (isMobile) {
                            // For mobile, add a small delay and use different approach
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        } else {
                            link.click();
                        }

                        // Delay cleanup for mobile browsers
                        setTimeout(() => URL.revokeObjectURL(url), isMobile ? 1000 : 100);

                        this.hideLoading(loading);
                        this.showToast(`‚úÖ Image downloaded! (${blobSizeMB} MB)`);
                    } catch (downloadError) {
                        console.error('Download failed:', downloadError);
                        this.hideLoading(loading);
                        this.showToast('‚ùå Download failed: ' + downloadError.message, 'error');
                    }
                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Image generation error:', error);

                    // Mobile-friendly error message
                    if (isMobile) {
                        this.showToast(`‚ùå Failed on ${deviceType}: ${error.message}. Try reducing image quality in settings.`, 'error');
                    } else {
                        this.showToast('‚ùå Error: ' + error.message, 'error');
                    }
                }
            },

            async generateMultiOrderImage(orders, date) {
                console.log(`\nüéØ ========== GENERATE MULTI ORDER IMAGE CALLED ==========`);
                console.log(`üìÖ Date: ${date}`);
                console.log(`üì¶ Number of orders: ${orders.length}`);
                console.log(`üìã Orders:`, orders.map(o => ({
                    orderId: o.orderId,
                    clientName: o.clientName,
                    isMultiDay: o.isMultiDay,
                    hasDayWiseData: !!(o.dayWiseData && o.dayWiseData.length > 0),
                    dayWiseDataCount: o.dayWiseData ? o.dayWiseData.length : 0,
                    hasItems: !!(o.items && o.items.length > 0),
                    itemsCount: o.items ? o.items.length : 0
                })));
                console.log(`========================================\n`);

                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? `Generating PDF (mobile mode, ${orders.length} orders)...` : 'Generating multi-page PDF...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    // Smart quality adjustment for multi-order images to prevent memory issues
                    let baseQualityScale = this.data.settings.imageQuality || 2;

                    // Apply mobile optimizations first
                    let qualityScale = Utils.getOptimalCanvasScale(baseQualityScale);

                    // Further reduce quality based on number of orders
                    if (orders.length > 5) {
                        qualityScale = Math.min(qualityScale, 2); // Limit to scale 2 for more than 5 orders
                        console.log('‚ö†Ô∏è Quality reduced to scale 2 due to multiple orders to prevent memory issues');
                    }
                    if (orders.length > 10) {
                        qualityScale = Math.min(qualityScale, 1.5); // Further reduce for very large sets
                        console.log('‚ö†Ô∏è Quality further reduced to scale 1.5 for large order set');
                    }

                    // Extra reduction for mobile with many orders
                    if (isMobile) {
                        if (orders.length > 3) {
                            qualityScale = Math.min(qualityScale, 1);
                            console.log(`üì± Mobile with ${orders.length} orders: Quality capped at scale 1`);
                        }
                        if (orders.length > 10) {
                            this.hideLoading(loading);
                            this.showToast(`‚ö†Ô∏è ${orders.length} orders may be too many for mobile device. Consider downloading fewer orders at once.`, 'error');
                            return;
                        }
                    }

                    if (isMobile && qualityScale < baseQualityScale) {
                        console.log(`üì± ${deviceType}: Quality auto-adjusted from ${baseQualityScale} to ${qualityScale}`);
                    }

                    // Use fontSize from settings, but slightly smaller for compact multi-order view
                    const compactFontSize = Math.max(16, fontSize - 6);

                    console.log(`üöÄ Starting PDF generation for ${orders.length} orders`);

                    // Calculate grand totals for all orders (needed early for page height calculations)
                    let grandTotalDryIce = 0;
                    let grandTotalFlowers = 0;
                    let grandTotalElectricity = 0;
                    let grandTotalDryMachines = 0;
                    let grandTotalFlowerMachines = 0;

                    orders.forEach(order => {
                        const requirements = this.calculateOrderRequirements(order);
                        console.log(`  ‚Üí Order ${order.orderId} requirements:`, requirements);
                        grandTotalDryIce += requirements.dryIceNeeded;
                        grandTotalFlowers += requirements.flowersNeeded;
                        grandTotalElectricity += requirements.totalElectricityKV;
                        grandTotalDryMachines += requirements.dryMachines;
                        grandTotalFlowerMachines += requirements.flowerShowerMachines;
                    });

                    console.log(`\nüìä Grand Totals Calculated: DryIce=${grandTotalDryIce}kg, Flowers=${grandTotalFlowers}kg, Electricity=${grandTotalElectricity}KV, DryMachines=${grandTotalDryMachines}, FlowerMachines=${grandTotalFlowerMachines}\n`);

                    // NEW ALGORITHM: Dynamic page building with actual measurements
                    // This ensures ALL orders are included and pages are packed optimally

                    // CRITICAL: Use 'static' positioning for accurate measurements
                    // Using 'absolute' causes grid/flexbox layouts to collapse and gives wrong scrollHeight
                    template.style.height = 'auto';
                    template.style.minHeight = '0';
                    template.style.maxHeight = 'none';
                    template.style.overflow = 'visible';
                    template.style.display = 'block';
                    template.style.visibility = 'hidden'; // Hidden but still in document flow
                    template.style.position = 'static'; // Keep in document flow for accurate measurement
                    template.style.opacity = '0'; // Extra insurance it's not visible

                    const headerHeight = 75; // Header height for date (reduced for better space utilization)
                    const separatorHeight = 15; // Space between orders (reduced for better space utilization)
                    const bottomMargin = 10; // Bottom margin for page (optimized for space utilization)
                    const safetyMargin = 15; // Safety buffer for rendering differences (optimized for maximum space usage)

                    // Measure the actual grand total summary height instead of estimating
                    const hasGrandTotalSummary = (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0);
                    let grandTotalSummaryHeight = 0;

                    if (hasGrandTotalSummary) {
                        // Render the actual summary to measure its real height
                        const summaryHtml = `
                            <div style="background: white; color: black; padding: 8px; margin-bottom: 12px; border: 2px solid #000; border-radius: 4px;">
                                <h3 style="margin: 0 0 6px 0; font-size: 15px; text-align: center; font-weight: bold;">üìä Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                    ${grandTotalDryIce > 0 ? `
                                    <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Dry Ice Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                            <div style="font-size: 50px;">‚ùÑÔ∏è</div>
                                            <div style="font-size: 50px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                        </div>
                                        <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalFlowers > 0 ? `
                                    <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Flowers Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                            <div style="font-size: 50px;">üå∏</div>
                                            <div style="font-size: 50px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                        </div>
                                        <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalElectricity > 0 ? `
                                    <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Electricity Required</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                            <div style="font-size: 50px;">‚ö°</div>
                                            <div style="font-size: 50px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                        </div>
                                        <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">Total power needed</div>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;

                        // Temporarily render to measure (use static positioning for accurate height)
                        template.innerHTML = summaryHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Increased wait for layout calculation
                        grandTotalSummaryHeight = template.scrollHeight;
                        console.log(`üìä Measured grand total summary height: ${grandTotalSummaryHeight}px`);
                        template.style.display = 'none';
                        template.style.opacity = '1';
                    }

                    const maxContentHeightFirstPage = paperDimensions.height - headerHeight - bottomMargin - safetyMargin - grandTotalSummaryHeight;
                    const maxContentHeightOtherPages = paperDimensions.height - headerHeight - bottomMargin - safetyMargin;

                    console.log(`üìê Page constraints: Paper=${paperDimensions.height}px, Header=${headerHeight}px, Margins=${bottomMargin + safetyMargin}px, GrandTotal=${grandTotalSummaryHeight}px`);
                    console.log(`üìä Max content: First page=${maxContentHeightFirstPage}px, Other pages=${maxContentHeightOtherPages}px`);

                    const pages = [];
                    let processedOrders = new Set(); // Track which orders we've added

                    // Helper function to check if a single order fits on a page
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const checkSingleOrderFits = async (order, maxHeight) => {
                        const testHtml = this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                        template.innerHTML = testHtml;
                        // Ensure template is visible for measurement (but hidden from user)
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Wait for layout
                        const height = template.scrollHeight;
                        return { fits: height <= maxHeight, height: height };
                    };

                    // Helper function to measure multiple orders together
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const measureOrdersHeight = async (ordersList) => {
                        let testHtml = '';
                        ordersList.forEach((o, idx) => {
                            testHtml += this.buildOrderHTML(o, compactFontSize, colors, true, bgColor, textColor);
                            if (idx < ordersList.length - 1) {
                                testHtml += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });
                        template.innerHTML = testHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100));
                        return template.scrollHeight;
                    };

                    // STEP 1: Measure all orders individually first
                    console.log('üìè Measuring all orders for optimal packing...');
                    const orderHeights = [];
                    for (let i = 0; i < orders.length; i++) {
                        const check = await checkSingleOrderFits(orders[i], maxContentHeightOtherPages);
                        orderHeights.push({
                            order: orders[i],
                            height: check.height,
                            originalIndex: i
                        });
                    }

                    // STEP 2: Sort orders by height (descending) - First Fit Decreasing algorithm
                    orderHeights.sort((a, b) => b.height - a.height);
                    console.log('üìä Order heights (sorted descending):', orderHeights.map(oh => `${oh.order.clientName || oh.order.orderId}: ${oh.height}px`).join(', '));

                    // STEP 3: Use First Fit Decreasing bin-packing algorithm
                    for (let i = 0; i < orderHeights.length; i++) {
                        const { order, height, originalIndex } = orderHeights[i];

                        // Check if this single order is too large for any page by itself
                        const fitsOnFirstPage = height <= maxContentHeightFirstPage;
                        const fitsOnOtherPage = height <= maxContentHeightOtherPages;

                        // If order doesn't fit on any page by itself, handle special case
                        if (!fitsOnOtherPage) {
                            // Check if this is a multifunction/multiday order that can be split
                            if (order.dayWiseData && order.dayWiseData.length > 0) {
                                // Try to split by function groups
                                let remainingFunctions = [];
                                order.dayWiseData.forEach(day => {
                                    if (day.functions && day.functions.length > 0) {
                                        day.functions.forEach((func, funcIdx) => {
                                            remainingFunctions.push({
                                                dayNumber: day.dayNumber,
                                                date: day.date,
                                                function: func,
                                                functionIndex: funcIdx
                                            });
                                        });
                                    }
                                });

                                // Split functions across multiple pages
                                while (remainingFunctions.length > 0) {
                                    let currentFunctionSet = [];

                                    for (let f = 0; f < remainingFunctions.length; f++) {
                                        const testFunctions = [...currentFunctionSet, remainingFunctions[f]];

                                        // Create a partial order with only these functions
                                        const partialOrder = {
                                            ...order,
                                            dayWiseData: testFunctions.map(tf => ({
                                                dayNumber: tf.dayNumber,
                                                date: tf.date,
                                                functions: [tf.function]
                                            }))
                                        };

                                        // Test if it fits
                                        const partialCheck = await checkSingleOrderFits(partialOrder, maxContentHeightOtherPages);

                                        if (partialCheck.fits) {
                                            currentFunctionSet.push(remainingFunctions[f]);
                                        } else {
                                            // Can't add more functions, save current set
                                            break;
                                        }
                                    }

                                    // If we couldn't fit even one function, we need to add it anyway
                                    if (currentFunctionSet.length === 0 && remainingFunctions.length > 0) {
                                        currentFunctionSet.push(remainingFunctions[0]);
                                    }

                                    // Create page with current function set
                                    const pageOrder = {
                                        ...order,
                                        orderId: `${order.orderId} (Part ${pages.length + 1})`,
                                        dayWiseData: currentFunctionSet.map(tf => ({
                                            dayNumber: tf.dayNumber,
                                            date: tf.date,
                                            functions: [tf.function]
                                        }))
                                    };

                                    pages.push([pageOrder]);

                                    // Remove processed functions
                                    remainingFunctions = remainingFunctions.slice(currentFunctionSet.length);
                                }

                                processedOrders.add(originalIndex);
                                continue;
                            } else {
                                // Not a multifunction order, add it anyway and let it scale or overflow
                                pages.push([order]);
                                processedOrders.add(originalIndex);
                                continue;
                            }
                        }

                        // FIRST FIT: Try to fit this order in existing pages
                        let placed = false;
                        for (let pageIdx = 0; pageIdx < pages.length; pageIdx++) {
                            const pageOrders = pages[pageIdx];
                            const isFirstPage = pageIdx === 0;
                            const maxHeight = isFirstPage ? maxContentHeightFirstPage : maxContentHeightOtherPages;

                            // Measure current page content
                            const currentHeight = pageOrders.length > 0 ? await measureOrdersHeight(pageOrders) : 0;
                            const availableSpace = maxHeight - currentHeight;

                            // Try adding this order to this page
                            const testOrders = [...pageOrders, order];
                            const testHeight = await measureOrdersHeight(testOrders);
                            const willFit = testHeight <= maxHeight;

                            console.log(`üìè Page ${pageIdx + 1} (${isFirstPage ? 'FIRST' : 'other'}): has ${pageOrders.length} order(s), used ${currentHeight}px, available ${availableSpace}px/${maxHeight}px`);
                            console.log(`   ‚Üí Testing "${order.clientName || order.orderId}" (${height}px): total would be ${testHeight}px, fits = ${willFit}`);

                            if (willFit) {
                                // Fits! Add to this page
                                pages[pageIdx].push(order);
                                processedOrders.add(originalIndex);
                                placed = true;
                                console.log(`‚úÖ Placed order "${order.clientName || order.orderId}" on page ${pageIdx + 1}`);
                                break;
                            }
                        }

                        // If didn't fit in any existing page, create a new page
                        if (!placed) {
                            pages.push([order]);
                            processedOrders.add(originalIndex);
                            console.log(`üìÑ Created new page ${pages.length} for order "${order.clientName || order.orderId}"`);
                        }
                    }

                    // Reset template to normal state
                    template.style.display = 'none';
                    template.style.visibility = 'visible';
                    template.style.position = 'static';
                    template.style.opacity = '1';

                    // VERIFICATION: Check all orders were processed
                    // Note: totalOrdersInPages may be > orders.length due to split multifunction orders
                    if (processedOrders.size !== orders.length) {
                        throw new Error(`Missing orders in PDF! Expected ${orders.length}, but only ${processedOrders.size} were processed.`);
                    }

                    const totalPages = pages.length;
                    console.log(`‚úÖ Generated ${totalPages} pages for ${orders.length} orders`);

                    // STEP 3: Generate multi-page PDF
                    this.updateLoadingMessage(loading, 'Creating PDF document...');

                    // Initialize jsPDF with exact dimensions matching our measurements (300 DPI)
                    const { jsPDF } = window.jspdf;

                    // CRITICAL FIX: Use the same paperDimensions we used for measurement
                    // This ensures content measured to fit will actually fit in the PDF
                    const pdf = new jsPDF({
                        orientation: 'p', // We handle orientation in paperDimensions
                        unit: 'px',
                        format: [paperDimensions.width, paperDimensions.height], // Use exact dimensions at 300 DPI
                        compress: true
                    });

                    // Get PDF page dimensions (should match paperDimensions)
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    console.log(`üìè PDF dimensions: ${pdfWidth} x ${pdfHeight} px (should match measurement dimensions)`);
                    console.log(`üìê Paper dimensions used for measurement: ${paperDimensions.width} x ${paperDimensions.height} px`);

                    // Generate each page and add to PDF
                    for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                        this.updateLoadingMessage(loading, `Adding page ${pageNum + 1} of ${totalPages} to PDF...`);

                        const pageOrders = pages[pageNum];

                        // Build HTML for this page
                        let html = `
                            <div style="text-align: center; margin-bottom: 15px; padding: 8px 0;">
                                <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 10px; margin: 0; font-size: 24px;">
                                    Orders for ${Utils.formatDate(date)} - Page ${pageNum + 1} of ${totalPages}
                                </h1>
                            </div>
                        `;

                        // Add summary section on first page only
                        console.log(`üîç Page ${pageNum}: Checking grand total condition - DryIce=${grandTotalDryIce}, Flowers=${grandTotalFlowers}, Electricity=${grandTotalElectricity}`);
                        if (pageNum === 0 && (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0)) {
                            console.log(`‚úÖ Adding grand total summary to first page`);
                            html += `
                                <div style="background: white; color: black; padding: 8px; margin-bottom: 12px; border: 2px solid #000; border-radius: 4px;">
                                    <h3 style="margin: 0 0 6px 0; font-size: 15px; text-align: center; font-weight: bold;">üìä Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                                        ${grandTotalDryIce > 0 ? `
                                        <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Dry Ice Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                                <div style="font-size: 50px;">‚ùÑÔ∏è</div>
                                                <div style="font-size: 50px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                            </div>
                                            <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalFlowers > 0 ? `
                                        <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Flowers Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                                <div style="font-size: 50px;">üå∏</div>
                                                <div style="font-size: 50px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                            </div>
                                            <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} √ó 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalElectricity > 0 ? `
                                        <div style="background: white; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">Electricity Required</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 6px;">
                                                <div style="font-size: 50px;">‚ö°</div>
                                                <div style="font-size: 50px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                            </div>
                                            <div style="font-size: 11px; font-weight: bold; margin-top: 4px;">Total power needed</div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }

                        pageOrders.forEach((order, i) => {
                            html += this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                            if (i < pageOrders.length - 1) {
                                html += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });

                        template.innerHTML = html;
                        template.style.display = 'block';
                        template.style.visibility = 'visible';
                        template.style.position = 'static';
                        template.style.height = 'auto';

                        // Increased wait time for mobile devices
                        await new Promise(r => setTimeout(r, isMobile ? 500 : 200));

                        // Validate canvas dimensions before creation
                        const expectedWidth = Math.round(paperDimensions.width * qualityScale);
                        const expectedHeight = Math.round(paperDimensions.height * qualityScale);
                        const validation = Utils.validateCanvasDimensions(expectedWidth, expectedHeight);

                        if (!validation.valid) {
                            throw new Error(`Page ${pageNum + 1}: ${validation.reason}`);
                        }

                        // Convert HTML to canvas with error handling
                        let canvas;
                        try {
                            canvas = await html2canvas(template, {
                                scale: qualityScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        } catch (canvasError) {
                            console.error('Canvas generation failed, retrying with lower quality:', canvasError);

                            // Retry with lower quality scale
                            const retryScale = isMobile ? 0.75 : 1;
                            console.log(`‚ö†Ô∏è Retrying page ${pageNum + 1} with scale ${retryScale}...`);

                            canvas = await html2canvas(template, {
                                scale: retryScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        }

                        template.style.display = 'none';

                        // Convert canvas to image and add to PDF with error handling
                        let imgData;
                        try {
                            imgData = canvas.toDataURL('image/png', 0.92);
                        } catch (pngError) {
                            console.error('PNG conversion failed, retrying with JPEG:', pngError);
                            // Fallback to JPEG if PNG fails
                            try {
                                imgData = canvas.toDataURL('image/jpeg', 0.85);
                            } catch (jpegError) {
                                console.error('JPEG conversion also failed:', jpegError);
                                if (isMobile) {
                                    throw new Error('Canvas conversion failed on mobile device. Try reducing image quality or downloading fewer orders.');
                                } else {
                                    throw jpegError;
                                }
                            }
                        }

                        // Check data URL size for mobile
                        if (isMobile && imgData.length > 10 * 1024 * 1024) {
                            console.warn(`‚ö†Ô∏è Page ${pageNum + 1} is large (${(imgData.length / 1024 / 1024).toFixed(2)} MB)`);
                        }
                        let imgWidth = pdfWidth;
                        let imgHeight = (canvas.height * pdfWidth) / canvas.width;

                        // Add new page if not first page
                        if (pageNum > 0) {
                            pdf.addPage();
                        }

                        // Check if image is too tall - if so, add it without scaling to preserve quality
                        // The content should have been properly split in the page allocation phase
                        if (imgHeight > pdfHeight) {
                            console.warn(`‚ö†Ô∏è Page ${pageNum + 1} image height (${imgHeight}px) exceeds PDF height (${pdfHeight}px)`);
                            console.warn(`   This should not happen - the page allocation should have split the content properly`);

                            // Calculate scale factor needed
                            const scaleFactor = pdfHeight / imgHeight;
                            console.warn(`   Content will be scaled down to ${(scaleFactor * 100).toFixed(1)}% to fit the page`);

                            // Scale to fit as last resort
                            imgHeight = pdfHeight;
                            imgWidth = (canvas.width * pdfHeight) / canvas.height;
                        }

                        // Add image to PDF page (centered if scaled down)
                        const xOffset = (pdfWidth - imgWidth) / 2;
                        pdf.addImage(imgData, 'PNG', xOffset, 0, imgWidth, imgHeight, undefined, 'FAST');
                    }

                    // Save the PDF
                    this.updateLoadingMessage(loading, 'Saving PDF...');
                    pdf.save(`Orders_${date}.pdf`);

                    this.hideLoading(loading);
                    this.showToast(`‚úÖ PDF generated with ${totalPages} page(s)! (${orders.length} orders)`);

                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Error generating multi-order images:', error);

                    // Mobile-friendly error messages
                    if (isMobile) {
                        this.showToast(`‚ùå Failed on ${deviceType}: ${error.message}. Try reducing quality in settings or downloading fewer orders.`, 'error');
                    } else {
                        this.showToast('‚ùå Error: ' + error.message, 'error');
                    }
                }
            },

            // Helper to update loading message dynamically
            updateLoadingMessage(loadingElement, message) {
                if (loadingElement && loadingElement.querySelector('.loading-text')) {
                    loadingElement.querySelector('.loading-text').textContent = message;
                }
            },

            // Get paper dimensions based on format and orientation
            getPaperDimensions() {
                const format = this.data.settings.paperFormat || 'A4';
                const orientation = this.data.settings.paperOrientation || 'portrait';

                // Paper dimensions in pixels (at 300 DPI)
                const formats = {
                    'A4': { width: 2480, height: 3508 },
                    'Legal': { width: 2550, height: 4200 },
                    'Letter': { width: 2550, height: 3300 },
                    'A3': { width: 3508, height: 4960 },
                    'A5': { width: 1748, height: 2480 },
                    'Tabloid': { width: 3300, height: 5100 }
                };

                let dimensions = formats[format] || formats['A4'];

                // Swap dimensions for landscape
                if (orientation === 'landscape') {
                    return {
                        width: dimensions.height,
                        height: dimensions.width
                    };
                }

                return dimensions;
            },

            // Calculate dry ice, flowers, and electricity requirements for a single order
            calculateOrderRequirements(order) {
                const items = [];

                // Collect all items from the order
                // Check for dayWiseData first (handles both multiday and filtered single-day orders)
                if (order.dayWiseData && Array.isArray(order.dayWiseData) && order.dayWiseData.length > 0) {
                    console.log(`üìã Order ${order.orderId || order.clientName}: Processing dayWiseData (${order.dayWiseData.length} days)`);
                    order.dayWiseData.forEach(day => {
                        if (day.functions && Array.isArray(day.functions)) {
                            day.functions.forEach(func => {
                                if (func.items && Array.isArray(func.items)) {
                                    const funcName = func.functionName || func.name || '(unnamed function)';
                                    console.log(`  ‚Üí Adding ${func.items.length} items from function "${funcName}"`);
                                    items.push(...func.items);
                                }
                            });
                        }
                    });
                } else if (order.items && Array.isArray(order.items)) {
                    console.log(`üìã Order ${order.orderId || order.clientName}: Processing items array (${order.items.length} items)`);
                    items.push(...order.items);
                }

                console.log(`  ‚Üí Total items collected: ${items.length}`);

                // DEBUG: Log all item names to understand what we're working with
                if (items.length > 0) {
                    console.log(`  ‚Üí Item details:`);
                    items.forEach((item, idx) => {
                        console.log(`     ${idx + 1}. Name: "${item.name}" | Qty: ${item.quantity || 0}`);
                    });
                }

                // Calculate dry ice requirements
                const dryMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = name.includes('dry ice');
                    if (matches) {
                        console.log(`     ‚úÖ DRY ICE MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Calculate flower requirements
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                    if (matches) {
                        console.log(`     ‚úÖ FLOWER SHOWER MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name?.toLowerCase() || '';
                    const qty = item.quantity || 0;

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     ‚úÖ ELECTRICITY 3KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 3}KV)`);
                        totalElectricityKV += qty * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     ‚úÖ ELECTRICITY 1KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 1}KV)`);
                        totalElectricityKV += qty * 1;
                    }
                });

                const result = {
                    dryIceNeeded,
                    dryMachines,
                    flowersNeeded,
                    flowerShowerMachines,
                    totalElectricityKV,
                    items
                };

                // DEBUG: Log the calculated requirements
                console.log(`  ‚Üí üìä Calculated: DryIce=${dryIceNeeded}kg (${dryMachines} machines), Flowers=${flowersNeeded}kg (${flowerShowerMachines} machines), Electricity=${totalElectricityKV}KV`);

                return result;
            },

            buildOrderHTML(order, fontSize, colors, compact = false, bgColor = '#ffffff', textColor = '#000000') {
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                const functionColor = this.data.settings.functionColor || '#667eea';

                // Calculate requirements for this order
                const requirements = this.calculateOrderRequirements(order);

                return `
                    <div style="margin-bottom: ${compact ? '25px' : '60px'}; ${compact ? 'border: 2px solid ' + colors.tableBorder + '; padding: 15px;' : ''}; color: ${textColor}; background: ${bgColor};">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px; color: ${textColor};">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : ''}

                        <!-- FP- Field at center/top -->
                        <div style="text-align: center; margin-bottom: ${compact ? '15px' : '25px'}; margin-top: ${compact ? '10px' : '0'};">
                            <div style="display: inline-block; border: 2px solid ${textColor}; padding: 8px 25px; font-size: ${fontSize + 4}px; font-weight: bold; color: #000000; background: #ffeb3b;">
                                FP-<span style="display: inline-block; min-width: 150px; border-bottom: 2px solid ${textColor}; margin-left: 10px; white-space: nowrap;">${order.orderId && order.orderId.startsWith('FP') ? order.orderId.substring(2) : ''}</span>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ${compact ? '12px' : '20px'}; font-size: ${fontSize}px; margin-bottom: ${compact ? '12px' : '20px'}; color: ${textColor};">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong style="color: ${textColor};">Start Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.startDate) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">End Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.endDate) || 'N/A'}</span><br>
                                ` : `
                                    <strong style="color: ${textColor};">Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.date) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${order.readyTime || '-'}</span><br>
                                `}
                                <strong style="color: ${textColor};">Client:</strong> ${order.clientName || '-'}<br>
                                <strong style="color: ${textColor};">Contact:</strong> ${order.contact || '-'}<br>
                                <strong style="color: ${textColor};">Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <strong style="color: ${textColor};">Dry Ice:</strong> ${requirements.dryIceNeeded > 0 ? '<span style="background: #ffeb3b; color: #000000; padding: 2px 4px; display: inline-block; min-width: 250px;">' + requirements.dryIceNeeded + ' kg (' + requirements.dryMachines + ' machine' + (requirements.dryMachines !== 1 ? 's' : '') + ')' + '</span>' : '<span style="display: inline-block; min-width: 250px;"></span>'}<br>
                                <strong style="color: ${textColor};">Flowers:</strong> ${requirements.flowersNeeded > 0 ? '<span style="background: #ffeb3b; color: #000000; padding: 2px 4px; display: inline-block; min-width: 250px;">' + requirements.flowersNeeded + ' kg (' + requirements.flowerShowerMachines + ' machine' + (requirements.flowerShowerMachines !== 1 ? 's' : '') + ')' + '</span>' : '<span style="display: inline-block; min-width: 250px;"></span>'}<br>
                                <strong style="color: ${textColor};">Electricity:</strong> ${requirements.totalElectricityKV > 0 ? '<span style="background: #ffeb3b; color: #000000; padding: 2px 4px; display: inline-block; min-width: 250px;">' + requirements.totalElectricityKV + ' KV' + '</span>' : '<span style="display: inline-block; min-width: 250px;"></span>'}<br>
                                <strong style="color: ${textColor};">Transport:</strong> ${order.transport || '-'}<br>
                                <strong style="color: ${textColor};">Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong style="color: ${textColor};">Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong style="color: ${textColor};">Driver 2:</strong> ${order.driverName2}<br>` : ''}
                            </div>
                            <div>
                                <strong style="color: ${textColor};">Event:</strong> ${order.eventType || '-'}<br>
                                <strong style="color: ${textColor};">Operator:</strong> ${order.operator || '-'}<br>
                                <strong style="color: ${textColor};">Helper(s):</strong> ${order.helper || '-'}
                            </div>
                        </div>

                            ${order.dayWiseData && order.dayWiseData.length > 0 ?
                            '<div style="margin-top: ' + (compact ? '15px' : '30px') + ';">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: ' + (compact ? '10px' : '15px') + '; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) =>
                                    '<div style="margin-top: ' + (compact ? '12px' : '25px') + '; border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '10px' : '15px') + '; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: ' + (compact ? '8px' : '15px') + ';">Day ' + day.dayNumber + ' - <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + Utils.formatDate(day.date) + '</span></h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: ' + bgColor + '; padding: ' + (compact ? '10px' : '15px') + '; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? (compact ? '8px' : '15px') : '0') + '; color: ' + textColor + ';">' +
                                                    '<h5 style="color: ' + functionColor + '; margin-bottom: ' + (compact ? '6px' : '10px') + '; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' +
                                                        '<strong style="color: ' + textColor + ';">Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                        '<strong style="color: ' + textColor + ';">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + (func.timeSlot || '-') + '</span><br>' +
                                                        '<strong style="color: ' + textColor + ';">Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                        '<strong style="color: ' + textColor + ';">Helper:</strong> ' + (func.helper || '-') + '<br>' +
                                                        '<strong style="color: ' + textColor + ';">Operator:</strong> ' + (func.operator || '-') + '<br>' +
                                                        (func.notes ? '<strong style="color: ' + textColor + ';">Notes:</strong> ' + func.notes + '<br>' : '') +
                                                    '</div>' +
                                                    (func.items && func.items.length > 0 ?
                                                        '<table style="width: 100%; border-collapse: collapse; font-size: ' + (fontSize - 4) + 'px; color: ' + textColor + ';">' +
                                                            '<thead>' +
                                                                '<tr style="background: ' + colors.tableHeaderBg + '; color: ' + colors.tableHeaderText + ';">' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; width: ' + ts.columnWidthSr + '%;">Sr</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; width: ' + ts.columnWidthItem + '%;">Item</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; width: ' + ts.columnWidthQty + '%;">Qty</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; width: ' + ts.columnWidthRemarks + '%;">Remarks</th>' +
                                                                '</tr>' +
                                                            '</thead>' +
                                                            '<tbody>' +
                                                                func.items.map((item, i) =>
                                                                    '<tr style="color: ' + textColor + ';">' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; text-align: center; color: ' + textColor + ';">' + (i + 1) + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' + item.name + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; text-align: center; color: ' + textColor + ';">' + item.quantity + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' + (item.remarks || '-') + '</td>' +
                                                                    '</tr>'
                                                                ).join('') +
                                                            '</tbody>' +
                                                        '</table>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '6px' : '10px') + ';">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <table style="width: 100%; border-collapse: collapse; font-size: ${fontSize - 4}px; margin-top: ${compact ? '12px' : '20px'}; color: ${textColor};">
                                <thead>
                                    <tr style="background: ${colors.tableHeaderBg}; color: ${colors.tableHeaderText};">
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; width: ${ts.columnWidthSr}%;">Sr</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; width: ${ts.columnWidthItem}%;">Item</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; width: ${ts.columnWidthQty}%;">Qty</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; width: ${ts.columnWidthRemarks}%;">Remarks</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${order.items.map((item, i) => `
                                        <tr style="color: ${textColor};">
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; text-align: center; color: ${textColor};">${i + 1}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; color: ${textColor};">${item.name}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; text-align: center; color: ${textColor};">${item.quantity}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: ${compact ? '6px' : '10px'}; color: ${textColor};">${item.remarks || ''}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '12px' : '20px') + ';">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: ${compact ? '10px' : '20px'}; font-size: ${fontSize}px; color: ${textColor};">
                                <strong style="color: ${textColor};">Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: ${compact ? '10px' : '15px'}; border: 1px solid ${colors.tableBorder}; color: ${textColor};">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            renderCalendar(date = new Date()) {
                const year = date.getFullYear();
                const month = date.getMonth();

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                let html = `
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(-1)">${this.t('previousMonth')}</button>
                                <h3>${monthNames[month]} ${year}</h3>
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(1)">${this.t('nextMonth')}</button>
                            </div>
                            <button class="btn btn-secondary btn-small" onclick="OMS.showToday()">${this.t('today')}</button>
                        </div>
                        <div class="calendar-grid">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day =>
                                `<div class="calendar-day-header">${day}</div>`
                            ).join('')}
                            ${Array(firstDay).fill('').map(() => '<div class="calendar-day"></div>').join('')}
                            ${Array.from({length: daysInMonth}, (_, i) => {
                                const day = i + 1;
                                const dateStr = Utils.toDateString(new Date(year, month, day));
                                const today = Utils.toDateString(new Date());

                                // ENHANCED CALENDAR FILTERING with fuzzy date matching
                                const orders = this.data.orders.filter(o => {
                                    if (o.isMultiDay) {
                                        // Use fuzzy date matcher for multi-day range check
                                        if (o.startDate && o.endDate) {
                                            return fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate);
                                        }
                                    }
                                    // Use fuzzy date matcher for single-day check
                                    return o.date && fuzzyDateMatcher.matches(o.date, dateStr);
                                });
                                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                                const festival = this.festivals[dateStr];

                                let classes = 'calendar-day';
                                if (dateStr === today) classes += ' today';
                                if (orders.length) classes += ' has-orders';
                                if (tasks.length) classes += ' has-tasks';
                                if (festival) classes += ' has-festival';

                                // Get color indicators for this day's orders
                                const orderColorDots = orders.slice(0, 3).map(o => {
                                    const color = this.getOrderColor(o);
                                    return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin:0 2px;"></span>`;
                                }).join('');

                                return `
                                    <div class="${classes}" onclick="OMS.showDayDetails('${dateStr}')">
                                        <div class="calendar-day-number">${day}</div>
                                        ${festival ? `<div class="festival-text">${festival[1]}</div>` : ''}
                                        ${orders.length ? `<div class="order-count" title="${orders.length} ${this.t('ordersText')}">${orderColorDots}${orders.length > 3 ? '+' : ''}</div>` : ''}
                                        ${tasks.length ? `<div class="calendar-day-content">${tasks.length} ${tasks.length > 1 ? this.t('ordersText') : this.t('order')}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="card">
                        <h3 class="card-title">${this.t('calendar')}</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <input type="date" id="taskDate" class="form-input" value="${Utils.toDateString(new Date())}">
                            </div>
                            <div class="form-group">
                                <input type="text" id="taskDescription" class="form-input" placeholder="${this.t('enterNotes')}">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-primary" onclick="OMS.addTask()">${this.t('add')}</button>
                            </div>
                        </div>
                    </div>
                `;

                return html;
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const date = Utils.getLocalDate(dateStr);

                // ============ ENHANCED FILTERING WITH LOGGING ============
                const startTime = performance.now();
                const normalizedDate = fuzzyDateMatcher.normalize(dateStr);

                filterLogger.log('showDayDetails_started', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                const matchedOrders = [];
                const orders = this.data.orders.filter(o => {
                    if (o.isMultiDay) {
                        // Use fuzzy date matcher for multi-day range check
                        if (o.startDate && o.endDate && fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    // Use fuzzy date matcher for single-day check
                    if (o.date && fuzzyDateMatcher.matches(o.date, dateStr)) {
                        matchedOrders.push(o);
                        return true;
                    }
                    return false;
                });

                const filterTime = (performance.now() - startTime).toFixed(2);

                // Log and learn from this filter
                filterLogger.log('showDayDetails_completed', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    matchedCount: orders.length,
                    filterTimeMs: filterTime
                });

                patternLearner.recordFilterResult(normalizedDate, orders.length, this.data.orders.length, 'showDayDetails');

                // Validate and alert if needed
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders,
                    allOrders: this.data.orders
                });

                if (validationResult.some(a => a.level === 'error' || a.level === 'warning')) {
                    orderValidator.showAlerts(validationResult, dateStr);
                }
                // ============ END ENHANCED FILTERING ============

                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                const festival = this.festivals[dateStr];

                let content = `<h3>${this.t('details')} ${this.t('for')} ${Utils.formatDate(dateStr)}</h3>`;

                if (festival) {
                    content += `<div class="festival-text" style="font-size: 1.2rem; margin: 1rem 0;">üéâ ${festival[1]} (${festival[0]})</div>`;
                }

                if (orders.length > 0) {
                    content += `<h4>${this.t('orders')} (${orders.length})</h4>`;
                    orders.forEach(o => {
                        const color = this.getOrderColor(o);
                        let dateInfo = '';
                        if (o.isMultiDay) {
                            dateInfo = `<br><small style="color:#666;">${this.t('multiDayOrder')}: ${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}</small>`;
                        }
                        content += `
                            <div style="padding:10px;margin:8px 0;border-left:4px solid ${color};background:#f9f9f9;border-radius:4px;">
                                <strong>${o.orderId || '[No ID]'}</strong> - ${o.clientName}
                                <br>
                                <span style="color:${color};font-weight:bold;">${o.eventType || this.t('event')}</span> |
                                <span style="background:${color};color:white;padding:2px 6px;border-radius:3px;font-size:12px;">${this.t(o.status.toLowerCase())}</span>
                                ${dateInfo}
                            </div>
                        `;
                    });
                }

                if (tasks.length > 0) {
                    content += `<h4>${this.t('calendar')} (${tasks.length})</h4><ul>`;
                    tasks.forEach(t => {
                        content += `<li>
                            ${t.description}
                            <button class="btn btn-secondary btn-small" data-action="edit" data-type="task" data-id="${t.id}">${this.t('edit')}</button>
                            <button class="btn btn-danger btn-small" data-action="delete" data-type="task" data-id="${t.id}">${this.t('delete')}</button>
                        </li>`;
                    });
                    content += '</ul>';
                }

                content += `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.addTaskForDate('${dateStr}')">${this.t('add')}</button>
                        <button class="btn btn-secondary" onclick="OMS.createOrderForDate('${dateStr}')">${this.t('orders')}</button>
                    </div>
                `;

                this.showModal(this.t('details'), content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders as CSV
                        const headers = ['Order ID', 'Date', 'Client', 'Contact', 'Venue', 'Status', 'Total Items'];
                        const rows = this.data.orders.map(o => [
                            o.orderId, o.date, o.clientName, o.contact, o.venue, o.status, o.items.length
                        ]);
                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();

                // Create close button
                const closeBtn = Utils.elem('button', { class: 'modal-close' }, ['√ó']);
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeModal();
                });

                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        closeBtn,
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);

                document.getElementById('modalsContainer').appendChild(modal);

                // Also allow closing by clicking the backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal();
                    }
                });

                // Add keyboard handler for Escape key
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

                // Store handler to remove later
                modal._escapeHandler = escapeHandler;
            },

            showToast(message, type = 'success', actions = []) {
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let topOffset = 20; // Initial top position

                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    topOffset = Math.max(topOffset, rect.bottom - document.documentElement.scrollTop + 10);
                });

                // Create action buttons if provided
                const actionButtons = actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' },
                    actions.map(a => {
                        const btn = Utils.elem('button', { class: 'toast-btn' }, [a.label]);
                        btn.addEventListener('click', a.handler);
                        return btn;
                    })
                ) : null;

                const toast = Utils.elem('div', {
                    class: `toast show ${type === 'error' ? 'error' : ''} ${type === 'warning' ? 'warning' : ''}`,
                    style: { top: `${topOffset}px` }
                }, [
                    Utils.elem('div', {}, [message]),
                    actionButtons
                ].filter(Boolean));

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },

            repositionToasts() {
                const toasts = document.querySelectorAll('.toast');
                let topOffset = 20;

                toasts.forEach(toast => {
                    toast.style.top = `${topOffset}px`;
                    const rect = toast.getBoundingClientRect();
                    topOffset = rect.bottom - document.documentElement.scrollTop + 10;
                });
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', { class: 'loading-text' }, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ RBAC NAVIGATION ============
            async applyRBACToNavigation() {
                const canViewFinancials = await this.canViewFinancials();
                const financialsTab = document.querySelector('[data-tab="financials"]');
                const user = await this.getCurrentUser();

                console.log('üîê RBAC Check:', {
                    userRole: user?.role,
                    canViewFinancials: canViewFinancials,
                    tabExists: !!financialsTab
                });

                if (financialsTab) {
                    if (canViewFinancials) {
                        // Show financials tab for admin/owner users
                        financialsTab.style.display = '';
                        console.log('‚úÖ Financials tab VISIBLE for admin/owner user');
                    } else {
                        // Hide financials tab for non-admin/owner users
                        financialsTab.style.display = 'none';
                        console.log('üîí Financials tab HIDDEN for non-admin/owner user');
                    }
                }

                // Display current user role in header
                if (user) {
                    const userInfoDiv = document.createElement('div');
                    userInfoDiv.id = 'userRoleInfo';
                    userInfoDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: rgba(0,0,0,0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; white-space: nowrap; margin-right: 0.5rem;';
                    userInfoDiv.innerHTML = `
                        <span style="opacity: 0.7; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${user.email}</span>
                        <span style="padding: 0.25rem 0.5rem; background: ${user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3'}; color: white; border-radius: 0.25rem; font-weight: bold; text-transform: uppercase; font-size: 0.75rem;">
                            ${user.role}
                        </span>
                    `;

                    // Add to header-controls instead of directly to header
                    const headerControls = document.querySelector('.header-controls');
                    if (headerControls && !document.getElementById('userRoleInfo')) {
                        // Insert at the beginning of header-controls
                        headerControls.insertBefore(userInfoDiv, headerControls.firstChild);
                    }
                }
            },

            // ============ NAVIGATION ============
            async switchTab(tabName) {
                // Check permissions for financial tab
                if (tabName === 'financials') {
                    const canView = await this.canViewFinancials();
                    if (!canView) {
                        this.showToast('‚õî Access Denied: Only Admin and Owner can view Financials', 'error');
                        return;
                    }
                }

                // Clean up preparation weather interval when leaving preparation tab
                if (this.currentTab === 'preparation' && tabName !== 'preparation') {
                    if (this.preparationWeatherInterval) {
                        clearInterval(this.preparationWeatherInterval);
                        this.preparationWeatherInterval = null;
                    }
                }

                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(tabName).classList.add('active');

                this.currentTab = tabName;

                // Render tab content
                setTimeout(() => {
                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') this.renderInventory();
                    else if (tabName === 'itemHistory') this.renderItemHistory();
                    else if (tabName === 'preparation') this.renderPreparation();
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'team') this.renderTeam();
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'financials') this.renderFinancials();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') this.initItemSearch();
                }, 50);
            },

            // ============ TAB RENDERERS ============
            renderDashboard() {
                const stats = [
                    { label: this.t('totalOrders'), value: this.data.orders.length, class: '' },
                    { label: this.t('confirmedOrders'), value: this.data.orders.filter(o => o.status && o.status.toLowerCase() === 'confirmed').length, class: 'success' },
                    { label: this.t('completedOrders'), value: this.data.orders.filter(o => o.status && o.status.toLowerCase() === 'completed').length, class: 'info' },
                    { label: this.t('customers'), value: this.data.customers.length, class: '' },
                    { label: this.t('lowStock'), value: this.data.inventory.items.filter(i => i.quantity <= this.data.settings.lowStockThreshold).length, class: 'warning' },
                    { label: this.t('today'), value: this.data.orders.filter(o => o.date === Utils.toDateString(new Date())).length, class: 'danger' }
                ];

                document.getElementById('dashboardStats').innerHTML = stats.map(s => `
                    <div class="stat-card ${s.class}">
                        <div class="stat-value">${s.value}</div>
                        <div class="stat-label">${s.label}</div>
                    </div>
                `).join('');

                const recentOrders = this.data.orders.slice(-5).reverse();
                this.renderTable('recentOrdersContainer', [
                    { key: 'orderId', label: this.t('orderId'), render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: this.t('client') },
                    { key: 'eventType', label: this.t('event'), render: o => o.eventType || this.t('na') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${o.status}</span>` }
                ], recentOrders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('view')}</button>
                    <button class="btn btn-info btn-small" onclick="OMS.duplicateOrder('${row.docId || row.orderId}')">üìã ${this.t('duplicate')}</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                `);

                // Top customer
                if (this.data.customers.length > 0) {
                    const top = this.data.customers.reduce((prev, curr) =>
                        (prev.totalOrders > curr.totalOrders) ? prev : curr
                    );
                    document.getElementById('topCustomerInfo').innerHTML = `
                        <div style="background: var(--light); padding: 1rem; border-radius: var(--radius);">
                            <strong>${top.name}</strong><br>
                            ${top.contact}<br>
                            <strong>${top.totalOrders} ${this.t('ordersText')}</strong>
                        </div>
                    `;
                }
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('inventoryManagement')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">${this.t('batchUpdate')}</button>
                        </div>
                        <div class="card">
                            <h3>${this.t('categories')}</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="${this.t('enterCategoryName')}">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">${this.t('add')}</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>${this.t('items')}</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="${this.t('enterItemName')}">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="${this.t('quantity')}" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">${this.t('add')}</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;

                this.updateInventoryDisplay();
            },

            renderItemHistory() {
                const container = document.getElementById('itemHistory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìú Item Usage History</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">
                                Track which items were used in which completed orders
                            </p>
                        </div>
                        <div class="form-row" style="margin-bottom: 1rem;">
                            <input type="text" id="itemHistorySearch" class="form-input" placeholder="Search by item name, order ID, or client...">
                            <select id="itemHistoryFilter" class="form-select">
                                <option value="all">All Items</option>
                                ${[...new Set(this.data.itemHistory.map(h => h.itemName))].sort().map(name =>
                                    `<option value="${name}">${name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div id="itemHistoryContainer"></div>
                    </div>
                `;

                this.renderItemHistoryTable();

                // Add search and filter handlers
                document.getElementById('itemHistorySearch')?.addEventListener('input', () => this.renderItemHistoryTable());
                document.getElementById('itemHistoryFilter')?.addEventListener('change', () => this.renderItemHistoryTable());
            },

            renderItemHistoryTable() {
                const searchTerm = document.getElementById('itemHistorySearch')?.value.toLowerCase() || '';
                const filterItem = document.getElementById('itemHistoryFilter')?.value || 'all';

                // Filter history
                let filteredHistory = this.data.itemHistory;

                if (filterItem !== 'all') {
                    filteredHistory = filteredHistory.filter(h => h.itemName === filterItem);
                }

                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(h =>
                        h.itemName.toLowerCase().includes(searchTerm) ||
                        h.orderId.toLowerCase().includes(searchTerm) ||
                        h.clientName.toLowerCase().includes(searchTerm) ||
                        (h.venue && h.venue.toLowerCase().includes(searchTerm))
                    );
                }

                // Sort by most recent first
                filteredHistory.sort((a, b) => new Date(b.usedAt) - new Date(a.usedAt));

                // Render table
                this.renderTable('itemHistoryContainer', [
                    { key: 'itemName', label: 'Item Name' },
                    { key: 'quantity', label: 'Qty' },
                    { key: 'orderId', label: 'Order ID', render: h => `<span class="order-id-highlight">${h.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'venue', label: 'Venue', render: h => h.venue || 'N/A' },
                    { key: 'eventDate', label: 'Event Date', render: h => Utils.formatDate(h.eventDate) },
                    { key: 'functionType', label: 'Function', render: h => h.functionType || 'N/A' },
                    { key: 'usedAt', label: 'Recorded On', render: h => new Date(h.usedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }) }
                ], filteredHistory, (row) => ``);
            },

            updateInventoryDisplay() {
                // Populate category dropdown
                const select = document.getElementById('itemCategory');
                if (select) {
                    select.innerHTML = `<option value="">${this.t('selectCategory')}</option>` +
                        this.data.inventory.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
                }

                // Render categories table
                this.renderTable('categoriesContainer', [
                    { key: 'name', label: this.t('category') },
                    { key: 'id', label: this.t('items'), render: c => this.data.inventory.items.filter(i => i.categoryId === c.id).length }
                ], this.data.inventory.categories, (row) => `
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="category" data-id="${row.id}">${this.t('delete')}</button>
                `);

                // Render items table
                this.renderTable('itemsContainer', [
                    { key: 'name', label: this.t('item') },
                    { key: 'categoryId', label: this.t('category'), render: i => this.data.inventory.categories.find(c => c.id === i.categoryId)?.name || this.t('na') },
                    { key: 'quantity', label: this.t('stock') }
                ], this.data.inventory.items, (row) => `
                    <button class="btn btn-success btn-small" onclick="OMS.increaseItemQuantity('${row.id}')">+</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.decreaseItemQuantity('${row.id}')">-</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.editInventoryItem('${row.id}')">‚úèÔ∏è ${this.t('edit')}</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="item" data-id="${row.id}">üóëÔ∏è ${this.t('delete')}</button>
                `);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Quantity</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION / FORECAST FUNCTIONS ============

            renderPreparation() {
                const container = document.getElementById('preparation');
                const today = new Date().toISOString().split('T')[0];
                const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                const nextWeek = new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('preparationForecast')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('itemsToPrep')}</p>
                        </div>

                        <div class="card">
                            <h3>${this.t('selectDateRange')}</h3>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('today')">${this.t('today')}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('tomorrow')">${this.t('tomorrow') || 'Tomorrow'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('week')">${this.t('next7Days') || 'Next 7 Days'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('month')">${this.t('next30Days') || 'Next 30 Days'}</button>
                            </div>
                            <div class="form-row">
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('from')}</label>
                                    <input type="date" id="forecastStartDate" class="form-input" value="${today}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('to')}</label>
                                    <input type="date" id="forecastEndDate" class="form-input" value="${tomorrow}">
                                </div>
                                <div style="display: flex; align-items: flex-end;">
                                    <button class="btn btn-primary" onclick="OMS.generateForecast()" style="height: fit-content;">
                                        üîç ${this.t('generateReport')}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="forecastResults"></div>
                    </div>
                `;

                // Auto-generate forecast for tomorrow by default
                setTimeout(() => this.generateForecast(), 100);
            },

            quickForecast(period) {
                const today = new Date();
                const startInput = document.getElementById('forecastStartDate');
                const endInput = document.getElementById('forecastEndDate');

                let start = new Date(today);
                let end = new Date(today);

                switch(period) {
                    case 'today':
                        // Start and end are same (today)
                        break;
                    case 'tomorrow':
                        start.setDate(start.getDate() + 1);
                        end.setDate(end.getDate() + 1);
                        break;
                    case 'week':
                        end.setDate(end.getDate() + 7);
                        break;
                    case 'month':
                        end.setDate(end.getDate() + 30);
                        break;
                }

                startInput.value = start.toISOString().split('T')[0];
                endInput.value = end.toISOString().split('T')[0];

                this.generateForecast();
            },

            async generateForecast() {
                const startDate = Utils.get('forecastStartDate');
                const endDate = Utils.get('forecastEndDate');

                if (!startDate || !endDate) {
                    this.showToast('Please select both start and end dates', 'error');
                    return;
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (end < start) {
                    this.showToast('End date must be after start date', 'error');
                    return;
                }

                // Get orders in date range
                const ordersInRange = this.getOrdersInDateRange(startDate, endDate);

                // Aggregate items from all orders
                const itemsMap = new Map();
                const orderItemsMap = new Map(); // Track which orders use which items

                ordersInRange.forEach(order => {
                    const items = this.getItemsFromOrder(order, startDate, endDate);

                    items.forEach(item => {
                        // Aggregate quantities
                        const current = itemsMap.get(item.name) || 0;
                        itemsMap.set(item.name, current + item.quantity);

                        // Track order references
                        if (!orderItemsMap.has(item.name)) {
                            orderItemsMap.set(item.name, []);
                        }
                        orderItemsMap.get(item.name).push({
                            orderId: order.orderId,
                            clientName: order.clientName,
                            quantity: item.quantity
                        });
                    });
                });

                // Convert to array and sort by quantity (descending)
                const aggregatedItems = Array.from(itemsMap, ([name, quantity]) => {
                    // Find matching inventory item
                    const inventoryItem = this.data.inventory.items.find(i =>
                        i.name.toLowerCase() === name.toLowerCase()
                    );

                    return {
                        name,
                        required: quantity,
                        inStock: inventoryItem ? inventoryItem.quantity : 0,
                        difference: inventoryItem ? inventoryItem.quantity - quantity : -quantity,
                        orders: orderItemsMap.get(name) || []
                    };
                }).sort((a, b) => b.required - a.required);

                // Fetch weather for the start date
                const weatherApiKey = this.data.settings.weatherApiKey || '';
                const defaultCity = this.data.settings.defaultCity || 'Delhi';
                const weatherData = await Utils.getWeatherForecast(defaultCity, startDate, weatherApiKey);

                // Render forecast results
                this.renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate, weatherData);
            },

            getOrdersInDateRange(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);

                return this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day orders, check if any day falls in range
                        const orderStart = new Date(order.startDate);
                        const orderEnd = new Date(order.endDate);

                        // Check for overlap: order overlaps if it starts before range ends AND ends after range starts
                        return orderStart <= end && orderEnd >= start;
                    } else {
                        // For single-day orders
                        const orderDate = new Date(order.date);
                        return orderDate >= start && orderDate <= end;
                    }
                });
            },

            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            renderForecastResults(orders, items, startDate, endDate, weatherData = null) {
                const container = document.getElementById('forecastResults');

                if (orders.length === 0) {
                    container.innerHTML = `
                        <div class="card" style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <h3>üì≠ ${this.t('noOrdersFoundShort')}</h3>
                            <p>${this.t('noOrdersScheduledBetween')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate statistics
                const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
                const pendingOrders = orders.filter(o => o.status !== 'Confirmed' && o.status !== 'Completed').length;
                const completedOrders = orders.filter(o => o.status === 'Completed').length;
                const totalItems = items.reduce((sum, item) => sum + item.required, 0);
                const shortageItems = items.filter(i => i.difference < 0);
                const okItems = items.filter(i => i.difference >= 0);

                // Calculate dry ice, flowers, and electricity requirements
                // Find all dry ice machines (items containing "dry ice")
                const dryMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return name.includes('dry ice');
                }).reduce((sum, item) => sum + item.required, 0);

                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Find all flower shower machines (items containing "flower shower" or "flower" and "shower")
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                }).reduce((sum, item) => sum + item.required, 0);

                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name.toLowerCase();

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 1;
                    }
                });

                container.innerHTML = `
                    <!-- Summary Cards -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 1.5rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">üìä ${this.t('summary')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${orders.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalOrders')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${confirmedOrders}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ ${this.t('confirmed')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${items.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('uniqueItems')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${totalItems}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalQuantity')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: ${shortageItems.length > 0 ? '#fca5a5' : '#86efac'};">${shortageItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚ö†Ô∏è ${this.t('shortages')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: #86efac;">${okItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ ${this.t('sufficient')}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Weather Forecast Card -->
                    ${weatherData ? `
                    <div class="card" style="background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">üå§Ô∏è Weather Forecast for ${Utils.formatDate(startDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 3rem; margin-bottom: 0.5rem;">${Utils.getWeatherEmoji(weatherData.condition)}</div>
                                <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.25rem;">${weatherData.condition}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${weatherData.description}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">üå°Ô∏è Temperature</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.temp}¬∞C</div>
                                ${weatherData.tempMin && weatherData.tempMax ? `
                                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem;">
                                        ${weatherData.tempMin}¬∞C - ${weatherData.tempMax}¬∞C
                                    </div>
                                ` : ''}
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">üíß Humidity</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.humidity}%</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">üìç Location</div>
                                <div style="font-size: 1.2rem; font-weight: 600;">${this.data.settings.defaultCity || 'Delhi'}</div>
                                <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.5rem;">
                                    ${weatherData.temp === 'N/A' ? 'Weather unavailable' : 'Live forecast'}
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Materials Calculation Card -->
                    ${(dryMachines > 0 || flowerShowerMachines > 0 || totalElectricityKV > 0) ? `
                    <div class="card" style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">üßä Materials Required</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                            ${dryMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">‚ùÑÔ∏è</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Dry Ice Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${dryIceNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    üì¶ ${dryMachines} dry machine(s) √ó 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${flowerShowerMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">üå∏</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Flowers Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${flowersNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    üå∫ ${flowerShowerMachines} flower shower machine(s) √ó 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${totalElectricityKV > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">‚ö°</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Electricity Required</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${totalElectricityKV} KV</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    ‚ö° 3 KV items: ${items.filter(i => electricity3KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs | 1 KV items: ${items.filter(i => electricity1KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Export Buttons -->
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="OMS.printForecast()">üñ®Ô∏è ${this.t('print')}</button>
                        <button class="btn btn-info" onclick="OMS.exportForecastPDF()">${this.t('exportPDF')}</button>
                        <button class="btn btn-warning" onclick="OMS.shareForecastWhatsApp()">${this.t('shareWhatsApp')}</button>
                    </div>

                    <!-- Items Table -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üì¶ ${this.t('itemsPreparationList')}</h3>
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th style="width: 5%;">${this.t('sr')}</th>
                                        <th style="width: 25%;">${this.t('itemName')}</th>
                                        <th style="width: 10%;">${this.t('required')}</th>
                                        <th style="width: 10%;">${this.t('inStock')}</th>
                                        <th style="width: 10%;">${this.t('difference')}</th>
                                        <th style="width: 10%;">${this.t('status')}</th>
                                        <th style="width: 30%;">${this.t('usedInOrders')}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${items.map((item, index) => {
                                        const statusBadge = item.difference >= 0
                                            ? `<span style="background: var(--success); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚úÖ ${this.t('ok')}</span>`
                                            : `<span style="background: var(--danger); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚ö†Ô∏è ${this.t('short')} ${item.difference}</span>`;

                                        const ordersText = item.orders.slice(0, 3).map(o => o.orderId).join(', ') +
                                            (item.orders.length > 3 ? ` +${item.orders.length - 3} ${this.t('more')}` : '');

                                        return `
                                            <tr style="background: ${item.difference < 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'};">
                                                <td>${index + 1}</td>
                                                <td><strong>${item.name}</strong></td>
                                                <td><strong>${item.required}</strong></td>
                                                <td>${item.inStock}</td>
                                                <td style="color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                </td>
                                                <td>${statusBadge}</td>
                                                <td>
                                                    <small style="color: var(--text-gray);">${ordersText}</small>
                                                    <button class="btn btn-secondary btn-small" onclick="OMS.showItemOrderDetails('${item.name.replace(/'/g, "\\'")}')"> ${this.t('details')}</button>
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                                <tfoot>
                                    <tr style="background: var(--light); font-weight: 700;">
                                        <td colspan="2">${this.t('grandTotal')}</td>
                                        <td>${totalItems}</td>
                                        <td>${items.reduce((sum, i) => sum + i.inStock, 0)}</td>
                                        <td style="color: ${items.reduce((sum, i) => sum + i.difference, 0) >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                            ${items.reduce((sum, i) => sum + i.difference, 0)}
                                        </td>
                                        <td colspan="2"></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Orders Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üìã ${this.t('orderDetailsBreakdown')}</h3>
                        </div>
                        <div style="display: grid; gap: 1rem;">
                            ${orders.map(order => {
                                const items = this.getItemsFromOrder(order, startDate, endDate);
                                const statusColor = {
                                    'Confirmed': 'var(--success)',
                                    'Completed': 'var(--info)',
                                    'Cancelled': 'var(--danger)'
                                }[order.status] || 'var(--warning)';

                                return `
                                    <div style="border: 2px solid var(--border); border-radius: var(--radius); padding: 1rem; background: var(--bg-card);">
                                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                                            <div>
                                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--primary);">${order.orderId}</div>
                                                <div style="color: var(--text-dark); font-weight: 500;">${order.clientName}</div>
                                                <div style="font-size: 0.9rem; color: var(--text-gray);">
                                                    üìç ${order.venue} |
                                                    üìÖ ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)} |
                                                    üïê ${order.readyTime || 'N/A'}
                                                </div>
                                            </div>
                                            <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                ${order.status || 'Pending'}
                                            </span>
                                        </div>
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                                            <strong style="font-size: 0.9rem; color: var(--text-gray);">Items Required:</strong>
                                            <div style="margin-top: 0.25rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                ${items.map(item => `
                                                    <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                        ${item.name}: <strong>${item.quantity}</strong>
                                                    </span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                // Store current forecast data for export
                this.currentForecastData = {
                    orders,
                    items,
                    startDate,
                    endDate,
                    weatherData,
                    stats: {
                        totalOrders: orders.length,
                        confirmed: confirmedOrders,
                        pending: pendingOrders,
                        completed: completedOrders,
                        totalItems: totalItems,
                        shortages: shortageItems.length,
                        sufficient: okItems.length
                    }
                };

                // Set up weather auto-refresh for preparation tab (every 15 minutes)
                if (this.preparationWeatherInterval) {
                    clearInterval(this.preparationWeatherInterval);
                }
                this.preparationWeatherInterval = setInterval(() => this.updatePreparationWeather(), 900000);
            },

            async updatePreparationWeather() {
                if (!this.currentForecastData || !this.currentForecastData.startDate) return;

                try {
                    const weatherApiKey = this.data.settings.weatherApiKey || '';
                    const defaultCity = this.data.settings.defaultCity || 'Delhi';
                    const weatherData = await Utils.getWeatherForecast(defaultCity, this.currentForecastData.startDate, weatherApiKey);

                    // Update the stored weather data
                    this.currentForecastData.weatherData = weatherData;

                    // Re-render the forecast results with updated weather
                    this.renderForecastResults(
                        this.currentForecastData.orders,
                        this.currentForecastData.items,
                        this.currentForecastData.startDate,
                        this.currentForecastData.endDate,
                        weatherData
                    );
                } catch (error) {
                    console.error('Error updating preparation weather:', error);
                }
            },

            showItemOrderDetails(itemName) {
                if (!this.currentForecastData) return;

                const item = this.currentForecastData.items.find(i => i.name === itemName);
                if (!item) return;

                const ordersHtml = item.orders.map(o => `
                    <div style="padding: 0.75rem; border-bottom: 1px solid var(--border);">
                        <div style="font-weight: 600; color: var(--primary);">${o.orderId}</div>
                        <div style="color: var(--text-gray); font-size: 0.9rem;">${o.clientName}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                Quantity: <strong>${o.quantity}</strong>
                            </span>
                        </div>
                    </div>
                `).join('');

                this.showModal(`üì¶ ${itemName}`, `
                    <div style="margin-bottom: 1rem;">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${item.required}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Required</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);">${item.inStock}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">In Stock</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Difference</div>
                            </div>
                        </div>
                    </div>
                    <h3 style="margin-bottom: 0.5rem;">Used in ${item.orders.length} order(s):</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: var(--radius);">
                        ${ordersHtml}
                    </div>
                `);
            },

            printForecast() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to print', 'error');
                    return;
                }

                const { items, orders, startDate, endDate, stats } = this.currentForecastData;

                const printWindow = window.open('', '', 'width=800,height=600');
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Preparation Forecast - ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #667eea; margin-top: 20px; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #667eea; color: white; }
                            .shortage { background: #fee; color: #c00; font-weight: bold; }
                            .ok { background: #efe; color: #060; font-weight: bold; }
                            .summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
                            .summary-card { border: 2px solid #667eea; padding: 15px; border-radius: 8px; text-align: center; }
                            .summary-card .value { font-size: 2rem; font-weight: bold; color: #667eea; }
                            .summary-card .label { color: #666; margin-top: 5px; }
                            @media print {
                                button { display: none; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>üìã Preparation & Forecast Report</h1>
                        <p><strong>Period:</strong> ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</p>
                        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

                        <div class="summary">
                            <div class="summary-card">
                                <div class="value">${stats.totalOrders}</div>
                                <div class="label">Total Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${items.length}</div>
                                <div class="label">Unique Items</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.totalItems}</div>
                                <div class="label">Total Quantity</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.confirmed}</div>
                                <div class="label">Confirmed Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: ${stats.shortages > 0 ? '#c00' : '#060'};">${stats.shortages}</div>
                                <div class="label">Items Short</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: #060;">${stats.sufficient}</div>
                                <div class="label">Items OK</div>
                            </div>
                        </div>

                        <h2>üì¶ Items Preparation List</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Sr</th>
                                    <th>Item Name</th>
                                    <th>Required</th>
                                    <th>In Stock</th>
                                    <th>Difference</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr class="${item.difference < 0 ? 'shortage' : ''}">
                                        <td>${index + 1}</td>
                                        <td><strong>${item.name}</strong></td>
                                        <td>${item.required}</td>
                                        <td>${item.inStock}</td>
                                        <td class="${item.difference >= 0 ? 'ok' : 'shortage'}">
                                            ${item.difference >= 0 ? '+' : ''}${item.difference}
                                        </td>
                                        <td>${item.difference >= 0 ? '‚úÖ OK' : '‚ö†Ô∏è SHORT'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <h2>üìã Orders Summary</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order ID</th>
                                    <th>Client</th>
                                    <th>Venue</th>
                                    <th>Date</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${orders.map(order => `
                                    <tr>
                                        <td>${order.orderId}</td>
                                        <td>${order.clientName}</td>
                                        <td>${order.venue}</td>
                                        <td>${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}</td>
                                        <td>${order.status || 'Pending'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <button onclick="window.print()" style="background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-top: 20px;">
                            üñ®Ô∏è Print This Report
                        </button>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            },

            exportForecastPDF() {
                this.showToast('PDF export coming soon! Use Print for now.', 'info');
                // Future: Implement PDF generation using jsPDF or similar
            },

            shareForecastWhatsApp() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to share', 'error');
                    return;
                }

                const { items, startDate, endDate, stats } = this.currentForecastData;

                // Create WhatsApp message
                let message = `üìã *PREPARATION FORECAST*\n\n`;
                message += `üìÖ *Period:* ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}\n\n`;
                message += `üìä *SUMMARY*\n`;
                message += `‚Ä¢ Total Orders: ${stats.totalOrders}\n`;
                message += `‚Ä¢ Confirmed: ${stats.confirmed}\n`;
                message += `‚Ä¢ Total Items: ${items.length}\n`;
                message += `‚Ä¢ Total Quantity: ${stats.totalItems}\n`;
                message += `‚Ä¢ Shortages: ${stats.shortages}\n\n`;

                message += `üì¶ *ITEMS NEEDED*\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;

                items.forEach((item, index) => {
                    const status = item.difference >= 0 ? '‚úÖ' : '‚ö†Ô∏è';
                    message += `${index + 1}. ${item.name}\n`;
                    message += `   Required: ${item.required} | Stock: ${item.inStock} | ${item.difference >= 0 ? '+' : ''}${item.difference} ${status}\n`;
                });

                message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `Generated: ${new Date().toLocaleString()}\n`;
                message += `\n_Powered by FirepowerSFX Admin_`;

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCustomers() {
                const container = document.getElementById('customers');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('customers')}</h2>
                        </div>
                        <div class="form-row">
                            <input type="text" id="customerSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}">
                            <button class="btn btn-primary" onclick="OMS.refreshCustomerDatabase()">üîÑ ${this.t('reset')}</button>
                        </div>
                        <div id="customersContainer"></div>
                    </div>
                `;

                this.renderTable('customersContainer', [
                    { key: 'name', label: this.t('customerName') },
                    { key: 'contact', label: this.t('contact') },
                    { key: 'totalOrders', label: this.t('totalOrdersCount') },
                    { key: 'lastOrderDate', label: this.t('lastOrder'), render: c => Utils.formatDate(c.lastOrderDate) }
                ], this.data.customers, (row) => `
                    <button class="btn btn-secondary btn-small" onclick="OMS.viewCustomerOrders('${row.id}')">${this.t('viewOrders')}</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.createOrderForCustomer('${row.id}')">${this.t('orders')}</button>
                `);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('history');
                // Filter logic would go here
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ TEAM MANAGEMENT ============

            renderTeam() {
                const container = document.getElementById('team');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('teamManagement')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('teamManagement')}</p>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('addTeamMember')}</h3>
                            </div>
                            <div class="form-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="form-group">
                                    <label class="form-label required">${this.t('memberName')}</label>
                                    <input type="text" id="teamMemberName" class="form-input" placeholder="e.g., Rajesh Kumar">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('phoneNumber')}</label>
                                    <input type="tel" id="teamMemberWhatsApp" class="form-input" placeholder="e.g., +91 98765 43210">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('email')}</label>
                                    <input type="email" id="teamMemberEmail" class="form-input" placeholder="e.g., rajesh@example.com">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('status')}</label>
                                    <select id="teamMemberStatus" class="form-select">
                                        <option value="Active">${this.t('active')}</option>
                                        <option value="Inactive">${this.t('inactive')}</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label required">${this.t('roles')}</label>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleDriver" value="Driver" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üöó ${this.t('driver')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleOperator" value="Operator" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>‚öôÔ∏è ${this.t('operator')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleHelper" value="Helper" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ü§ù ${this.t('helpers')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleManager" value="Manager" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üëî Manager</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleSupervisor" value="Supervisor" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üìã Supervisor</span>
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">${this.t('roles')}</label>
                                <input type="text" id="teamMemberSkills" class="form-input" placeholder="e.g., Wedding Expert, Corporate Events, Sound Systems">
                                <small style="color: var(--text-gray);">${this.t('multipleHelpersSeparated')}</small>
                            </div>

                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="OMS.addTeamMember()">${this.t('addTeamMember')}</button>
                                <button class="btn btn-secondary" onclick="OMS.clearTeamForm()">${this.t('clearForm')}</button>
                            </div>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('team')}</h3>
                            </div>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <select id="teamRoleFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('roles')}</option>
                                    <option value="Driver">üöó ${this.t('driver')}</option>
                                    <option value="Operator">‚öôÔ∏è ${this.t('operator')}</option>
                                    <option value="Helper">ü§ù ${this.t('helpers')}</option>
                                    <option value="Manager">üëî Manager</option>
                                    <option value="Supervisor">üìã Supervisor</option>
                                </select>
                                <select id="teamStatusFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('status')}</option>
                                    <option value="Active">${this.t('active')}</option>
                                    <option value="Inactive">${this.t('inactive')}</option>
                                </select>
                                <input type="text" id="teamSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}" oninput="OMS.renderTeamTable()">
                            </div>
                            <div id="teamMembersContainer"></div>
                        </div>

                        <div class="card" id="userRolesCard">
                            <div class="card-header">
                                <h3 class="card-title">üîê User Access Control</h3>
                                <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage user roles and access permissions</p>
                            </div>
                            <div id="userRolesContainer"></div>
                        </div>
                    </div>
                `;

                this.renderTeamTable();
                this.renderUserRoles();
            },

            renderTeamTable() {
                const container = document.getElementById('teamMembersContainer');
                if (!container) return;

                // Get filter values
                const roleFilter = document.getElementById('teamRoleFilter')?.value || '';
                const statusFilter = document.getElementById('teamStatusFilter')?.value || '';
                const searchQuery = document.getElementById('teamSearch')?.value.toLowerCase() || '';

                // Filter team members
                let filteredTeam = this.data.team.filter(member => {
                    const matchesRole = !roleFilter || member.roles.includes(roleFilter);
                    const matchesStatus = !statusFilter || member.status === statusFilter;
                    const matchesSearch = !searchQuery || member.name.toLowerCase().includes(searchQuery);
                    return matchesRole && matchesStatus && matchesSearch;
                });

                if (filteredTeam.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>${this.t('noOrdersFound')}</p>
                        </div>
                    `;
                    return;
                }

                // Render table
                const tableHtml = `
                    <div style="overflow-x: auto;">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>${this.t('memberName')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('phoneNumber')}</th>
                                    <th>${this.t('email')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('status')}</th>
                                    <th>${this.t('actions')}</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${filteredTeam.map(member => {
                                    const roleIcons = {
                                        'Driver': 'üöó',
                                        'Operator': '‚öôÔ∏è',
                                        'Helper': 'ü§ù',
                                        'Manager': 'üëî',
                                        'Supervisor': 'üìã'
                                    };
                                    const roleBadges = member.roles.map(role =>
                                        `<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; margin-right: 0.25rem;">${roleIcons[role] || ''} ${role}</span>`
                                    ).join('');

                                    const statusColor = member.status === 'Active' ? 'var(--success)' : 'var(--text-gray)';
                                    const statusBadge = `<span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">${this.t(member.status.toLowerCase())}</span>`;

                                    return `
                                        <tr>
                                            <td><strong>${member.name}</strong></td>
                                            <td>${roleBadges}</td>
                                            <td>
                                                <a href="https://wa.me/${member.whatsApp.replace(/[^0-9]/g, '')}" target="_blank" style="color: var(--success);">
                                                    ${member.whatsApp}
                                                </a>
                                            </td>
                                            <td>${member.email || '-'}</td>
                                            <td><small>${member.skills && member.skills.length > 0 ? member.skills.join(', ') : '-'}</small></td>
                                            <td>${statusBadge}</td>
                                            <td>
                                                <button class="btn btn-info btn-small" onclick="OMS.editTeamMember('${member.id}')">${this.t('edit')}</button>
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteTeamMember('${member.id}')">${this.t('delete')}</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                container.innerHTML = tableHtml;
            },

            addTeamMember() {
                const name = Utils.get('teamMemberName');
                const whatsApp = Utils.get('teamMemberWhatsApp');
                const email = Utils.get('teamMemberEmail');
                const status = Utils.get('teamMemberStatus');
                const skillsStr = Utils.get('teamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('roleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('roleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('roleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('roleManager')?.checked) roles.push('Manager');
                if (document.getElementById('roleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill Name, WhatsApp, and select at least one Role', 'error');
                    return;
                }

                // Parse skills
                const skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // Create team member object
                const teamMember = {
                    id: Utils.generateId(),
                    name,
                    roles,
                    whatsApp,
                    email: email || '',
                    skills,
                    status,
                    createdAt: new Date().toISOString()
                };

                this.data.team.push(teamMember);
                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(teamMember).then(success => {
                    if (success) {
                        this.showToast(`${name} added to team and synced!`, 'success');
                    } else {
                        this.showToast(`${name} added locally, but sync failed`, 'warning');
                    }
                });

                this.renderTeamTable();
                this.clearTeamForm();
            },

            clearTeamForm() {
                Utils.set('teamMemberName', '');
                Utils.set('teamMemberWhatsApp', '');
                Utils.set('teamMemberEmail', '');
                Utils.set('teamMemberSkills', '');
                Utils.set('teamMemberStatus', 'Active');

                // Uncheck all role checkboxes
                ['roleDriver', 'roleOperator', 'roleHelper', 'roleManager', 'roleSupervisor'].forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) checkbox.checked = false;
                });
            },

            editTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                // Show edit modal
                this.showModal('Edit Team Member', `
                    <div class="form-group">
                        <label class="form-label required">Name</label>
                        <input type="text" id="editTeamMemberName" class="form-input" value="${member.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">WhatsApp Number</label>
                        <input type="tel" id="editTeamMemberWhatsApp" class="form-input" value="${member.whatsApp}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" id="editTeamMemberEmail" class="form-input" value="${member.email || ''}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Status</label>
                        <select id="editTeamMemberStatus" class="form-select">
                            <option value="Active" ${member.status === 'Active' ? 'selected' : ''}>Active</option>
                            <option value="Inactive" ${member.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Roles</label>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleDriver" value="Driver" ${member.roles.includes('Driver') ? 'checked' : ''}>
                                üöó Driver
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleOperator" value="Operator" ${member.roles.includes('Operator') ? 'checked' : ''}>
                                ‚öôÔ∏è Operator
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleHelper" value="Helper" ${member.roles.includes('Helper') ? 'checked' : ''}>
                                ü§ù Helper
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleManager" value="Manager" ${member.roles.includes('Manager') ? 'checked' : ''}>
                                üëî Manager
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleSupervisor" value="Supervisor" ${member.roles.includes('Supervisor') ? 'checked' : ''}>
                                üìã Supervisor
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Skills (comma-separated)</label>
                        <input type="text" id="editTeamMemberSkills" class="form-input" value="${member.skills && member.skills.length > 0 ? member.skills.join(', ') : ''}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTeamMemberEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveTeamMemberEdit(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                const name = Utils.get('editTeamMemberName');
                const whatsApp = Utils.get('editTeamMemberWhatsApp');
                const email = Utils.get('editTeamMemberEmail');
                const status = Utils.get('editTeamMemberStatus');
                const skillsStr = Utils.get('editTeamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('editRoleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('editRoleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('editRoleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('editRoleManager')?.checked) roles.push('Manager');
                if (document.getElementById('editRoleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update member
                member.name = name;
                member.whatsApp = whatsApp;
                member.email = email;
                member.status = status;
                member.roles = roles;
                member.skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];
                member.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(member).then(success => {
                    if (success) {
                        this.showToast('Team member updated and synced!', 'success');
                    } else {
                        this.showToast('Team member updated locally, but sync failed', 'warning');
                    }
                });

                this.renderTeamTable();
                this.closeModal();
            },

            deleteTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                if (confirm(`Are you sure you want to delete ${member.name} from the team?`)) {
                    const index = this.data.team.findIndex(m => m.id === id);
                    if (index !== -1) {
                        const memberName = member.name;

                        this.data.team.splice(index, 1);
                        this.saveToStorage();

                        // Delete from Firestore
                        this.deleteTeamMemberFromFirestore(id).then(success => {
                            if (success) {
                                this.showToast(`${memberName} removed from team and synced!`, 'success');
                            } else {
                                this.showToast(`${memberName} removed locally, but sync failed`, 'warning');
                            }
                        });

                        this.renderTeamTable();
                    }
                }
            },

            // ============ USER ROLES MANAGEMENT (RBAC) ============

            async renderUserRoles() {
                const container = document.getElementById('userRolesContainer');
                if (!container) return;

                const isAdmin = await this.isAdminOrOwner();

                if (!isAdmin) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>‚õî Only Admin and Owner can manage user roles</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = '<div style="text-align: center; padding: 1rem;">Loading users...</div>';

                try {
                    // Fetch all user roles from Firestore
                    const userRolesSnapshot = await db.collection('user_roles').get();
                    const users = [];

                    userRolesSnapshot.forEach(doc => {
                        users.push({
                            uid: doc.id,
                            ...doc.data()
                        });
                    });

                    if (users.length === 0) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                                <p>No users found. Users will appear here after they log in.</p>
                            </div>
                        `;
                        return;
                    }

                    // Render users table
                    const tableHtml = `
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Email</th>
                                        <th>Name</th>
                                        <th>Current Role</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${users.map(user => {
                                        const roleColor = user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3';
                                        const roleBadge = `<span style="background: ${roleColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem; text-transform: uppercase;">${user.role || 'staff'}</span>`;

                                        return `
                                            <tr>
                                                <td><strong>${user.email}</strong></td>
                                                <td>${user.name || '-'}</td>
                                                <td>${roleBadge}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        <div style="margin-top: 1rem; padding: 1rem; background: #fff9c4; border-left: 4px solid #fbc02d; border-radius: 0.25rem;">
                            <strong>‚ö†Ô∏è Role Permissions:</strong>
                            <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                                <li><strong>Admin</strong> - Full access to all features including financials</li>
                                <li><strong>Owner</strong> - Full access to all features including financials</li>
                                <li><strong>Staff</strong> - Limited access (no financial data or payment information)</li>
                            </ul>
                        </div>
                    `;

                    container.innerHTML = tableHtml;

                } catch (error) {
                    console.error('Error loading user roles:', error);
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--danger);">
                            <p>Error loading users: ${error.message}</p>
                        </div>
                    `;
                }
            },

            // ============ TEAM ALLOCATION & NOTIFICATIONS ============

            populateTeamDropdowns() {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');

                // Populate Driver dropdown
                const driverSelect = document.getElementById('driverName');
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Driver 2 dropdown
                const driver2Select = document.getElementById('driverName2');
                if (driver2Select) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driver2Select.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown
                const operatorSelect = document.getElementById('operator');
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}">‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');
                const functionId = `day${dayIndex}func${functionIndex}`;

                // Populate Driver multi-select for this function
                const driverSelect = document.getElementById(`${functionId}Driver`);
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    const currentValues = Array.from(driverSelect.selectedOptions).map(opt => opt.value);
                    driverSelect.innerHTML = drivers.map(d =>
                        `<option value="${d.name}" data-id="${d.id}" ${currentValues.includes(d.name) ? 'selected' : ''}>üöó ${d.name}</option>`
                    ).join('');
                }

                // Populate Operator dropdown for this function
                const operatorSelect = document.getElementById(`${functionId}Operator`);
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    const currentValue = operatorSelect.value;
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}" ${o.name === currentValue ? 'selected' : ''}>‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            updateTeamDropdowns() {
                // Update single-day order form dropdowns
                this.populateTeamDropdowns();

                // Update multiday function dropdowns if they exist
                const multidayData = this.data.multidayOrders || [];
                multidayData.forEach((day, dayIndex) => {
                    if (day.functions) {
                        day.functions.forEach((func, functionIndex) => {
                            this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
                        });
                    }
                });
            },

            notifyAllocatedTeam() {
                // Get current order form data
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v) : [];

                // Get order details
                const orderId = Utils.get('orderId') || 'NEW';
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const date = Utils.get('orderDate');
                const readyTime = Utils.get('readyTime');
                const contact = Utils.get('contact');

                if (!clientName || !venue || !date) {
                    this.showToast('Please fill Order ID, Client Name, Venue, and Date first', 'error');
                    return;
                }

                // Get items from current order
                const items = this.currentOrderItems || [];

                // Collect all team members to notify
                const teamToNotify = [];

                // Prepare team list for messages
                const teamListForMessage = [
                    driverName ? `Driver: ${driverName}` : null,
                    operatorName ? `Operator: ${operatorName}` : null,
                    helperNames.length > 0 ? `Helper(s): ${helperNames.join(', ')}` : null
                ].filter(Boolean).join(', ');

                // Add Driver
                if (driverName) {
                    const driver = this.data.team.find(m => m.name === driverName);
                    if (driver && driver.whatsApp) {
                        teamToNotify.push({ member: driver, role: 'Driver' });
                    }
                }

                // Add Operator
                if (operatorName) {
                    const operator = this.data.team.find(m => m.name === operatorName);
                    if (operator && operator.whatsApp) {
                        teamToNotify.push({ member: operator, role: 'Operator' });
                    }
                }

                // Add ALL Helpers
                if (helperNames.length > 0) {
                    helperNames.forEach(helperName => {
                        const helper = this.data.team.find(m => m.name === helperName);
                        if (helper && helper.whatsApp) {
                            teamToNotify.push({ member: helper, role: 'Helper' });
                        }
                    });
                }

                if (teamToNotify.length === 0) {
                    this.showToast('No team members selected or no WhatsApp numbers found', 'warning');
                    return;
                }

                // Send notifications with delay to prevent popup blocking
                teamToNotify.forEach((item, index) => {
                    setTimeout(() => {
                        this.sendTeamMemberNotification(item.member, item.role, {
                            orderId, clientName, venue, date, readyTime, contact, items,
                            teamList: teamListForMessage
                        });
                    }, index * 500); // 500ms delay between each window
                });

                this.showToast(`Opening WhatsApp for ${teamToNotify.length} team member(s): ${teamToNotify.map(t => t.member.name).join(', ')}`, 'success');

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'team_allocation',
                    orderId,
                    recipients: teamToNotify.map(t => t.member.name),
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);
            },

            sendTeamMemberNotification(teamMember, role, orderDetails) {
                const { orderId, clientName, venue, date, readyTime, contact, items, teamList } = orderDetails;

                // Format items list
                const itemsList = items && items.length > 0
                    ? items.map(item => `‚Ä¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}`).join('\n')
                    : '‚Ä¢ No items added yet';

                // Create WhatsApp message
                let message = `üéâ *NEW ORDER ASSIGNED TO YOU*\n\n`;
                message += `üìã *Order ID:* ${orderId}\n`;
                message += `üë§ *Client:* ${clientName}\n`;
                message += `üìç *Venue:* ${venue}\n`;
                message += `üìÖ *Date:* ${Utils.formatDate(date)}\n`;
                message += `üïê *Ready Time:* ${readyTime || 'TBD'}\n\n`;
                message += `üé≠ *Your Role:* ${role.toUpperCase()}\n\n`;

                if (teamList) {
                    message += `üë∑ *Team Members:*\n${teamList}\n\n`;
                }

                message += `üì¶ *Items Required:*\n${itemsList}\n\n`;

                if (contact) {
                    message += `üìû *Client Contact:* ${contact}\n\n`;
                }

                message += `‚ö° Please confirm receipt by replying "OK"\n\n`;
                message += `--\n_FirepowerSFX Order Management_`;

                // Encode and open WhatsApp
                const phoneNumber = teamMember.whatsApp.replace(/[^0-9]/g, '');
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
            },

            sendManagerReport() {
                // Get all managers
                const managers = this.data.team.filter(m => m.roles.includes('Manager') && m.status === 'Active');

                if (managers.length === 0) {
                    this.showToast('No managers found in team. Add a team member with Manager role first.', 'warning');
                    return;
                }

                // Get the current order data from the form
                const currentOrderId = Utils.get('orderId');
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const currentOrderDate = Utils.get('orderDate');
                const currentStartDate = Utils.get('startDate');
                const eventType = Utils.get('eventTypeSelect');
                const isMultiDay = eventType === 'multi';
                const readyTime = Utils.get('readyTime');
                const status = Utils.get('orderStatus');
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v).join(', ') : '';

                // Check if we have order data in the form
                if (!clientName || !venue) {
                    this.showToast('Please open/select an order first to send report', 'warning');
                    return;
                }

                // Use the order date from the form
                const targetDate = isMultiDay ? currentStartDate : currentOrderDate;

                if (!targetDate) {
                    this.showToast('Order date is missing', 'error');
                    return;
                }

                // Build manager report for THIS SPECIFIC ORDER ONLY
                let message = `üìä *ORDER REPORT*\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

                message += `*ORDER ID:* ${currentOrderId || 'NEW'}\n`;
                message += `üë§ *Client:* ${clientName}\n`;
                message += `üìç *Venue:* ${venue}\n`;
                message += `üìÖ *Date:* ${Utils.formatDate(targetDate)}\n`;
                message += `üïê *Ready Time:* ${readyTime || 'TBD'}\n`;
                message += `üìä *Status:* ${status || 'Pending'}\n\n`;

                if (driverName || operatorName || helperNames) {
                    message += `üë∑ *Team Allocation:*\n`;
                    if (driverName) message += `  ‚Ä¢ Driver: ${driverName}\n`;
                    if (operatorName) message += `  ‚Ä¢ Operator: ${operatorName}\n`;
                    if (helperNames) message += `  ‚Ä¢ Helper(s): ${helperNames}\n`;
                } else {
                    message += `‚ö†Ô∏è *Team Not Allocated Yet*\n`;
                }

                message += `\n`;

                // Get items from current order
                const items = this.currentOrderItems || [];
                if (items.length > 0) {
                    message += `üì¶ *Items Required:*\n`;
                    items.forEach(item => {
                        message += `  ‚Ä¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}\n`;
                    });
                    message += `\n`;
                }

                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `--\n_FirepowerSFX Admin_`;

                // Filter managers with valid WhatsApp numbers
                const managersWithWhatsApp = managers.filter(m => m.whatsApp && m.whatsApp.trim() !== '');

                if (managersWithWhatsApp.length === 0) {
                    this.showToast('No managers have WhatsApp numbers configured', 'warning');
                    return;
                }

                // Send to all managers with delay to prevent popup blocking
                const encodedMessage = encodeURIComponent(message);
                const managerNames = [];

                managersWithWhatsApp.forEach((manager, index) => {
                    const phoneNumber = manager.whatsApp.replace(/[^0-9]/g, '');
                    if (phoneNumber) {
                        managerNames.push(manager.name);
                        // Add delay between each window to prevent popup blocking
                        setTimeout(() => {
                            window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
                        }, index * 500); // 500ms delay between each window
                    }
                });

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'manager_report',
                    recipients: managerNames,
                    orderId: currentOrderId,
                    targetDate: targetDate,
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);

                this.showToast(`Opening WhatsApp for ${managerNames.length} manager(s): ${managerNames.join(', ')}`, 'success');
            },

            renderCalendarTab() {
                document.getElementById('calendar').innerHTML = this.renderCalendar(this.currentCalendarDate || new Date());
            },

            renderHistory() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('orderHistory')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">${this.t('export')}</button>
                        </div>
                        <div class="form-group" style="margin: 20px 0;">
                            <label class="form-label">üîç Search Orders</label>
                            <input type="text" id="historySearch" class="form-input" placeholder="Search by client name, order ID, date, or venue...">
                            <div id="historySearchResults" class="search-dropdown"></div>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;

                // Add search functionality
                this.setupHistorySearch();

                this.renderTable('historyContainer', [
                    { key: 'orderId', label: this.t('orderId'), render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: this.t('client') },
                    { key: 'venue', label: this.t('venue') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${this.t(o.status.toLowerCase())}</span>` }
                ], this.data.orders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('edit')}</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.addPaymentForOrder('${row.docId || row.orderId}')">üíµ Payment</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.addExpenseForOrder('${row.docId || row.orderId}')">üí∏ Expense</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.docId || row.orderId}">${this.t('delete')}</button>
                `);
            },

            setupHistorySearch() {
                const searchInput = document.getElementById('historySearch');
                const searchResults = document.getElementById('historySearchResults');

                if (!searchInput || !searchResults) return;

                let searchTimeout;

                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim().toLowerCase();

                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        searchResults.innerHTML = '';
                        return;
                    }

                    searchTimeout = setTimeout(() => {
                        // Search through all orders
                        const results = this.data.orders.filter(order => {
                            const clientName = (order.clientName || '').toLowerCase();
                            const orderId = (order.orderId || '').toLowerCase();
                            const venue = (order.venue || '').toLowerCase();
                            const date = order.isMultiDay
                                ? `${Utils.formatDate(order.startDate)} ${Utils.formatDate(order.endDate)}`.toLowerCase()
                                : Utils.formatDate(order.date).toLowerCase();

                            return clientName.includes(query) ||
                                   orderId.includes(query) ||
                                   venue.includes(query) ||
                                   date.includes(query);
                        }).slice(0, 10); // Limit to top 10 results

                        if (results.length === 0) {
                            searchResults.innerHTML = '<div class="search-dropdown-item">No orders found</div>';
                            searchResults.style.display = 'block';
                        } else {
                            searchResults.innerHTML = results.map(order => {
                                const dateDisplay = order.isMultiDay
                                    ? `${Utils.formatDate(order.startDate)} - ${Utils.formatDate(order.endDate)}`
                                    : Utils.formatDate(order.date);
                                const statusClass = `status-${order.status.toLowerCase()}`;

                                return `
                                    <div class="search-dropdown-item" data-order-id="${order.docId || order.orderId}" style="cursor: pointer; padding: 10px; border-bottom: 1px solid var(--border-color);">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <strong>${order.orderId || '[No ID]'}</strong> - ${order.clientName}
                                                <br>
                                                <small style="color: var(--text-gray);">
                                                    üìÖ ${dateDisplay} | üìç ${order.venue || 'N/A'}
                                                </small>
                                            </div>
                                            <span class="status-badge ${statusClass}">${order.status}</span>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            searchResults.style.display = 'block';

                            // Add click handlers to search results
                            searchResults.querySelectorAll('.search-dropdown-item').forEach(item => {
                                const orderId = item.getAttribute('data-order-id');
                                if (orderId && orderId !== 'null') {
                                    item.addEventListener('click', () => {
                                        // Find the order
                                        const order = this.data.orders.find(o =>
                                            o.docId === orderId || o.orderId === orderId
                                        );

                                        if (order) {
                                            // Switch to orders tab
                                            this.switchTab('orders');
                                            // Load order into form for editing
                                            this.loadOrderToForm(order);
                                            // Clear search
                                            searchInput.value = '';
                                            searchResults.style.display = 'none';
                                        }
                                    });
                                }
                            });
                        }
                    }, 300); // Debounce 300ms
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            },

            renderAnalytics() {
    const container = document.getElementById('analytics');
    const trackingData = this.data.trackingData || [];
    const orders = this.data.orders || [];

    // Website visitor analytics
    const pageViews = trackingData.filter(t => t.type === 'page_view').length;
    const cartActions = trackingData.filter(t => t.type === 'cart_add' || t.type === 'cart_remove').length;
    const uniqueSessions = [...new Set(trackingData.map(t => t.sessionId))].length;

    // Get device breakdown
    const devices = {};
    trackingData.forEach(t => {
        const device = t.userInfo?.device || 'Unknown';
        devices[device] = (devices[device] || 0) + 1;
    });

    // Get location breakdown
    const locations = {};
    trackingData.forEach(t => {
        const city = t.userInfo?.city || 'Unknown';
        locations[city] = (locations[city] || 0) + 1;
    });

    // Order-based analytics
    const totalOrders = orders.length;
    const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
    const completedOrders = orders.filter(o => o.status === 'Completed').length;
    const cancelledOrders = orders.filter(o => o.status === 'Cancelled').length;

    // Get event type breakdown
    const eventTypes = {};
    orders.forEach(o => {
        const type = o.eventType || 'Other';
        eventTypes[type] = (eventTypes[type] || 0) + 1;
    });

    container.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analyticsReport')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card info">
                    <div class="stat-value">${pageViews}</div>
                    <div class="stat-label">${this.t('analytics')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${uniqueSessions}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${cartActions}</div>
                    <div class="stat-label">${this.t('actions')}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${trackingData.length}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(devices).length > 0 ? Object.entries(devices).map(([device, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${device}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(locations).length > 0 ? Object.entries(locations).slice(0, 8).map(([city, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${city}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('history')}</h3>
            <div class="table-container">
                ${trackingData.length > 0 ? `
                <table class="table">
                    <thead>
                        <tr>
                            <th>${this.t('readyTime')}</th>
                            <th>${this.t('eventType')}</th>
                            <th>${this.t('status')}</th>
                            <th>${this.t('venue')}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${trackingData.slice(0, 20).map(t => {
                            const date = t.timestamp instanceof Date ? t.timestamp : new Date(t.timestamp);
                            const formattedDate = date.toLocaleDateString('en-GB') + ' ' + date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                            const formattedType = (t.type || 'unknown').replace(/_/g, ' ').split(' ').map(word =>
                                word.charAt(0).toUpperCase() + word.slice(1)
                            ).join(' ');

                            return `
                                <tr>
                                    <td>${formattedDate}</td>
                                    <td><span class="status-badge">${formattedType}</span></td>
                                    <td>${t.userInfo?.device || this.t('na')}</td>
                                    <td>${t.userInfo?.city || this.t('na')}${t.userInfo?.country ? ', ' + t.userInfo.country : ''}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
                ` : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analytics')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${totalOrders}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${confirmedOrders}</div>
                    <div class="stat-label">${this.t('confirmedOrders')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${completedOrders}</div>
                    <div class="stat-label">${this.t('completedOrders')}</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value">${cancelledOrders}</div>
                    <div class="stat-label">${this.t('cancelledOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('eventType')}</h3>
            <div class="stats-grid">
                ${Object.entries(eventTypes).length > 0 ? Object.entries(eventTypes).map(([type, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${type}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('customers')}</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${this.data.customers.length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders > 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders === 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${this.data.customers.length > 0 ? Math.round(orders.length / this.data.customers.length * 10) / 10 : 0}</div>
                    <div class="stat-label">${this.t('totalOrdersCount')}</div>
                </div>
            </div>
        </div>
    `;
},

            renderFinancials() {
    const container = document.getElementById('financials');
    const orders = this.data.orders || [];
    const expenses = this.data.expenses || [];
    const payments = this.data.payments || [];

    // Initialize default date range (current month)
    const now = new Date();
    const defaultStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
    const defaultEndDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    // Calculate financial metrics
    const calculateFinancials = (startDate, endDate) => {
        const start = startDate ? new Date(startDate) : defaultStartDate;
        const end = endDate ? new Date(endDate) : defaultEndDate;
        end.setHours(23, 59, 59, 999); // Include the entire end date

        // Filter orders by date range
        const filteredOrders = orders.filter(o => {
            const orderDate = o.orderDate ? new Date(o.orderDate) : new Date(o.createdAt || 0);
            return orderDate >= start && orderDate <= end;
        });

        // Filter expenses by date range
        const filteredExpenses = expenses.filter(e => {
            const expenseDate = e.date ? new Date(e.date) : new Date(e.timestamp?.toDate?.() || 0);
            return expenseDate >= start && expenseDate <= end;
        });

        // Filter payments by date range
        const filteredPayments = payments.filter(p => {
            const paymentDate = p.paymentDate ? new Date(p.paymentDate) : new Date(p.timestamp?.toDate?.() || 0);
            return paymentDate >= start && paymentDate <= end;
        });

        // Calculate revenue
        const totalRevenue = filteredOrders.reduce((sum, o) => {
            const amount = parseFloat(o.financials?.grandTotal || o.totalAmount || 0);
            return sum + amount;
        }, 0);

        // Calculate payments received (filtered by date range)
        const paymentsReceived = filteredPayments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);

        // Calculate total payments received (all time)
        const totalPaymentsReceived = payments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);

        // Calculate outstanding dues
        const outstandingDues = filteredOrders.reduce((sum, o) => {
            const balanceDue = parseFloat(o.financials?.balanceDue || 0);
            return sum + balanceDue;
        }, 0);

        // Calculate total costs
        const directCosts = filteredOrders.reduce((sum, o) => {
            const costs = o.financials?.directCosts?.total || 0;
            return sum + parseFloat(costs);
        }, 0);

        const indirectCosts = filteredExpenses.reduce((sum, e) => {
            if (e.category !== 'Materials Purchase') {
                return sum + parseFloat(e.amount || 0);
            }
            return sum;
        }, 0);

        const totalCosts = directCosts + indirectCosts;

        // Calculate profit
        const grossProfit = totalRevenue - directCosts;
        const netProfit = totalRevenue - totalCosts;
        const profitMargin = totalRevenue > 0 ? ((netProfit / totalRevenue) * 100).toFixed(2) : 0;

        return {
            totalRevenue,
            paymentsReceived,
            totalPaymentsReceived,
            outstandingDues,
            directCosts,
            indirectCosts,
            totalCosts,
            grossProfit,
            netProfit,
            profitMargin,
            ordersCount: filteredOrders.length,
            expensesCount: filteredExpenses.length,
            paymentsCount: filteredPayments.length,
            filteredOrders,
            filteredExpenses,
            filteredPayments
        };
    };

    const metrics = calculateFinancials();

    // Check if user has no financial data - might indicate permission issues
    const hasNoFinancialData = expenses.length === 0 && payments.length === 0;
    const roleSetupWarning = hasNoFinancialData ? `
        <div class="card" style="background: #fff3e0; border-left: 4px solid #ff9800; margin-bottom: 1.5rem;">
            <div style="padding: 1.5rem;">
                <h3 style="color: #f57c00; margin: 0 0 0.5rem 0;">‚ö†Ô∏è No Financial Data Found</h3>
                <p style="margin: 0.5rem 0; color: #666;">
                    If you're seeing this message and can't load expenses or payments, you might not have the proper role configured in Firestore.
                </p>
                <p style="margin: 0.5rem 0; color: #666;">
                    <strong>Check the browser console for permission errors.</strong>
                </p>
                <button onclick="OMS.showRoleSetupDialog()"
                        style="background: #ff9800; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem;">
                    üîê Setup Your Role
                </button>
                <button onclick="window.location.href='setup-admin-users.html'"
                        style="background: #2196F3; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem; margin-left: 0.5rem;">
                    üìñ View Setup Guide
                </button>
            </div>
        </div>
    ` : '';

    container.innerHTML = `
        ${roleSetupWarning}
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üí∞ Financial Management</h2>
            </div>

            <!-- Date Range Selector -->
            <div class="card" style="background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: white;">
                <h3 style="color: white; margin-bottom: 1rem;">üìÖ Date Range Selection</h3>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label" style="color: white;">From Date</label>
                        <input type="date" id="finStartDate" class="form-input" value="${Utils.toDateString(defaultStartDate)}">
                    </div>
                    <div class="form-group">
                        <label class="form-label" style="color: white;">To Date</label>
                        <input type="date" id="finEndDate" class="form-input" value="${Utils.toDateString(defaultEndDate)}">
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('today')">üìÜ Today</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('week')">üìÜ This Week</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('month')">üìÜ This Month</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('quarter')">üìÜ This Quarter</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('year')">üìÜ This Year</button>
                    <button class="btn btn-success" onclick="OMS.applyFinancialRange()">üîç Apply Range</button>
                </div>
            </div>

            <!-- Financial Dashboard -->
            <div class="stats-grid">
                <div class="stat-card success">
                    <div class="stat-value">‚Çπ${metrics.totalRevenue.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Total Revenue</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">‚Çπ${metrics.paymentsReceived.toLocaleString('en-IN')} / ‚Çπ${metrics.totalPaymentsReceived.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Payments Received (Period / All Time)</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">‚Çπ${metrics.outstandingDues.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Outstanding Dues</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value">‚Çπ${metrics.totalCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Total Costs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">‚Çπ${metrics.directCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Direct Costs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">‚Çπ${metrics.indirectCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Indirect/Overhead Costs</div>
                </div>
                <div class="stat-card ${metrics.grossProfit >= 0 ? 'success' : 'danger'}">
                    <div class="stat-value">‚Çπ${metrics.grossProfit.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Gross Profit</div>
                </div>
                <div class="stat-card ${metrics.netProfit >= 0 ? 'success' : 'danger'}">
                    <div class="stat-value">‚Çπ${metrics.netProfit.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Net Profit</div>
                </div>
                <div class="stat-card ${metrics.profitMargin >= 20 ? 'success' : metrics.profitMargin >= 10 ? 'warning' : 'danger'}">
                    <div class="stat-value">${metrics.profitMargin}%</div>
                    <div class="stat-label">Profit Margin</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${metrics.ordersCount}</div>
                    <div class="stat-label">Orders</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${metrics.paymentsCount} / ${payments.length}</div>
                    <div class="stat-label">Payments (Period / Total)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${metrics.expensesCount} / ${expenses.length}</div>
                    <div class="stat-label">Expenses (Period / Total)</div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="btn-group">
                <button class="btn btn-success" onclick="OMS.showAddPaymentModal()">üíµ Add Payment</button>
                <button class="btn btn-warning" onclick="OMS.showAddExpenseModal()">üí∏ Add Expense</button>
                <button class="btn btn-info" onclick="OMS.exportFinancialReport()">üìä Export Report</button>
                <button class="btn btn-primary" onclick="OMS.showMonthlyComparison()">üìà Monthly Comparison</button>
            </div>
        </div>

        <!-- Payments Section -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">üíµ Payment History</h3>
            </div>
            <div class="table-container">
                ${payments.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Order ID</th>
                                <th>Customer</th>
                                <th>Amount</th>
                                <th>Method</th>
                                <th>Transaction ID</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${payments.slice(0, 50).map(p => `
                                <tr>
                                    <td>${Utils.formatDate(p.paymentDate || p.timestamp?.toDate?.())}</td>
                                    <td>${p.orderId || 'N/A'}</td>
                                    <td>${p.customerName || 'N/A'}</td>
                                    <td>‚Çπ${parseFloat(p.amount || 0).toLocaleString('en-IN')}</td>
                                    <td>${p.paymentMethod || 'N/A'}</td>
                                    <td>${p.transactionId || 'N/A'}</td>
                                    <td>
                                        <button class="btn btn-info btn-small" onclick="OMS.editPayment('${p.id}')">Edit</button>
                                        <button class="btn btn-danger btn-small" onclick="OMS.deletePayment('${p.id}')">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No payment records found. Click "Add Payment" to get started.</p>`}
            </div>
        </div>

        <!-- Expenses Section -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">üí∏ Expenses</h3>
            </div>
            <div class="table-container">
                ${expenses.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Category</th>
                                <th>Description</th>
                                <th>Amount</th>
                                <th>Vendor</th>
                                <th>Payment Method</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${expenses.slice(0, 50).map(e => `
                                <tr>
                                    <td>${Utils.formatDate(e.date || e.timestamp?.toDate?.())}</td>
                                    <td><span class="badge">${e.category || 'N/A'}</span></td>
                                    <td>${e.description || 'N/A'}</td>
                                    <td>‚Çπ${parseFloat(e.amount || 0).toLocaleString('en-IN')}</td>
                                    <td>${e.vendor || 'N/A'}</td>
                                    <td>${e.paymentMethod || 'N/A'}</td>
                                    <td>
                                        <button class="btn btn-info btn-small" onclick="OMS.editExpense('${e.id}')">Edit</button>
                                        <button class="btn btn-danger btn-small" onclick="OMS.deleteExpense('${e.id}')">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No expense records found. Click "Add Expense" to get started.</p>`}
            </div>
        </div>

        <!-- Order Financial Details -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">üìä Order-wise Financial Breakdown</h3>
            </div>
            <div class="table-container">
                ${orders.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Order ID</th>
                                <th>Date</th>
                                <th>Customer</th>
                                <th>Revenue</th>
                                <th>Costs</th>
                                <th>Profit</th>
                                <th>Margin %</th>
                                <th>Payment Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${orders.filter(o => o.status === 'Completed' || o.status === 'Confirmed').slice(0, 50).map(o => {
                                const revenue = parseFloat(o.financials?.grandTotal || o.totalAmount || 0);
                                const costs = parseFloat(o.financials?.directCosts?.total || 0);
                                const profit = revenue - costs;
                                const margin = revenue > 0 ? ((profit / revenue) * 100).toFixed(1) : 0;
                                const balanceDue = parseFloat(o.financials?.balanceDue || 0);
                                const paymentStatus = balanceDue === 0 ? 'Paid' : balanceDue >= revenue ? 'Pending' : 'Partial';

                                return `
                                <tr>
                                    <td>${o.orderId || 'Pending'}</td>
                                    <td>${Utils.formatDate(o.orderDate)}</td>
                                    <td>${o.clientName || 'N/A'}</td>
                                    <td>‚Çπ${revenue.toLocaleString('en-IN')}</td>
                                    <td>‚Çπ${costs.toLocaleString('en-IN')}</td>
                                    <td class="${profit >= 0 ? 'success' : 'danger'}">‚Çπ${profit.toLocaleString('en-IN')}</td>
                                    <td class="${margin >= 20 ? 'success' : margin >= 10 ? 'warning' : 'danger'}">${margin}%</td>
                                    <td><span class="badge ${paymentStatus === 'Paid' ? 'success' : paymentStatus === 'Partial' ? 'warning' : 'danger'}">${paymentStatus}</span></td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No orders found for the selected period.</p>`}
            </div>
        </div>
    `;

    // Add event listeners for date inputs
    setTimeout(() => {
        const startDateInput = document.getElementById('finStartDate');
        const endDateInput = document.getElementById('finEndDate');

        if (startDateInput && endDateInput) {
            startDateInput.addEventListener('change', () => OMS.applyFinancialRange());
            endDateInput.addEventListener('change', () => OMS.applyFinancialRange());
        }
    }, 100);
},

            renderSettings() {
                const container = document.getElementById('settings');
                const s = this.data.settings;
                const ts = s.tableSettings;
                const colors = s.printColors;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('systemSettings')}</h2>
                        </div>

                        <div class="card">
                            <h3>${this.t('tableLayoutSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('srColumnWidth')}: <span id="srWidthValue">${ts.columnWidthSr}%</span></label>
                                    <input type="range" id="columnWidthSr" class="form-input" min="5" max="25" value="${ts.columnWidthSr}"
                                           oninput="document.getElementById('srWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('itemColumnWidth')}: <span id="itemWidthValue">${ts.columnWidthItem}%</span></label>
                                    <input type="range" id="columnWidthItem" class="form-input" min="15" max="60" value="${ts.columnWidthItem}"
                                           oninput="document.getElementById('itemWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('qtyColumnWidth')}: <span id="qtyWidthValue">${ts.columnWidthQty}%</span></label>
                                    <input type="range" id="columnWidthQty" class="form-input" min="5" max="30" value="${ts.columnWidthQty}"
                                           oninput="document.getElementById('qtyWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('remarksColumnWidth')}: <span id="remarksWidthValue">${ts.columnWidthRemarks}%</span></label>
                                    <input type="range" id="columnWidthRemarks" class="form-input" min="15" max="60" value="${ts.columnWidthRemarks}"
                                           oninput="document.getElementById('remarksWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('leftMarginFiling')}: <span id="leftMarginValue">${ts.leftMargin}mm</span></label>
                                    <input type="range" id="leftMargin" class="form-input" min="30" max="100" value="${ts.leftMargin}"
                                           oninput="document.getElementById('leftMarginValue').textContent = this.value + 'mm'">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('colorCustomization')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerBackground')}</label>
                                    <input type="color" id="printHeaderBg" class="form-input" value="${colors.headerBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerText')}</label>
                                    <input type="color" id="printHeaderText" class="form-input" value="${colors.headerText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdBackground')}</label>
                                    <input type="color" id="printOrderIdBg" class="form-input" value="${colors.orderIdBg || '#667eea'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdText')}</label>
                                    <input type="color" id="printOrderIdText" class="form-input" value="${colors.orderIdText || '#ffffff'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderBackground')}</label>
                                    <input type="color" id="printTableHeaderBg" class="form-input" value="${colors.tableHeaderBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderText')}</label>
                                    <input type="color" id="printTableHeaderText" class="form-input" value="${colors.tableHeaderText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableBorder')}</label>
                                    <input type="color" id="printTableBorder" class="form-input" value="${colors.tableBorder}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('notesBackground')}</label>
                                    <input type="color" id="printNotesBg" class="form-input" value="${colors.notesBg}" style="height: 50px;">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('printSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('fontSize')}: <span id="fontSizeValue">${s.printFontSize}px</span></label>
                                    <input type="range" id="printFontSize" class="form-input" min="16" max="80" value="${s.printFontSize}"
                                           oninput="document.getElementById('fontSizeValue').textContent = this.value + 'px'">
                                    <small style="color: var(--text-gray);">${this.t('multiOrderNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('paperFormat')}</label>
                                    <select id="paperFormat" class="form-select">
                                        <option value="A4" ${s.paperFormat === 'A4' ? 'selected' : ''}>A4 (210 √ó 297 mm)</option>
                                        <option value="Legal" ${s.paperFormat === 'Legal' ? 'selected' : ''}>Legal (216 √ó 356 mm)</option>
                                        <option value="Letter" ${s.paperFormat === 'Letter' ? 'selected' : ''}>Letter (216 √ó 279 mm)</option>
                                        <option value="A3" ${s.paperFormat === 'A3' ? 'selected' : ''}>A3 (297 √ó 420 mm)</option>
                                        <option value="A5" ${s.paperFormat === 'A5' ? 'selected' : ''}>A5 (148 √ó 210 mm)</option>
                                        <option value="Tabloid" ${s.paperFormat === 'Tabloid' ? 'selected' : ''}>Tabloid (279 √ó 432 mm)</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('chooseFormat')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('pageOrientation')}</label>
                                    <select id="paperOrientation" class="form-select">
                                        <option value="portrait" ${s.paperOrientation === 'portrait' ? 'selected' : ''}>${this.t('portrait')}</option>
                                        <option value="landscape" ${s.paperOrientation === 'landscape' ? 'selected' : ''}>${this.t('landscape')}</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('portraitOrLandscape')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('imageQuality')}</label>
                                    <select id="imageQuality" class="form-select">
                                        <option value="1" ${s.imageQuality === 1 ? 'selected' : ''}>${this.t('low')} (${this.t('faster')})</option>
                                        <option value="2" ${s.imageQuality === 2 ? 'selected' : ''}>${this.t('medium')} (${this.t('balanced')})</option>
                                        <option value="3" ${s.imageQuality === 3 ? 'selected' : ''}>${this.t('high')} (${this.t('betterQuality')})</option>
                                        <option value="4" ${s.imageQuality === 4 ? 'selected' : ''}>${this.t('ultra')} (${this.t('bestQuality')})</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('higherQualityNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('functionColor')}</label>
                                    <input type="color" id="functionColor" class="form-input" value="${s.functionColor || '#667eea'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">${this.t('customColorNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Background Color</label>
                                    <input type="color" id="printBgColor" class="form-input" value="${s.printBgColor || '#ffffff'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">Set the background color for downloaded images</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Text Color</label>
                                    <input type="color" id="printTextColor" class="form-input" value="${s.printTextColor || '#000000'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">Set the text color for downloaded images</small>
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('systemPreferences')}</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('defaultOrderStatus')}</label>
                                    <select id="defaultOrderStatus" class="form-select">
                                        <option value="Confirmed" ${s.defaultOrderStatus === 'Confirmed' ? 'selected' : ''}>${this.t('confirmed')}</option>
                                        <option value="Completed" ${s.defaultOrderStatus === 'Completed' ? 'selected' : ''}>${this.t('completed')}</option>
                                        <option value="Cancelled" ${s.defaultOrderStatus === 'Cancelled' ? 'selected' : ''}>${this.t('cancelled')}</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('lowStockThreshold')}</label>
                                    <input type="number" id="lowStockThreshold" class="form-input" value="${s.lowStockThreshold}" min="1">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('language')}</label>
                                    <select id="appLanguage" class="form-select">
                                        <option value="en" ${s.language === 'en' ? 'selected' : ''}>English</option>
                                        <option value="gu" ${s.language === 'gu' ? 'selected' : ''}>‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('invoiceFormat')}</label>
                                    <select id="invoiceFormat" class="form-select">
                                        <option value="FP" ${s.invoicePrefix === 'FP' ? 'selected' : ''}>FP001</option>
                                        <option value="ORD" ${s.invoicePrefix === 'ORD' ? 'selected' : ''}>ORD001</option>
                                        <option value="INV" ${s.invoicePrefix === 'INV' ? 'selected' : ''}>INV001</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>üå§Ô∏è Weather Integration</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">OpenWeatherMap API Key</label>
                                    <input type="text" id="weatherApiKey" class="form-input" value="${s.weatherApiKey || ''}" placeholder="Enter your API key">
                                    <small style="color: var(--text-gray);">Get a free API key from <a href="https://openweathermap.org/api" target="_blank">OpenWeatherMap</a></small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Default City</label>
                                    <input type="text" id="defaultCity" class="form-input" value="${s.defaultCity || 'Delhi'}" placeholder="Delhi">
                                    <small style="color: var(--text-gray);">Default city for weather data (e.g., Delhi, Mumbai, etc.)</small>
                                </div>
                            </div>
                        </div>

                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="OMS.saveSettings()">${this.t('saveAllSettings')}</button>
                            <button class="btn btn-secondary" onclick="OMS.resetSettings()">${this.t('resetToDefaults')}</button>
                        </div>

                        <div class="card">
                            <h3>${this.t('dataManagement')}</h3>
                            <div class="btn-group">
                                <button class="btn btn-info" data-action="exportData">${this.t('exportJSON')}</button>
                                <button class="btn btn-success" onclick="OMS.exportData('csv')">${this.t('exportCSV')}</button>
                                <button class="btn btn-warning" data-action="importData">${this.t('importBackup')}</button>
                                <button class="btn btn-danger" onclick="OMS.resetAllData()">${this.t('resetAllData')}</button>
                            </div>
                        </div>
                    </div>
                `;
            },

            async saveSettings() {
                // Save table settings
                this.data.settings.tableSettings = {
                    columnWidthSr: parseInt(Utils.get('columnWidthSr')) || 8,
                    columnWidthItem: parseInt(Utils.get('columnWidthItem')) || 40,
                    columnWidthQty: parseInt(Utils.get('columnWidthQty')) || 12,
                    columnWidthRemarks: parseInt(Utils.get('columnWidthRemarks')) || 40,
                    leftMargin: parseInt(Utils.get('leftMargin')) || 50
                };

                // Save colors
                this.data.settings.printColors = {
                    headerBg: Utils.get('printHeaderBg') || '#667eea',
                    headerText: Utils.get('printHeaderText') || '#ffffff',
                    orderIdBg: Utils.get('printOrderIdBg') || '#667eea',
                    orderIdText: Utils.get('printOrderIdText') || '#ffffff',
                    tableHeaderBg: Utils.get('printTableHeaderBg') || '#f8f9fa',
                    tableHeaderText: Utils.get('printTableHeaderText') || '#333333',
                    tableBorder: Utils.get('printTableBorder') || '#333333',
                    notesBg: Utils.get('printNotesBg') || '#f9f9f9'
                };

                // Save other settings
                this.data.settings.printFontSize = parseInt(Utils.get('printFontSize')) || 26;
                this.data.settings.printBgColor = Utils.get('printBgColor') || '#ffffff';
                this.data.settings.printTextColor = Utils.get('printTextColor') || '#000000';
                this.data.settings.defaultOrderStatus = Utils.get('defaultOrderStatus') || 'Confirmed';
                this.data.settings.lowStockThreshold = parseInt(Utils.get('lowStockThreshold')) || 5;
                this.data.settings.language = Utils.get('appLanguage') || 'en';
                this.data.settings.invoicePrefix = Utils.get('invoiceFormat') || 'FP';

                // Save new print settings
                this.data.settings.paperFormat = Utils.get('paperFormat') || 'A4';
                this.data.settings.paperOrientation = Utils.get('paperOrientation') || 'portrait';
                this.data.settings.imageQuality = parseInt(Utils.get('imageQuality')) || 2;
                this.data.settings.functionColor = Utils.get('functionColor') || '#667eea';

                // Save weather settings
                this.data.settings.weatherApiKey = Utils.get('weatherApiKey') || '';
                this.data.settings.defaultCity = Utils.get('defaultCity') || 'Delhi';

                // Save to localStorage
                this.saveToStorage();

                // Save to Firestore for persistence across devices
                const saved = await this.saveSettingsToFirestore();

                if (saved) {
                    this.refreshOrderId();
                    this.showToast('All settings saved successfully!');
                } else {
                    this.showToast('Settings saved locally, but Firestore sync failed. Check permissions.');
                }
            },

            resetAllData() {
                if (!confirm('‚ö†Ô∏è This will delete ALL data permanently. Are you absolutely sure?')) return;
                if (!confirm('Last chance! This action CANNOT be undone. Confirm data reset?')) return;
                
                localStorage.removeItem('oms_data');
                this.showToast('Data reset! Reloading...');
                setTimeout(() => location.reload(), 1000);
            },

            resetSettings() {
                if (!confirm('Reset all settings?')) return;

                this.data.settings = {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: this.data.settings.orderIdCounter,
                    invoicePrefix: 'FP',
                    lowStockThreshold: 5,
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9'
                    },
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                };

                this.saveToStorage();
                this.renderSettings();
                this.showToast('Settings reset!');
            },

            // ============ ITEM SEARCH ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Prevent duplicate event listener registration
                if (itemSearch.dataset.searchInitialized === 'true') return;
                itemSearch.dataset.searchInitialized = 'true';

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                // Capture OMS context
                const self = this;

                const handleSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const items = self.data.inventory.items.filter(i =>
                            i.name.toLowerCase().includes(query)
                        );

                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                itemSearch.addEventListener('input', Utils.debounce(handleSearch, 300));

                // Initialize client name search with autocomplete
                this.initClientSearch();
            },

            initClientSearch() {
                const clientInput = document.getElementById('clientName');
                const dropdown = document.getElementById('clientSearchDropdown');

                if (!clientInput || !dropdown) return;

                // Prevent duplicate event listener registration
                if (clientInput.dataset.searchInitialized === 'true') return;
                clientInput.dataset.searchInitialized = 'true';

                // Capture OMS context
                const self = this;

                const handleClientSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const customers = self.data.customers.filter(c =>
                            c.name.toLowerCase().includes(query)
                        );

                        if (customers.length > 0) {
                            dropdown.innerHTML = customers.map(c => `
                                <div class="search-item" onclick="OMS.selectCustomer('${c.id}')">
                                    <span>${c.name}</span>
                                    <span style="color: var(--text-gray);">${c.contact}</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                clientInput.addEventListener('input', Utils.debounce(handleClientSearch, 300));

                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!clientInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            },

            selectCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                // Auto-fill customer name and contact
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);

                // Hide dropdown
                document.getElementById('clientSearchDropdown').classList.remove('show');

                this.showToast(`Selected: ${customer.name}`, 'success');
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;
                
                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }
                
                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;
                
                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }
                
                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)" 
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}" 
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ FINANCIAL MANAGEMENT ============

            setFinancialRange(range) {
                const now = new Date();
                let startDate, endDate;

                switch(range) {
                    case 'today':
                        startDate = endDate = now;
                        break;
                    case 'week':
                        startDate = new Date(now.setDate(now.getDate() - now.getDay()));
                        endDate = new Date(now.setDate(startDate.getDate() + 6));
                        break;
                    case 'month':
                        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        break;
                    case 'quarter':
                        const quarter = Math.floor(now.getMonth() / 3);
                        startDate = new Date(now.getFullYear(), quarter * 3, 1);
                        endDate = new Date(now.getFullYear(), quarter * 3 + 3, 0);
                        break;
                    case 'year':
                        startDate = new Date(now.getFullYear(), 0, 1);
                        endDate = new Date(now.getFullYear(), 11, 31);
                        break;
                }

                Utils.set('finStartDate', Utils.toDateString(startDate));
                Utils.set('finEndDate', Utils.toDateString(endDate));
            },

            applyFinancialRange() {
                this.renderFinancials();
            },

            async showAddPaymentModal() {
                const orders = this.data.orders.filter(o => o.status !== 'Cancelled');

                const modalHTML = `
                    <div class="modal-overlay" id="paymentModal">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('paymentModal')">√ó</button>
                            <h2>üíµ Add Payment</h2>
                            <form id="paymentForm" onsubmit="OMS.savePayment(event)">
                                <div class="form-group">
                                    <label class="form-label required">Order</label>
                                    <select id="paymentOrderId" class="form-select" required onchange="OMS.updatePaymentOrderInfo()">
                                        <option value="">Select Order</option>
                                        ${orders.map(o => `<option value="${o.docId || o.orderId}">${o.orderId || 'Pending'} - ${o.clientName} (‚Çπ${parseFloat(o.financials?.balanceDue || o.totalAmount || 0).toLocaleString('en-IN')} due)</option>`).join('')}
                                    </select>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="paymentDate" class="form-input" value="${Utils.toDateString(new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="paymentAmount" class="form-input" min="1" step="0.01" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="paymentMethod" class="form-select" required>
                                            <option value="Cash">Cash</option>
                                            <option value="UPI">UPI</option>
                                            <option value="Bank Transfer">Bank Transfer</option>
                                            <option value="Cheque">Cheque</option>
                                            <option value="Card">Card</option>
                                            <option value="Other">Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="paymentTransactionId" class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="paymentNotes" class="form-textarea" rows="3"></textarea>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">üíæ Save Payment</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('paymentModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            updatePaymentOrderInfo() {
                const orderId = Utils.get('paymentOrderId');
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);
                if (order) {
                    const balanceDue = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                    Utils.set('paymentAmount', balanceDue);
                }
            },

            async savePayment(event) {
                event.preventDefault();

                const orderId = Utils.get('paymentOrderId');
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                if (!order) {
                    this.showToast('Order not found!', 'error');
                    return;
                }

                const payment = {
                    orderId: order.orderId || 'Pending',
                    orderDocId: order.docId,
                    customerName: order.clientName,
                    amount: parseFloat(Utils.get('paymentAmount')),
                    paymentDate: Utils.get('paymentDate'),
                    paymentMethod: Utils.get('paymentMethod'),
                    transactionId: Utils.get('paymentTransactionId'),
                    notes: Utils.get('paymentNotes'),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };

                try {
                    const docRef = await db.collection('payments').add(payment);
                    payment.id = docRef.id;
                    this.data.payments.push(payment);

                    // Update order balance
                    const currentBalance = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                    const newBalance = currentBalance - payment.amount;
                    const advancePaid = parseFloat(order.financials?.advancePaid || 0) + payment.amount;

                    await db.collection('orders').doc(order.docId).update({
                        'financials.advancePaid': advancePaid,
                        'financials.balanceDue': Math.max(0, newBalance),
                        'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < (order.financials?.grandTotal || order.totalAmount || 0) ? 'partial' : 'pending'
                    });

                    this.showToast('Payment added successfully!', 'success');
                    this.closeModal('paymentModal');
                    this.renderFinancials();
                    await this.loadOrdersFromFirestore();
                } catch (error) {
                    console.error('Error saving payment:', error);
                    this.showToast('Error saving payment: ' + error.message, 'error');
                }
            },

            async showAddExpenseModal() {
                const modalHTML = `
                    <div class="modal-overlay" id="expenseModal">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('expenseModal')">√ó</button>
                            <h2>üí∏ Add Expense</h2>
                            <form id="expenseForm" onsubmit="OMS.saveExpense(event)">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Date</label>
                                        <input type="date" id="expenseDate" class="form-input" value="${Utils.toDateString(new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="expenseAmount" class="form-input" min="1" step="0.01" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Category</label>
                                        <select id="expenseCategory" class="form-select" required>
                                            <option value="Materials Purchase">Materials Purchase</option>
                                            <option value="Salaries & Wages">Salaries & Wages</option>
                                            <option value="Transportation & Fuel">Transportation & Fuel</option>
                                            <option value="Equipment Maintenance">Equipment Maintenance</option>
                                            <option value="Rent & Utilities">Rent & Utilities</option>
                                            <option value="Marketing & Advertising">Marketing & Advertising</option>
                                            <option value="Office Supplies">Office Supplies</option>
                                            <option value="Insurance">Insurance</option>
                                            <option value="Taxes & Licenses">Taxes & Licenses</option>
                                            <option value="Miscellaneous">Miscellaneous</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Vendor/Supplier</label>
                                        <input type="text" id="expenseVendor" class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Description</label>
                                    <input type="text" id="expenseDescription" class="form-input" required>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Payment Method</label>
                                    <select id="expensePaymentMethod" class="form-select">
                                        <option value="Cash">Cash</option>
                                        <option value="UPI">UPI</option>
                                        <option value="Bank Transfer">Bank Transfer</option>
                                        <option value="Cheque">Cheque</option>
                                        <option value="Card">Card</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">üíæ Save Expense</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('expenseModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async saveExpense(event) {
                event.preventDefault();

                const expense = {
                    date: Utils.get('expenseDate'),
                    amount: parseFloat(Utils.get('expenseAmount')),
                    category: Utils.get('expenseCategory'),
                    vendor: Utils.get('expenseVendor'),
                    description: Utils.get('expenseDescription'),
                    paymentMethod: Utils.get('expensePaymentMethod'),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };

                try {
                    const docRef = await db.collection('expenses').add(expense);
                    expense.id = docRef.id;
                    this.data.expenses.push(expense);

                    this.showToast('Expense added successfully!', 'success');
                    this.closeModal('expenseModal');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error saving expense:', error);
                    this.showToast('Error saving expense: ' + error.message, 'error');
                }
            },

            addPaymentForOrder(orderId) {
                // Open payment modal with pre-selected order
                this.showAddPaymentModal();
                setTimeout(() => {
                    Utils.set('paymentOrderId', orderId);
                    this.updatePaymentOrderInfo();
                }, 100);
            },

            addExpenseForOrder(orderId) {
                // Open expense modal with order info in notes
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);
                this.showAddExpenseModal();
                if (order) {
                    setTimeout(() => {
                        const notes = `Related to Order: ${order.orderId || 'Pending'} - ${order.clientName}`;
                        Utils.set('expenseDescription', notes);
                    }, 100);
                }
            },

            quickAddPayment() {
                // Check if there's a current order being edited or if we need to save first
                const clientName = Utils.get('clientName');
                const orderId = Utils.get('orderId');
                const orderStatus = Utils.get('orderStatus');

                if (!clientName) {
                    this.showToast('‚ö†Ô∏è Please fill in client name first', 'warning');
                    return;
                }

                // Show a simplified payment modal for the current order
                const modalHTML = `
                    <div class="modal-overlay" id="quickPaymentModal">
                        <div class="modal-content" style="max-width: 500px;">
                            <button class="modal-close" onclick="OMS.closeModal('quickPaymentModal')">√ó</button>
                            <h2>üíµ Quick Payment</h2>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">
                                For order: <strong>${orderId || 'New Order'} - ${clientName}</strong>
                            </p>
                            <form id="quickPaymentForm" onsubmit="OMS.saveQuickPayment(event)">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="quickPaymentDate" class="form-input" value="${Utils.toDateString(new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount (‚Çπ)</label>
                                        <input type="number" id="quickPaymentAmount" class="form-input" min="1" step="0.01" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="quickPaymentMethod" class="form-select" required>
                                            <option value="Cash">Cash</option>
                                            <option value="UPI">UPI</option>
                                            <option value="Bank Transfer">Bank Transfer</option>
                                            <option value="Cheque">Cheque</option>
                                            <option value="Card">Card</option>
                                            <option value="Other">Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="quickPaymentTransactionId" class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="quickPaymentNotes" class="form-textarea" rows="2"></textarea>
                                </div>
                                <div class="alert" style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                                    <strong>‚ÑπÔ∏è Note:</strong> The order will be saved first before recording the payment.
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">üíæ Save Payment</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('quickPaymentModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async saveQuickPayment(event) {
                event.preventDefault();

                try {
                    // First, save the current order if it doesn't have a docId
                    if (!this.editingDocId) {
                        this.showToast('üìù Saving order first...', 'info');
                        await this.saveOrder();

                        // Wait a bit for the order to be saved and assigned a docId
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        // Check if we have a saved order now
                        const clientName = Utils.get('clientName');
                        const recentOrder = this.data.orders.find(o => o.clientName === clientName);

                        if (!recentOrder || !recentOrder.docId) {
                            this.showToast('‚ùå Could not find saved order. Please try again.', 'error');
                            return;
                        }

                        this.editingDocId = recentOrder.docId;
                    }

                    // Now save the payment
                    const order = this.data.orders.find(o => o.docId === this.editingDocId);

                    if (!order) {
                        this.showToast('Order not found!', 'error');
                        return;
                    }

                    const payment = {
                        orderId: order.orderId || 'Pending',
                        orderDocId: order.docId,
                        customerName: order.clientName,
                        amount: parseFloat(Utils.get('quickPaymentAmount')),
                        paymentDate: Utils.get('quickPaymentDate'),
                        paymentMethod: Utils.get('quickPaymentMethod'),
                        transactionId: Utils.get('quickPaymentTransactionId'),
                        notes: Utils.get('quickPaymentNotes'),
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    const docRef = await db.collection('payments').add(payment);
                    payment.id = docRef.id;
                    this.data.payments.push(payment);

                    // Update order balance
                    const currentBalance = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                    const newBalance = currentBalance - payment.amount;
                    const advancePaid = parseFloat(order.financials?.advancePaid || 0) + payment.amount;

                    await db.collection('orders').doc(order.docId).update({
                        'financials.advancePaid': advancePaid,
                        'financials.balanceDue': Math.max(0, newBalance),
                        'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < (order.financials?.grandTotal || order.totalAmount || 0) ? 'partial' : 'pending'
                    });

                    this.showToast('‚úÖ Payment recorded successfully!', 'success');
                    this.closeModal('quickPaymentModal');
                    await this.loadOrdersFromFirestore();

                } catch (error) {
                    console.error('Error saving quick payment:', error);
                    this.showToast('Error saving payment: ' + error.message, 'error');
                }
            },

            async deletePayment(paymentId) {
                if (!confirm('Are you sure you want to delete this payment record?')) return;

                try {
                    await db.collection('payments').doc(paymentId).delete();
                    this.data.payments = this.data.payments.filter(p => p.id !== paymentId);
                    this.showToast('Payment deleted!', 'success');
                    this.renderFinancials();
                    await this.loadOrdersFromFirestore(); // Reload to update balances
                } catch (error) {
                    console.error('Error deleting payment:', error);
                    this.showToast('Error deleting payment: ' + error.message, 'error');
                }
            },

            async deleteExpense(expenseId) {
                if (!confirm('Are you sure you want to delete this expense record?')) return;

                try {
                    await db.collection('expenses').doc(expenseId).delete();
                    this.data.expenses = this.data.expenses.filter(e => e.id !== expenseId);
                    this.showToast('Expense deleted!', 'success');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error deleting expense:', error);
                    this.showToast('Error deleting expense: ' + error.message, 'error');
                }
            },

            async editPayment(paymentId) {
                const payment = this.data.payments.find(p => p.id === paymentId);
                if (!payment) {
                    this.showToast('Payment not found!', 'error');
                    return;
                }

                const orders = this.data.orders.filter(o => o.status !== 'Cancelled');

                const modalHTML = `
                    <div class="modal-overlay" id="editPaymentModal">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('editPaymentModal')">√ó</button>
                            <h2>‚úèÔ∏è Edit Payment</h2>
                            <form id="editPaymentForm" onsubmit="OMS.updatePayment(event, '${paymentId}')">
                                <div class="form-group">
                                    <label class="form-label required">Order</label>
                                    <select id="editPaymentOrderId" class="form-select" required>
                                        <option value="">Select Order</option>
                                        ${orders.map(o => `<option value="${o.docId || o.orderId}" ${(o.docId || o.orderId) === payment.orderDocId ? 'selected' : ''}>${o.orderId || 'Pending'} - ${o.clientName}</option>`).join('')}
                                    </select>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="editPaymentDate" class="form-input" value="${payment.paymentDate || Utils.toDateString(payment.timestamp?.toDate?.() || new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="editPaymentAmount" class="form-input" min="1" step="0.01" value="${payment.amount}" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="editPaymentMethod" class="form-select" required>
                                            <option value="Cash" ${payment.paymentMethod === 'Cash' ? 'selected' : ''}>Cash</option>
                                            <option value="UPI" ${payment.paymentMethod === 'UPI' ? 'selected' : ''}>UPI</option>
                                            <option value="Bank Transfer" ${payment.paymentMethod === 'Bank Transfer' ? 'selected' : ''}>Bank Transfer</option>
                                            <option value="Cheque" ${payment.paymentMethod === 'Cheque' ? 'selected' : ''}>Cheque</option>
                                            <option value="Card" ${payment.paymentMethod === 'Card' ? 'selected' : ''}>Card</option>
                                            <option value="Other" ${payment.paymentMethod === 'Other' ? 'selected' : ''}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="editPaymentTransactionId" class="form-input" value="${payment.transactionId || ''}">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="editPaymentNotes" class="form-textarea" rows="3">${payment.notes || ''}</textarea>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">üíæ Update Payment</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('editPaymentModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async updatePayment(event, paymentId) {
                event.preventDefault();

                const orderId = Utils.get('editPaymentOrderId');
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                if (!order) {
                    this.showToast('Order not found!', 'error');
                    return;
                }

                const oldPayment = this.data.payments.find(p => p.id === paymentId);
                const oldAmount = parseFloat(oldPayment.amount || 0);
                const newAmount = parseFloat(Utils.get('editPaymentAmount'));

                const updatedPayment = {
                    orderId: order.orderId || 'Pending',
                    orderDocId: order.docId,
                    customerName: order.clientName,
                    amount: newAmount,
                    paymentDate: Utils.get('editPaymentDate'),
                    paymentMethod: Utils.get('editPaymentMethod'),
                    transactionId: Utils.get('editPaymentTransactionId'),
                    notes: Utils.get('editPaymentNotes')
                };

                try {
                    await db.collection('payments').doc(paymentId).update(updatedPayment);

                    // Update local data
                    const paymentIndex = this.data.payments.findIndex(p => p.id === paymentId);
                    if (paymentIndex !== -1) {
                        this.data.payments[paymentIndex] = { ...this.data.payments[paymentIndex], ...updatedPayment };
                    }

                    // Update order balance if amount changed
                    if (oldAmount !== newAmount) {
                        const amountDiff = newAmount - oldAmount;
                        const currentBalance = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                        const newBalance = currentBalance - amountDiff;
                        const advancePaid = parseFloat(order.financials?.advancePaid || 0) + amountDiff;

                        await db.collection('orders').doc(order.docId).update({
                            'financials.advancePaid': advancePaid,
                            'financials.balanceDue': Math.max(0, newBalance),
                            'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < (order.financials?.grandTotal || order.totalAmount || 0) ? 'partial' : 'pending'
                        });
                    }

                    this.showToast('Payment updated successfully!', 'success');
                    this.closeModal('editPaymentModal');
                    this.renderFinancials();
                    await this.loadOrdersFromFirestore();
                } catch (error) {
                    console.error('Error updating payment:', error);
                    this.showToast('Error updating payment: ' + error.message, 'error');
                }
            },

            async editExpense(expenseId) {
                const expense = this.data.expenses.find(e => e.id === expenseId);
                if (!expense) {
                    this.showToast('Expense not found!', 'error');
                    return;
                }

                const modalHTML = `
                    <div class="modal-overlay" id="editExpenseModal">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('editExpenseModal')">√ó</button>
                            <h2>‚úèÔ∏è Edit Expense</h2>
                            <form id="editExpenseForm" onsubmit="OMS.updateExpense(event, '${expenseId}')">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Date</label>
                                        <input type="date" id="editExpenseDate" class="form-input" value="${expense.date || Utils.toDateString(expense.timestamp?.toDate?.() || new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="editExpenseAmount" class="form-input" min="1" step="0.01" value="${expense.amount}" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Category</label>
                                        <select id="editExpenseCategory" class="form-select" required>
                                            <option value="Inventory" ${expense.category === 'Inventory' ? 'selected' : ''}>Inventory</option>
                                            <option value="Equipment" ${expense.category === 'Equipment' ? 'selected' : ''}>Equipment</option>
                                            <option value="Transportation" ${expense.category === 'Transportation' ? 'selected' : ''}>Transportation</option>
                                            <option value="Staff" ${expense.category === 'Staff' ? 'selected' : ''}>Staff</option>
                                            <option value="Marketing" ${expense.category === 'Marketing' ? 'selected' : ''}>Marketing</option>
                                            <option value="Utilities" ${expense.category === 'Utilities' ? 'selected' : ''}>Utilities</option>
                                            <option value="Other" ${expense.category === 'Other' ? 'selected' : ''}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Vendor</label>
                                        <input type="text" id="editExpenseVendor" class="form-input" value="${expense.vendor || ''}">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Payment Method</label>
                                    <select id="editExpensePaymentMethod" class="form-select">
                                        <option value="Cash" ${expense.paymentMethod === 'Cash' ? 'selected' : ''}>Cash</option>
                                        <option value="UPI" ${expense.paymentMethod === 'UPI' ? 'selected' : ''}>UPI</option>
                                        <option value="Bank Transfer" ${expense.paymentMethod === 'Bank Transfer' ? 'selected' : ''}>Bank Transfer</option>
                                        <option value="Cheque" ${expense.paymentMethod === 'Cheque' ? 'selected' : ''}>Cheque</option>
                                        <option value="Card" ${expense.paymentMethod === 'Card' ? 'selected' : ''}>Card</option>
                                        <option value="Other" ${expense.paymentMethod === 'Other' ? 'selected' : ''}>Other</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Description</label>
                                    <textarea id="editExpenseDescription" class="form-textarea" rows="3">${expense.description || ''}</textarea>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">üíæ Update Expense</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('editExpenseModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async updateExpense(event, expenseId) {
                event.preventDefault();

                const updatedExpense = {
                    date: Utils.get('editExpenseDate'),
                    amount: parseFloat(Utils.get('editExpenseAmount')),
                    category: Utils.get('editExpenseCategory'),
                    vendor: Utils.get('editExpenseVendor'),
                    description: Utils.get('editExpenseDescription'),
                    paymentMethod: Utils.get('editExpensePaymentMethod')
                };

                try {
                    await db.collection('expenses').doc(expenseId).update(updatedExpense);

                    // Update local data
                    const expenseIndex = this.data.expenses.findIndex(e => e.id === expenseId);
                    if (expenseIndex !== -1) {
                        this.data.expenses[expenseIndex] = { ...this.data.expenses[expenseIndex], ...updatedExpense };
                    }

                    this.showToast('Expense updated successfully!', 'success');
                    this.closeModal('editExpenseModal');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error updating expense:', error);
                    this.showToast('Error updating expense: ' + error.message, 'error');
                }
            },

            exportFinancialReport() {
                const startDate = Utils.get('finStartDate');
                const endDate = Utils.get('finEndDate');

                const data = {
                    period: `${startDate} to ${endDate}`,
                    generatedAt: new Date().toISOString(),
                    orders: this.data.orders,
                    payments: this.data.payments,
                    expenses: this.data.expenses
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `financial-report-${startDate}-to-${endDate}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('Financial report exported!', 'success');
            },

            showMonthlyComparison() {
                // Calculate monthly stats for the past 12 months
                const months = [];
                const now = new Date();

                for (let i = 11; i >= 0; i--) {
                    const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);

                    const monthOrders = this.data.orders.filter(o => {
                        const orderDate = new Date(o.orderDate || o.createdAt);
                        return orderDate >= monthDate && orderDate <= monthEnd;
                    });

                    const revenue = monthOrders.reduce((sum, o) => sum + parseFloat(o.financials?.grandTotal || o.totalAmount || 0), 0);

                    months.push({
                        month: monthDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                        revenue: revenue,
                        orders: monthOrders.length
                    });
                }

                const modalHTML = `
                    <div class="modal-overlay" id="monthlyComparisonModal">
                        <div class="modal-content" style="max-width: 900px;">
                            <button class="modal-close" onclick="OMS.closeModal('monthlyComparisonModal')">√ó</button>
                            <h2>üìà Monthly Revenue Comparison (Last 12 Months)</h2>
                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Month</th>
                                            <th>Orders</th>
                                            <th>Revenue</th>
                                            <th>Avg per Order</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${months.map(m => `
                                            <tr>
                                                <td>${m.month}</td>
                                                <td>${m.orders}</td>
                                                <td>‚Çπ${m.revenue.toLocaleString('en-IN')}</td>
                                                <td>‚Çπ${m.orders > 0 ? (m.revenue / m.orders).toFixed(0).toLocaleString('en-IN') : 0}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                    <tfoot>
                                        <tr style="font-weight: bold;">
                                            <td>TOTAL</td>
                                            <td>${months.reduce((sum, m) => sum + m.orders, 0)}</td>
                                            <td>‚Çπ${months.reduce((sum, m) => sum + m.revenue, 0).toLocaleString('en-IN')}</td>
                                            <td>‚Çπ${(months.reduce((sum, m) => sum + m.revenue, 0) / months.reduce((sum, m) => sum + m.orders, 0)).toFixed(0).toLocaleString('en-IN')}</td>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            closeModal(modalId = 'dynamicModal') {
                const modal = document.getElementById(modalId);
                if (modal) {
                    // Remove escape handler if it exists (for dynamicModal)
                    if (modal._escapeHandler) {
                        document.removeEventListener('keydown', modal._escapeHandler);
                    }
                    modal.remove();
                }
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('üì• Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                itemHistory: [], // Will load from Firestore
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        // Check if user has permission to load financial data
        const canViewFinancials = await this.canViewFinancials();

        const loadPromises = [
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadItemHistoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore()
        ];

        // Only load financial data if user has permission
        if (canViewFinancials) {
            loadPromises.push(this.loadPaymentsFromFirestore());
            loadPromises.push(this.loadExpensesFromFirestore());
        } else {
            console.log('‚ÑπÔ∏è Skipping financial data - user does not have admin/owner role');
        }

        await Promise.all(loadPromises);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('‚úÖ All data loaded from Firestore successfully!');

        // Update all displays after data is loaded to ensure dashboard and other tabs show fresh data
        this.updateAllDisplays();

    } catch (error) {
        console.error('‚ùå Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('üì• Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`‚ö†Ô∏è Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                console.warn(`   Customer: ${customer.name}, Date: ${customer.dates}`);
                skippedDeleted++;
                return;
            }

            const loadedOrder = {
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                date: Utils.convertDateFormat(customer.dates) || '',
                readyTime: customer.timeSlot || '',
                clientName: customer.name || '',
                contact: customer.phone || '',
                venue: customer.venue || '',
                eventType: orderData.functionType || customer.functionType || '',
                transport: orderData.transport || '',
                driverName: orderData.driverName || '',
                transport2: orderData.transport2 || '',
                driverName2: orderData.driverName2 || '',
                operator: orderData.operator || '',
                helper: orderData.helper || '',
                status: orderData.status || 'Confirmed',
                notes: orderData.notes || '',
                weather: orderData.weather || null,
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.qty || 0,
                    remarks: item.desc || '',
                    price: item.price || 0
                })),
                createdAt: orderData.createdAt || new Date().toISOString(),
                updatedAt: orderData.updatedAt || null,
                totalAmount: orderData.totalAmount || 0,
                // Multi-day order fields
                isMultiDay: orderData.isMultiDay || false,
                startDate: orderData.startDate || null,
                endDate: orderData.endDate || null,
                dayWiseData: orderData.dayWiseData || []
            };

            // Debug log multi-day orders
            if (orderData.isMultiDay) {
                console.log(`üìÖ Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`‚úÖ Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('‚ùå Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('üìä Loading tracking data from Firestore...');

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('‚ö†Ô∏è Not authenticated yet - skipping tracking data load');
            this.data.trackingData = [];
            return;
        }

        // Load without orderBy to avoid index requirement
        // We'll sort in JavaScript instead
        const trackingSnapshot = await db.collection('tracking')
            .limit(500)  // Get more data, will sort client-side
            .get();

        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });

        // Sort by timestamp in JavaScript (newest first)
        this.data.trackingData.sort((a, b) => b.timestamp - a.timestamp);

        console.log(`‚úÖ Loaded ${this.data.trackingData.length} tracking events from website`);
        console.log(`üìç Sample data:`, this.data.trackingData.slice(0, 3));

    } catch (error) {
        console.error('‚ùå Error loading tracking data:', error);
        console.error('Error details:', error.code, error.message);

        // If permissions error, log it but don't retry
        // (retrying won't help if Firestore rules don't allow access)
        if (error.code === 'permission-denied') {
            console.warn('‚ö†Ô∏è Insufficient permissions to access tracking data. Please check Firestore security rules.');
        }

        this.data.trackingData = [];
    }
},

// ============ TEAM FIRESTORE SYNC ============

async saveTeamMemberToFirestore(teamMember) {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('‚ùå No user logged in');
            return false;
        }

        await db.collection('team').doc(teamMember.id).set({
            ...teamMember,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Team member saved to Firestore:', teamMember.name);
        return true;
    } catch (error) {
        console.error('‚ùå Error saving team member to Firestore:', error);
        this.showToast('Failed to sync team member: ' + error.message, 'error');
        return false;
    }
},

async loadTeamFromFirestore() {
    try {
        console.log('üë∑ Loading team from Firestore...');

        const teamSnapshot = await db.collection('team')
            .orderBy('createdAt', 'desc')
            .get();

        this.data.team = [];
        teamSnapshot.forEach(doc => {
            this.data.team.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`‚úÖ Loaded ${this.data.team.length} team members from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading team from Firestore:', error);
        // Try to load from localStorage as fallback
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data.team = parsed.team || [];
            console.log('üì¶ Loaded team from localStorage backup');
        }
        return false;
    }
},

async deleteTeamMemberFromFirestore(teamMemberId) {
    try {
        await db.collection('team').doc(teamMemberId).delete();
        console.log('‚úÖ Team member deleted from Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting team member from Firestore:', error);
        return false;
    }
},

// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('üì¶ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`üì¶ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`üì¶ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`‚úÖ Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`‚úÖ Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`‚ö†Ô∏è Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('üîÑ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('‚úÖ Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('‚ö†Ô∏è‚ö†Ô∏è Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('‚ùå‚ùå CRITICAL: Both Firestore AND local are empty!');
            console.error('‚ùå ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('‚ö†Ô∏è Keeping existing local inventory due to error');
        return false;
    }
},

async loadItemHistoryFromFirestore() {
    try {
        console.log('üìú Loading item history from Firestore...');

        const snapshot = await db.collection('itemHistory').orderBy('usedAt', 'desc').get();
        const history = [];
        snapshot.forEach(doc => {
            history.push({ id: doc.id, ...doc.data() });
        });

        this.data.itemHistory = history;
        console.log(`‚úÖ Loaded ${history.length} item history records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading item history from Firestore:', error);
        return false;
    }
},

async loadPaymentsFromFirestore() {
    try {
        console.log('üíµ Loading payments from Firestore...');

        const snapshot = await db.collection('payments').orderBy('timestamp', 'desc').get();
        const payments = [];
        snapshot.forEach(doc => {
            payments.push({ id: doc.id, ...doc.data() });
        });

        this.data.payments = payments;
        console.log(`‚úÖ Loaded ${payments.length} payment records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading payments from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('üîí Permission Denied: You need admin/owner role to access financial data');
            console.error('üí° Solution: Run the setup script or create your user_roles document manually');
            console.error('üìñ Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async loadExpensesFromFirestore() {
    try {
        console.log('üí∏ Loading expenses from Firestore...');

        const snapshot = await db.collection('expenses').orderBy('timestamp', 'desc').get();
        const expenses = [];
        snapshot.forEach(doc => {
            expenses.push({ id: doc.id, ...doc.data() });
        });

        this.data.expenses = expenses;
        console.log(`‚úÖ Loaded ${expenses.length} expense records from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading expenses from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('üîí Permission Denied: You need admin/owner role to access financial data');
            console.error('üí° Solution: Run the setup script or create your user_roles document manually');
            console.error('üìñ Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('‚úÖ Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('‚úÖ Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('‚úÖ Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('üîî Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`‚úÖ Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ SETTINGS FIRESTORE SYNC ============

async saveSettingsToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) return false;

        await db.collection('settings').doc('app_settings').set({
            ...this.data.settings,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Settings saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving settings to Firestore:', error);
        return false;
    }
},

async loadSettingsFromFirestore() {
    try {
        console.log('‚öôÔ∏è Loading settings from Firestore...');

        const settingsDoc = await db.collection('settings').doc('app_settings').get();

        if (settingsDoc.exists) {
            const firestoreSettings = settingsDoc.data();
            // Merge with default settings
            this.data.settings = {
                ...this.data.settings,
                ...firestoreSettings
            };
            console.log('‚úÖ Settings loaded from Firestore');
            return true;
        } else {
            console.log('üìù No settings in Firestore, using defaults');
            // Save default settings to Firestore
            await this.saveSettingsToFirestore();
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error loading settings from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('‚ö†Ô∏è All listeners already active');
        return;
    }

    console.log('üîÑ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('üë∑ Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                    console.log('üë∑ Team member updated:', teamMember.name);
                }
                // Update UI in real-time - always render when data changes
                this.renderTeamTable();
                // Also update dropdowns in order form
                this.updateTeamDropdowns();
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('üë∑ Team member removed:', teamMember.name);
                    // Update UI in real-time
                    this.renderTeamTable();
                    this.updateTeamDropdowns();
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('üì¶ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if category was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedCategories &&
                                      this.data.inventory.deletedCategories.includes(category.id);
                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Category was previously deleted - ignoring:', category.name);
                        return;
                    }

                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`üìÅ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        // Track deleted categories to prevent re-addition
                        if (!this.data.inventory.deletedCategories) {
                            this.data.inventory.deletedCategories = [];
                        }
                        if (!this.data.inventory.deletedCategories.includes(category.id)) {
                            this.data.inventory.deletedCategories.push(category.id);
                        }
                        console.log(`üóëÔ∏è Category removed:`, category.name);
                    }
                }
            });

            console.log(`üì¶ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('üì¶ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if item was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedItems &&
                                      this.data.inventory.deletedItems.includes(item.id);
                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Inventory item was previously deleted - ignoring:', item.name);
                        return;
                    }

                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`üì¶ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        // Track deleted items to prevent re-addition
                        if (!this.data.inventory.deletedItems) {
                            this.data.inventory.deletedItems = [];
                        }
                        if (!this.data.inventory.deletedItems.includes(item.id)) {
                            this.data.inventory.deletedItems.push(item.id);
                        }
                        console.log(`üóëÔ∏è Item removed:`, item.name);
                    }
                }
            });

            console.log(`üì¶ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('‚öôÔ∏è Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    // Payments real-time listener
    this.paymentsUnsubscribe = db.collection('payments').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const payment = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index === -1) {
                    this.data.payments.push(payment);
                    console.log('üíµ Payment added:', payment.id);
                } else {
                    this.data.payments[index] = payment;
                    console.log('üíµ Payment updated:', payment.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index !== -1) {
                    this.data.payments.splice(index, 1);
                    console.log('üíµ Payment removed:', payment.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    // Expenses real-time listener
    this.expensesUnsubscribe = db.collection('expenses').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const expense = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index === -1) {
                    this.data.expenses.push(expense);
                    console.log('üí∏ Expense added:', expense.id);
                } else {
                    this.data.expenses[index] = expense;
                    console.log('üí∏ Expense updated:', expense.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index !== -1) {
                    this.data.expenses.splice(index, 1);
                    console.log('üí∏ Expense removed:', expense.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    console.log('‚úÖ All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('‚ö†Ô∏è Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('üõë Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('üîÑ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`üìã Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('üÜï New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    const newOrder = {
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        isMultiDay: orderData.isMultiDay || false,
                        startDate: orderData.startDate || null,
                        endDate: orderData.endDate || null,
                        dayWiseData: orderData.dayWiseData || [],
                        date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
                        readyTime: customer.timeSlot || '',
                        clientName: customer.name || '',
                        contact: customer.phone || '',
                        venue: customer.venue || '',
                        eventType: orderData.functionType || customer.functionType || '',
                        transport: orderData.transport || '',
                        driverName: orderData.driverName || '',
                        operator: orderData.operator || '',
                        helper: orderData.helper || '',
                        status: orderData.status || 'Confirmed',
                        notes: orderData.notes || '',
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.qty || 0,
                            remarks: item.desc || '',
                            price: item.price || 0
                        })),
                        createdAt: orderData.createdAt || new Date().toISOString(),
                        totalAmount: orderData.totalAmount || 0
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        // Update dashboard statistics in real-time
                        if (this.currentTab === 'dashboard') {
                            this.renderDashboard();
                        }
                        this.showToast(`üÜï New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('‚úèÔ∏è Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // Update existing order
        this.data.orders[index] = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();
        // Update dashboard statistics in real-time
        if (this.currentTab === 'dashboard') {
            this.renderDashboard();
        }
        this.showToast(`‚úèÔ∏è Order updated: ${this.data.orders[index].clientName}`, 'success');
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('‚ö†Ô∏è Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('‚ö†Ô∏è Modified order not found locally, adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                console.log('üóëÔ∏è Order removed from Firestore:', orderData.orderId || change.doc.id);
                const index = this.data.orders.findIndex(o => o.orderId === (orderData.orderId || change.doc.id));
                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();
                    this.showToast(`üóëÔ∏è Order deleted: ${deleted.orderId}`, 'success');
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`‚úÖ Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('‚úÖ Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('üìã Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('‚ö†Ô∏è Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('‚ö†Ô∏è Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('üìã No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('‚úÖ Demo data loaded for first-time user');
    } else {
        console.log('‚úÖ Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') this.updateInventoryDisplay();
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();
        else if (this.currentTab === 'financials') this.renderFinancials();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `‚ö†Ô∏è OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'üî• TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = '‚ö° TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `‚è∞ In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `üìÖ In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    ‚úì Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            this.loadOrderToForm(order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('‚úÖ Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('‚ùå Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('‚ùå Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // Expose OMS globally for console access and backward compatibility
        window.OMS = OMS;
        window.appManager = OMS;

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`‚úÖ Cleared ${count} entries from deletedOrders list`);
                console.log('üîÑ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('‚úÖ Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('üîÑ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('‚úÖ Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`‚úÖ Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('‚úÖ No demo orders found!');
                        return [];
                    }

                    console.log(`‚ö†Ô∏è Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`‚úÖ Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('‚ùå Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('‚úÖ Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`üìã Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Restore a specific order (remove from deletedOrders list)
            async restoreDeletedOrder(orderId) {
                console.log(`üîÑ Attempting to restore order: ${orderId}`);

                // Find the order in deletedOrders list
                const deletedOrder = OMS.data.deletedOrders.find(o => o.orderId === orderId || o.docId === orderId);

                if (!deletedOrder) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in deletedOrders list`);
                    console.log('üí° Run AdminUtils.viewDeletedOrders() to see all deleted orders');
                    return false;
                }

                console.log(`‚úÖ Found deleted order: ${deletedOrder.orderId || orderId}`);
                console.log(`   Client: ${deletedOrder.clientName || 'N/A'}`);
                console.log(`   Deleted at: ${deletedOrder.deletedAt || 'N/A'}`);

                // Remove from deletedOrders list
                const beforeCount = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o =>
                    o.orderId !== orderId && o.docId !== orderId
                );
                const afterCount = OMS.data.deletedOrders.length;

                // Save to localStorage
                OMS.saveToStorage();
                console.log(`‚úÖ Removed from deletedOrders list (${beforeCount} ‚Üí ${afterCount})`);

                // Reload orders from Firestore
                console.log('üîÑ Reloading orders from Firestore...');
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();

                // Check if order is now visible
                const restoredOrder = OMS.data.orders.find(o => o.orderId === orderId || o.docId === orderId);
                if (restoredOrder) {
                    console.log(`‚úÖ‚úÖ SUCCESS! Order ${orderId} has been restored and is now visible!`);
                    console.log(`   Client: ${restoredOrder.clientName}`);
                    console.log(`   Status: ${restoredOrder.status}`);
                    return true;
                } else {
                    console.warn(`‚ö†Ô∏è Order removed from block list, but not found in Firestore.`);
                    console.log(`üí° The order may have been permanently deleted from Firestore.`);
                    console.log(`üí° If you saved it again, try refreshing the page or run:`);
                    console.log(`   await AdminUtils.forceFullSync()`);
                    return false;
                }
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('üîÑ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('üì¶ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('‚ùå Firestore inventory is empty! Nothing to recover.');
                        console.log('üí° Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('‚ùå No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('‚ùå No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('üì¶ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('üì¶ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('üîç Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`üìÅ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`üì¶ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('‚ùå Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`‚úÖ Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('üëª Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('‚úÖ No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`üëª Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nüí° These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('‚ùå Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('‚ö†Ô∏è This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('‚ùå Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('‚úÖ Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`üóëÔ∏è Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('üîç Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`üî• Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('‚úÖ Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('‚úÖ Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('‚ö†Ô∏è Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('‚úÖ Added to deletedOrders block list');
                } else {
                    console.log('‚ÑπÔ∏è Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\n‚úÖ Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  ‚úì Firestore database');
                console.log('  ‚úì Local data');
                console.log('  ‚úì Added to block list (deletedOrders)');
                console.log('  ‚úì Saved to localStorage');
                console.log('\nüõ°Ô∏è This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('üîç Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('üìä ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`‚ö†Ô∏è Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('‚úÖ Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nüì¶ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('‚ùå CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('üßπ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`‚ö†Ô∏è Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`‚úÖ Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`üìã Deleted orders list: ${before} ‚Üí ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('‚úÖ No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('üîçüîçüîç COMPREHENSIVE SYSTEM DIAGNOSTIC üîçüîçüîç\n');

                // 1. Check localStorage
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('1Ô∏è‚É£ LOCALSTORAGE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('‚úÖ localStorage exists');
                    console.log(`  üì¶ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  üì¶ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  üìã Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  üóëÔ∏è Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('‚ùå NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('2Ô∏è‚É£ CURRENT MEMORY (OMS.data)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  üì¶ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  üì¶ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  üìã Orders: ${OMS.data.orders.length}`);
                console.log(`  üóëÔ∏è Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('3Ô∏è‚É£ FIRESTORE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  üìã Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  üì¶ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  üì¶ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('4Ô∏è‚É£ MISMATCH ANALYSIS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  ‚ö†Ô∏è Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  ‚ùå DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  ‚úÖ ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  ‚ö†Ô∏è Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('5Ô∏è‚É£ RECOMMENDATIONS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  üí° Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN MEMORY!');
                    console.log('  üí° Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  üí° Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\n‚úÖ Diagnostic complete!\n');
            },

            // ============ FILTERING DIAGNOSTICS ============

            // View filter logs
            viewFilterLogs(count = 50) {
                const logs = filterLogger.getRecentLogs(count);
                console.group(`üìä Recent Filter Logs (${logs.length})`);
                console.table(logs.map(log => ({
                    Time: new Date(log.timestamp).toLocaleString(),
                    Operation: log.operation,
                    Date: log.filterDate,
                    Matched: log.matchedCount,
                    Total: log.totalAvailable,
                    Time_ms: log.filterTimeMs
                })));
                console.groupEnd();
                return logs;
            },

            // View learned patterns
            viewLearnedPatterns() {
                const patterns = patternLearner.patterns;
                console.group('üß† Learned Patterns');

                console.log('\nüìÖ Date-specific patterns:');
                const datePatterns = Object.entries(patterns.datePatterns)
                    .sort((a, b) => new Date(b[0]) - new Date(a[0]))
                    .slice(0, 20);
                console.table(datePatterns.map(([date, data]) => ({
                    Date: date,
                    AvgOrders: data.avgCount.toFixed(1),
                    Observations: data.counts.length,
                    LastSeen: new Date(data.lastSeen).toLocaleDateString()
                })));

                console.log('\nüìä Typical order counts:');
                console.table({
                    Weekday: {
                        Min: patterns.typicalOrderCounts.weekday.min,
                        Avg: patterns.typicalOrderCounts.weekday.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekday.max,
                        Samples: patterns.typicalOrderCounts.weekday.samples
                    },
                    Weekend: {
                        Min: patterns.typicalOrderCounts.weekend.min,
                        Avg: patterns.typicalOrderCounts.weekend.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekend.max,
                        Samples: patterns.typicalOrderCounts.weekend.samples
                    }
                });

                console.log('\nüîÑ Learned date formats:');
                const dateFormats = Object.entries(patterns.dateFormats).slice(0, 10);
                if (dateFormats.length > 0) {
                    console.table(dateFormats.map(([original, data]) => ({
                        Original: original,
                        Normalized: data.normalized,
                        Count: data.count
                    })));
                } else {
                    console.log('  No custom date formats learned yet');
                }

                console.groupEnd();
                return patterns;
            },

            // Clear all filter logs
            clearFilterLogs() {
                const count = filterLogger.logs.length;
                filterLogger.logs = [];
                filterLogger.saveLogs();
                console.log(`‚úÖ Cleared ${count} filter logs`);
            },

            // Reset learned patterns
            resetLearnedPatterns() {
                const confirmed = confirm('Reset all learned patterns? This cannot be undone.');
                if (confirmed) {
                    localStorage.removeItem('oms_filter_patterns');
                    location.reload();
                    console.log('‚úÖ Patterns reset. Page reloading...');
                }
            },

            // Test filter accuracy for a specific date
            async testFilterAccuracy(date) {
                console.group(`üß™ Testing Filter Accuracy for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                console.log(`üìÖ Normalized date: ${normalizedDate}`);

                // Test all date variations
                const variations = fuzzyDateMatcher.getVariations(date);
                console.log(`üîÑ Testing ${variations.length} date variations:`, variations);

                // Run the actual filter
                const startTime = performance.now();
                const matchedOrders = [];
                const orders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    return false;
                });
                const filterTime = (performance.now() - startTime).toFixed(2);

                console.log(`‚úÖ Found ${orders.length} orders in ${filterTime}ms`);

                // Show expected count
                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`üß† Expected based on learning: ~${expectedCount} orders`);
                    const deviation = Math.abs(orders.length - expectedCount);
                    if (deviation > 0) {
                        console.log(`üìä Deviation: ${deviation} orders (${((deviation / Math.max(expectedCount, 1)) * 100).toFixed(1)}%)`);
                    }
                }

                // Run validation
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: OMS.data.orders.length,
                    matchedOrders,
                    allOrders: OMS.data.orders
                });

                if (validationResult.length > 0) {
                    console.log(`\n‚ö†Ô∏è Validation Issues (${validationResult.length}):`);
                    validationResult.forEach(alert => {
                        console.log(`  ${alert.level.toUpperCase()}: ${alert.message}`);
                    });
                } else {
                    console.log('\n‚úÖ No validation issues detected');
                }

                console.log(`\nüìã Matched orders:`);
                console.table(orders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    Date: o.date || `${o.startDate} to ${o.endDate}`,
                    Status: o.status,
                    MultiDay: o.isMultiDay ? 'Yes' : 'No'
                })));

                console.groupEnd();
                return { orders, validationResult, filterTime };
            },

            // Show filtering statistics
            showFilteringStats() {
                console.group('üìä Filtering System Statistics');

                const logs = filterLogger.logs;
                const patterns = patternLearner.patterns;

                console.log(`üìù Total filter operations logged: ${logs.length}`);
                console.log(`üß† Patterns learned for ${Object.keys(patterns.datePatterns).length} dates`);
                console.log(`üìÖ Date formats learned: ${Object.keys(patterns.dateFormats).length}`);
                console.log(`üìà Filter results history: ${patterns.filterResults.length} entries`);

                if (logs.length > 0) {
                    const avgTime = logs
                        .filter(l => l.filterTimeMs)
                        .reduce((sum, l) => sum + parseFloat(l.filterTimeMs), 0) / logs.filter(l => l.filterTimeMs).length;
                    console.log(`‚ö° Average filter time: ${avgTime.toFixed(2)}ms`);
                }

                console.log('\nüí° Available commands:');
                console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
                console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
                console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a date');
                console.log('  - AdminUtils.clearFilterLogs() - Clear all logs');
                console.log('  - AdminUtils.resetLearnedPatterns() - Reset all patterns');

                console.groupEnd();
            },

            // ============ RATING & LEARNING UTILITIES ============

            // Show rating UI for last filter result
            rateLastFilter() {
                if (!filterRatingSystem.currentFilterContext) {
                    console.warn('‚ö†Ô∏è No filter result available to rate. Run a filter first.');
                    return;
                }
                filterRatingSystem.showRatingUI(OMS);
            },

            // View all ratings
            viewRatings(count = 20) {
                const ratings = filterRatingSystem.ratings.slice(-count);
                if (ratings.length === 0) {
                    console.log('üì≠ No ratings yet. Use AdminUtils.rateLastFilter() after filtering orders.');
                    return;
                }

                console.group(`‚≠ê Recent Ratings (${ratings.length})`);
                console.table(ratings.map(r => ({
                    Date: r.date,
                    Rating: typeof r.rating === 'number' ? '‚≠ê'.repeat(r.rating) : r.rating,
                    Matched: r.matchedOrders.length,
                    WrongIncluded: r.feedback.incorrectlyIncluded.length,
                    WrongExcluded: r.feedback.incorrectlyExcluded.length,
                    Tags: r.feedback.tags.join(', '),
                    RatedAt: new Date(r.ratedAt).toLocaleString()
                })));

                const stats = filterRatingSystem.getStats();
                console.log(`\nüìä Overall Statistics:`);
                console.log(`  Average Rating: ${stats.avgRating} / 5`);
                console.log(`  Total Ratings: ${stats.totalRatings}`);
                console.log(`  Sentiment Trend: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' ‚Üí ')}`);

                console.groupEnd();
            },

            // View learning rules
            viewLearningRules(date = null) {
                const rules = date
                    ? filterRatingSystem.getLearningRules(date)
                    : JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (rules.length === 0) {
                    console.log(`üì≠ No learning rules${date ? ' for ' + date : ''}.`);
                    return;
                }

                console.group(`üß† Learning Rules${date ? ' for ' + date : ''} (${rules.length})`);
                console.table(rules.map(r => ({
                    Type: r.type,
                    Date: r.targetDate,
                    OrderID: r.orderId || 'N/A',
                    Reason: r.reason,
                    Weight: r.weight
                })));
                console.groupEnd();
            },

            // View rating statistics
            getRatingStats() {
                const stats = filterRatingSystem.getStats();
                console.group('üìä Rating System Statistics');
                console.log(`Average Rating: ${stats.avgRating} / 5`);
                console.log(`Total Ratings: ${stats.totalRatings}`);
                console.log(`Recent Sentiment: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' ‚Üí ')}`);

                const learningRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                console.log(`\nLearning Rules: ${learningRules.length}`);
                console.log(`  - Exclusions: ${learningRules.filter(r => r.type === 'exclusion').length}`);
                console.log(`  - Inclusions: ${learningRules.filter(r => r.type === 'inclusion').length}`);
                console.log(`  - Anomalies: ${learningRules.filter(r => r.type === 'anomaly').length}`);

                console.log('\nüí° Available commands:');
                console.log('  - AdminUtils.rateLastFilter() - Rate the last filter result');
                console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
                console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
                console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
                console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');

                console.groupEnd();
            },

            // Test learning corrections for a date
            testLearning(date) {
                console.group(`üß™ Testing Learning Corrections for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                const learningRules = filterRatingSystem.getLearningRules(normalizedDate);

                if (learningRules.length === 0) {
                    console.log('üì≠ No learning rules for this date yet. Rate a filter result first.');
                    console.groupEnd();
                    return;
                }

                console.log(`üß† Found ${learningRules.length} learning rules`);
                console.table(learningRules);

                // Run filter without corrections
                const originalOrders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) return true;
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) return true;
                    }
                    return false;
                });

                console.log(`\nüìã Original filter: ${originalOrders.length} orders`);

                // Apply learning corrections
                const result = filterRatingSystem.applyLearningRules(normalizedDate, originalOrders, OMS.data.orders);

                console.log(`üß† After learning: ${result.orders.length} orders`);
                console.log(`‚úÖ Corrections applied: ${result.corrections.length}`);

                if (result.corrections.length > 0) {
                    console.log('\nüìù Corrections:');
                    console.table(result.corrections.map(c => ({
                        Type: c.type,
                        OrderID: c.order.orderId,
                        Client: c.order.clientName,
                        Reason: c.reason
                    })));
                }

                console.groupEnd();
                return result;
            },

            // Clear all ratings and learning rules
            clearAllRatings() {
                const confirmed = confirm('Clear all ratings and learning rules? This cannot be undone.');
                if (confirmed) {
                    filterRatingSystem.clearAllRatings();
                    console.log('‚úÖ All ratings and learning rules cleared');
                }
            },

            // Export ratings and learning data
            exportLearningData() {
                const data = {
                    ratings: filterRatingSystem.ratings,
                    learningRules: JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]'),
                    patterns: patternLearner.patterns,
                    exportedAt: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `filter-learning-data-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                console.log('‚úÖ Learning data exported');
            },

            // Import ratings and learning data
            async importLearningData() {
                return new Promise((resolve, reject) => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';

                    input.onchange = async (e) => {
                        try {
                            const file = e.target.files[0];
                            const text = await file.text();
                            const data = JSON.parse(text);

                            if (data.ratings) {
                                filterRatingSystem.ratings = data.ratings;
                                filterRatingSystem.saveRatings();
                            }

                            if (data.learningRules) {
                                localStorage.setItem('oms_filter_learning_rules', JSON.stringify(data.learningRules));
                            }

                            if (data.patterns) {
                                localStorage.setItem('oms_filter_patterns', JSON.stringify(data.patterns));
                            }

                            console.log('‚úÖ Learning data imported successfully');
                            console.log(`  - Ratings: ${data.ratings?.length || 0}`);
                            console.log(`  - Learning Rules: ${data.learningRules?.length || 0}`);

                            resolve(data);
                        } catch (error) {
                            console.error('‚ùå Failed to import learning data:', error);
                            reject(error);
                        }
                    };

                    input.click();
                });
            },

            // Enable ML corrections
            enableML() {
                localStorage.setItem('oms_ml_enabled', 'true');
                console.log('‚úÖ ML Corrections ENABLED');
                console.log('üß† The system will now apply learned corrections from previous ratings');
                console.log('üí° To disable: AdminUtils.disableML()');
                console.log('üí° To clear learned rules: AdminUtils.clearAllRatings()');
                return true;
            },

            // Disable ML corrections
            disableML() {
                localStorage.setItem('oms_ml_enabled', 'false');
                console.log('‚úÖ ML Corrections DISABLED');
                console.log('üìä Filter will now use ONLY the original logic (no ML modifications)');
                console.log('üí° To enable: AdminUtils.enableML()');
                console.log('‚ö†Ô∏è Note: This does NOT clear learned rules, just stops applying them');
                return true;
            },

            // Check ML status
            checkMLStatus() {
                const enabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const ratings = JSON.parse(localStorage.getItem('oms_filter_ratings') || '[]');
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                console.log('ü§ñ ML System Status:');
                console.log(`  Status: ${enabled ? '‚úÖ ENABLED' : 'üîá DISABLED'}`);
                console.log(`  Ratings stored: ${ratings.length}`);
                console.log(`  Learning rules: ${rules.length}`);

                if (enabled && rules.length > 0) {
                    console.log('\n‚ö†Ô∏è WARNING: ML is ACTIVE and will modify filter results');
                    console.log('üí° To disable: AdminUtils.disableML()');
                    console.log('üí° To clear rules: AdminUtils.clearAllRatings()');
                } else if (!enabled) {
                    console.log('\n‚úÖ ML is disabled - using original filter logic only');
                } else {
                    console.log('\nüìã ML is enabled but no learning rules stored yet');
                }

                return { enabled, ratingsCount: ratings.length, rulesCount: rules.length };
            },

            // Quick fix: Disable ML and clear all learned rules
            resetMLSystem() {
                const confirmed = confirm('This will:\n1. Disable ML corrections\n2. Clear all ratings and learning rules\n\nContinue?');
                if (confirmed) {
                    this.disableML();
                    filterRatingSystem.clearAllRatings();
                    console.log('\n‚úÖ ML System Reset Complete!');
                    console.log('üìä Filter will now use ONLY original logic');
                    console.log('üí° To re-enable: AdminUtils.enableML()');
                    return true;
                }
                return false;
            }
        };

        console.log('üõ†Ô∏è Admin utilities loaded. Available commands:');
        console.log('\nüìã ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - ‚≠ê PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nüì¶ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - ‚≠ê LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nüîç DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - ‚≠ê FULL SYSTEM DIAGNOSTIC (find all bugs)');
        console.log('\nüéØ FILTERING DIAGNOSTICS:');
        console.log('  - AdminUtils.showFilteringStats() - Show filtering system overview');
        console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
        console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
        console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a specific date');
        console.log('  - AdminUtils.clearFilterLogs() - Clear all filter logs');
        console.log('  - AdminUtils.resetLearnedPatterns() - Reset learned patterns');
        console.log('\n‚≠ê RATING & LEARNING SYSTEM:');
        console.log('  - AdminUtils.rateLastFilter() - ‚≠ê Rate the last filter result');
        console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
        console.log('  - AdminUtils.getRatingStats() - View rating statistics and trends');
        console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
        console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');
        console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
        console.log('  - AdminUtils.exportLearningData() - Export learning data to JSON');
        console.log('  - await AdminUtils.importLearningData() - Import learning data from JSON');
        console.log('\nü§ñ ML SYSTEM CONTROLS:');
        console.log('  - AdminUtils.checkMLStatus() - ‚≠ê Check if ML is enabled/disabled and view stats');
        console.log('  - AdminUtils.disableML() - ‚≠ê DISABLE ML corrections (use original filter only)');
        console.log('  - AdminUtils.enableML() - Enable ML corrections');
        console.log('  - AdminUtils.resetMLSystem() - ‚≠ê DISABLE ML + clear all learned rules');

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Check ML status on page load
            setTimeout(() => {
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (mlEnabled && rules.length > 0) {
                    console.warn('‚ö†Ô∏è ML SYSTEM IS ACTIVE! The filter may automatically modify results based on previous feedback.');
                    console.warn(`üìä ${rules.length} learning rules are stored and will be applied.`);
                    console.warn('üí° To disable: AdminUtils.disableML()');
                    console.warn('üí° To check status: AdminUtils.checkMLStatus()');
                    console.warn('üí° To reset everything: AdminUtils.resetMLSystem()');
                } else if (!mlEnabled) {
                    console.log('‚úÖ ML corrections are DISABLED - using original filter logic only');
                    console.log('üí° To enable: AdminUtils.enableML()');
                }
            }, 1000);

            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'grid';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Set required fields for single day
            document.getElementById('orderDate').required = true;
            document.getElementById('readyTime').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Set required fields for multi-day
            document.getElementById('orderDate').required = false;
            document.getElementById('readyTime').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;

            // Hide event type field for multi-day
            document.getElementById('eventType').parentElement.style.display = 'none';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });

        // Initialize required attributes based on default state (single day)
        if (eventTypeSelect && eventTypeSelect.value === 'single') {
            document.getElementById('orderDate').required = true;
            document.getElementById('readyTime').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;
        } else if (eventTypeSelect && eventTypeSelect.value === 'multi') {
            document.getElementById('orderDate').required = false;
            document.getElementById('readyTime').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;
        }
    }
    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // Initialize Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyC5c2BmVHnbWlBwwHtFwll97nq_xOdqxCc",
                authDomain: "firepowersfx-2558.firebaseapp.com",
                projectId: "firepowersfx-2558",
                storageBucket: "firepowersfx-2558.firebasestorage.app",
                messagingSenderId: "723483292867",
                appId: "1:723483292867:web:d6d83a79ba87cd2dee5e76"
            };

            firebase.initializeApp(firebaseConfig);
            window.auth = firebase.auth();
            window.db = firebase.firestore();
            console.log('‚úÖ Firebase initialized successfully!');

            // Track token refresh errors to prevent infinite loops
            let tokenErrorCount = 0;
            let lastTokenError = 0;
            const TOKEN_ERROR_THRESHOLD = 3; // Sign out after 3 consecutive errors
            const TOKEN_ERROR_WINDOW = 10000; // 10 seconds window

            // Monitor for token refresh errors
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                return originalFetch.apply(this, args).catch(error => {
                    // Check if this is a token refresh error
                    if (args[0] && typeof args[0] === 'string' && args[0].includes('securetoken.googleapis.com')) {
                        const now = Date.now();

                        // Reset counter if errors are not consecutive (more than 10s apart)
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`‚ö†Ô∏è Firebase token refresh failed (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive errors, sign out user to force fresh login
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('‚ùå Multiple token refresh failures detected. Signing out to force fresh login...');
                            tokenErrorCount = 0; // Reset counter

                            // Sign out user
                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    }
                    throw error;
                }).then(response => {
                    // Check for 403 errors on token refresh
                    if (args[0] && typeof args[0] === 'string' &&
                        args[0].includes('securetoken.googleapis.com') &&
                        response.status === 403) {

                        const now = Date.now();

                        // Reset counter if errors are not consecutive
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`‚ö†Ô∏è Firebase token refresh 403 error (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive 403 errors, sign out user
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('‚ùå Multiple 403 token errors detected. Signing out to force fresh login...');
                            tokenErrorCount = 0;

                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    } else {
                        // Reset counter on successful non-token requests
                        if (response.ok) {
                            tokenErrorCount = 0;
                        }
                    }
                    return response;
                });
            };

            // Check if user is logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    // User is logged in
                    console.log('‚úÖ User logged in:', user.email);
                    tokenErrorCount = 0; // Reset error counter on successful auth
                    document.getElementById('loginScreen').style.display = 'none';
                    document.querySelector('.app-container').style.display = 'flex';
                    OMS.init().then(() => OMS.updateAllDisplays());
                } else {
                    // User is logged out
                    console.log('‚ùå User not logged in');
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.querySelector('.app-container').style.display = 'none';
                }
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');
                
                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';
                
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('‚úÖ Login successful!');
                } catch (error) {
                    console.error('‚ùå Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

            // Transport 2 custom field
            document.getElementById('transport2').addEventListener('change', (e) => {
                const group = document.getElementById('customTransport2Group');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('‚úÖ Date restrictions removed - can add orders from any date');
        });

    </script>
</body>
</html>
