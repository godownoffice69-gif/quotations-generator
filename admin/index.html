<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 2025-11-21 - Materials Calculation & Details Fix -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System - Enhanced</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="shortcut icon" type="image/png" href="logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --light: #f8fafc;
            --white: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        /* Light Theme Variables */
        :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-hover: rgba(102, 126, 234, 0.05);
            --bg-input: #ffffff;
            --table-header-bg: #f8f9fa;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Noto Sans Gujarati', sans-serif;
            background: var(--bg-body);
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Layout */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        
        .app-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--white);
            padding: 1rem 0;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .company-name { font-size: 1.8rem; font-weight: 700; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #weatherMiniDashboard {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
            padding: 0.5rem 1rem;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.9rem;
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        #weatherMiniDashboard:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.3));
            border-color: rgba(59, 130, 246, 0.5);
        }

        .weather-mini-icon {
            font-size: 1.5rem;
            line-height: 1;
        }

        .weather-mini-info {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .weather-mini-temp {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .weather-mini-condition {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .search-global {
            position: relative;
            width: 300px;
        }

        .search-global input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        .search-global-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            margin-top: 0.25rem;
            box-shadow: var(--shadow-lg);
        }

        .search-results.show { display: block; }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-dark);
        }

        .search-result-item:hover { background: var(--bg-hover); }

        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-gray);
            text-transform: uppercase;
        }

        /* Navigation */
        .nav-tabs {
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            padding: 0 1rem;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-gray);
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tab:hover { color: var(--primary); background: var(--bg-hover); }
        .nav-tab.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg-hover); }

        .main-content {
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
            width: 100%;
        }

        .tab-content { display: none; animation: fadeIn 0.3s ease-in; }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .card-header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Forms */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        .form-label.required::after { content: ' *'; color: var(--danger); }

        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--bg-input);
            color: var(--text-dark);
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Highlighted Date & Time Fields */
        .highlight-datetime {
            background-color: #fef3c7 !important;
            font-weight: 500;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Noto Sans Gujarati', sans-serif;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: var(--white); }
        .btn-secondary { background: var(--white); color: var(--primary); border: 2px solid var(--primary); }
        .btn-success { background: var(--success); color: var(--white); }
        .btn-warning { background: var(--warning); color: var(--white); }
        .btn-danger { background: var(--danger); color: var(--white); }
        .btn-info { background: var(--info); color: var(--white); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.info { border-left-color: var(--info); }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-gray);
            font-weight: 500;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th, .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-dark);
        }

        .table tr:hover { background: var(--bg-hover); }
        .table tr:last-child td { border-bottom: none; }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-confirmed { background: rgba(16, 185, 129, 0.1); color: var(--success); }
        .status-completed { background: rgba(102, 126, 234, 0.1); color: var(--primary); }
        .status-cancelled { background: rgba(239, 68, 68, 0.1); color: var(--danger); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2000;
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-left: 4px solid var(--success);
            padding: 1rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            transform: translateX(400px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            color: var(--text-dark);
        }

        .toast.show { transform: translateX(0); }
        .toast.error { border-left-color: var(--danger); }
        .toast.warning { border-left-color: #ff9800; }
        .toast-actions { display: flex; gap: 0.5rem; }
        .toast-btn { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            text-align: center;
            color: var(--text-dark);
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ============ AD ANIMATION EFFECTS ============ */

        /* Fade In/Out */
        @keyframes adFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes adFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Slide In Effects */
        @keyframes adSlideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes adSlideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes adSlideInTop {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes adSlideInBottom {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Bounce */
        @keyframes adBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-30px); }
            60% { transform: translateY(-15px); }
        }

        /* Zoom In/Out */
        @keyframes adZoomIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes adZoomOut {
            from { transform: scale(1.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Rotate */
        @keyframes adRotateIn {
            from { transform: rotate(-360deg) scale(0); opacity: 0; }
            to { transform: rotate(0deg) scale(1); opacity: 1; }
        }

        /* Pulse/Glow */
        @keyframes adPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes adGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 1), 0 0 30px rgba(102, 126, 234, 0.8); }
        }

        /* Flip */
        @keyframes adFlipIn {
            from { transform: perspective(400px) rotateY(90deg); opacity: 0; }
            to { transform: perspective(400px) rotateY(0deg); opacity: 1; }
        }

        @keyframes adFlipX {
            0% { transform: perspective(400px) rotateX(0deg); }
            50% { transform: perspective(400px) rotateX(180deg); }
            100% { transform: perspective(400px) rotateX(360deg); }
        }

        /* Wave */
        @keyframes adWave {
            0%, 100% { transform: translateY(0px); }
            25% { transform: translateY(-10px); }
            50% { transform: translateY(0px); }
            75% { transform: translateY(10px); }
        }

        /* Type Writer Effect */
        @keyframes adTypeWriter {
            from { width: 0; }
            to { width: 100%; }
        }

        @keyframes adBlink {
            0%, 100% { border-color: transparent; }
            50% { border-color: currentColor; }
        }

        /* Sparkle */
        @keyframes adSparkle {
            0%, 100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            25% {
                opacity: 0.7;
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(-5deg);
                filter: brightness(1.5);
            }
            75% {
                opacity: 0.8;
                transform: scale(1.1) rotate(3deg);
                filter: brightness(1.2);
            }
        }

        /* Shake */
        @keyframes adShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Swing */
        @keyframes adSwing {
            20% { transform: rotate(15deg); }
            40% { transform: rotate(-10deg); }
            60% { transform: rotate(5deg); }
            80% { transform: rotate(-5deg); }
            100% { transform: rotate(0deg); }
        }

        /* Rubber Band */
        @keyframes adRubberBand {
            0% { transform: scale(1); }
            30% { transform: scaleX(1.25) scaleY(0.75); }
            40% { transform: scaleX(0.75) scaleY(1.25); }
            50% { transform: scaleX(1.15) scaleY(0.85); }
            65% { transform: scaleX(0.95) scaleY(1.05); }
            75% { transform: scaleX(1.05) scaleY(0.95); }
            100% { transform: scale(1); }
        }

        /* Animation Classes */
        .ad-animation-fadeIn { animation: adFadeIn 1s ease-in-out infinite; }
        .ad-animation-fadeOut { animation: adFadeOut 1s ease-in-out infinite alternate; }
        .ad-animation-slideInLeft { animation: adSlideInLeft 1s ease-out infinite; }
        .ad-animation-slideInRight { animation: adSlideInRight 1s ease-out infinite; }
        .ad-animation-slideInTop { animation: adSlideInTop 1s ease-out infinite; }
        .ad-animation-slideInBottom { animation: adSlideInBottom 1s ease-out infinite; }
        .ad-animation-bounce { animation: adBounce 2s ease infinite; }
        .ad-animation-zoomIn { animation: adZoomIn 1s ease-in-out infinite; }
        .ad-animation-zoomOut { animation: adZoomOut 1s ease-in-out infinite; }
        .ad-animation-rotateIn { animation: adRotateIn 1s ease-in-out infinite; }
        .ad-animation-pulse { animation: adPulse 1.5s ease-in-out infinite; }
        .ad-animation-glow { animation: adGlow 2s ease-in-out infinite; }
        .ad-animation-flipIn { animation: adFlipIn 1s ease-in-out infinite; }
        .ad-animation-flipX { animation: adFlipX 2s ease-in-out infinite; }
        .ad-animation-wave { animation: adWave 2s ease-in-out infinite; }
        .ad-animation-sparkle { animation: adSparkle 2s ease-in-out infinite; }
        .ad-animation-shake { animation: adShake 0.5s ease infinite; }
        .ad-animation-swing { animation: adSwing 1s ease infinite; }
        .ad-animation-rubberBand { animation: adRubberBand 1s ease infinite; }
        .ad-animation-none { animation: none; }

        /* Calendar */
        .calendar-container {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .calendar-day-header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .calendar-day {
            background: var(--bg-card);
            min-height: 100px;
            padding: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .calendar-day:hover { background: var(--bg-hover); }
        .calendar-day.today { background: rgba(102, 126, 234, 0.2); }
        .calendar-day.has-orders { border-left: 4px solid var(--success); }
        .calendar-day.has-tasks { border-right: 4px solid var(--warning); }
        .calendar-day.has-festival { border-top: 4px solid var(--danger); }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .calendar-day-content {
            font-size: 0.8rem;
            color: var(--text-gray);
        }

        .festival-text {
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .order-count {
            background: var(--success);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
        }

        /* Quantity Controls */
        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Search Dropdown */
        .search-container { position: relative; margin-bottom: 1rem; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-dropdown.show { display: block; }

        .search-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-dark);
        }

        .search-item:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.3s ease;
        }

        /* Order ID Highlight */
        .order-id-highlight {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }

        /* Print Template - Force Light Theme Colors */
        .print-template {
            display: none;
            width: 2480px;
            min-height: 3508px;
            background: white !important;
            color: #000000 !important;
            padding: 80px 80px 80px 590px;
            font-family: 'Noto Sans Gujarati', Arial, sans-serif;
            font-size: 32px;
            line-height: 1.4;
            /* Force light theme - prevent dark theme inheritance */
            --text-dark: #1f2937 !important;
            --text-gray: #6b7280 !important;
            --border: #e5e7eb !important;
        }

        /* Ensure all text within print template is black */
        .print-template * {
            color: inherit;
        }

        /* Undo Bar */
        .undo-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: transform 0.3s ease;
        }

        .undo-bar.show { transform: translateX(-50%) translateY(0); }

        .undo-btn {
            background: var(--white);
            color: var(--text-dark);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Quick Action Menu */
        .quick-menu {
            position: absolute;
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 0.5rem 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .quick-menu.show { display: block; }

        .quick-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quick-menu-item:hover { background: var(--light); }

        /* Keyboard Shortcuts Panel */
        .shortcuts-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2499;
            display: none;
        }

        .shortcuts-backdrop.show {
            display: block;
        }

        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 2500;
            max-width: 600px;
            display: none;
        }

        .shortcuts-panel.show { display: block; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-key {
            background: var(--light);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Drag Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        /* Mobile Responsive - Comprehensive Optimization */
        @media (max-width: 768px) {
            /* Typography */
            html {
                font-size: 14px;
            }

            body {
                overflow-x: hidden;
            }

            /* Header Optimization */
            .app-header {
                padding: 0.75rem 0;
                position: relative;
            }

            .header-content {
                flex-direction: column;
                gap: 0.75rem;
                padding: 0 0.75rem;
            }

            .company-name {
                font-size: 1.4rem;
                text-align: center;
                width: 100%;
            }

            .header-controls {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                gap: 0.5rem;
                padding-bottom: 0.75rem;
                margin-bottom: 0.5rem;
                border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            }

            /* Logout Button Safety - Prevent Accidental Clicks */
            .header-controls .btn-danger {
                order: -1; /* Move logout button to the first position (top) */
                width: 100%;
                max-width: 200px;
                margin-bottom: 0.75rem;
                padding: 0.75rem 1.5rem;
                font-size: 0.95rem;
                font-weight: 600;
                border: 2px solid rgba(255, 255, 255, 0.3);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            }

            /* Other header buttons */
            .header-controls .btn-info,
            .header-controls .btn-secondary {
                flex: 1;
                min-width: 90px;
            }

            /* Weather Mini Dashboard */
            #weatherMiniDashboard {
                font-size: 0.8rem;
                padding: 0.4rem 0.75rem;
                gap: 0.5rem;
            }

            .weather-mini-icon {
                font-size: 1.2rem;
            }

            .weather-mini-temp {
                font-size: 0.95rem;
            }

            /* Search Optimization */
            .search-global {
                width: 100%;
                max-width: 300px;
            }

            .search-global input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 0.65rem 2.5rem 0.65rem 1rem;
            }

            .search-results {
                max-height: 300px;
            }

            /* Navigation Tabs */
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .nav-container {
                padding: 0 0.5rem;
                min-width: min-content;
            }

            .nav-tab {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
                min-width: max-content;
            }

            /* Main Content */
            .main-content {
                padding: 1rem 0.75rem;
            }

            /* Cards */
            .card {
                padding: 1rem;
                margin-bottom: 1rem;
                border-radius: 12px;
            }

            .card-header {
                margin-bottom: 1rem;
                padding-bottom: 0.75rem;
            }

            .card-title {
                font-size: 1.25rem;
                flex-wrap: wrap;
            }

            /* Forms - Touch Friendly */
            .form-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .form-group {
                gap: 0.4rem;
            }

            .form-label {
                font-size: 0.9rem;
            }

            .form-input,
            .form-select,
            .form-textarea {
                padding: 0.85rem;
                font-size: 16px; /* Prevents zoom on iOS */
                border-width: 2px;
                min-height: 44px; /* Touch-friendly minimum */
            }

            .form-textarea {
                min-height: 120px;
            }

            /* Buttons - Touch Friendly */
            .btn {
                padding: 0.85rem 1.25rem;
                font-size: 1rem;
                min-height: 44px; /* Touch-friendly minimum */
                width: 100%;
                justify-content: center;
            }

            .btn-small {
                padding: 0.65rem 1rem;
                font-size: 0.85rem;
                min-height: 40px;
            }

            .btn-group {
                flex-direction: column;
                gap: 0.75rem;
                width: 100%;
            }

            .btn-group .btn {
                width: 100%;
            }

            /* Stats Grid */
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .stat-card {
                padding: 1.25rem;
            }

            .stat-value {
                font-size: 2rem;
            }

            /* Tables - Horizontal Scroll */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 0 -0.75rem;
                border-radius: 0;
            }

            .table {
                min-width: 600px; /* Ensures table doesn't squish */
            }

            .table th,
            .table td {
                padding: 0.65rem 0.5rem;
                font-size: 0.85rem;
                white-space: nowrap;
            }

            .table th {
                position: sticky;
                top: 0;
                z-index: 10;
            }

            /* Status Badges */
            .status-badge {
                padding: 0.3rem 0.65rem;
                font-size: 0.8rem;
            }

            /* Modals - Full Screen on Mobile */
            .modal {
                padding: 0;
                align-items: stretch;
            }

            .modal.show {
                padding: 0;
            }

            .modal-content {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
                border-radius: 0;
                padding: 1rem;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .modal-close {
                top: 0.75rem;
                right: 0.75rem;
                font-size: 2rem;
                padding: 0.5rem;
                z-index: 1001;
                background: var(--bg-card);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Calendar Optimization */
            .calendar-container {
                padding: 0.75rem;
                margin: 0 -0.75rem;
                border-radius: 0;
            }

            .calendar-header {
                flex-wrap: wrap;
                gap: 0.75rem;
            }

            .calendar-nav {
                gap: 0.5rem;
                flex-wrap: wrap;
            }

            .calendar-grid {
                gap: 1px;
            }

            .calendar-day-header {
                padding: 0.5rem 0.25rem;
                font-size: 0.75rem;
            }

            .calendar-day {
                min-height: 60px;
                padding: 0.3rem;
            }

            .calendar-day-number {
                font-size: 0.85rem;
            }

            .calendar-day-content {
                font-size: 0.7rem;
            }

            .festival-text {
                font-size: 0.65rem;
            }

            .order-count {
                width: 18px;
                height: 18px;
                font-size: 0.65rem;
            }

            /* Quantity Controls */
            .quantity-controls {
                gap: 0.4rem;
            }

            .quantity-btn {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            /* Toast Notifications */
            .toast {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
                padding: 0.85rem;
                font-size: 0.9rem;
            }

            /* Undo Bar */
            .undo-bar {
                bottom: 10px;
                left: 10px;
                right: 10px;
                transform: translateY(100px);
                padding: 0.85rem;
                min-width: auto;
            }

            .undo-bar.show {
                transform: translateY(0);
            }

            /* Loading Spinner */
            .loading {
                padding: 1.5rem;
                max-width: calc(100% - 2rem);
            }

            /* Quick Menu */
            .quick-menu {
                min-width: 160px;
                max-width: calc(100vw - 2rem);
            }

            .quick-menu-item {
                padding: 0.85rem;
                min-height: 44px;
            }

            /* Shortcuts Panel */
            .shortcuts-panel {
                max-width: calc(100% - 2rem);
                padding: 1.5rem;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
            }

            .shortcut-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
                padding: 0.75rem 0;
            }

            /* Drop Zone */
            .drop-zone {
                padding: 1.5rem 1rem;
                font-size: 0.9rem;
            }

            /* Search Dropdown */
            .search-dropdown {
                max-height: 250px;
            }

            .search-item {
                padding: 0.85rem;
                min-height: 44px;
            }

            /* Print Template - Adjust for Mobile Preview */
            .print-template {
                width: 100%;
                padding: 40px 20px;
                font-size: 14px;
            }

            /* Order ID Highlight */
            .order-id-highlight {
                padding: 0.3rem 0.65rem;
                font-size: 0.85rem;
            }

            /* Progress Bar */
            .progress-bar {
                height: 6px;
                margin: 0.75rem 0;
            }

            /* Utility Adjustments */
            .text-center {
                text-align: center !important;
            }
        }

        /* Extra Small Devices */
        @media (max-width: 480px) {
            html {
                font-size: 13px;
            }

            .company-name {
                font-size: 1.2rem;
            }

            .nav-tab {
                padding: 0.65rem 0.85rem;
                font-size: 0.85rem;
            }

            .card {
                padding: 0.85rem;
            }

            .card-title {
                font-size: 1.1rem;
            }

            .form-input,
            .form-select,
            .form-textarea {
                padding: 0.75rem;
            }

            .btn {
                padding: 0.75rem 1rem;
            }

            .stat-value {
                font-size: 1.75rem;
            }

            .calendar-day {
                min-height: 50px;
            }

            .modal-content {
                padding: 0.75rem;
            }
        }

        /* Landscape Orientation Optimization */
        @media (max-width: 768px) and (orientation: landscape) {
            .modal-content {
                height: auto;
                max-height: 95vh;
            }

            .calendar-day {
                min-height: 45px;
            }
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: 0.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }

    </style>
    <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>

    <!-- Google Maps JavaScript API with Places Library -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAInxvvhevCHpLy9P5K5VvBNxDgbtZF-A4&libraries=places&loading=async&callback=initGoogleMaps" async defer></script>

    <!-- Confetti Library for Login Success -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        /* ðŸ”¥ BURNING FLAMES LOGIN THEME - OPTION 1 */

        #loginScreen {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><rect width="100%25" height="100%25" fill="%23000"/></svg>');
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
        }

        /* Login Slideshow Container */
        .login-slideshow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .login-slideshow-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        .login-slideshow-slide.active {
            opacity: 0.85;
        }

        /* Realistic Flame Flicker Animation */
        @keyframes flame-flicker {
            0%, 100% {
                filter: brightness(1) contrast(1.1);
                transform: scale(1);
            }
            25% {
                filter: brightness(1.15) contrast(1.2);
                transform: scale(1.02);
            }
            50% {
                filter: brightness(0.95) contrast(1.05);
                transform: scale(1.01);
            }
            75% {
                filter: brightness(1.1) contrast(1.15);
                transform: scale(1.015);
            }
        }

        /* Heat Distortion Overlay */
        #loginScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,140,0,0.1) 50%, rgba(255,69,0,0.2) 100%);
            animation: heat-wave 4s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes heat-wave {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }


        /* Floating Embers Canvas */
        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        /* Login Card with Glass-Morphism */
        .login-card {
            position: relative;
            z-index: 3;
            background: rgba(0, 0, 0, 0.25) !important;
            border: 2px solid rgba(255,140,0,0.5);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            animation: rise-from-flames 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                       card-fire-glow 2s ease-in-out 1.2s infinite;
        }

        /* Card Rises from Flames - Bottom Right */
        @keyframes rise-from-flames {
            0% {
                opacity: 0;
                transform: translate(100px, 100px) scale(0.8);
                filter: blur(10px);
            }
            60% {
                opacity: 0.8;
            }
            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
                filter: blur(0);
            }
        }

        @keyframes card-fire-glow {
            0%, 100% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 40px rgba(255,107,0,0.4),
                            inset 0 0 20px rgba(255,140,0,0.15);
                border-color: rgba(255,140,0,0.5);
            }
            50% {
                box-shadow: 0 10px 40px rgba(0,0,0,0.4),
                            0 0 60px rgba(255,140,0,0.6),
                            inset 0 0 30px rgba(255,107,0,0.25);
                border-color: rgba(255,165,0,0.7);
            }
        }

        /* Logo with Fire Animation */
        .login-logo {
            animation: logo-burn 3s ease-in-out infinite;
            color: #ffa500 !important;
            text-shadow: 0 0 15px rgba(255,140,0,1),
                         0 0 30px rgba(255,107,0,0.8),
                         0 0 45px rgba(255,69,0,0.6);
        }

        @keyframes logo-burn {
            0%, 100% {
                transform: translateY(0px);
                text-shadow: 0 0 15px rgba(255,140,0,1),
                             0 0 30px rgba(255,107,0,0.8),
                             0 0 45px rgba(255,69,0,0.6);
            }
            50% {
                transform: translateY(-8px);
                text-shadow: 0 0 20px rgba(255,165,0,1),
                             0 0 40px rgba(255,140,0,0.9),
                             0 0 60px rgba(255,107,0,0.7);
            }
        }

        /* Fire-themed Button */
        #loginBtn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #ff6b00 0%, #ff4500 100%) !important;
            border: 2px solid #ff8c00;
        }

        #loginBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(255,107,0,0.6),
                        0 0 40px rgba(255,69,0,0.4);
            border-color: #ffa500;
        }

        #loginBtn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,215,0,0.4);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #loginBtn:hover::before {
            width: 300px;
            height: 300px;
        }

        /* Input Fields with Glass Effect */
        #loginEmail, #loginPassword {
            background: rgba(255, 255, 255, 0.15) !important;
            color: #fff !important;
            border: 2px solid rgba(255,140,0,0.4) !important;
            backdrop-filter: blur(10px);
        }

        #loginEmail:focus, #loginPassword:focus {
            border-color: #ff8c00 !important;
            box-shadow: 0 0 25px rgba(255,140,0,0.6),
                        inset 0 0 15px rgba(255,165,0,0.2) !important;
            outline: none !important;
            background: rgba(255, 255, 255, 0.2) !important;
        }

        /* Labels in Glass Theme */
        .login-card label {
            color: #ffb347 !important;
            text-shadow: 0 0 8px rgba(255,140,0,0.7);
            font-weight: 600;
        }

        /* Footer Text */
        .login-card > div:last-child {
            color: #ffa500 !important;
            text-shadow: 0 0 5px rgba(255,140,0,0.5);
        }
    </style>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: flex; align-items: flex-end; justify-content: flex-end; padding: 2rem;">
        <!-- Login Background Slideshow -->
        <div class="login-slideshow">
            <div class="login-slideshow-slide active" style="background-image: url('https://raw.githubusercontent.com/godownoffice69-gif/quotations-generator/main/assets/fire-background.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('https://raw.githubusercontent.com/godownoffice69-gif/quotations-generator/main/assets/slideshow-1.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('https://raw.githubusercontent.com/godownoffice69-gif/quotations-generator/main/assets/slideshow-2.jpg');"></div>
            <div class="login-slideshow-slide" style="background-image: url('https://raw.githubusercontent.com/godownoffice69-gif/quotations-generator/main/assets/slideshow-3.jpg');"></div>
        </div>

        <!-- Floating Particles Background -->
        <canvas id="particles-canvas"></canvas>

        <div class="login-card" style="background: white; padding: 2rem; border-radius: 16px; max-width: 320px; width: auto;">
            <h1 class="login-logo" style="text-align: center; color: #667eea; margin-bottom: 1.5rem; font-size: 1.75rem;">ðŸ”¥ Firepower SFX</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="ðŸ” Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <div id="weatherMiniDashboard">
                        <span class="weather-mini-icon">ðŸŒ¤ï¸</span>
                        <div class="weather-mini-info">
                            <span class="weather-mini-temp">--Â°C</span>
                            <span class="weather-mini-condition">Loading...</span>
                        </div>
                    </div>
                    <button class="btn btn-info btn-small" onclick="OMS.toggleLanguage()" id="languageToggle" title="Switch Language">
                        ðŸŒ EN
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">âŒ¨ï¸</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">ðŸšª Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">ðŸ“Š Dashboard</button>
                <button class="nav-tab" data-tab="orders">ðŸ“ Orders</button>
                <button class="nav-tab" data-tab="inventory">ðŸ“¦ Inventory</button>
                <button class="nav-tab" data-tab="itemHistory">ðŸ“œ Item History</button>
                <button class="nav-tab" data-tab="preparation">ðŸ“‹ Preparation</button>
                <button class="nav-tab" data-tab="customers">ðŸ‘¥ Customers</button>
                <button class="nav-tab" data-tab="quotations">ðŸ“„ Quotations</button>
                <button class="nav-tab" data-tab="team">ðŸ‘· Team</button>
                <button class="nav-tab" data-tab="calendar">ðŸ—“ï¸ Calendar</button>
                <button class="nav-tab" data-tab="history">ðŸ“š History</button>
                <button class="nav-tab" data-tab="analytics">ðŸ“ˆ Analytics</button>
                <button class="nav-tab" data-tab="videos">ðŸŽ¥ Videos</button>
                <button class="nav-tab" data-tab="advertisements">ðŸ“¢ Ads</button>
                <button class="nav-tab" data-tab="financials">ðŸ’° Financials</button>
                <button class="nav-tab" data-tab="settings">âš™ï¸ Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">ðŸ”” Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">ðŸ• Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">ðŸ“ Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Event Type</label>
                                <select id="eventTypeSelect" class="form-select" required>
                                    <option value="single">Single Day Event</option>
                                    <option value="multi">Multi-Day Event</option>
                                </select>
                            </div>
                        </div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-grid">
    <div class="form-group">
        <label class="form-label required">Event Date</label>
        <input type="date" id="orderDate" name="orderDate" class="form-input highlight-datetime" required>
    </div>
    <div class="form-group">
        <label class="form-label">Ready Time</label>
        <select id="readyTime" name="readyTime" class="form-select highlight-datetime"></select>
    </div>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" name="startDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" name="endDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">ðŸ“… Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Contact</label>
                                <input type="tel" id="contact" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Venue</label>
                                <input type="text" id="venue" class="form-input" placeholder="Search for venue...">
                                <!-- Hidden field to store Google Maps link -->
                                <input type="hidden" id="venueMapLink">
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <select id="eventType" class="form-select">
                                    <option value="">Select Event Type</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Transport</label>
                                <select id="transport" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Transport 2 (Optional)</label>
                                <select id="transport2" class="form-select">
                                    <option value="">Select</option>
                                    <option value="New Bolero">New Bolero</option>
                                    <option value="Old Bolero">Old Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransport2Group">
                                <label class="form-label">Custom Transport 2</label>
                                <input type="text" id="customTransport2" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver 2 (Optional)</label>
                                <select id="driverName2" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper(s)</label>
                                <input type="text" id="helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)">
                                <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">ðŸ“¦ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="ðŸ” Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">ðŸ’¾ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-success" onclick="OMS.quickAddPayment()">ðŸ’µ Quick Payment</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">ðŸ‘ï¸ Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">ðŸ“‹ Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">ðŸ“… Same Day</button>
                            <button type="button" class="btn btn-danger" data-action="clear">ðŸ—‘ï¸ Clear (Ctrl+D)</button>
                        </div>
                    </form>
                </div>

                <!-- WhatsApp Date Filter Section -->
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <h2 class="card-title">ðŸ“± WhatsApp Orders Report</h2>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Select Date to View Orders</label>
                        <input type="date" id="whatsappFilterDate" class="form-input" style="max-width: 300px;">
                        <small style="color: var(--text-gray); display: block; margin-top: 0.5rem;">Select a date to see all orders and send them via WhatsApp</small>
                    </div>
                    <div id="whatsappOrdersPreview" style="margin-top: 1rem; display: none;">
                        <div style="background: var(--bg-hover); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <h4 style="margin: 0 0 0.5rem 0;">ðŸ“‹ Orders Found: <span id="whatsappOrderCount">0</span></h4>
                            <div id="whatsappOrdersList" style="max-height: 300px; overflow-y: auto; font-size: 0.9rem; white-space: pre-wrap; font-family: monospace; background: var(--bg-card); padding: 0.75rem; border-radius: 4px;"></div>
                        </div>
                        <button type="button" class="btn btn-success" id="sendWhatsAppOrdersBtn" style="width: 100%;">
                            ðŸ“± Send on WhatsApp
                        </button>
                    </div>
                    <div id="whatsappNoOrders" style="display: none; padding: 1rem; text-align: center; color: var(--text-gray);">
                        ðŸ“­ No orders found for selected date
                    </div>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="itemHistory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="quotations" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="videos" class="tab-content"></div>
            <div id="advertisements" class="tab-content"></div>
            <div id="financials" class="tab-content"></div>
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsBackdrop" class="shortcuts-backdrop" onclick="OMS.hideShortcuts()"></div>
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">Ã—</button>
        <h2>âŒ¨ï¸ Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <script>
        
        // ============ UTILITIES ============
        const Utils = {
            get: (id, defaultValue = '') => {
                const el = document.getElementById(id);
                return el ? (el.value || '').toString().trim() : defaultValue;
            },

            set: (id, value) => {
                const el = document.getElementById(id);
                if (el) el.value = value;
            },

            elem: (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.entries(props).forEach(([key, val]) => {
                    if (key === 'class') el.className = val;
                    else if (key === 'style') Object.assign(el.style, val);
                    else if (key.startsWith('on')) el.addEventListener(key.slice(2).toLowerCase(), val);
                    else if (key.startsWith('data-')) el.dataset[key.slice(5)] = val;
                    else el[key] = val;
                });
                children.filter(child => child != null).forEach(child => {
                    el.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
                });
                return el;
            },

            formatDate: (dateStr) => {
    if (!dateStr) return 'N/A';
    try {
        const date = new Date(dateStr + 'T00:00:00');
        return date.toLocaleDateString('en-GB');
    } catch {
        return dateStr;
    }
},

convertDateFormat: (dateStr) => {
    if (!dateStr) return '';
    try {
        // Convert DD/MM/YYYY to YYYY-MM-DD
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            const day = parts[0].padStart(2, '0');
            const month = parts[1].padStart(2, '0');
            const year = parts[2];
            return `${year}-${month}-${day}`;
        }
        return dateStr;
    } catch {
        return dateStr;
    }
},

getLocalDate: (dateStr) => {
    if (!dateStr) return new Date();
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day);
},

toDateString: (date) => {
    const d = date instanceof Date ? date : new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
},

generateId: () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

debounce: (func, wait) => {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
},

            validateRequired: (fields) => {
                const errors = [];
                fields.forEach(field => {
                    const value = Utils.get(field);
                    if (!value) errors.push(field);
                });
                return errors;
            },

            // Mobile device detection
            isMobileDevice: () => {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            // Get device type for logging
            getDeviceType: () => {
                const ua = navigator.userAgent;
                if (/iPad/i.test(ua)) return 'iPad';
                if (/iPhone|iPod/i.test(ua)) return 'iPhone';
                if (/Android/i.test(ua)) return 'Android';
                return 'Desktop';
            },

            // Convert canvas.toBlob callback to Promise
            canvasToBlobPromise: (canvas, type = 'image/png', quality = 0.95) => {
                return new Promise((resolve, reject) => {
                    try {
                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas toBlob returned null - image may be too large for device memory'));
                            }
                        }, type, quality);
                    } catch (error) {
                        reject(error);
                    }
                });
            },

            // Get optimal canvas scale for device
            getOptimalCanvasScale: (baseScale) => {
                const isMobile = Utils.isMobileDevice();
                const deviceMemory = navigator.deviceMemory || 4; // Default to 4GB if not available

                if (!isMobile) {
                    return baseScale; // Desktop: use requested scale
                }

                // Mobile optimizations based on device memory
                if (deviceMemory <= 2) {
                    return Math.min(baseScale, 1); // Low memory: max scale 1
                } else if (deviceMemory <= 4) {
                    return Math.min(baseScale, 1.5); // Medium memory: max scale 1.5
                } else {
                    return Math.min(baseScale, 2); // Higher memory: max scale 2
                }
            },

            // Validate canvas dimensions for device
            validateCanvasDimensions: (width, height) => {
                const maxDimension = Utils.isMobileDevice() ? 4096 : 32767; // Mobile: 4096, Desktop: 32767
                const maxArea = Utils.isMobileDevice() ? 16777216 : 268435456; // Mobile: 16MP, Desktop: 256MP
                const area = width * height;

                if (width > maxDimension || height > maxDimension) {
                    return {
                        valid: false,
                        reason: `Canvas dimension exceeds maximum (${maxDimension}px) for this device`
                    };
                }

                if (area > maxArea) {
                    return {
                        valid: false,
                        reason: `Canvas area (${area}px) exceeds maximum (${maxArea}px) for this device`
                    };
                }

                return { valid: true };
            },

            // Weather API integration
            getWeather: async (city = 'Delhi', apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('âš ï¸ Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    // Using OpenWeatherMap free API
                    // Get your free API key from: https://openweathermap.org/api
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        // Fallback to mock data if API fails
                        console.error(`Weather API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather data unavailable'
                        };
                    }

                    const data = await response.json();
                    return {
                        temp: Math.round(data.main.temp),
                        humidity: data.main.humidity,
                        condition: data.weather[0].main,
                        description: data.weather[0].description,
                        icon: data.weather[0].icon
                    };
                } catch (error) {
                    console.error('Weather API error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather data unavailable'
                    };
                }
            },

            // Get weather by coordinates
            getWeatherByCoords: async (lat, lon, apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('âš ï¸ Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        console.error(`Weather API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather data unavailable'
                        };
                    }

                    const data = await response.json();
                    return {
                        temp: Math.round(data.main.temp),
                        humidity: data.main.humidity,
                        condition: data.weather[0].main,
                        description: data.weather[0].description,
                        icon: data.weather[0].icon,
                        city: data.name
                    };
                } catch (error) {
                    console.error('Weather API error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather data unavailable'
                    };
                }
            },

            // Get weather forecast for a specific date
            getWeatherForecast: async (city = 'Delhi', targetDate, apiKey = '') => {
                try {
                    // Check if API key is valid (not empty, not 'demo')
                    if (!apiKey || apiKey === 'demo' || apiKey.trim() === '') {
                        console.warn('âš ï¸ Weather API key not configured. Please add your API key in Settings.');
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Configure API key in Settings'
                        };
                    }

                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const target = new Date(targetDate);
                    target.setHours(0, 0, 0, 0);

                    // If target date is today, use current weather API
                    if (target.getTime() === today.getTime()) {
                        return await Utils.getWeather(city, apiKey);
                    }

                    // For future dates (up to 5 days), use forecast API
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(city)}&appid=${apiKey}&units=metric`);

                    if (!response.ok) {
                        console.error(`Weather forecast API error: ${response.status} ${response.statusText}`);
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: response.status === 401 ? 'Invalid API key' : 'Weather forecast unavailable'
                        };
                    }

                    const data = await response.json();

                    // Find forecast closest to noon on target date
                    const targetTime = new Date(target);
                    targetTime.setHours(12, 0, 0, 0);

                    let closestForecast = null;
                    let minDiff = Infinity;

                    data.list.forEach(forecast => {
                        const forecastTime = new Date(forecast.dt * 1000);
                        const diff = Math.abs(forecastTime - targetTime);

                        if (diff < minDiff) {
                            minDiff = diff;
                            closestForecast = forecast;
                        }
                    });

                    if (!closestForecast) {
                        return {
                            temp: 'N/A',
                            humidity: 'N/A',
                            condition: 'N/A',
                            description: 'Forecast not available for this date'
                        };
                    }

                    return {
                        temp: Math.round(closestForecast.main.temp),
                        tempMin: Math.round(closestForecast.main.temp_min),
                        tempMax: Math.round(closestForecast.main.temp_max),
                        humidity: closestForecast.main.humidity,
                        condition: closestForecast.weather[0].main,
                        description: closestForecast.weather[0].description,
                        icon: closestForecast.weather[0].icon
                    };
                } catch (error) {
                    console.error('Weather forecast error:', error);
                    return {
                        temp: 'N/A',
                        humidity: 'N/A',
                        condition: 'N/A',
                        description: 'Weather forecast unavailable'
                    };
                }
            },

            // Get weather icon emoji
            getWeatherEmoji: (condition) => {
                const conditionLower = condition.toLowerCase();
                if (conditionLower.includes('clear') || conditionLower.includes('sun')) return 'â˜€ï¸';
                if (conditionLower.includes('cloud')) return 'â˜ï¸';
                if (conditionLower.includes('rain') || conditionLower.includes('drizzle')) return 'ðŸŒ§ï¸';
                if (conditionLower.includes('thunder') || conditionLower.includes('storm')) return 'â›ˆï¸';
                if (conditionLower.includes('snow')) return 'â„ï¸';
                if (conditionLower.includes('mist') || conditionLower.includes('fog') || conditionLower.includes('haze')) return 'ðŸŒ«ï¸';
                return 'ðŸŒ¤ï¸';
            }
        };

        // ============ TRANSLATIONS ============
        const translations = {
            en: {
                // Header
                companyName: 'Order Management System',
                searchPlaceholder: 'ðŸ” Search everything...',
                next: 'Next',
                logout: 'ðŸšª Logout',

                // Tabs
                dashboard: 'ðŸ“Š Dashboard',
                orders: 'ðŸ“‹ Orders',
                inventory: 'ðŸ“¦ Inventory',
                itemHistory: 'ðŸ“œ Item History',
                preparation: 'ðŸ³ Preparation',
                customers: 'ðŸ‘¥ Customers',
                team: 'ðŸ‘¨â€ðŸ’¼ Team',
                calendar: 'ðŸ“… Calendar',
                history: 'ðŸ•’ History',
                analytics: 'ðŸ“ˆ Analytics',
                videos: 'ðŸŽ¥ Videos',
                advertisements: 'ðŸ“¢ Ads',
                financials: 'ðŸ’° Financials',
                settings: 'âš™ï¸ Settings',

                // Common Buttons
                save: 'Save',
                cancel: 'Cancel',
                edit: 'Edit',
                delete: 'Delete',
                add: 'Add',
                close: 'Close',
                confirm: 'Confirm',
                clear: 'Clear',
                preview: 'Preview',
                duplicate: 'Duplicate',
                export: 'Export',
                import: 'Import',
                reset: 'Reset',
                search: 'Search',
                download: 'Download',
                upload: 'Upload',
                filter: 'Filter',
                print: 'Print',

                // Order Form
                orderDetails: 'Order Details',
                clientName: 'Client Name',
                contact: 'Contact',
                venue: 'Venue',
                orderDate: 'Order Date',
                readyTime: 'Ready Time',
                eventType: 'Event Type',
                transport: 'Transport',
                customTransport: 'Custom Transport',
                driverName: 'Driver Name',
                operator: 'Operator',
                helpers: 'Helper(s)',
                helperPlaceholder: 'Enter helper name(s), separate multiple with commas',
                orderStatus: 'Order Status',
                notes: 'Notes',
                items: 'Items',
                addItem: 'Add Item',
                itemName: 'Item Name',
                quantity: 'Pieces',
                remarks: 'Remarks',
                serialNumber: 'Sr. No.',

                // Status
                confirmed: 'Confirmed',
                completed: 'Completed',
                cancelled: 'Cancelled',
                pending: 'Pending',
                active: 'Active',
                inactive: 'Inactive',

                // Actions
                saveOrder: 'ðŸ’¾ Save Order',
                saveOrderShortcut: 'ðŸ’¾ Save Order (Ctrl+S)',
                duplicateLast: 'ðŸ“‹ Duplicate Last',
                sameDay: 'ðŸ“… Same Day',
                clearForm: 'ðŸ—‘ï¸ Clear',
                clearFormShortcut: 'ðŸ—‘ï¸ Clear (Ctrl+D)',
                notifyTeam: 'ðŸ“± Notify Allocated Team',
                sendReport: 'ðŸ“Š Send Manager Report',

                // Settings
                systemSettings: 'âš™ï¸ System Settings',
                printSettings: 'ðŸ–¨ï¸ Print Settings',
                tableLayoutSettings: 'ðŸ“‹ Table Layout Settings',
                colorCustomization: 'ðŸŽ¨ Color Customization',
                systemPreferences: 'ðŸ”§ System Preferences',
                dataManagement: 'ðŸ“Š Data Management',

                fontSize: 'Default Font Size',
                paperFormat: 'Paper Format',
                pageOrientation: 'Page Orientation',
                imageQuality: 'Image Quality',
                functionColor: 'Function Slot Color',
                portrait: 'ðŸ“„ Portrait',
                landscape: 'ðŸ“ƒ Landscape',
                low: 'Low',
                medium: 'Medium',
                high: 'High',
                ultra: 'Ultra',
                faster: 'Faster',
                balanced: 'Balanced',
                betterQuality: 'Better Quality',
                bestQuality: 'Best Quality',

                srColumnWidth: 'Sr.No Column Width',
                itemColumnWidth: 'Item Name Width',
                qtyColumnWidth: 'Pieces Width',
                remarksColumnWidth: 'Remarks Width',
                leftMarginFiling: 'Left Margin (filing)',

                headerBackground: 'Header Background',
                headerText: 'Header Text',
                orderIdBackground: 'Order ID Background',
                orderIdText: 'Order ID Text',
                tableHeaderBackground: 'Table Header Background',
                tableHeaderText: 'Table Header Text',
                tableBorder: 'Table Border',
                notesBackground: 'Notes Background',

                defaultOrderStatus: 'Default Order Status',
                lowStockThreshold: 'Low Stock Threshold',
                language: 'Language',
                invoiceFormat: 'Invoice Number Format',

                saveAllSettings: 'ðŸ’¾ Save All Settings',
                resetToDefaults: 'ðŸ”„ Reset to Defaults',
                exportJSON: 'ðŸ“¤ Export JSON',
                exportCSV: 'ðŸ“Š Export CSV',
                importBackup: 'ðŸ“¥ Import Backup',
                resetAllData: 'ðŸ—‘ï¸ Reset All Data',

                // Multi-day
                multiDayOrder: 'Multi-day Order',
                singleDayOrder: 'Single-day Order',
                startDate: 'Start Date',
                endDate: 'End Date',
                addDay: 'âž• Add Day',
                addFunction: 'âž• Add Function',
                removeDay: 'ðŸ—‘ï¸ Remove Day',
                removeFunction: 'ðŸ—‘ï¸ Remove Function',
                dayNumber: 'Day',
                functionNumber: 'Function',
                functionType: 'Function Type',
                timeSlot: 'Time Slot',
                driver: 'Driver',

                // Dashboard
                totalOrders: 'Total Orders',
                confirmedOrders: 'Confirmed',
                completedOrders: 'Completed',
                cancelledOrders: 'Cancelled',
                pendingOrders: 'Pending',
                recentOrders: 'Recent Orders',
                quickStats: 'Quick Stats',
                thisMonth: 'This Month',
                thisWeek: 'This Week',
                today: 'Today',

                // Team
                teamManagement: 'Team Management',
                addTeamMember: 'Add Team Member',
                memberName: 'Member Name',
                role: 'Role',
                roles: 'Roles',
                phoneNumber: 'Phone Number',
                email: 'Email',
                status: 'Status',
                actions: 'Actions',

                // Inventory
                inventoryManagement: 'Inventory Management',
                addCategory: 'Add Category',
                addInventoryItem: 'Add Inventory Item',
                categoryName: 'Category Name',
                currentStock: 'Current Stock',
                unit: 'Unit',
                reorderLevel: 'Reorder Level',

                // Calendar
                month: 'Month',
                week: 'Week',
                day: 'Day',
                ordersFor: 'Orders for',
                noOrders: 'No orders for this date',

                // History
                orderHistory: 'Order History',
                deletedOrders: 'Deleted Orders',
                restore: 'Restore',
                permanentlyDelete: 'Permanently Delete',

                // Analytics
                analyticsReport: 'Analytics Report',
                dateRange: 'Date Range',
                from: 'From',
                to: 'To',
                generateReport: 'Generate Report',
                topItems: 'Top Items',
                orderTrends: 'Order Trends',

                // Messages
                orderSaved: 'Order saved successfully!',
                orderDeleted: 'Order deleted!',
                settingsSaved: 'All settings saved successfully!',
                itemAdded: 'Item added!',
                itemRemoved: 'Item removed!',
                error: 'Error',
                success: 'Success',
                warning: 'Warning',
                info: 'Info',
                loading: 'Loading...',
                generatingImage: 'Generating image...',
                downloadComplete: 'Download complete!',

                // Placeholders
                enterClientName: 'Enter client name',
                enterContact: 'Enter contact number',
                enterVenue: 'Enter venue',
                selectDate: 'Select date',
                selectTime: 'Select time',
                selectEventType: 'Select event type',
                selectTransport: 'Select transport',
                selectDriver: 'Select Driver',
                selectOperator: 'Select Operator',
                selectHelper: 'Select Helper',
                enterNotes: 'Enter notes...',
                searchItem: 'Search item...',

                // Confirmations
                confirmDelete: 'Are you sure you want to delete?',
                confirmReset: 'Reset all settings?',
                confirmClear: 'Clear form?',
                cannotUndo: 'This action cannot be undone.',

                // Info messages
                multiOrderNote: 'Note: Multi-order images use smart auto-sizing',
                higherQualityNote: 'Higher quality = larger file size',
                multipleHelpersNote: 'You can add multiple helpers separated by commas (e.g., John, Mary, David)',
                chooseFormat: 'Choose paper size for print layout',
                portraitOrLandscape: 'Portrait or landscape mode',
                customColorNote: 'Custom color for function slots',

                // Additional translations for complete coverage
                lowStock: 'Low Stock',
                orderId: 'Order ID',
                client: 'Client',
                event: 'Event',
                date: 'Date',
                view: 'View',
                ordersText: 'orders',
                batchUpdate: 'âš¡ Batch Update',
                categories: 'Categories',
                enterCategoryName: 'Category name',
                enterItemName: 'Item name',
                selectCategory: 'Select category',
                category: 'Category',
                item: 'Item',
                stock: 'Stock',
                topCustomer: 'Top Customer',
                preparationForecast: 'Preparation Forecast',
                selectDateRange: 'Select Date Range',
                generate: 'Generate',
                aggregatedItems: 'Aggregated Items for Date Range',
                forecastSummary: 'Forecast Summary',
                totalItems: 'Total Items',
                ordersInRange: 'Orders in Range',
                itemsToPrep: 'Items to Prepare',
                noOrdersFound: 'No orders found in the selected date range',
                customers: 'Customers',
                addCustomer: 'Add Customer',
                customerName: 'Customer Name',
                totalOrdersCount: 'Total Orders',
                lastOrder: 'Last Order',
                never: 'Never',
                na: 'N/A',
                viewOrders: 'View Orders',
                editTeamMember: 'Edit Team Member',
                addThisDay: 'âž• Add to This Day',
                removeThisDay: 'ðŸ—‘ï¸ Remove',
                functionColor: 'Function Slot Color',
                addFunctionToThisDay: 'Add Function to This Day',
                selectOperatorPlaceholder: 'Select Operator',
                selectHelperPlaceholder: 'Select Helper',
                functionNotes: 'Special requirements for this function...',
                searchItems: 'ðŸ” Search items...',
                noItemsAdded: 'No items added yet',
                calendarView: 'Calendar View',
                previousMonth: 'â€¹ Previous',
                nextMonth: 'Next â€º',
                ordersScheduled: 'orders scheduled',
                noOrdersForDate: 'No orders for this date',
                viewOrderDetails: 'View details',
                restoreOrder: 'Restore',
                permanentDelete: 'Permanently Delete',
                ordersInHistory: 'orders in history',
                deletedOrdersCount: 'deleted orders',
                chartPlaceholder: 'Chart will appear here',
                noDataForRange: 'No data available for selected range',
                multiDayToggle: 'Multi-day Order',
                singleDay: 'Single Day',
                multiDay: 'Multi Day',
                transportOptions: 'Transport',
                customTransportOption: 'Custom',
                enterCustomTransport: 'Enter custom transport',
                selectStatus: 'Select Status',
                switchToEnglish: 'Switch to English',
                switchToGujarati: 'àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚ àª¬àª¦àª²à«‹',
                englishShort: 'EN',
                gujaratiShort: 'àª—à«',
                preparation: 'Preparation',
                forecast: 'Forecast',
                selectOperatorDropdown: 'Select Operator',
                noSelection: '',
                multiDayFormLabel: 'Multi-day Order?',
                enterFunctionType: 'e.g., Sangeet, Reception',
                enterTimeSlot: 'e.g., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: 'You can add multiple helpers separated by commas',
                tomorrow: 'Tomorrow',
                next7Days: 'Next 7 Days',
                next30Days: 'Next 30 Days',
                noOrdersFoundShort: 'No Orders Found',
                noOrdersScheduledBetween: 'No orders scheduled between',
                summary: 'Summary',
                uniqueItems: 'Unique Items',
                totalQuantity: 'Total Pieces',
                shortages: 'Shortages',
                sufficient: 'Sufficient',
                itemsPreparationList: 'Items Preparation List',
                sr: 'Sr',
                required: 'Required',
                inStock: 'In Stock',
                difference: 'Difference',
                usedInOrders: 'Used In Orders',
                ok: 'OK',
                short: 'SHORT',
                more: 'more',
                details: 'Details',
                grandTotal: 'GRAND TOTAL',
                orderDetailsBreakdown: 'Order Details Breakdown',
                shareWhatsApp: 'ðŸ“± Share WhatsApp',
                exportPDF: 'ðŸ“„ Export PDF'
            },
            gu: {
                // Header
                companyName: 'àª“àª°à«àª¡àª° àª®à«‡àª¨à«‡àªœàª®à«‡àª¨à«àªŸ àª¸àª¿àª¸à«àªŸàª®',
                searchPlaceholder: 'ðŸ” àª¬àª§à«àª‚ àª¶à«‹àª§à«‹...',
                next: 'àª†àª—àª³',
                logout: 'ðŸšª àª²à«‹àª—àª†àª‰àªŸ',

                // Tabs
                dashboard: 'ðŸ“Š àª¡à«‡àª¶àª¬à«‹àª°à«àª¡',
                orders: 'ðŸ“‹ àª“àª°à«àª¡àª°à«àª¸',
                inventory: 'ðŸ“¦ àª‡àª¨à«àªµà«‡àª¨à«àªŸàª°à«€',
                itemHistory: 'ðŸ“œ àª†àª‡àªŸàª® àª‡àª¤àª¿àª¹àª¾àª¸',
                preparation: 'ðŸ³ àª¤à«ˆàª¯àª¾àª°à«€',
                customers: 'ðŸ‘¥ àª—à«àª°àª¾àª¹àª•à«‹',
                team: 'ðŸ‘¨â€ðŸ’¼ àªŸà«€àª®',
                calendar: 'ðŸ“… àª•à«‡àª²à«‡àª¨à«àª¡àª°',
                history: 'ðŸ•’ àª‡àª¤àª¿àª¹àª¾àª¸',
                analytics: 'ðŸ“ˆ àªµàª¿àª¶à«àª²à«‡àª·àª£',
                videos: 'ðŸŽ¥ àªµàª¿àª¡àª¿àª¯à«‹',
                advertisements: 'ðŸ“¢ àªœàª¾àª¹à«‡àª°àª¾àª¤',
                financials: 'ðŸ’° àª¨àª¾àª£àª¾àª•à«€àª¯',
                settings: 'âš™ï¸ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸',

                // Common Buttons
                save: 'àª¸àª¾àªšàªµà«‹',
                cancel: 'àª°àª¦ àª•àª°à«‹',
                edit: 'àª¸à«àª§àª¾àª°à«‹',
                delete: 'àª•àª¾àª¢à«€ àª¨àª¾àª–à«‹',
                add: 'àª‰àª®à«‡àª°à«‹',
                close: 'àª¬àª‚àª§ àª•àª°à«‹',
                confirm: 'àªªà«àª·à«àªŸàª¿ àª•àª°à«‹',
                clear: 'àª¸àª¾àª« àª•àª°à«‹',
                preview: 'àªªà«‚àª°à«àªµàª¾àªµàª²à«‹àª•àª¨',
                duplicate: 'àª¨àª•àª²',
                export: 'àª¨àª¿àª•àª¾àª¸ àª•àª°à«‹',
                import: 'àª†àª¯àª¾àª¤ àª•àª°à«‹',
                reset: 'àª°à«€àª¸à«‡àªŸ àª•àª°à«‹',
                search: 'àª¶à«‹àª§à«‹',
                download: 'àª¡àª¾àª‰àª¨àª²à«‹àª¡ àª•àª°à«‹',
                upload: 'àª…àªªàª²à«‹àª¡ àª•àª°à«‹',
                filter: 'àª«àª¿àª²à«àªŸàª°',
                print: 'àªªà«àª°àª¿àª¨à«àªŸ',

                // Order Form
                orderDetails: 'àª“àª°à«àª¡àª°àª¨à«€ àªµàª¿àª—àª¤à«‹',
                clientName: 'àª—à«àª°àª¾àª¹àª•àª¨à«àª‚ àª¨àª¾àª®',
                contact: 'àª¸àª‚àªªàª°à«àª•',
                venue: 'àª¸à«àª¥àª³',
                orderDate: 'àª“àª°à«àª¡àª°àª¨à«€ àª¤àª¾àª°à«€àª–',
                readyTime: 'àª¤à«ˆàª¯àª¾àª° àª¸àª®àª¯',
                eventType: 'àª‡àªµà«‡àª¨à«àªŸàª¨à«‹ àªªà«àª°àª•àª¾àª°',
                transport: 'àªŸà«àª°àª¾àª¨à«àª¸àªªà«‹àª°à«àªŸ',
                customTransport: 'àª•àª¸à«àªŸàª® àªŸà«àª°àª¾àª¨à«àª¸àªªà«‹àª°à«àªŸ',
                driverName: 'àª¡à«àª°àª¾àªˆàªµàª°àª¨à«àª‚ àª¨àª¾àª®',
                operator: 'àª“àªªàª°à«‡àªŸàª°',
                helpers: 'àª¹à«‡àª²à«àªªàª°(àª¸)',
                helperPlaceholder: 'àª¹à«‡àª²à«àªªàª°àª¨àª¾ àª¨àª¾àª® àª¦àª¾àª–àª² àª•àª°à«‹, àªµàª§à« àª®àª¾àªŸà«‡ àª…àª²à«àªªàªµàª¿àª°àª¾àª®àª¥à«€ àª…àª²àª— àª•àª°à«‹',
                orderStatus: 'àª“àª°à«àª¡àª° àª¸à«àª¥àª¿àª¤àª¿',
                notes: 'àª¨à«‹àª‚àª§',
                items: 'àª†àª‡àªŸàª®à«àª¸',
                addItem: 'àª†àª‡àªŸàª® àª‰àª®à«‡àª°à«‹',
                itemName: 'àª†àª‡àªŸàª®àª¨à«àª‚ àª¨àª¾àª®',
                quantity: 'àªœàª¥à«àª¥à«‹',
                remarks: 'àªŸàª¿àªªà«àªªàª£à«€',
                serialNumber: 'àª•à«àª°àª®àª¾àª‚àª•',

                // Status
                confirmed: 'àªªà«àª·à«àªŸàª¿ àª¥àª¯à«‡àª²',
                completed: 'àªªà«‚àª°à«àª£ àª¥àª¯à«àª‚',
                cancelled: 'àª°àª¦ àª•àª°à«àª¯à«àª‚',
                pending: 'àª¬àª¾àª•à«€',
                active: 'àª¸àª•à«àª°àª¿àª¯',
                inactive: 'àª¨àª¿àª·à«àª•à«àª°àª¿àª¯',

                // Actions
                saveOrder: 'ðŸ’¾ àª“àª°à«àª¡àª° àª¸àª¾àªšàªµà«‹',
                saveOrderShortcut: 'ðŸ’¾ àª“àª°à«àª¡àª° àª¸àª¾àªšàªµà«‹ (Ctrl+S)',
                duplicateLast: 'ðŸ“‹ àª›à«‡àª²à«àª²à«€ àª¨àª•àª²',
                sameDay: 'ðŸ“… àª¸àª®àª¾àª¨ àª¦àª¿àªµàª¸',
                clearForm: 'ðŸ—‘ï¸ àª¸àª¾àª« àª•àª°à«‹',
                clearFormShortcut: 'ðŸ—‘ï¸ àª¸àª¾àª« àª•àª°à«‹ (Ctrl+D)',
                notifyTeam: 'ðŸ“± àªŸà«€àª®àª¨à«‡ àª¸à«‚àªšàª¨àª¾',
                sendReport: 'ðŸ“Š àª®à«‡àª¨à«‡àªœàª° àª°àª¿àªªà«‹àª°à«àªŸ àª®à«‹àª•àª²à«‹',

                // Settings
                systemSettings: 'âš™ï¸ àª¸àª¿àª¸à«àªŸàª® àª¸à«‡àªŸàª¿àª‚àª—à«àª¸',
                printSettings: 'ðŸ–¨ï¸ àªªà«àª°àª¿àª¨à«àªŸ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸',
                tableLayoutSettings: 'ðŸ“‹ àªŸà«‡àª¬àª² àª²à«‡àª†àª‰àªŸ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸',
                colorCustomization: 'ðŸŽ¨ àª°àª‚àª— àª•àª¸à«àªŸàª®àª¾àª‡àªà«‡àª¶àª¨',
                systemPreferences: 'ðŸ”§ àª¸àª¿àª¸à«àªŸàª® àªªàª¸àª‚àª¦àª—à«€àª“',
                dataManagement: 'ðŸ“Š àª¡à«‡àªŸàª¾ àª®à«‡àª¨à«‡àªœàª®à«‡àª¨à«àªŸ',

                fontSize: 'àª¡àª¿àª«à«‰àª²à«àªŸ àª«à«‹àª¨à«àªŸ àª¸àª¾àª‡àª',
                paperFormat: 'àªªà«‡àªªàª° àª«à«‹àª°à«àª®à«‡àªŸ',
                pageOrientation: 'àªªà«‡àªœ àª“àª°àª¿àªàª¨à«àªŸà«‡àª¶àª¨',
                imageQuality: 'àª‡àª®à«‡àªœ àª—à«àª£àªµàª¤à«àª¤àª¾',
                functionColor: 'àª«àª‚àª•à«àª¶àª¨ àª¸à«àª²à«‹àªŸ àª°àª‚àª—',
                portrait: 'ðŸ“„ àªªà«‹àª°à«àªŸà«àª°à«‡àªŸ',
                landscape: 'ðŸ“ƒ àª²à«‡àª¨à«àª¡àª¸à«àª•à«‡àªª',
                low: 'àª“àª›à«€',
                medium: 'àª®àª§à«àª¯àª®',
                high: 'àª‰àªšà«àªš',
                ultra: 'àª…àª²à«àªŸà«àª°àª¾',
                faster: 'àªàª¡àªªà«€',
                balanced: 'àª¸àª‚àª¤à«àª²àª¿àª¤',
                betterQuality: 'àª¸àª¾àª°à«€ àª—à«àª£àªµàª¤à«àª¤àª¾',
                bestQuality: 'àª¶à«àª°à«‡àª·à«àª  àª—à«àª£àªµàª¤à«àª¤àª¾',

                srColumnWidth: 'àª•à«àª°àª®àª¾àª‚àª• àª•à«‰àª²àª® àªªàª¹à«‹àª³àª¾àªˆ',
                itemColumnWidth: 'àª†àª‡àªŸàª® àª¨àª¾àª® àªªàª¹à«‹àª³àª¾àªˆ',
                qtyColumnWidth: 'àªªà«€àª¸à«€àª¸ àªªàª¹à«‹àª³àª¾àªˆ',
                remarksColumnWidth: 'àªŸàª¿àªªà«àªªàª£à«€ àªªàª¹à«‹àª³àª¾àªˆ',
                leftMarginFiling: 'àª¡àª¾àª¬à«‹ àª®àª¾àª°à«àªœàª¿àª¨ (àª«àª¾àª‡àª²àª¿àª‚àª—)',

                headerBackground: 'àª¹à«‡àª¡àª° àªªà«ƒàª·à«àª àª­à«‚àª®àª¿',
                headerText: 'àª¹à«‡àª¡àª° àªŸà«‡àª•à«àª¸à«àªŸ',
                orderIdBackground: 'àª“àª°à«àª¡àª° ID àªªà«ƒàª·à«àª àª­à«‚àª®àª¿',
                orderIdText: 'àª“àª°à«àª¡àª° ID àªŸà«‡àª•à«àª¸à«àªŸ',
                tableHeaderBackground: 'àªŸà«‡àª¬àª² àª¹à«‡àª¡àª° àªªà«ƒàª·à«àª àª­à«‚àª®àª¿',
                tableHeaderText: 'àªŸà«‡àª¬àª² àª¹à«‡àª¡àª° àªŸà«‡àª•à«àª¸à«àªŸ',
                tableBorder: 'àªŸà«‡àª¬àª² àª¬à«‹àª°à«àª¡àª°',
                notesBackground: 'àª¨à«‹àª‚àª§ àªªà«ƒàª·à«àª àª­à«‚àª®àª¿',

                defaultOrderStatus: 'àª¡àª¿àª«à«‰àª²à«àªŸ àª“àª°à«àª¡àª° àª¸à«àª¥àª¿àª¤àª¿',
                lowStockThreshold: 'àª“àª›àª¾ àª¸à«àªŸà«‰àª•àª¨à«€ àª®àª°à«àª¯àª¾àª¦àª¾',
                language: 'àª­àª¾àª·àª¾',
                invoiceFormat: 'àª‡àª¨à«àªµà«‰àª‡àª¸ àª¨àª‚àª¬àª° àª«à«‹àª°à«àª®à«‡àªŸ',

                saveAllSettings: 'ðŸ’¾ àª¬àª§à«€ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸ àª¸àª¾àªšàªµà«‹',
                resetToDefaults: 'ðŸ”„ àª¡àª¿àª«à«‰àª²à«àªŸ àªªàª° àª°à«€àª¸à«‡àªŸ àª•àª°à«‹',
                exportJSON: 'ðŸ“¤ JSON àª¨àª¿àª•àª¾àª¸ àª•àª°à«‹',
                exportCSV: 'ðŸ“Š CSV àª¨àª¿àª•àª¾àª¸ àª•àª°à«‹',
                importBackup: 'ðŸ“¥ àª¬à«‡àª•àª…àªª àª†àª¯àª¾àª¤ àª•àª°à«‹',
                resetAllData: 'ðŸ—‘ï¸ àª¬àª§à«‹ àª¡à«‡àªŸàª¾ àª°à«€àª¸à«‡àªŸ àª•àª°à«‹',

                // Multi-day
                multiDayOrder: 'àª®àª²à«àªŸàª¿-àª¡à«‡ àª“àª°à«àª¡àª°',
                singleDayOrder: 'àª¸àª¿àª‚àª—àª²-àª¡à«‡ àª“àª°à«àª¡àª°',
                startDate: 'àª¶àª°à«‚àª†àª¤àª¨à«€ àª¤àª¾àª°à«€àª–',
                endDate: 'àª…àª‚àª¤àª¿àª® àª¤àª¾àª°à«€àª–',
                addDay: 'âž• àª¦àª¿àªµàª¸ àª‰àª®à«‡àª°à«‹',
                addFunction: 'âž• àª«àª‚àª•à«àª¶àª¨ àª‰àª®à«‡àª°à«‹',
                removeDay: 'ðŸ—‘ï¸ àª¦àª¿àªµàª¸ àª¦à«‚àª° àª•àª°à«‹',
                removeFunction: 'ðŸ—‘ï¸ àª«àª‚àª•à«àª¶àª¨ àª¦à«‚àª° àª•àª°à«‹',
                dayNumber: 'àª¦àª¿àªµàª¸',
                functionNumber: 'àª«àª‚àª•à«àª¶àª¨',
                functionType: 'àª«àª‚àª•à«àª¶àª¨àª¨à«‹ àªªà«àª°àª•àª¾àª°',
                timeSlot: 'àª¸àª®àª¯',
                driver: 'àª¡à«àª°àª¾àªˆàªµàª°',

                // Dashboard
                totalOrders: 'àª•à«àª² àª“àª°à«àª¡àª°à«àª¸',
                confirmedOrders: 'àªªà«àª·à«àªŸàª¿ àª¥àª¯à«‡àª²',
                completedOrders: 'àªªà«‚àª°à«àª£ àª¥àª¯à«àª‚',
                cancelledOrders: 'àª°àª¦ àª•àª°à«àª¯à«àª‚',
                pendingOrders: 'àª¬àª¾àª•à«€',
                recentOrders: 'àª¤àª¾àªœà«‡àª¤àª°àª¨àª¾ àª“àª°à«àª¡àª°à«àª¸',
                quickStats: 'àªàª¡àªªà«€ àª†àª‚àª•àª¡àª¾',
                thisMonth: 'àª† àª®àª¹àª¿àª¨à«‡',
                thisWeek: 'àª† àª…àª àªµàª¾àª¡àª¿àª¯à«‡',
                today: 'àª†àªœà«‡',

                // Team
                teamManagement: 'àªŸà«€àª® àª®à«‡àª¨à«‡àªœàª®à«‡àª¨à«àªŸ',
                addTeamMember: 'àªŸà«€àª® àª¸àª­à«àª¯ àª‰àª®à«‡àª°à«‹',
                memberName: 'àª¸àª­à«àª¯àª¨à«àª‚ àª¨àª¾àª®',
                role: 'àª­à«‚àª®àª¿àª•àª¾',
                roles: 'àª­à«‚àª®àª¿àª•àª¾àª“',
                phoneNumber: 'àª«à«‹àª¨ àª¨àª‚àª¬àª°',
                email: 'àª‡àª®à«‡àª‡àª²',
                status: 'àª¸à«àª¥àª¿àª¤àª¿',
                actions: 'àª•à«àª°àª¿àª¯àª¾àª“',

                // Inventory
                inventoryManagement: 'àª‡àª¨à«àªµà«‡àª¨à«àªŸàª°à«€ àª®à«‡àª¨à«‡àªœàª®à«‡àª¨à«àªŸ',
                addCategory: 'àª•à«‡àªŸà«‡àª—àª°à«€ àª‰àª®à«‡àª°à«‹',
                addInventoryItem: 'àª‡àª¨à«àªµà«‡àª¨à«àªŸàª°à«€ àª†àª‡àªŸàª® àª‰àª®à«‡àª°à«‹',
                categoryName: 'àª•à«‡àªŸà«‡àª—àª°à«€àª¨à«àª‚ àª¨àª¾àª®',
                currentStock: 'àªµàª°à«àª¤àª®àª¾àª¨ àª¸à«àªŸà«‰àª•',
                unit: 'àªàª•àª®',
                reorderLevel: 'àª«àª°à«€àª¥à«€ àª“àª°à«àª¡àª°àª¨à«€ àª¸à«àª¤àª°',

                // Calendar
                month: 'àª®àª¹àª¿àª¨à«‹',
                week: 'àª…àª àªµàª¾àª¡àª¿àª¯à«àª‚',
                day: 'àª¦àª¿àªµàª¸',
                ordersFor: 'àª®àª¾àªŸà«‡ àª“àª°à«àª¡àª°à«àª¸',
                noOrders: 'àª† àª¤àª¾àª°à«€àª– àª®àª¾àªŸà«‡ àª•à«‹àªˆ àª“àª°à«àª¡àª° àª¨àª¥à«€',

                // History
                orderHistory: 'àª“àª°à«àª¡àª° àª‡àª¤àª¿àª¹àª¾àª¸',
                deletedOrders: 'àª•àª¾àª¢à«€ àª¨àª¾àª–à«‡àª²àª¾ àª“àª°à«àª¡àª°à«àª¸',
                restore: 'àªªà«àª¨àªƒàª¸à«àª¥àª¾àªªàª¿àª¤ àª•àª°à«‹',
                permanentlyDelete: 'àª•àª¾àª¯àª® àª®àª¾àªŸà«‡ àª•àª¾àª¢à«€ àª¨àª¾àª–à«‹',

                // Analytics
                analyticsReport: 'àªµàª¿àª¶à«àª²à«‡àª·àª£ àª°àª¿àªªà«‹àª°à«àªŸ',
                dateRange: 'àª¤àª¾àª°à«€àª–àª¨à«€ àª¶à«àª°à«‡àª£à«€',
                from: 'àª¥à«€',
                to: 'àª¸à«àª§à«€',
                generateReport: 'àª°àª¿àªªà«‹àª°à«àªŸ àª¬àª¨àª¾àªµà«‹',
                topItems: 'àªŸà«‹àªª àª†àª‡àªŸàª®à«àª¸',
                orderTrends: 'àª“àª°à«àª¡àª° àªŸà«àª°à«‡àª¨à«àª¡à«àª¸',

                // Messages
                orderSaved: 'àª“àª°à«àª¡àª° àª¸àª«àª³àª¤àª¾àªªà«‚àª°à«àªµàª• àª¸àª¾àªšàªµà«àª¯à«‹!',
                orderDeleted: 'àª“àª°à«àª¡àª° àª•àª¾àª¢à«€ àª¨àª¾àª–à«àª¯à«‹!',
                settingsSaved: 'àª¬àª§à«€ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸ àª¸àª«àª³àª¤àª¾àªªà«‚àª°à«àªµàª• àª¸àª¾àªšàªµà«€!',
                itemAdded: 'àª†àª‡àªŸàª® àª‰àª®à«‡àª°à«àª¯à«àª‚!',
                itemRemoved: 'àª†àª‡àªŸàª® àª¦à«‚àª° àª•àª°à«àª¯à«àª‚!',
                error: 'àª­à«‚àª²',
                success: 'àª¸àª«àª³àª¤àª¾',
                warning: 'àªšà«‡àª¤àªµàª£à«€',
                info: 'àª®àª¾àª¹àª¿àª¤à«€',
                loading: 'àª²à«‹àª¡ àª¥àªˆ àª°àª¹à«àª¯à«àª‚ àª›à«‡...',
                generatingImage: 'àª‡àª®à«‡àªœ àª¬àª¨àª¾àªµà«€ àª°àª¹à«àª¯àª¾ àª›à«€àª...',
                downloadComplete: 'àª¡àª¾àª‰àª¨àª²à«‹àª¡ àªªà«‚àª°à«àª£!',

                // Placeholders
                enterClientName: 'àª—à«àª°àª¾àª¹àª•àª¨à«àª‚ àª¨àª¾àª® àª¦àª¾àª–àª² àª•àª°à«‹',
                enterContact: 'àª¸àª‚àªªàª°à«àª• àª¨àª‚àª¬àª° àª¦àª¾àª–àª² àª•àª°à«‹',
                enterVenue: 'àª¸à«àª¥àª³ àª¦àª¾àª–àª² àª•àª°à«‹',
                selectDate: 'àª¤àª¾àª°à«€àª– àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectTime: 'àª¸àª®àª¯ àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectEventType: 'àª‡àªµà«‡àª¨à«àªŸàª¨à«‹ àªªà«àª°àª•àª¾àª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectTransport: 'àªŸà«àª°àª¾àª¨à«àª¸àªªà«‹àª°à«àªŸ àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectDriver: 'àª¡à«àª°àª¾àªˆàªµàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectOperator: 'àª“àªªàª°à«‡àªŸàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectHelper: 'àª¹à«‡àª²à«àªªàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                enterNotes: 'àª¨à«‹àª‚àª§ àª¦àª¾àª–àª² àª•àª°à«‹...',
                searchItem: 'àª†àª‡àªŸàª® àª¶à«‹àª§à«‹...',

                // Confirmations
                confirmDelete: 'àª¶à«àª‚ àª¤àª®à«‡ àª–àª°à«‡àª–àª° àª•àª¾àª¢à«€ àª¨àª¾àª–àªµàª¾ àª®àª¾àª‚àª—à«‹ àª›à«‹?',
                confirmReset: 'àª¬àª§à«€ àª¸à«‡àªŸàª¿àª‚àª—à«àª¸ àª°à«€àª¸à«‡àªŸ àª•àª°àªµà«€ àª›à«‡?',
                confirmClear: 'àª«à«‹àª°à«àª® àª¸àª¾àª« àª•àª°àªµà«àª‚ àª›à«‡?',
                cannotUndo: 'àª† àª•à«àª°àª¿àª¯àª¾ àªªà«‚àª°à«àªµàªµàª¤à« àª•àª°à«€ àª¶àª•àª¾àª¤à«€ àª¨àª¥à«€.',

                // Info messages
                multiOrderNote: 'àª¨à«‹àª‚àª§: àª®àª²à«àªŸàª¿-àª“àª°à«àª¡àª° àª‡àª®à«‡àªœà«€àª¸ àª¸à«àª®àª¾àª°à«àªŸ àª“àªŸà«‹-àª¸àª¾àª‡àªàª¿àª‚àª— àªµàª¾àªªàª°à«‡ àª›à«‡',
                higherQualityNote: 'àª‰àªšà«àªš àª—à«àª£àªµàª¤à«àª¤àª¾ = àª®à«‹àªŸà«€ àª«àª¾àª‡àª² àª¸àª¾àª‡àª',
                multipleHelpersNote: 'àª¤àª®à«‡ àª…àª²à«àªªàªµàª¿àª°àª¾àª®àª¥à«€ àª…àª²àª— àª•àª°à«€àª¨à«‡ àª˜àª£àª¾ àª¹à«‡àª²à«àªªàª°à«‹ àª‰àª®à«‡àª°à«€ àª¶àª•à«‹ àª›à«‹ (àª¦àª¾.àª¤., àªœà«‹àª¨, àª®à«‡àª°à«€, àª¡à«‡àªµàª¿àª¡)',
                chooseFormat: 'àªªà«àª°àª¿àª¨à«àªŸ àª²à«‡àª†àª‰àªŸ àª®àª¾àªŸà«‡ àªªà«‡àªªàª° àª¸àª¾àª‡àª àªªàª¸àª‚àª¦ àª•àª°à«‹',
                portraitOrLandscape: 'àªªà«‹àª°à«àªŸà«àª°à«‡àªŸ àª…àª¥àªµàª¾ àª²à«‡àª¨à«àª¡àª¸à«àª•à«‡àªª àª®à«‹àª¡',
                customColorNote: 'àª«àª‚àª•à«àª¶àª¨ àª¸à«àª²à«‹àªŸ àª®àª¾àªŸà«‡ àª•àª¸à«àªŸàª® àª°àª‚àª—',

                // Additional translations for complete coverage
                lowStock: 'àª“àª›à«‹ àª¸à«àªŸà«‰àª•',
                orderId: 'àª“àª°à«àª¡àª° ID',
                client: 'àª—à«àª°àª¾àª¹àª•',
                event: 'àª‡àªµà«‡àª¨à«àªŸ',
                date: 'àª¤àª¾àª°à«€àª–',
                view: 'àªœà«àª“',
                ordersText: 'àª“àª°à«àª¡àª°à«àª¸',
                batchUpdate: 'âš¡ àª¬à«‡àªš àª…àªªàª¡à«‡àªŸ',
                categories: 'àª•à«‡àªŸà«‡àª—àª°à«€àª“',
                enterCategoryName: 'àª•à«‡àªŸà«‡àª—àª°à«€àª¨à«àª‚ àª¨àª¾àª®',
                enterItemName: 'àª†àª‡àªŸàª®àª¨à«àª‚ àª¨àª¾àª®',
                selectCategory: 'àª•à«‡àªŸà«‡àª—àª°à«€ àªªàª¸àª‚àª¦ àª•àª°à«‹',
                category: 'àª•à«‡àªŸà«‡àª—àª°à«€',
                item: 'àª†àª‡àªŸàª®',
                stock: 'àª¸à«àªŸà«‰àª•',
                topCustomer: 'àªŸà«‹àªª àª—à«àª°àª¾àª¹àª•',
                preparationForecast: 'àª¤à«ˆàª¯àª¾àª°à«€ àª…àª‚àª¦àª¾àªœ',
                selectDateRange: 'àª¤àª¾àª°à«€àª–àª¨à«€ àª¶à«àª°à«‡àª£à«€ àªªàª¸àª‚àª¦ àª•àª°à«‹',
                generate: 'àª¬àª¨àª¾àªµà«‹',
                aggregatedItems: 'àª¤àª¾àª°à«€àª–àª¨à«€ àª¶à«àª°à«‡àª£à«€ àª®àª¾àªŸà«‡ àªàª•àª¤à«àª°àª¿àª¤ àª†àª‡àªŸàª®à«àª¸',
                forecastSummary: 'àª…àª‚àª¦àª¾àªœ àª¸àª¾àª°àª¾àª‚àª¶',
                totalItems: 'àª•à«àª² àª†àª‡àªŸàª®à«àª¸',
                ordersInRange: 'àª¶à«àª°à«‡àª£à«€àª®àª¾àª‚ àª“àª°à«àª¡àª°à«àª¸',
                itemsToPrep: 'àª¤à«ˆàª¯àª¾àª° àª•àª°àªµàª¾àª¨à«€ àª†àª‡àªŸàª®à«àª¸',
                noOrdersFound: 'àªªàª¸àª‚àª¦ àª•àª°à«‡àª²à«€ àª¤àª¾àª°à«€àª–àª¨à«€ àª¶à«àª°à«‡àª£à«€àª®àª¾àª‚ àª•à«‹àªˆ àª“àª°à«àª¡àª° àª®àª³à«àª¯àª¾ àª¨àª¥à«€',
                customers: 'àª—à«àª°àª¾àª¹àª•à«‹',
                addCustomer: 'àª—à«àª°àª¾àª¹àª• àª‰àª®à«‡àª°à«‹',
                customerName: 'àª—à«àª°àª¾àª¹àª•àª¨à«àª‚ àª¨àª¾àª®',
                totalOrdersCount: 'àª•à«àª² àª“àª°à«àª¡àª°à«àª¸',
                lastOrder: 'àª›à«‡àª²à«àª²à«‹ àª“àª°à«àª¡àª°',
                never: 'àª•à«àª¯àª¾àª°à«‡àª¯ àª¨àª¹à«€àª‚',
                na: 'àª²àª¾àª—à« àª¨àª¥à«€',
                viewOrders: 'àª“àª°à«àª¡àª°à«àª¸ àªœà«àª“',
                editTeamMember: 'àªŸà«€àª® àª¸àª­à«àª¯ àª¸à«àª§àª¾àª°à«‹',
                addThisDay: 'âž• àª† àª¦àª¿àªµàª¸àª®àª¾àª‚ àª‰àª®à«‡àª°à«‹',
                removeThisDay: 'ðŸ—‘ï¸ àª¦à«‚àª° àª•àª°à«‹',
                functionColor: 'àª«àª‚àª•à«àª¶àª¨ àª¸à«àª²à«‹àªŸ àª°àª‚àª—',
                addFunctionToThisDay: 'àª† àª¦àª¿àªµàª¸àª®àª¾àª‚ àª«àª‚àª•à«àª¶àª¨ àª‰àª®à«‡àª°à«‹',
                selectOperatorPlaceholder: 'àª“àªªàª°à«‡àªŸàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                selectHelperPlaceholder: 'àª¹à«‡àª²à«àªªàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                functionNotes: 'àª† àª«àª‚àª•à«àª¶àª¨ àª®àª¾àªŸà«‡ àªµàª¿àª¶à«‡àª· àªœàª°à«‚àª°àª¿àª¯àª¾àª¤à«‹...',
                searchItems: 'ðŸ” àª†àª‡àªŸàª® àª¶à«‹àª§à«‹...',
                noItemsAdded: 'àª¹àªœà« àª¸à«àª§à«€ àª•à«‹àªˆ àª†àª‡àªŸàª® àª‰àª®à«‡àª°à«àª¯àª¾ àª¨àª¥à«€',
                calendarView: 'àª•à«‡àª²à«‡àª¨à«àª¡àª° àª¦à«ƒàª¶à«àª¯',
                previousMonth: 'â€¹ àªªàª¹à«‡àª²àª¾àª‚',
                nextMonth: 'àª†àª—àª³ â€º',
                ordersScheduled: 'àª“àª°à«àª¡àª°à«àª¸ àª¸à«àª¨àª¿àª¶à«àªšàª¿àª¤',
                noOrdersForDate: 'àª† àª¤àª¾àª°à«€àª– àª®àª¾àªŸà«‡ àª•à«‹àªˆ àª“àª°à«àª¡àª° àª¨àª¥à«€',
                viewOrderDetails: 'àªµàª¿àª—àª¤à«‹ àªœà«àª“',
                restoreOrder: 'àªªà«àª¨àªƒàª¸à«àª¥àª¾àªªàª¿àª¤ àª•àª°à«‹',
                permanentDelete: 'àª•àª¾àª¯àª® àª®àª¾àªŸà«‡ àª•àª¾àª¢à«€ àª¨àª¾àª–à«‹',
                ordersInHistory: 'àª‡àª¤àª¿àª¹àª¾àª¸àª®àª¾àª‚ àª“àª°à«àª¡àª°à«àª¸',
                deletedOrdersCount: 'àª•àª¾àª¢à«€ àª¨àª¾àª–à«‡àª²àª¾ àª“àª°à«àª¡àª°à«àª¸',
                chartPlaceholder: 'àªšàª¾àª°à«àªŸ àª…àª¹à«€àª‚ àª¦à«‡àª–àª¾àª¶à«‡',
                noDataForRange: 'àªªàª¸àª‚àª¦ àª•àª°à«‡àª²à«€ àª¶à«àª°à«‡àª£à«€ àª®àª¾àªŸà«‡ àª•à«‹àªˆ àª¡à«‡àªŸàª¾ àª‰àªªàª²àª¬à«àª§ àª¨àª¥à«€',
                multiDayToggle: 'àª®àª²à«àªŸàª¿-àª¡à«‡ àª“àª°à«àª¡àª°',
                singleDay: 'àª¸àª¿àª‚àª—àª² àª¡à«‡',
                multiDay: 'àª®àª²à«àªŸàª¿ àª¡à«‡',
                transportOptions: 'àªŸà«àª°àª¾àª¨à«àª¸àªªà«‹àª°à«àªŸ',
                customTransportOption: 'àª•àª¸à«àªŸàª®',
                enterCustomTransport: 'àª•àª¸à«àªŸàª® àªŸà«àª°àª¾àª¨à«àª¸àªªà«‹àª°à«àªŸ àª¦àª¾àª–àª² àª•àª°à«‹',
                selectStatus: 'àª¸à«àª¥àª¿àª¤àª¿ àªªàª¸àª‚àª¦ àª•àª°à«‹',
                switchToEnglish: 'àª…àª‚àª—à«àª°à«‡àªœà«€àª®àª¾àª‚ àª¬àª¦àª²à«‹',
                switchToGujarati: 'àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚ àª¬àª¦àª²à«‹',
                englishShort: 'EN',
                gujaratiShort: 'àª—à«',
                preparation: 'àª¤à«ˆàª¯àª¾àª°à«€',
                forecast: 'àª…àª‚àª¦àª¾àªœ',
                selectOperatorDropdown: 'àª“àªªàª°à«‡àªŸàª° àªªàª¸àª‚àª¦ àª•àª°à«‹',
                noSelection: '',
                multiDayFormLabel: 'àª®àª²à«àªŸàª¿-àª¡à«‡ àª“àª°à«àª¡àª°?',
                enterFunctionType: 'àª¦àª¾.àª¤., àª¸àª‚àª—à«€àª¤, àª°àª¿àª¸à«‡àªªà«àª¶àª¨',
                enterTimeSlot: 'àª¦àª¾.àª¤., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: 'àª¤àª®à«‡ àª…àª²à«àªªàªµàª¿àª°àª¾àª®àª¥à«€ àª…àª²àª— àª•àª°à«€àª¨à«‡ àª˜àª£àª¾ àª¹à«‡àª²à«àªªàª°à«‹ àª‰àª®à«‡àª°à«€ àª¶àª•à«‹ àª›à«‹',
                tomorrow: 'àª†àªµàª¤à«€ àª•àª¾àª²à«‡',
                next7Days: 'àª†àª—àª¾àª®à«€ 7 àª¦àª¿àªµàª¸',
                next30Days: 'àª†àª—àª¾àª®à«€ 30 àª¦àª¿àªµàª¸',
                noOrdersFoundShort: 'àª•à«‹àªˆ àª“àª°à«àª¡àª° àª®àª³à«àª¯àª¾ àª¨àª¥à«€',
                noOrdersScheduledBetween: 'àª•à«‹àªˆ àª“àª°à«àª¡àª° àª¸à«àª¨àª¿àª¶à«àªšàª¿àª¤ àª¨àª¥à«€',
                summary: 'àª¸àª¾àª°àª¾àª‚àª¶',
                uniqueItems: 'àª…àª¨àª¨à«àª¯ àª†àª‡àªŸàª®à«àª¸',
                totalQuantity: 'àª•à«àª² àªªà«€àª¸à«€àª¸',
                shortages: 'àª‰àª£àªª',
                sufficient: 'àªªàª°à«àª¯àª¾àªªà«àª¤',
                itemsPreparationList: 'àª†àª‡àªŸàª®à«àª¸ àª¤à«ˆàª¯àª¾àª°à«€ àª¯àª¾àª¦à«€',
                sr: 'àª•à«àª°àª®',
                required: 'àªœàª°à«‚àª°à«€',
                inStock: 'àª¸à«àªŸà«‰àª•àª®àª¾àª‚',
                difference: 'àª¤àª«àª¾àªµàª¤',
                usedInOrders: 'àª“àª°à«àª¡àª°à«àª¸àª®àª¾àª‚ àªµàªªàª°àª¾àª¯à«‡àª²',
                ok: 'àª¬àª°àª¾àª¬àª°',
                short: 'àª“àª›à«àª‚',
                more: 'àªµàª§à«',
                details: 'àªµàª¿àª—àª¤à«‹',
                grandTotal: 'àª•à«àª² àª¸àª°àªµàª¾àª³à«‹',
                orderDetailsBreakdown: 'àª“àª°à«àª¡àª° àªµàª¿àª—àª¤ àªµàª¿àª­àª¾àªœàª¨',
                shareWhatsApp: 'ðŸ“± WhatsApp àª¶à«‡àª° àª•àª°à«‹',
                exportPDF: 'ðŸ“„ PDF àª¨àª¿àª•àª¾àª¸ àª•àª°à«‹'
            }
        };

        // ============ FILTERING INFRASTRUCTURE ============

        /**
         * FilterLogger - Detailed logging system for all filtering operations
         * Tracks every filter with timestamp, parameters, results, and performance metrics
         */
        class FilterLogger {
            constructor() {
                this.logs = this.loadLogs();
                this.maxLogs = 1000; // Keep last 1000 operations
            }

            loadLogs() {
                try {
                    const saved = localStorage.getItem('oms_filter_logs');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter logs:', error);
                    return [];
                }
            }

            saveLogs() {
                try {
                    // Keep only the most recent logs
                    if (this.logs.length > this.maxLogs) {
                        this.logs = this.logs.slice(-this.maxLogs);
                    }
                    localStorage.setItem('oms_filter_logs', JSON.stringify(this.logs));
                } catch (error) {
                    console.warn('Failed to save filter logs:', error);
                }
            }

            log(operation, details) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    operation,
                    ...details
                };

                this.logs.push(logEntry);
                this.saveLogs();

                // Also log to console for debugging
                console.log(`ðŸ” [FilterLog] ${operation}:`, details);

                return logEntry;
            }

            getRecentLogs(count = 50) {
                return this.logs.slice(-count);
            }

            getLogsByDate(date) {
                return this.logs.filter(log => log.filterDate === date);
            }

            clearOldLogs(daysToKeep = 30) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - daysToKeep);
                const cutoffTime = cutoff.toISOString();

                this.logs = this.logs.filter(log => log.timestamp > cutoffTime);
                this.saveLogs();
            }
        }

        /**
         * PatternLearner - Machine learning-style pattern recognition system
         * Learns from filtering patterns to detect anomalies and improve accuracy
         */
        class PatternLearner {
            constructor() {
                this.patterns = this.loadPatterns();
                this.anomalyThreshold = 0.3; // 30% deviation triggers alert
            }

            loadPatterns() {
                try {
                    const saved = localStorage.getItem('oms_filter_patterns');
                    return saved ? JSON.parse(saved) : {
                        datePatterns: {}, // date -> expected order count
                        filterResults: [], // historical filter results
                        dateFormats: {}, // learned date format variations
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                } catch (error) {
                    console.warn('Failed to load patterns:', error);
                    return {
                        datePatterns: {},
                        filterResults: [],
                        dateFormats: {},
                        typicalOrderCounts: {
                            weekday: { min: 0, max: 0, avg: 0, samples: 0 },
                            weekend: { min: 0, max: 0, avg: 0, samples: 0 }
                        }
                    };
                }
            }

            savePatterns() {
                try {
                    localStorage.setItem('oms_filter_patterns', JSON.stringify(this.patterns));
                } catch (error) {
                    console.warn('Failed to save patterns:', error);
                }
            }

            recordFilterResult(date, orderCount, totalAvailable, filterType = 'date') {
                // Update date-specific patterns
                if (!this.patterns.datePatterns[date]) {
                    this.patterns.datePatterns[date] = {
                        counts: [],
                        avgCount: 0,
                        lastSeen: new Date().toISOString()
                    };
                }

                const pattern = this.patterns.datePatterns[date];
                pattern.counts.push(orderCount);
                pattern.lastSeen = new Date().toISOString();

                // Keep only last 10 observations per date
                if (pattern.counts.length > 10) {
                    pattern.counts = pattern.counts.slice(-10);
                }

                // Calculate average
                pattern.avgCount = pattern.counts.reduce((sum, c) => sum + c, 0) / pattern.counts.length;

                // Update weekday/weekend patterns
                const dateObj = new Date(date);
                const dayOfWeek = dateObj.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                const key = isWeekend ? 'weekend' : 'weekday';
                const stats = this.patterns.typicalOrderCounts[key];

                if (stats.samples === 0) {
                    stats.min = orderCount;
                    stats.max = orderCount;
                    stats.avg = orderCount;
                    stats.samples = 1;
                } else {
                    stats.min = Math.min(stats.min, orderCount);
                    stats.max = Math.max(stats.max, orderCount);
                    stats.avg = (stats.avg * stats.samples + orderCount) / (stats.samples + 1);
                    stats.samples++;
                }

                // Record in filter results history
                this.patterns.filterResults.push({
                    timestamp: new Date().toISOString(),
                    date,
                    orderCount,
                    totalAvailable,
                    filterType,
                    dayOfWeek,
                    isWeekend
                });

                // Keep only last 500 results
                if (this.patterns.filterResults.length > 500) {
                    this.patterns.filterResults = this.patterns.filterResults.slice(-500);
                }

                this.savePatterns();
            }

            learnDateFormat(originalDate, normalizedDate) {
                if (!this.patterns.dateFormats[originalDate]) {
                    this.patterns.dateFormats[originalDate] = {
                        normalized: normalizedDate,
                        count: 1,
                        lastSeen: new Date().toISOString()
                    };
                } else {
                    this.patterns.dateFormats[originalDate].count++;
                    this.patterns.dateFormats[originalDate].lastSeen = new Date().toISOString();
                }
                this.savePatterns();
            }

            detectAnomaly(date, actualCount) {
                // Check if we have historical data for this date
                const pattern = this.patterns.datePatterns[date];

                if (pattern && pattern.counts.length >= 3) {
                    const expected = pattern.avgCount;
                    const deviation = Math.abs(actualCount - expected) / Math.max(expected, 1);

                    if (deviation > this.anomalyThreshold) {
                        return {
                            isAnomaly: true,
                            expected,
                            actual: actualCount,
                            deviation: (deviation * 100).toFixed(1) + '%',
                            message: `âš ï¸ Unusual order count! Expected ~${Math.round(expected)} orders, found ${actualCount}`
                        };
                    }
                }

                // Check against weekday/weekend patterns
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                if (stats.samples >= 10) {
                    if (actualCount < stats.min * 0.5 || actualCount > stats.max * 1.5) {
                        return {
                            isAnomaly: true,
                            expected: `${stats.min}-${stats.max}`,
                            actual: actualCount,
                            message: `âš ï¸ Order count outside normal range! Typical ${isWeekend ? 'weekend' : 'weekday'}: ${stats.min}-${stats.max}, found ${actualCount}`
                        };
                    }
                }

                return { isAnomaly: false };
            }

            getExpectedCount(date) {
                const pattern = this.patterns.datePatterns[date];
                if (pattern && pattern.counts.length > 0) {
                    return Math.round(pattern.avgCount);
                }

                // Fallback to weekday/weekend average
                const dateObj = new Date(date);
                const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                const stats = this.patterns.typicalOrderCounts[isWeekend ? 'weekend' : 'weekday'];

                return stats.samples > 0 ? Math.round(stats.avg) : null;
            }
        }

        /**
         * FuzzyDateMatcher - Handles date format variations and near-matches
         * Provides error tolerance for date matching
         */
        class FuzzyDateMatcher {
            constructor() {
                this.dateFormats = [
                    'YYYY-MM-DD',
                    'DD-MM-YYYY',
                    'MM-DD-YYYY',
                    'DD/MM/YYYY',
                    'MM/DD/YYYY',
                    'YYYY/MM/DD'
                ];
            }

            // Normalize various date formats to YYYY-MM-DD
            normalize(dateStr) {
                if (!dateStr) return null;

                try {
                    // If already a Date object
                    if (dateStr instanceof Date) {
                        return this.toYYYYMMDD(dateStr);
                    }

                    // If ISO format
                    if (dateStr.includes('T') || dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        const d = new Date(dateStr);
                        return this.toYYYYMMDD(d);
                    }

                    // Try different formats
                    const formats = [
                        // DD-MM-YYYY or DD/MM/YYYY
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // MM-DD-YYYY or MM/DD/YYYY (US format)
                        /^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/,
                        // YYYY-MM-DD or YYYY/MM/DD
                        /^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/
                    ];

                    for (const format of formats) {
                        const match = dateStr.match(format);
                        if (match) {
                            let year, month, day;

                            if (match[1].length === 4) {
                                // YYYY-MM-DD format
                                [, year, month, day] = match;
                            } else {
                                // Assume DD-MM-YYYY (more common internationally)
                                [, day, month, year] = match;
                            }

                            const d = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
                            if (!isNaN(d.getTime())) {
                                return this.toYYYYMMDD(d);
                            }
                        }
                    }

                    // Fallback: try native Date parsing
                    const d = new Date(dateStr);
                    if (!isNaN(d.getTime())) {
                        return this.toYYYYMMDD(d);
                    }

                } catch (error) {
                    console.warn('Failed to normalize date:', dateStr, error);
                }

                return null;
            }

            toYYYYMMDD(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Check if two dates are the same, handling various formats
            matches(date1, date2) {
                const norm1 = this.normalize(date1);
                const norm2 = this.normalize(date2);
                return norm1 && norm2 && norm1 === norm2;
            }

            // Check if date is within range (inclusive)
            isInRange(dateToCheck, startDate, endDate) {
                const check = new Date(this.normalize(dateToCheck));
                const start = new Date(this.normalize(startDate));
                const end = new Date(this.normalize(endDate));

                return check >= start && check <= end;
            }

            // Find near matches (within N days)
            findNearMatches(targetDate, dates, daysTolerance = 1) {
                const target = new Date(this.normalize(targetDate));
                const matches = [];

                for (const date of dates) {
                    const d = new Date(this.normalize(date));
                    const diffDays = Math.abs((d - target) / (1000 * 60 * 60 * 24));

                    if (diffDays <= daysTolerance) {
                        matches.push({
                            date,
                            daysAway: diffDays,
                            isExact: diffDays === 0
                        });
                    }
                }

                return matches.sort((a, b) => a.daysAway - b.daysAway);
            }

            // Get date variations that should be checked
            getVariations(dateStr) {
                const normalized = this.normalize(dateStr);
                if (!normalized) return [dateStr];

                const d = new Date(normalized);
                const variations = new Set();

                // Add normalized version
                variations.add(normalized);

                // Add original
                variations.add(dateStr);

                // Add common formats
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');

                variations.add(`${year}-${month}-${day}`);
                variations.add(`${day}-${month}-${year}`);
                variations.add(`${month}-${day}-${year}`);
                variations.add(`${day}/${month}/${year}`);
                variations.add(`${month}/${day}/${year}`);

                return Array.from(variations);
            }
        }

        /**
         * OrderValidator - Validation system to detect missing orders
         * Alerts when filtering results seem incomplete
         */
        class OrderValidator {
            constructor(patternLearner) {
                this.patternLearner = patternLearner;
            }

            validate(filterResult) {
                const alerts = [];
                const { date, orderCount, totalAvailable, matchedOrders, allOrders } = filterResult;

                // Alert 1: Check for anomalies based on learned patterns
                const anomaly = this.patternLearner.detectAnomaly(date, orderCount);
                if (anomaly.isAnomaly) {
                    alerts.push({
                        level: 'warning',
                        type: 'anomaly',
                        message: anomaly.message,
                        details: anomaly
                    });
                }

                // Alert 2: Check if there are orders with similar dates that weren't matched
                const targetDate = new Date(date);
                const nearbyOrders = allOrders.filter(order => {
                    if (matchedOrders.includes(order)) return false;

                    const orderDate = new Date(order.date || order.startDate);
                    const diffDays = Math.abs((orderDate - targetDate) / (1000 * 60 * 60 * 24));
                    return diffDays <= 2; // Within 2 days
                });

                if (nearbyOrders.length > 0) {
                    alerts.push({
                        level: 'info',
                        type: 'nearby_dates',
                        message: `â„¹ï¸ Found ${nearbyOrders.length} order(s) within 2 days of ${date}`,
                        details: {
                            nearbyOrders: nearbyOrders.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                date: o.date || o.startDate
                            }))
                        }
                    });
                }

                // Alert 3: Check for orders with blank/missing dates
                const ordersWithoutDates = allOrders.filter(o =>
                    !o.date && !o.startDate && o.status !== 'Completed'
                );

                if (ordersWithoutDates.length > 0) {
                    alerts.push({
                        level: 'warning',
                        type: 'missing_dates',
                        message: `âš ï¸ Found ${ordersWithoutDates.length} order(s) without dates`,
                        details: {
                            orders: ordersWithoutDates.map(o => ({
                                orderId: o.orderId,
                                clientName: o.clientName,
                                status: o.status
                            }))
                        }
                    });
                }

                // Alert 4: Check for multiday orders that might be partially matched
                const multidayOrders = allOrders.filter(o =>
                    o.isMultiDay && !matchedOrders.includes(o)
                );

                for (const order of multidayOrders) {
                    if (order.startDate && order.endDate) {
                        const checkDate = new Date(date);
                        const start = new Date(order.startDate);
                        const end = new Date(order.endDate);

                        // Check if date should fall in range but wasn't matched
                        if (checkDate >= start && checkDate <= end) {
                            alerts.push({
                                level: 'error',
                                type: 'missed_multiday',
                                message: `ðŸš¨ Multi-day order "${order.orderId || order.clientName}" should include ${date} but wasn't matched!`,
                                details: {
                                    orderId: order.orderId,
                                    clientName: order.clientName,
                                    startDate: order.startDate,
                                    endDate: order.endDate
                                }
                            });
                        }
                    }
                }

                return alerts;
            }

            showAlerts(alerts, date) {
                if (alerts.length === 0) return;

                console.group(`ðŸ”” Validation Alerts for ${date}`);

                for (const alert of alerts) {
                    const emoji = alert.level === 'error' ? 'ðŸš¨' :
                                 alert.level === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
                    console.log(`${emoji} [${alert.type}] ${alert.message}`);
                    if (alert.details) {
                        console.log('Details:', alert.details);
                    }
                }

                console.groupEnd();

                // Show toast for critical alerts
                const criticalAlerts = alerts.filter(a => a.level === 'error');
                if (criticalAlerts.length > 0 && window.OMS) {
                    window.OMS.showToast(
                        `${criticalAlerts.length} critical validation issue(s) detected!`,
                        'error'
                    );
                }
            }
        }

        /**
         * FilterRatingSystem - User feedback system for filter algorithm
         * Allows users to rate filtering results and helps system learn from mistakes
         */
        class FilterRatingSystem {
            constructor() {
                this.ratings = this.loadRatings();
                this.currentFilterContext = null;
                this.maxRatings = 500; // Keep last 500 ratings
            }

            loadRatings() {
                try {
                    const saved = localStorage.getItem('oms_filter_ratings');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Failed to load filter ratings:', error);
                    return [];
                }
            }

            saveRatings() {
                try {
                    if (this.ratings.length > this.maxRatings) {
                        this.ratings = this.ratings.slice(-this.maxRatings);
                    }
                    localStorage.setItem('oms_filter_ratings', JSON.stringify(this.ratings));
                } catch (error) {
                    console.warn('Failed to save filter ratings:', error);
                }
            }

            // Store context of current filter operation for rating
            setFilterContext(context) {
                this.currentFilterContext = {
                    timestamp: new Date().toISOString(),
                    date: context.date,
                    normalizedDate: context.normalizedDate,
                    matchedOrders: context.matchedOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    })),
                    totalOrders: context.totalOrders,
                    filterDetails: context.filterDetails,
                    allOrderIds: context.allOrders.map(o => ({
                        orderId: o.orderId,
                        docId: o.docId,
                        clientName: o.clientName,
                        date: o.date,
                        startDate: o.startDate,
                        endDate: o.endDate,
                        isMultiDay: o.isMultiDay
                    }))
                };
            }

            // Record user rating with feedback
            recordRating(rating, feedback = {}) {
                if (!this.currentFilterContext) {
                    console.warn('No filter context available for rating');
                    return;
                }

                const ratingEntry = {
                    ...this.currentFilterContext,
                    rating, // 1-5 stars or thumbs up/down
                    feedback: {
                        userComment: feedback.comment || '',
                        incorrectlyIncluded: feedback.incorrectlyIncluded || [], // Order IDs that shouldn't be there
                        incorrectlyExcluded: feedback.incorrectlyExcluded || [], // Order IDs that should be there
                        ratingType: feedback.ratingType || 'numeric', // 'numeric', 'thumbs', 'words'
                        sentimentScore: this.calculateSentiment(rating, feedback),
                        tags: feedback.tags || [] // ['wrong_date', 'missing_orders', 'extra_orders', 'perfect']
                    },
                    ratedAt: new Date().toISOString()
                };

                this.ratings.push(ratingEntry);
                this.saveRatings();

                console.log('âœ¨ Rating recorded:', ratingEntry);

                // Learn from this feedback
                this.learnFromRating(ratingEntry);

                return ratingEntry;
            }

            // Calculate sentiment score from rating
            calculateSentiment(rating, feedback) {
                let score = 0;

                // Numeric rating (1-5 stars)
                if (typeof rating === 'number') {
                    score = (rating - 1) / 4; // Normalize to 0-1
                }
                // Thumbs up/down
                else if (rating === 'up') {
                    score = 1;
                } else if (rating === 'down') {
                    score = 0;
                }
                // Word-based rating
                else if (typeof rating === 'string') {
                    const wordScores = {
                        'perfect': 1.0,
                        'excellent': 1.0,
                        'good': 0.75,
                        'okay': 0.5,
                        'bad': 0.25,
                        'terrible': 0
                    };
                    score = wordScores[rating.toLowerCase()] || 0.5;
                }

                // Adjust based on specific feedback
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    score *= 0.5; // Penalty for wrong inclusions
                }
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    score *= 0.5; // Penalty for missing orders
                }

                return score;
            }

            // Learn from user rating
            learnFromRating(ratingEntry) {
                const { date, normalizedDate, feedback, rating } = ratingEntry;

                // Create learning rules based on feedback
                const learningRules = [];

                // Rule 1: Learn from incorrectly included orders
                if (feedback.incorrectlyIncluded && feedback.incorrectlyIncluded.length > 0) {
                    feedback.incorrectlyIncluded.forEach(badOrder => {
                        learningRules.push({
                            type: 'exclusion',
                            targetDate: normalizedDate,
                            orderId: badOrder.orderId,
                            reason: 'User marked as incorrectly included',
                            orderDate: badOrder.date || badOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 2: Learn from incorrectly excluded orders
                if (feedback.incorrectlyExcluded && feedback.incorrectlyExcluded.length > 0) {
                    feedback.incorrectlyExcluded.forEach(missedOrder => {
                        learningRules.push({
                            type: 'inclusion',
                            targetDate: normalizedDate,
                            orderId: missedOrder.orderId,
                            reason: 'User marked as incorrectly excluded',
                            orderDate: missedOrder.date || missedOrder.startDate,
                            weight: 1.0
                        });
                    });
                }

                // Rule 3: Learn from overall sentiment
                if (feedback.sentimentScore < 0.5) {
                    learningRules.push({
                        type: 'anomaly',
                        targetDate: normalizedDate,
                        reason: 'Low user satisfaction',
                        sentimentScore: feedback.sentimentScore,
                        weight: 0.5
                    });
                }

                // Store learning rules
                if (learningRules.length > 0) {
                    this.storeLearningRules(learningRules);
                }

                console.log('ðŸ§  Learned from rating:', learningRules.length, 'new rules');
            }

            // Store learning rules for future use
            storeLearningRules(rules) {
                try {
                    let existingRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    existingRules = [...existingRules, ...rules];

                    // Keep only last 1000 rules
                    if (existingRules.length > 1000) {
                        existingRules = existingRules.slice(-1000);
                    }

                    localStorage.setItem('oms_filter_learning_rules', JSON.stringify(existingRules));
                } catch (error) {
                    console.warn('Failed to store learning rules:', error);
                }
            }

            // Get learning rules for a specific date
            getLearningRules(date) {
                try {
                    const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                    return rules.filter(rule => rule.targetDate === date);
                } catch (error) {
                    console.warn('Failed to get learning rules:', error);
                    return [];
                }
            }

            // Apply learning rules to filter results
            applyLearningRules(date, orders, allOrders) {
                const rules = this.getLearningRules(date);
                if (rules.length === 0) return { orders, corrections: [] };

                console.log(`ðŸ§  Applying ${rules.length} learning rules for ${date}`);

                const corrections = [];
                let correctedOrders = [...orders];

                // Apply exclusion rules
                const exclusionRules = rules.filter(r => r.type === 'exclusion');
                exclusionRules.forEach(rule => {
                    const idx = correctedOrders.findIndex(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (idx !== -1) {
                        corrections.push({
                            type: 'removed',
                            order: correctedOrders[idx],
                            reason: rule.reason
                        });
                        correctedOrders.splice(idx, 1);
                    }
                });

                // Apply inclusion rules
                const inclusionRules = rules.filter(r => r.type === 'inclusion');
                inclusionRules.forEach(rule => {
                    const order = allOrders.find(o => o.orderId === rule.orderId || o.docId === rule.orderId);
                    if (order && !correctedOrders.find(o => o.orderId === order.orderId)) {
                        corrections.push({
                            type: 'added',
                            order: order,
                            reason: rule.reason
                        });
                        correctedOrders.push(order);
                    }
                });

                if (corrections.length > 0) {
                    console.log(`âœ… Applied ${corrections.length} corrections:`, corrections);
                }

                return { orders: correctedOrders, corrections };
            }

            // Show rating UI modal
            showRatingUI(OMS) {
                if (!this.currentFilterContext) return;

                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>â­ Rate Filter Results</h3>
                            <button onclick="this.closest('.modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 20px; color: var(--text-secondary);">
                                Found <strong>${this.currentFilterContext.matchedOrders.length}</strong> orders for
                                <strong>${this.currentFilterContext.date}</strong>
                            </p>

                            <!-- Star Rating -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">How accurate was this filter?</label>
                                <div id="starRating" style="font-size: 36px; cursor: pointer;">
                                    ${[1, 2, 3, 4, 5].map(i => `<span data-rating="${i}" style="color: #ddd;">â­</span>`).join('')}
                                </div>
                                <div style="margin-top: 8px; color: var(--text-secondary); font-size: 14px;">
                                    <span id="ratingLabel">Click to rate</span>
                                </div>
                            </div>

                            <!-- Quick Feedback Buttons -->
                            <div style="margin-bottom: 25px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Quick Feedback:</label>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <button class="btn btn-sm feedback-tag" data-tag="perfect">âœ… Perfect</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="missing_orders">âŒ Missing Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="extra_orders">âž• Extra Orders</button>
                                    <button class="btn btn-sm feedback-tag" data-tag="wrong_date">ðŸ“… Wrong Date</button>
                                </div>
                            </div>

                            <!-- Matched Orders List -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">
                                    Matched Orders (Click to mark as incorrect):
                                </label>
                                <div id="matchedOrdersList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 10px;">
                                    ${this.currentFilterContext.matchedOrders.map(o => `
                                        <div class="order-item" data-order-id="${o.orderId}" data-doc-id="${o.docId}" style="padding: 8px; margin: 5px 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                                            <strong>${o.orderId || o.clientName}</strong>
                                            <span style="color: var(--text-secondary); margin-left: 10px; font-size: 12px;">
                                                ${o.date || o.startDate || 'No date'}
                                            </span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <!-- Comment -->
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 10px; font-weight: 600;">Additional Comments (Optional):</label>
                                <textarea id="ratingComment" rows="3" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; resize: vertical;" placeholder="Tell us what went wrong or what was good..."></textarea>
                            </div>

                            <!-- Submit Buttons -->
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Skip</button>
                                <button id="submitRating" class="btn btn-primary">Submit Rating</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Star rating interaction
                let selectedRating = 0;
                const stars = modal.querySelectorAll('#starRating span');
                const ratingLabel = modal.querySelector('#ratingLabel');
                const labels = ['Terrible', 'Bad', 'Okay', 'Good', 'Excellent'];

                stars.forEach(star => {
                    star.addEventListener('mouseenter', function() {
                        const rating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < rating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[rating - 1];
                    });

                    star.addEventListener('click', function() {
                        selectedRating = parseInt(this.dataset.rating);
                        stars.forEach((s, i) => {
                            s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                        });
                        ratingLabel.textContent = labels[selectedRating - 1] + ' â­'.repeat(selectedRating);
                    });
                });

                modal.querySelector('#starRating').addEventListener('mouseleave', function() {
                    stars.forEach((s, i) => {
                        s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
                    });
                    ratingLabel.textContent = selectedRating > 0 ? labels[selectedRating - 1] + ' â­'.repeat(selectedRating) : 'Click to rate';
                });

                // Feedback tags interaction
                const selectedTags = new Set();
                modal.querySelectorAll('.feedback-tag').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (selectedTags.has(tag)) {
                            selectedTags.delete(tag);
                            this.style.background = '';
                            this.style.color = '';
                        } else {
                            selectedTags.add(tag);
                            this.style.background = 'var(--primary)';
                            this.style.color = 'white';
                        }
                    });
                });

                // Order selection interaction
                const incorrectOrders = new Set();
                modal.querySelectorAll('.order-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const orderId = this.dataset.orderId || this.dataset.docId;
                        if (incorrectOrders.has(orderId)) {
                            incorrectOrders.delete(orderId);
                            this.style.background = 'var(--bg-card)';
                            this.style.border = '1px solid var(--border)';
                        } else {
                            incorrectOrders.add(orderId);
                            this.style.background = '#ffebee';
                            this.style.border = '2px solid #f44336';
                        }
                    });
                });

                // Submit rating
                modal.querySelector('#submitRating').addEventListener('click', () => {
                    if (selectedRating === 0) {
                        OMS.showToast('Please select a rating', 'error');
                        return;
                    }

                    const incorrectlyIncluded = Array.from(incorrectOrders).map(orderId => {
                        return this.currentFilterContext.matchedOrders.find(o =>
                            o.orderId === orderId || o.docId === orderId
                        );
                    }).filter(Boolean);

                    this.recordRating(selectedRating, {
                        comment: modal.querySelector('#ratingComment').value,
                        incorrectlyIncluded,
                        incorrectlyExcluded: [], // Can be enhanced to allow selecting missing orders
                        ratingType: 'numeric',
                        tags: Array.from(selectedTags)
                    });

                    OMS.showToast('âœ¨ Thank you! The system has learned from your feedback.', 'success');
                    modal.remove();
                });
            }

            // Get statistics about ratings
            getStats() {
                if (this.ratings.length === 0) {
                    return { avgRating: 0, totalRatings: 0, recentRatings: [] };
                }

                const numericRatings = this.ratings.filter(r => typeof r.rating === 'number');
                const avgRating = numericRatings.length > 0
                    ? numericRatings.reduce((sum, r) => sum + r.rating, 0) / numericRatings.length
                    : 0;

                return {
                    avgRating: avgRating.toFixed(2),
                    totalRatings: this.ratings.length,
                    recentRatings: this.ratings.slice(-10),
                    sentimentTrend: this.ratings.slice(-20).map(r => r.feedback.sentimentScore)
                };
            }

            // Clear all ratings
            clearAllRatings() {
                this.ratings = [];
                this.saveRatings();
                localStorage.removeItem('oms_filter_learning_rules');
                console.log('ðŸ—‘ï¸ All ratings and learning rules cleared');
            }
        }

        // Initialize global instances
        const filterLogger = new FilterLogger();
        const patternLearner = new PatternLearner();
        const fuzzyDateMatcher = new FuzzyDateMatcher();
        const orderValidator = new OrderValidator(patternLearner);
        const filterRatingSystem = new FilterRatingSystem();

        // Clean up old logs periodically (keep last 30 days)
        filterLogger.clearOldLogs(30);

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [], deletedItems: [], deletedCategories: [] },
                itemHistory: [],
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                payments: [],
                expenses: [],
                trackingData: [],
                eventsList: [
                    'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                    'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                    'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                    'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                    'Ganesh Agman', 'Ganesh Visarjan'
                ],
                settings: {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["à¤®à¤•à¤° à¤¸à¤‚à¤•à¥à¤°à¤¾à¤‚à¤¤à¤¿", "Makar Sankranti"],
                "2025-01-26": ["à¤—à¤£à¤¤à¤‚à¤¤à¥à¤° à¤¦à¤¿à¤µà¤¸", "Republic Day"],
                "2025-02-13": ["à¤®à¤¹à¤¾ à¤¶à¤¿à¤µà¤°à¤¾à¤¤à¥à¤°à¤¿", "Maha Shivratri"],
                "2025-03-13": ["à¤¹à¥‹à¤²à¥€", "Holi"],
                "2025-03-14": ["à¤§à¥à¤²à¥‡à¤Ÿà¥€", "Dhuleti"],
                "2025-04-06": ["à¤°à¤¾à¤® à¤¨à¤µà¤®à¥€", "Ram Navami"],
                "2025-08-15": ["à¤¸à¥à¤µà¤¤à¤‚à¤¤à¥à¤°à¤¤à¤¾ à¤¦à¤¿à¤µà¤¸", "Independence Day"],
                "2025-08-19": ["à¤œà¤¨à¥à¤®à¤¾à¤·à¥à¤Ÿà¤®à¥€", "Janmashtami"],
                "2025-10-02": ["à¤—à¤¾à¤‚à¤§à¥€ à¤œà¤¯à¤‚à¤¤à¥€", "Gandhi Jayanti"],
                "2025-11-01": ["à¤§à¤¨à¤¤à¥‡à¤°à¤¸", "Dhanteras"],
                "2025-11-02": ["à¤¦à¥€à¤µà¤¾à¤²à¥€", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('âš ï¸ Already initialized - skipping duplicate init');
        return;
    }

    console.log('ðŸš€ Initializing OMS...');
    this.initialized = true;

    // Load user role first
    await this.getCurrentUser();

    await this.loadFromStorage();
    await this.loadEventsListFromFirestore();
    this.populateEventsDatalist(); // Populate events dropdown immediately
    await this.loadTrackingFromFirestore();
    await this.loadVideosFromFirestore(); // Load videos from Firestore
    await this.loadAdsFromFirestore(); // Load advertisements from Firestore
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();

    // Apply RBAC to navigation tabs
    await this.applyRBACToNavigation();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
                this.applyLanguage(); // Apply saved language

                // Initialize weather mini dashboard and set up auto-refresh
                this.updateWeatherMiniDashboard();
                setInterval(() => this.updateWeatherMiniDashboard(), 900000); // Refresh every 15 minutes

                // Check for draft order after initialization
                setTimeout(() => this.checkForDraft(), 1000);
            },

            // ============ LANGUAGE SWITCHING ============
            toggleLanguage() {
                const currentLang = this.data.settings.language || 'en';
                const newLang = currentLang === 'en' ? 'gu' : 'en';
                this.data.settings.language = newLang;
                this.saveToStorage();
                this.applyLanguage();
                this.showToast(newLang === 'en' ? 'Language switched to English' : 'àª­àª¾àª·àª¾ àª—à«àªœàª°àª¾àª¤à«€àª®àª¾àª‚ àª¬àª¦àª²àª¾àªˆ àª—àªˆ', 'success');
            },

            applyLanguage() {
                const lang = this.data.settings.language || 'en';
                const t = translations[lang];

                // Update language toggle button
                const toggleBtn = document.getElementById('languageToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = lang === 'en' ? 'ðŸŒ EN' : 'ðŸŒ àª—à«';
                    toggleBtn.title = lang === 'en' ? 'Switch to Gujarati' : 'àª…àª‚àª—à«àª°à«‡àªœà«€àª®àª¾àª‚ àª¬àª¦àª²à«‹';
                }

                // Update header
                const companyName = document.querySelector('.company-name');
                if (companyName) companyName.textContent = t.companyName;

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) searchInput.placeholder = t.searchPlaceholder;

                // Update tabs
                const tabs = document.querySelectorAll('.nav-tab');
                const tabKeys = ['dashboard', 'orders', 'inventory', 'itemHistory', 'preparation', 'customers', 'quotations', 'team', 'calendar', 'history', 'analytics', 'videos', 'advertisements', 'financials', 'settings'];
                tabs.forEach((tab, index) => {
                    if (tabKeys[index] && t[tabKeys[index]]) {
                        tab.textContent = t[tabKeys[index]];
                    }
                });

                // Update Orders tab static labels using data-translate attributes
                this.updateOrdersTabLabels();

                // Update action buttons
                this.updateActionButtons();

                // Re-render current tab to apply translations
                if (this.currentTab) {
                    this.switchTab(this.currentTab);
                }
            },

            updateOrdersTabLabels() {
                // Helper function to update label text
                const updateLabel = (selector, translationKey) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.textContent = this.t(translationKey);
                    });
                };

                // Update form labels by finding them with specific text patterns
                // This will update all label elements in the orders tab
                const labels = {
                    'Client Name': 'clientName',
                    'Contact': 'contact',
                    'Venue': 'venue',
                    'Ready Time': 'readyTime',
                    'Order Status': 'orderStatus',
                    'Notes': 'notes',
                    'Driver Name': 'driverName',
                    'Operator': 'operator',
                    'Helper(s)': 'helpers',
                    'Transport': 'transport'
                };

                document.querySelectorAll('.form-label').forEach(label => {
                    const text = label.textContent.trim();
                    Object.keys(labels).forEach(key => {
                        if (text.includes(key)) {
                            const translatedText = this.t(labels[key]);
                            label.textContent = label.textContent.replace(key, translatedText);
                        }
                    });
                });

                // Update helper placeholder
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.placeholder = this.t('helperPlaceholder');
                }

                // Update client name placeholder
                const clientInput = document.getElementById('clientName');
                if (clientInput) {
                    clientInput.placeholder = this.t('enterClientName');
                }
            },

            updateActionButtons() {
                // Update button texts by finding buttons with specific onclick handlers
                const updateButton = (selector, translationKey) => {
                    const btn = document.querySelector(selector);
                    if (btn) btn.textContent = this.t(translationKey);
                };

                // Update form action buttons
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    const text = btn.textContent.trim();
                    if (text.includes('Save Order')) btn.textContent = this.t('saveOrderShortcut');
                    else if (text.includes('Duplicate Last')) btn.textContent = this.t('duplicateLast');
                    else if (text.includes('Same Day')) btn.textContent = this.t('sameDay');
                    else if (text.includes('Clear') && text.includes('Ctrl')) btn.textContent = this.t('clearFormShortcut');
                    else if (text.includes('Preview')) btn.textContent = `ðŸ‘ï¸ ${this.t('preview')}`;
                    else if (text.includes('Notify')) btn.textContent = this.t('notifyTeam');
                    else if (text.includes('Send Manager')) btn.textContent = this.t('sendReport');
                });
            },

            // Helper function to get translations
            t(key) {
                const lang = this.data.settings.language || 'en';
                return translations[lang][key] || translations.en[key] || key;
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    // FIXED: Get all data attributes from the same element to avoid mismatched selections
                    const actionElement = e.target.closest('[data-action]');
                    if (!actionElement) return;

                    const action = actionElement.dataset.action;
                    const id = actionElement.dataset.id;
                    const type = actionElement.dataset.type;

                    // Log only relevant data for each action type
                    const actionsNeedingIdType = ['edit', 'delete', 'print', 'quickAction'];
                    if (actionsNeedingIdType.includes(action)) {
                        console.log('ðŸ–±ï¸ Button clicked - Action:', action, 'ID:', id, 'Type:', type);
                    } else {
                        console.log('ðŸ–±ï¸ Button clicked - Action:', action);
                    }

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;

        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            container.innerHTML = '';
            return;
        }

        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">${this.t('dayNumber')} ${i + 1} - ${dateStr}</h4>

                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>

                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ${this.t('addFunctionToThisDay')}
                    </button>
                </div>
            `;
        }

        container.innerHTML = html;

        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;

        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }

        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;

        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            venue: '',
            transport: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });

        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">${this.t('functionNumber')} ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">${this.t('removeFunction')}</button>` : ''}
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('functionType')}</label>
                        <select id="${functionId}Type" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                            <option value="">Select Event Type</option>
                            ${(this.data.eventsList || []).map(event => `<option value="${event}">${event}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('timeSlot')}</label>
                        <input type="text" id="${functionId}Time" class="form-input highlight-datetime"
                               placeholder="${this.t('enterTimeSlot')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('venue')}</label>
                        <input type="text" id="${functionId}Venue" class="form-input"
                               placeholder="Enter venue address"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'venue', this.value)">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Transport (Multiple)</label>
                        <select id="${functionId}Transport" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'transport', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                            <option value="New Bolero">New Bolero</option>
                            <option value="Old Bolero">Old Bolero</option>
                            <option value="Isuzu">Isuzu</option>
                            <option value="Porter">Porter</option>
                            <option value="Other">Other</option>
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple transports</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('driver')} (Multiple)</label>
                        <select id="${functionId}Driver" class="form-select" multiple style="min-height: 80px;"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', Array.from(this.selectedOptions).map(opt => opt.value).join(', '))">
                        </select>
                        <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple drivers</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('operator')}</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">${this.t('selectOperator')}</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('helpers')}</label>
                        <input type="text" id="${functionId}Helper" class="form-input" placeholder="Enter helper names separated by commas (e.g., John, Mary, David)"
                               oninput="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value.trim())">
                        <small style="color: var(--text-gray);">Enter multiple helper names separated by commas</small>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('notes')}</label>
                    <textarea id="${functionId}Notes" class="form-textarea"
                              placeholder="${this.t('functionNotes')}"
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('items')}</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input"
                               placeholder="${this.t('searchItems')}" autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">${this.t('noItemsAdded')}</div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">ðŸ—‘ï¸</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Pcs</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">ðŸ—‘ï¸</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); this.saveOrder(); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); this.clearForm(); },
                            'd': () => { e.preventDefault(); this.clearForm(); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.add('show');
                backdrop.classList.add('show');

                // Add Escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideShortcuts();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                panel._escapeHandler = escapeHandler;
            },

            hideShortcuts() {
                const panel = document.getElementById('shortcutsPanel');
                const backdrop = document.getElementById('shortcutsBackdrop');
                panel.classList.remove('show');
                backdrop.classList.remove('show');

                // Remove escape handler
                if (panel._escapeHandler) {
                    document.removeEventListener('keydown', panel._escapeHandler);
                    panel._escapeHandler = null;
                }
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    const form = document.getElementById('orderForm');
                    if (form && this.hasUnsavedChanges()) {
                        localStorage.setItem('oms_draft', JSON.stringify(this.collectFormData()));
                        console.log('ðŸ“ Draft auto-saved');
                    }
                }, 2000); // Auto-save every 2 seconds
            },

            hasUnsavedChanges() {
                return Utils.get('clientName') || this.currentOrderItems.length > 0;
            },

            checkForDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        // Only show restore option if draft has meaningful data
                        if (draftData.clientName || (draftData.items && draftData.items.length > 0)) {
                            const draftDate = new Date(draftData.createdAt || Date.now()).toLocaleString();
                            const message = `
                                <div style="text-align: left;">
                                    <h3 style="margin-top: 0;">ðŸ“‹ Draft Order Found</h3>
                                    <p>You have an unsaved draft from: <strong>${draftDate}</strong></p>
                                    <p><strong>Client:</strong> ${draftData.clientName || 'Not specified'}</p>
                                    <p><strong>Items:</strong> ${draftData.items?.length || 0} items</p>
                                    <p>Would you like to restore this draft?</p>
                                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                                        <button class="btn btn-success" onclick="OMS.restoreDraft(); OMS.closeModal('draftModal');">âœ… Restore Draft</button>
                                        <button class="btn btn-danger" onclick="OMS.discardDraft(); OMS.closeModal('draftModal');">ðŸ—‘ï¸ Discard Draft</button>
                                        <button class="btn btn-secondary" onclick="OMS.closeModal('draftModal');">â­ï¸ Ignore for Now</button>
                                    </div>
                                </div>
                            `;

                            // Show modal with draft info
                            const modalHTML = `
                                <div class="modal show" id="draftModal" onclick="if(event.target === this) document.getElementById('draftModal').remove()">
                                    <div class="modal-content" style="max-width: 500px;">
                                        ${message}
                                    </div>
                                </div>
                            `;
                            document.body.insertAdjacentHTML('beforeend', modalHTML);
                        }
                    } catch (error) {
                        console.error('Error checking draft:', error);
                    }
                }
            },

            restoreDraft() {
                const draft = localStorage.getItem('oms_draft');
                if (draft) {
                    try {
                        const draftData = JSON.parse(draft);
                        console.log('ðŸ“‹ Restoring draft:', draftData);

                        // Switch to orders tab
                        this.switchTab('orders');

                        // Wait for tab to be visible
                        setTimeout(() => {
                            // Populate form fields
                            if (draftData.clientName) Utils.set('clientName', draftData.clientName);
                            if (draftData.contact) Utils.set('contact', draftData.contact);
                            if (draftData.venue) Utils.set('venue', draftData.venue);
                            if (draftData.eventType) Utils.set('eventType', draftData.eventType);
                            if (draftData.date) Utils.set('orderDate', draftData.date);
                            if (draftData.readyTime) Utils.set('readyTime', draftData.readyTime);
                            if (draftData.transport) Utils.set('transport', draftData.transport);
                            if (draftData.driverName) Utils.set('driverName', draftData.driverName);
                            if (draftData.operator) Utils.set('operator', draftData.operator);
                            if (draftData.status) Utils.set('orderStatus', draftData.status);
                            if (draftData.notes) Utils.set('notes', draftData.notes);

                            // Restore multiday data if exists
                            if (draftData.isMultiDay) {
                                Utils.set('eventTypeSelect', 'multi');
                                if (draftData.startDate) Utils.set('startDate', draftData.startDate);
                                if (draftData.endDate) Utils.set('endDate', draftData.endDate);

                                // Trigger multiday form generation
                                const event = new Event('change');
                                document.getElementById('eventTypeSelect')?.dispatchEvent(event);

                                // Restore day-wise data after form is generated
                                if (draftData.dayWiseData) {
                                    setTimeout(() => {
                                        window.dayFunctionsData = draftData.dayWiseData;
                                        console.log('ðŸ“… Restored multiday data with items');
                                    }, 500);
                                }
                            } else {
                                // Restore items for single-day events only
                                if (draftData.items && Array.isArray(draftData.items) && draftData.items.length > 0) {
                                    console.log('ðŸ“¦ Restoring items:', draftData.items);
                                    this.currentOrderItems = [...draftData.items];
                                    this.updateOrderItemsList();
                                }
                            }

                            this.showToast('âœ… Draft restored successfully!', 'success');
                        }, 100);

                    } catch (error) {
                        console.error('Error restoring draft:', error);
                        this.showToast('âŒ Error restoring draft', 'error');
                    }
                }
            },

            discardDraft() {
                localStorage.removeItem('oms_draft');
                this.showToast('ðŸ—‘ï¸ Draft discarded', 'info');
                console.log('ðŸ—‘ï¸ Draft discarded by user');
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('âœ… Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('âœ… Auto-backup created successfully');
                    this.showToast('ðŸ“¦ Auto-backup created', 'success');
                } catch (error) {
                    console.error('âŒ Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('ðŸ“¥ Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            initGlobalSearch() {
                const input = document.getElementById('globalSearch');
                const results = document.getElementById('globalSearchResults');

                input.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    if (query.length < 2) {
                        results.classList.remove('show');
                        return;
                    }

                    const searchResults = this.performGlobalSearch(query);
                    this.displayGlobalSearchResults(searchResults);
                }, 300));

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        results.classList.remove('show');
                        input.value = '';
                    }
                });
            },

            performGlobalSearch(query) {
                const results = [];

                // Search orders
                this.data.orders.forEach(order => {
                    if (order.orderId.toLowerCase().includes(query) ||
                        order.clientName.toLowerCase().includes(query) ||
                        order.venue.toLowerCase().includes(query)) {
                        results.push({ type: 'order', data: order });
                    }
                });

                // Search customers
                this.data.customers.forEach(customer => {
                    if (customer.name.toLowerCase().includes(query) ||
                        customer.contact.includes(query)) {
                        results.push({ type: 'customer', data: customer });
                    }
                });

                // Search inventory
                this.data.inventory.items.forEach(item => {
                    if (item.name.toLowerCase().includes(query)) {
                        results.push({ type: 'item', data: item });
                    }
                });

                return results.slice(0, 10);
            },

            displayGlobalSearchResults(results) {
                const container = document.getElementById('globalSearchResults');
                if (results.length === 0) {
                    container.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    container.innerHTML = results.map(r => `
                        <div class="search-result-item" onclick="OMS.navigateToResult('${r.type}', '${r.data.id || r.data.orderId}')">
                            <div>
                                <div class="search-result-type">${r.type}</div>
                                <div>${r.type === 'order' ? r.data.orderId + ' - ' + r.data.clientName : 
                                       r.type === 'customer' ? r.data.name : r.data.name}</div>
                            </div>
                        </div>
                    `).join('');
                }
                container.classList.add('show');
            },

            navigateToResult(type, id) {
                const tabMap = { order: 'history', customer: 'customers', item: 'inventory' };
                this.switchTab(tabMap[type]);
                document.getElementById('globalSearchResults').classList.remove('show');
                document.getElementById('globalSearch').value = '';
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('ðŸ”¥ Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`ðŸ”¥ Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('ðŸ§© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    // FIXED: Search by docId first (always unique), then orderId as fallback
    const index = this.data.orders.findIndex(o => o.docId === id || o.orderId === id);
    if (index === -1) {
        console.warn('âš ï¸ Order not found in local array:', id);
        return false;
    }

    try {
        console.log('ðŸ”„ Attempting to delete orderId:', id);

        // Use the actual docId from the found order
        const orderToDelete = this.data.orders[index];
        const docRef = db.collection('orders').doc(orderToDelete.docId || id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('âœ… Deleted Firestore doc with ID:', id);
        } else {
            console.warn('âš ï¸ No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`ðŸ“ Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('âŒ Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                // Track deleted category to prevent re-addition
                if (!this.data.inventory.deletedCategories) {
                    this.data.inventory.deletedCategories = [];
                }
                if (!this.data.inventory.deletedCategories.includes(id)) {
                    this.data.inventory.deletedCategories.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('âŒ Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                // Track deleted item to prevent re-addition
                if (!this.data.inventory.deletedItems) {
                    this.data.inventory.deletedItems = [];
                }
                if (!this.data.inventory.deletedItems.includes(id)) {
                    this.data.inventory.deletedItems.push(id);
                }
                this.saveToStorage();

                return true;
            } catch (error) {
                console.error('âŒ Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();

        // Reload data from Firestore to ensure all tabs are in sync
        await this.loadOrdersFromFirestore();

        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        console.log('ðŸ” EditItem called with ID:', id);
                        console.log('ðŸ“‹ All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                        // FIXED: Search by docId first (always unique), then orderId as fallback
                        const order = this.data.orders.find(o => o.docId === id || o.orderId === id);
                        console.log('âœ… Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                        if (!order) return;
                        this.switchTab('orders');
                        this.loadOrderToForm(order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
},

            async updateWeatherMiniDashboard() {
                try {
                    const city = this.data.settings.city || 'Delhi';
                    const apiKey = this.data.settings.weatherApiKey || '';
                    const weather = await Utils.getWeather(city, apiKey);

                    const iconElement = document.querySelector('.weather-mini-icon');
                    const tempElement = document.querySelector('.weather-mini-temp');
                    const conditionElement = document.querySelector('.weather-mini-condition');

                    if (iconElement && tempElement && conditionElement) {
                        iconElement.textContent = Utils.getWeatherEmoji(weather.condition);
                        tempElement.textContent = weather.temp !== 'N/A' ? `${weather.temp}Â°C` : '--Â°C';
                        conditionElement.textContent = weather.condition !== 'N/A' ? weather.condition : 'Loading...';
                    }
                } catch (error) {
                    console.error('Error updating weather mini dashboard:', error);
                }
            },

            getNextOrderId() {
                const prefix = this.data.settings.invoicePrefix || 'FP';
                const counter = this.data.settings.orderIdCounter || 1;
                return `${prefix}${String(counter).padStart(3, '0')}`;
            },

            incrementOrderCounter() {
                this.data.settings.orderIdCounter = (this.data.settings.orderIdCounter || 1) + 1;
                this.refreshOrderId();
            },

   collectFormData() {

        const transport = Utils.get('transport');
        const eventType = Utils.get('eventTypeSelect');
        const isMultiDay = eventType === 'multi';

        // Get helper names from text input
        const helperInput = document.getElementById('helper');
        const selectedHelpers = helperInput ? helperInput.value.trim() : '';

        // Collect day-wise data for multi-day events
        let dayWiseData = [];
        if (isMultiDay) {
            const startDate = Utils.get('startDate');
            const endDate = Utils.get('endDate');
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

            for (let i = 0; i < diffDays; i++) {
                const currentDate = new Date(start);
                currentDate.setDate(start.getDate() + i);

                // Get functions for this day
                const dayFunctions = window.dayFunctionsData?.[i] || [];

                dayWiseData.push({
                    dayNumber: i + 1,
                    date: Utils.toDateString(currentDate),
                    functions: dayFunctions.map(func => ({
                        functionType: func.functionType || '',
                        timeSlot: func.timeSlot || '',
                        driver: func.driver || '',
                        operator: func.operator || '',
                        helper: func.helper || '',
                        notes: func.notes || '',
                        items: func.items || []
                    }))
                });
            }
        }

        const transport2 = Utils.get('transport2');

        // Get location data - prioritize autocomplete selection, then fall back to manual Maps link
        let venueLocation = null;
        const mapLink = Utils.get('venueMapLink');

        // Check if user selected place from autocomplete
        if (window.selectedPlaceData) {
            venueLocation = {
                lat: window.selectedPlaceData.lat,
                lng: window.selectedPlaceData.lng,
                source: 'google_autocomplete',
                place_id: window.selectedPlaceData.place_id,
                formatted_address: window.selectedPlaceData.formatted_address
            };
            console.log('âœ… Using location from autocomplete:', venueLocation);
            console.log('ðŸ“ Will save to Firestore:', {
                venue: Utils.get('venue'),
                venueLocation: venueLocation,
                venueMapLink: mapLink
            });
        }
        // Otherwise, try to extract from manually pasted Maps link
        else if (mapLink && mapLink.trim()) {
            venueLocation = this.extractLocationFromMapsLink(mapLink);
            console.log('âœ… Using location extracted from Maps link:', venueLocation);
        } else {
            console.warn('âš ï¸ No venue location data available - neither autocomplete nor map link provided');
        }

        return {
            orderId: Utils.get('orderId'),
            isMultiDay: isMultiDay,
            date: isMultiDay ? null : Utils.get('orderDate'),
            startDate: isMultiDay ? Utils.get('startDate') : null,
            endDate: isMultiDay ? Utils.get('endDate') : null,
            dayWiseData: dayWiseData,
            lastEventDate: isMultiDay ? Utils.get('endDate') : Utils.get('orderDate'),
            readyTime: Utils.get('readyTime'),
            clientName: Utils.get('clientName'),
            contact: Utils.get('contact'),
            venue: Utils.get('venue'),
            venueMapLink: mapLink || null, // Store the Google Maps link
            venueLocation: venueLocation, // Extracted coordinates from Maps link
            eventType: Utils.get('eventType'),
            transport: transport === 'Other' ? Utils.get('customTransport') : transport,
            driverName: Utils.get('driverName'),
            transport2: transport2 === 'Other' ? Utils.get('customTransport2') : transport2,
            driverName2: Utils.get('driverName2'),
            operator: Utils.get('operator'),
            helper: selectedHelpers,
            status: Utils.get('orderStatus'),
            notes: Utils.get('orderNotes'),
            items: isMultiDay ? [] : [...this.currentOrderItems],
            createdAt: new Date().toISOString()
        };
    },

    // Extract latitude and longitude from Google Maps link
    extractLocationFromMapsLink(link) {
        if (!link) return null;

        try {
            // Google Maps link formats:
            // https://maps.app.goo.gl/... (short link - can't extract directly)
            // https://www.google.com/maps/place/.../@LAT,LNG,ZOOMz/...
            // https://www.google.com/maps/@LAT,LNG,ZOOMz
            // https://maps.google.com/?q=LAT,LNG
            // https://www.google.com/maps/search/?api=1&query=LAT,LNG
            // https://goo.gl/maps/... (short link)

            // Try to find coordinates in various formats
            let lat = null, lng = null;

            // Format 1: query=LAT,LNG (from API links)
            const queryMatch = link.match(/[?&]query=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (queryMatch) {
                lat = parseFloat(queryMatch[1]);
                lng = parseFloat(queryMatch[2]);
            }

            // Format 2: @LAT,LNG or ?q=LAT,LNG
            if (!lat) {
                const coordMatch = link.match(/[@?]q?=?(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                if (coordMatch) {
                    lat = parseFloat(coordMatch[1]);
                    lng = parseFloat(coordMatch[2]);
                }
            }

            // Format 3: /maps/place/NAME/@LAT,LNG
            if (!lat) {
                const placeMatch = link.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                if (placeMatch) {
                    lat = parseFloat(placeMatch[1]);
                    lng = parseFloat(placeMatch[2]);
                }
            }

            if (lat && lng) {
                return {
                    lat: lat,
                    lng: lng,
                    source: 'google_maps_link'
                };
            }

            // Only warn once per unique link to avoid console spam
            if (!this._warnedLinks) this._warnedLinks = new Set();
            if (!this._warnedLinks.has(link)) {
                console.warn('Could not extract coordinates from Maps link:', link);
                this._warnedLinks.add(link);
            }
            return null;
        } catch (error) {
            console.error('Error extracting location from Maps link:', error);
            return null;
        }
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('âœ… Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('âš ï¸ Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('â³ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('ðŸ’¾ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('âœï¸ Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('âœï¸ Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Calculate total amount from items
        const totalAmount = orderData.isMultiDay
            ? (orderData.dayWiseData || []).reduce((sum, day) => {
                const dayTotal = (day.functions || []).reduce((daySum, func) => {
                    const funcTotal = (func.items || []).reduce((itemSum, item) => {
                        return itemSum + ((item.price || 0) * (item.quantity || 0));
                    }, 0);
                    return daySum + funcTotal;
                }, 0);
                return sum + dayTotal;
            }, 0)
            : (orderData.items || []).reduce((sum, item) => {
                return sum + ((item.price || 0) * (item.quantity || 0));
            }, 0);

        console.log('ðŸ’° Calculated total amount:', totalAmount);

        // Fetch weather data for the order
        let weatherData = null;
        try {
            // Get weather API key from settings (if stored) or use default
            const weatherApiKey = this.data.settings?.weatherApiKey || '';
            const defaultCity = this.data.settings?.defaultCity || 'Delhi';

            // Fetch weather data
            weatherData = await Utils.getWeather(defaultCity, weatherApiKey);
            console.log('ðŸŒ¤ï¸ Weather data fetched:', weatherData);
        } catch (error) {
            console.warn('âš ï¸ Could not fetch weather data:', error);
        }

        // Add weather data to orderData
        orderData.weather = weatherData;

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    totalAmount: totalAmount,  // CRITICAL: Add totalAmount field
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    venueMapLink: orderData.venueMapLink || null,  // CRITICAL: Save venue map link
    venueLocation: orderData.venueLocation || null, // CRITICAL: Save venue coordinates
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    transport2: orderData.transport2 || '',
    driverName2: orderData.driverName2 || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    weather: weatherData,  // Add weather data
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('âœï¸ Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('ðŸ”„ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('ðŸ—‘ï¸ Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('âœ… Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} â†’ ${finalOrderId} âœ…`);

        // Auto-clear form after upgrade
        this.clearForm(true);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('âœ… Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            totalAmount: totalAmount  // Include totalAmount in local data
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        // ITEM HISTORY TRACKING (if order is now completed)
        if (status === 'completed') {
            if (orderData.items && orderData.items.length > 0) {
                this.recordItemHistory(orderData.items, orderData);
            }

            // For multi-day orders, track items from dayWiseData
            if (orderData.isMultiDay && orderData.dayWiseData) {
                orderData.dayWiseData.forEach(day => {
                    day.functions.forEach(func => {
                        if (func.items && func.items.length > 0) {
                            this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                        }
                    });
                });
            }
        }

        this.showToast('Order updated! âœï¸');

        // Auto-clear form after update
        this.clearForm(true);
    }

    // Save new custom events to the list
    await this.addCustomEventsToList(orderData);

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;

} else {
            // CREATE new order
            console.log('ðŸ†• Creating new order');

            // Save to Firestore
            console.log('ðŸ’¾ Saving to Firestore - venue data:', {
                venue: firestoreData.venue,
                venueLocation: firestoreData.venueLocation,
                venueMapLink: firestoreData.venueMapLink
            });

            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
                console.log('âœ… Saved with FP ID:', finalOrderId);
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('âœ… Saved with auto ID:', docRef.id);
            }

            // Verify what was actually saved
            console.log('âœ… venueLocation saved:', !!firestoreData.venueLocation, firestoreData.venueLocation);
            console.log('âœ… venueMapLink saved:', !!firestoreData.venueMapLink, firestoreData.venueMapLink);

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
    console.log('âœ… Order added to local array with totalAmount:', totalAmount);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION & ITEM HISTORY TRACKING (if order is completed)
                if (status === 'completed') {
                    if (orderData.items && orderData.items.length > 0) {
                        this.deductInventory(orderData.items, orderData.orderId);
                        this.recordItemHistory(orderData.items, orderData);
                    }

                    // For multi-day orders, track items from dayWiseData
                    if (orderData.isMultiDay && orderData.dayWiseData) {
                        orderData.dayWiseData.forEach(day => {
                            day.functions.forEach(func => {
                                if (func.items && func.items.length > 0) {
                                    this.recordItemHistory(func.items, orderData, day.date, func.functionType);
                                }
                            });
                        });
                    }
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! ðŸ†•`);

                // Auto-clear form after save
                this.clearForm(true);
                this.refreshOrderId();

                // Save new custom events to the list
                await this.addCustomEventsToList(orderData);

                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('âŒ Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

async addCustomEventsToList(orderData) {
    try {
        const newEvents = new Set();

        // Collect event from single-day order
        if (!orderData.isMultiDay && orderData.eventType && orderData.eventType.trim()) {
            const event = orderData.eventType.trim();
            if (!this.data.eventsList.includes(event)) {
                newEvents.add(event);
            }
        }

        // Collect events from multi-day order functions
        if (orderData.isMultiDay && orderData.dayWiseData) {
            orderData.dayWiseData.forEach(day => {
                if (day.functions) {
                    day.functions.forEach(func => {
                        if (func.functionType && func.functionType.trim()) {
                            const event = func.functionType.trim();
                            if (!this.data.eventsList.includes(event)) {
                                newEvents.add(event);
                            }
                        }
                    });
                }
            });
        }

        // Add new events to the list
        if (newEvents.size > 0) {
            newEvents.forEach(event => {
                this.data.eventsList.push(event);
            });

            // Sort alphabetically
            this.data.eventsList.sort();

            // Save to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                updatedAt: new Date().toISOString()
            });

            // Refresh the datalist
            this.populateEventsDatalist();

            console.log('âœ… Added new custom events:', Array.from(newEvents));
        }
    } catch (error) {
        console.error('Error saving custom events:', error);
    }
},

populateEventsDatalist() {
    console.log('ðŸ” populateEventsDatalist called');

    const eventTypeSelect = document.getElementById('eventType');
    if (!eventTypeSelect) {
        console.warn('âš ï¸ eventType element not found - will populate when orders tab is opened');
        return;
    }

    // Check if eventsList is defined
    if (!this.data.eventsList || !Array.isArray(this.data.eventsList)) {
        console.error('âŒ eventsList not initialized!', {
            exists: !!this.data.eventsList,
            isArray: Array.isArray(this.data.eventsList),
            length: this.data.eventsList?.length
        });
        // Try to initialize with default list
        this.data.eventsList = [
            'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
            'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
            'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
            'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
            'Ganesh Agman', 'Ganesh Visarjan'
        ];
        console.log('âœ… Initialized default events list with', this.data.eventsList.length, 'events');
    }

    console.log(`ðŸ“‹ Populating dropdown with ${this.data.eventsList.length} events`);

    // Get current value to preserve selection
    const currentValue = eventTypeSelect.value;

    // Clear existing options except the first one
    eventTypeSelect.innerHTML = '<option value="">Select Event Type</option>';

    // Add all events as options
    this.data.eventsList.forEach((event, index) => {
        const option = document.createElement('option');
        option.value = event;
        option.textContent = event;
        eventTypeSelect.appendChild(option);
        if (index < 3) {
            console.log(`  âœ“ Added option: ${event}`);
        }
    });

    // Restore previous selection if it exists
    if (currentValue && this.data.eventsList.includes(currentValue)) {
        eventTypeSelect.value = currentValue;
    }

    console.log(`âœ…âœ… Events dropdown fully populated! Total options: ${eventTypeSelect.options.length}`);
    console.log(`   First 5 options:`, Array.from(eventTypeSelect.options).slice(0, 5).map(o => o.value));
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`ðŸ“¦ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} â†’ ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`âš ï¸ LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`ðŸš¨ CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Item Usage History Tracking (for completed orders only)
async recordItemHistory(items, orderData, specificDate = null, functionType = null) {
    if (!items || items.length === 0) return;

    console.log(`ðŸ“œ Recording item history for order ${orderData.orderId}`);

    const usedAt = new Date().toISOString();
    const eventDate = specificDate || orderData.date || orderData.startDate;

    for (const item of items) {
        const historyRecord = {
            itemName: item.name,
            quantity: item.quantity,
            orderId: orderData.orderId,
            clientName: orderData.clientName,
            venue: orderData.venue,
            eventDate: eventDate,
            functionType: functionType || orderData.eventType || '',
            usedAt: usedAt,
            remarks: item.remarks || ''
        };

        // Add to local array
        this.data.itemHistory.push(historyRecord);

        // Save to Firestore
        try {
            await db.collection('itemHistory').add(historyRecord);
            console.log(`âœ… Saved item history: ${item.name} x${item.quantity} for order ${orderData.orderId}`);
        } catch (error) {
            console.error('âŒ Error saving item history to Firestore:', error);
        }
    }

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`ðŸ“ Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
async getCurrentUser() {
    // If already loaded, return cached user
    if (this.data.currentUser && this.data.currentUser.roleLoaded) {
        return this.data.currentUser;
    }

    // Get Firebase Auth user
    const authUser = auth.currentUser;
    if (!authUser) {
        console.warn('âš ï¸ No authenticated user found');
        return null;
    }

    try {
        // Fetch user role from Firestore
        const userRoleDoc = await db.collection('user_roles').doc(authUser.uid).get();

        let role = 'staff'; // Default role
        let email = authUser.email;
        let name = authUser.displayName || authUser.email;

        if (userRoleDoc.exists) {
            const roleData = userRoleDoc.data();
            role = roleData.role || 'staff';
            name = roleData.name || name;
            console.log('âœ… User role loaded from Firestore:', role, 'for', email);
        } else {
            // If no role exists, user defaults to 'staff' with limited access
            // Only admin/owner can create roles in Firestore via admin panel
            console.warn('âš ï¸ No role document found for:', email);
            console.warn('âš ï¸ User defaulted to "staff" role with limited access.');
            console.warn('âš ï¸ Admin must create role in Firestore: user_roles/' + authUser.uid);
        }

        this.data.currentUser = {
            id: authUser.uid,
            email: email,
            name: name,
            role: role,
            roleLoaded: true,
            permissions: this.getRolePermissions(role)
        };

        return this.data.currentUser;
    } catch (error) {
        console.error('âŒ Error loading user role:', error);
        console.error('Full error:', error);
        // Fallback to staff role if error occurs
        this.data.currentUser = {
            id: authUser.uid,
            email: authUser.email,
            name: authUser.displayName || authUser.email,
            role: 'staff',
            roleLoaded: true,
            permissions: this.getRolePermissions('staff')
        };
        return this.data.currentUser;
    }
},

// Force refresh user role from Firestore (bypasses cache)
async refreshUserRole() {
    console.log('ðŸ”„ Force refreshing user role from Firestore...');
    this.data.currentUser = null; // Clear cache
    const user = await this.getCurrentUser();
    console.log('âœ… User role refreshed:', user?.role);
    return user;
},

// Get permissions for a role
getRolePermissions(role) {
    const permissions = {
        admin: ['all'],
        owner: ['all'],
        staff: ['orders.view', 'orders.create', 'inventory.view', 'customers.view', 'team.view']
    };
    return permissions[role] || permissions.staff;
},

// Check if current user has permission
async hasPermission(permission) {
    const user = await this.getCurrentUser();
    if (!user) return false;

    // Admin and owner have all permissions
    if (user.role === 'admin' || user.role === 'owner') {
        return true;
    }

    // Check specific permission
    return user.permissions.includes(permission) || user.permissions.includes('all');
},

// Check if user can view financials
async canViewFinancials() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

// Check if user is admin or owner
async isAdminOrOwner() {
    const user = await this.getCurrentUser();
    if (!user) return false;
    return user.role === 'admin' || user.role === 'owner';
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Clear the form first to prevent data mixing between orders
        const wasCleared = !this.hasUnsavedChanges();
        if (!wasCleared) {
            // Clear without confirmation since we're loading a different order
            document.getElementById('orderForm').reset();
            this.currentOrderItems = [];
            this.updateOrderItemsTable();
            window.dayFunctionsData = {};

            // Clear multiday containers
            const multiDayContainer = document.getElementById('multiDayContainer');
            if (multiDayContainer) multiDayContainer.innerHTML = '';
            const functionsContainer = document.getElementById('functionsContainer');
            if (functionsContainer) functionsContainer.innerHTML = '';
        }

        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('ðŸ” Loading order to form:', order);
        console.log('ðŸ” Order status:', order.status);
        console.log('ðŸ” Is Multi-Day:', order.isMultiDay);

        // Show merged order indicator if this is a merged order
        if (order.mergedFrom && order.mergedFrom.length > 0) {
            const mergedOrderIds = order.mergedFrom.map(m => m.orderId).join(', ');
            this.showToast(`ðŸ”— MERGED ORDER: This order was created by merging ${order.mergedFrom.length} orders (${mergedOrderIds})`, 'info', 8000);
            console.log('ðŸ”— This is a MERGED order from:', order.mergedFrom);
        }

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('ðŸ“… Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const venueInput = document.getElementById(`${functionId}Venue`);
                                        const transportSelect = document.getElementById(`${functionId}Transport`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (venueInput) venueInput.value = func.venue || '';

                                        // Handle multi-select fields (transport, driver, helper)
                                        if (transportSelect && func.transport) {
                                            const transports = func.transport.split(',').map(t => t.trim());
                                            Array.from(transportSelect.options).forEach(option => {
                                                option.selected = transports.includes(option.value);
                                            });
                                        }

                                        if (driverSelect && func.driver) {
                                            const drivers = func.driver.split(',').map(d => d.trim());
                                            Array.from(driverSelect.options).forEach(option => {
                                                option.selected = drivers.includes(option.value);
                                            });
                                        }

                                        if (operatorSelect) operatorSelect.value = func.operator || '';

                                        if (helperSelect && func.helper) {
                                            helperSelect.value = func.helper;
                                        }

                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'venue', func.venue || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'transport', func.transport || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            // IMPORTANT: Normalize item fields for consistency
                                            window.dayFunctionsData[dayIndex][funcIndex].items = func.items.map(item => ({
                                                name: item.name || '',
                                                quantity: item.quantity || item.qty || 0,
                                                remarks: item.remarks || item.desc || '',
                                                price: item.price || 0
                                            }));
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('âœ… Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order
            // IMPORTANT: Set event type to single day first to ensure proper form display
            Utils.set('eventTypeSelect', 'single');

            // Show single day fields, hide multiday fields
            const singleDayFields = document.getElementById('singleDayFields');
            const multiDayFields = document.getElementById('multiDayFields');
            if (singleDayFields) singleDayFields.style.display = 'grid';
            if (multiDayFields) multiDayFields.style.display = 'none';

            // Trigger event type change to update required fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                venueMapLink: order.venueMapLink || '',
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                transport2: order.transport2 && ['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : (order.transport2 ? 'Other' : ''),
                customTransport2: order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2) ? order.transport2 : '',
                driverName2: order.driverName2 || '',
                operator: order.operator,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Restore venue location data if available
            if (order.venueLocation) {
                window.selectedPlaceData = {
                    name: order.venue || '',
                    lat: order.venueLocation.lat,
                    lng: order.venueLocation.lng,
                    formatted_address: order.venueLocation.formatted_address || '',
                    place_id: order.venueLocation.place_id || '',
                    url: order.venueLocation.url || '',
                    source: order.venueLocation.source || 'restored'
                };
            }

            // Load helper names to text input
            if (order.helper) {
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.value = order.helper;
                }
            }

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            if (order.transport2 && !['Bolero', 'Isuzu', 'Porter'].includes(order.transport2)) {
                document.getElementById('customTransport2Group').classList.remove('hidden');
            }

            // IMPORTANT: Normalize item fields to ensure consistency
            // Items from Firestore might use 'qty' but UI expects 'quantity'
            this.currentOrderItems = order.items ? order.items.map(item => ({
                name: item.name || '',
                quantity: item.quantity || item.qty || 0, // Support both field names
                remarks: item.remarks || item.desc || '', // Support both field names
                price: item.price || 0
            })) : [];

            console.log(`ðŸ“‹ Loaded ${this.currentOrderItems.length} items for order`, {
                orderId: order.orderId,
                sampleItem: this.currentOrderItems[0],
                isMerged: !!order.mergedFrom
            });

            this.updateOrderItemsTable();

            // Show original orders cards if this is a merged order
            this.renderOriginalOrdersCards(order);
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            // Render editable cards for original orders in a merged order
            renderOriginalOrdersCards(order) {
                const container = document.getElementById('originalOrdersContainer');

                // If container doesn't exist yet, create it
                if (!container) {
                    const orderForm = document.getElementById('orderForm');
                    if (orderForm) {
                        const newContainer = document.createElement('div');
                        newContainer.id = 'originalOrdersContainer';
                        newContainer.style.marginTop = '2rem';
                        orderForm.parentNode.insertBefore(newContainer, orderForm.nextSibling);
                    }
                }

                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (!originalOrdersContainer) return;

                // Check if this is a merged order
                if (!order.mergedFrom || order.mergedFrom.length === 0) {
                    originalOrdersContainer.innerHTML = '';
                    return;
                }

                console.log('ðŸ”— Rendering original orders cards for merged order:', order.orderId);

                // Generate HTML for original orders cards
                const cardsHTML = `
                    <div class="card" style="margin-top: 2rem; background: #f9f9f9; border: 2px solid #667eea;">
                        <div class="card-header" style="background: #667eea; color: white; padding: 1rem;">
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                                ðŸ”— ORIGINAL ORDERS (${order.mergedFrom.length})
                            </h3>
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; opacity: 0.9;">
                                You can edit each original order's details below and save changes individually
                            </p>
                        </div>
                        <div style="padding: 1.5rem;">
                            ${order.mergedFrom.map((originalOrder, index) => this.renderOriginalOrderCard(originalOrder, index)).join('')}
                        </div>
                    </div>
                `;

                originalOrdersContainer.innerHTML = cardsHTML;
            },

            renderOriginalOrderCard(originalOrderData, index) {
                const order = originalOrderData.orderData;
                const cardId = `originalOrder_${index}`;

                // Get items list
                const itemsList = order.items && order.items.length > 0
                    ? order.items.map(item => `${item.name} x${item.quantity || item.qty || 0}`).join(', ')
                    : 'No items';

                return `
                    <div class="card" style="margin-bottom: 1.5rem; background: white; border: 1px solid #ddd;" id="${cardId}">
                        <div style="background: #f5f5f5; padding: 1rem; border-bottom: 2px solid #ddd;">
                            <h4 style="margin: 0; color: #667eea; display: flex; justify-content: space-between; align-items: center;">
                                ðŸ“‹ Order: ${order.orderId}
                                <button type="button" class="btn btn-small"
                                        style="background: #667eea; color: white;"
                                        onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                    âœï¸ Edit
                                </button>
                            </h4>
                        </div>

                        <!-- View Mode -->
                        <div id="${cardId}_view" style="padding: 1.5rem;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>ðŸ“… Date:</strong> ${order.date || 'N/A'}</div>
                                <div><strong>â° Ready Time:</strong> ${order.readyTime || 'N/A'}</div>
                                <div><strong>ðŸ‘¤ Client:</strong> ${order.clientName || 'N/A'}</div>
                                <div><strong>ðŸ“ž Contact:</strong> ${order.contact || 'N/A'}</div>
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <strong>ðŸ“ Venue:</strong> ${order.venue || 'N/A'}
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                <div><strong>ðŸš— Transport:</strong> ${order.transport || 'N/A'}</div>
                                <div><strong>ðŸš˜ Driver:</strong> ${order.driverName || 'N/A'}</div>
                                <div><strong>ðŸŽ¬ Operator:</strong> ${order.operator || 'N/A'}</div>
                                <div><strong>ðŸ‘· Helper:</strong> ${order.helper || 'N/A'}</div>
                            </div>
                            <div style="padding: 1rem; background: #f9f9f9; border-radius: 4px;">
                                <strong>ðŸ“¦ Items:</strong> ${itemsList}
                            </div>
                            ${order.notes ? `<div style="margin-top: 1rem;"><strong>ðŸ“ Notes:</strong><br>${order.notes}</div>` : ''}
                        </div>

                        <!-- Edit Mode (Hidden by default) -->
                        <div id="${cardId}_edit" style="display: none; padding: 1.5rem; background: #fefefe;">
                            <form onsubmit="OMS.saveOriginalOrder(event, ${index}, '${order.docId}')">
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ðŸ“… Date</label>
                                        <input type="date" class="form-input" id="${cardId}_date" value="${order.date || ''}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">â° Ready Time</label>
                                        <input type="text" class="form-input" id="${cardId}_readyTime" value="${order.readyTime || ''}" placeholder="e.g., 10:00 AM">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">ðŸ“ Venue</label>
                                    <input type="text" class="form-input" id="${cardId}_venue" value="${order.venue || ''}" required>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ðŸš— Transport</label>
                                        <input type="text" class="form-input" id="${cardId}_transport" value="${order.transport || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">ðŸš˜ Driver</label>
                                        <input type="text" class="form-input" id="${cardId}_driverName" value="${order.driverName || ''}">
                                    </div>
                                </div>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
                                    <div class="form-group">
                                        <label class="form-label">ðŸŽ¬ Operator</label>
                                        <input type="text" class="form-input" id="${cardId}_operator" value="${order.operator || ''}">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">ðŸ‘· Helper</label>
                                        <input type="text" class="form-input" id="${cardId}_helper" value="${order.helper || ''}">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1rem;">
                                    <label class="form-label">ðŸ“ Notes</label>
                                    <textarea class="form-textarea" id="${cardId}_notes" rows="3">${order.notes || ''}</textarea>
                                </div>

                                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                                    <button type="button" class="btn btn-secondary" onclick="OMS.toggleOriginalOrderEdit('${cardId}')">
                                        Cancel
                                    </button>
                                    <button type="submit" class="btn btn-success">
                                        ðŸ’¾ Save Changes
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;
            },

            toggleOriginalOrderEdit(cardId) {
                const viewMode = document.getElementById(`${cardId}_view`);
                const editMode = document.getElementById(`${cardId}_edit`);

                if (viewMode && editMode) {
                    const isEditing = editMode.style.display !== 'none';
                    viewMode.style.display = isEditing ? 'block' : 'none';
                    editMode.style.display = isEditing ? 'none' : 'block';
                }
            },

            async saveOriginalOrder(event, index, docId) {
                event.preventDefault();
                const cardId = `originalOrder_${index}`;

                try {
                    // Collect form data
                    const updatedData = {
                        date: Utils.get(`${cardId}_date`),
                        readyTime: Utils.get(`${cardId}_readyTime`),
                        venue: Utils.get(`${cardId}_venue`),
                        transport: Utils.get(`${cardId}_transport`),
                        driverName: Utils.get(`${cardId}_driverName`),
                        operator: Utils.get(`${cardId}_operator`),
                        helper: Utils.get(`${cardId}_helper`),
                        notes: Utils.get(`${cardId}_notes`)
                    };

                    console.log('ðŸ’¾ Saving original order changes:', docId, updatedData);

                    // Get the full order from Firestore
                    const orderDoc = await db.collection('orders').doc(docId).get();
                    if (!orderDoc.exists) {
                        throw new Error('Order not found in Firestore');
                    }

                    const fullOrder = orderDoc.data();

                    // Update with new data
                    const updatedOrder = {
                        ...fullOrder,
                        ...updatedData,
                        updatedAt: new Date().toISOString()
                    };

                    // Save to Firestore
                    await db.collection('orders').doc(docId).update(updatedOrder);

                    this.showToast(`âœ… Order updated successfully!`, 'success');

                    // Toggle back to view mode
                    this.toggleOriginalOrderEdit(cardId);

                    // Reload orders to refresh display
                    await this.loadOrdersFromFirestore();

                    // Reload the current merged order
                    const currentOrder = this.data.orders.find(o => o.docId === this.editingDocId);
                    if (currentOrder) {
                        this.loadOrderToForm(currentOrder);
                    }

                } catch (error) {
                    console.error('âŒ Error saving original order:', error);
                    this.showToast(`Error: ${error.message}`, 'error');
                }
            },

            clearForm(skipConfirmation = false) {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (!skipConfirmation && this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();

                // Clear original orders cards
                const originalOrdersContainer = document.getElementById('originalOrdersContainer');
                if (originalOrdersContainer) {
                    originalOrdersContainer.innerHTML = '';
                }
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');
                document.getElementById('customTransport2Group').classList.add('hidden');

                // Clear venue location data from autocomplete
                window.selectedPlaceData = null;

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'grid';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Trigger event type change to update required fields
                const eventTypeSelect = document.getElementById('eventTypeSelect');
                if (eventTypeSelect) {
                    const event = new Event('change');
                    eventTypeSelect.dispatchEvent(event);
                }

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                // Clear functions container for multiday events
                const functionsContainer = document.getElementById('functionsContainer');
                if (functionsContainer) {
                    functionsContainer.innerHTML = '';
                }

                // Hide day-wise functions section
                const dayWiseFunctions = document.getElementById('dayWiseFunctions');
                if (dayWiseFunctions) {
                    dayWiseFunctions.style.display = 'none';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`âœ… Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                this.loadOrderToForm(lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                // Preview doesn't require validation - just show what's been filled
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong>Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong>Driver 2:</strong> ${order.driverName2}<br>` : ''}
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }

                // ============ START ENHANCED FILTERING WITH LOGGING & VALIDATION ============
                const startTime = performance.now();

                // Normalize the target date using fuzzy matcher
                const normalizedDate = fuzzyDateMatcher.normalize(date);
                filterLogger.log('filter_started', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                // IMPROVED FILTER: Include ALL order types for selected date with fuzzy matching
                const matchedOrders = [];
                const filterDetails = {
                    singleDayMatches: 0,
                    multiDayRangeMatches: 0,
                    dayWiseDataMatches: 0,
                    fuzzyMatches: 0,
                    skipped: 0
                };

                let orders = this.data.orders.filter(o => {
                    // Case 1: Single-day order with matching date (use fuzzy matcher)
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            filterDetails.singleDayMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    // Case 2: Multi-day order WITH dayWiseData - check specific day functions (PRIORITY)
                    if (o.isMultiDay && o.dayWiseData && Array.isArray(o.dayWiseData) && o.dayWiseData.length > 0) {
                        const hasMatch = o.dayWiseData.some(day => fuzzyDateMatcher.matches(day.date, date));
                        if (hasMatch) {
                            filterDetails.dayWiseDataMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                        // If order has dayWiseData but no match, skip it (don't fall through to range check)
                        filterDetails.skipped++;
                        return false;
                    }

                    // Case 3: Multi-day order WITHOUT dayWiseData - fallback to range check
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            filterDetails.multiDayRangeMatches++;
                            matchedOrders.push(o);
                            return true;
                        }
                    }

                    filterDetails.skipped++;
                    return false;
                });

                // Calculate performance metrics
                const endTime = performance.now();
                const filterTime = (endTime - startTime).toFixed(2);

                // Log detailed filter results
                filterLogger.log('filter_completed', {
                    operation: 'downloadSameDayOrders',
                    filterDate: date,
                    normalizedDate,
                    matchedCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    filterTimeMs: filterTime,
                    breakdown: filterDetails,
                    matchedOrderIds: orders.map(o => o.orderId || o.docId)
                });

                // Record pattern for learning
                patternLearner.recordFilterResult(
                    normalizedDate,
                    orders.length,
                    this.data.orders.length,
                    'downloadSameDayOrders'
                );

                // APPLY LEARNING RULES FROM PREVIOUS USER FEEDBACK (if enabled)
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false'; // Default: enabled for backward compatibility
                let finalOrders = orders;
                let hasCorrections = false;

                if (mlEnabled) {
                    const learningResult = filterRatingSystem.applyLearningRules(
                        normalizedDate,
                        orders,
                        this.data.orders
                    );

                    finalOrders = learningResult.orders;
                    hasCorrections = learningResult.corrections.length > 0;

                    if (hasCorrections) {
                        console.log(`ðŸ§  Smart Learning Applied: ${learningResult.corrections.length} corrections made based on your previous feedback`);
                        learningResult.corrections.forEach(correction => {
                            if (correction.type === 'added') {
                                console.log(`  âœ… Added: ${correction.order.orderId} - ${correction.reason}`);
                            } else if (correction.type === 'removed') {
                                console.log(`  âŒ Removed: ${correction.order.orderId} - ${correction.reason}`);
                            }
                        });
                        this.showToast(`ðŸ§  Smart filter applied ${learningResult.corrections.length} learned corrections`, 'info');
                    }
                } else {
                    console.log('ðŸ”‡ ML Corrections DISABLED - Using original filter results only');
                    console.log('ðŸ’¡ To enable: AdminUtils.enableML() or localStorage.setItem("oms_ml_enabled", "true")');
                }

                // STORE FILTER CONTEXT FOR RATING
                filterRatingSystem.setFilterContext({
                    date,
                    normalizedDate,
                    matchedOrders: finalOrders,
                    totalOrders: this.data.orders.length,
                    filterDetails,
                    allOrders: this.data.orders
                });

                // Validate results and show alerts
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: finalOrders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders: finalOrders,
                    allOrders: this.data.orders
                });
                orderValidator.showAlerts(validationResult, date);

                // Show enhanced console summary
                console.group(`ðŸ“Š Filter Summary for ${date}`);
                console.log(`âœ… Matched: ${finalOrders.length} orders in ${filterTime}ms`);
                if (hasCorrections) {
                    console.log(`ðŸ§  Corrections: ${learningResult.corrections.length} (from your previous ratings)`);
                }
                console.log(`ðŸ“‹ Breakdown:`, filterDetails);
                console.log(`ðŸŽ¯ Match rate: ${((finalOrders.length / this.data.orders.length) * 100).toFixed(1)}%`);

                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`ðŸ§  Expected based on learning: ~${expectedCount} orders`);
                }

                if (validationResult.length > 0) {
                    console.log(`âš ï¸ Validation alerts: ${validationResult.length}`);
                }

                // Show rating option in console
                console.log(`â­ To rate this filter result, use: AdminUtils.rateLastFilter()`);
                console.groupEnd();
                // ============ END ENHANCED FILTERING ============

                if (finalOrders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    // Still show rating UI for zero results (user can report this as wrong)
                    setTimeout(() => {
                        if (confirm('No orders found. Would you like to rate this filter result?')) {
                            filterRatingSystem.showRatingUI(this);
                        }
                    }, 500);
                    return;
                }

                // Replace orders with finalOrders for rest of the function
                orders = finalOrders;

                // FILTER MULTIDAY ORDERS TO ONLY INCLUDE SELECTED DATE'S DATA
                const filteredOrders = orders.map(order => {
                    // For single-day orders, return as is
                    if (!order.isMultiDay) {
                        return order;
                    }

                    // For multiday orders, create a filtered copy with only the selected date's data
                    const filteredOrder = { ...order };

                    // Filter dayWiseData to only include the selected date (use fuzzy matcher for better matching)
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        filteredOrder.dayWiseData = order.dayWiseData.filter(day => fuzzyDateMatcher.matches(day.date, date));
                        console.log(`ðŸ” Multiday order ${order.orderId}: Filtered ${filteredOrder.dayWiseData.length}/${order.dayWiseData.length} days for date ${date}`);

                        // Log function and item counts for debugging
                        filteredOrder.dayWiseData.forEach((day, idx) => {
                            const funcCount = day.functions ? day.functions.length : 0;
                            const itemCount = day.functions ? day.functions.reduce((sum, f) => sum + (f.items?.length || 0), 0) : 0;
                            console.log(`  ðŸ“‹ Day ${day.dayNumber}: ${funcCount} functions, ${itemCount} total items`);
                        });
                    }

                    // Update the order to show only selected date info
                    filteredOrder.date = date;
                    filteredOrder.isMultiDay = false; // Treat as single day for display purposes

                    return filteredOrder;
                });

                console.log(`ðŸ“… Found ${filteredOrders.length} orders for ${date}:`, filteredOrders.map(o => o.orderId || o.clientName));
                console.log(`ðŸ’¡ To rate this filter result, use: AdminUtils.rateLastFilter() in console`);

                this.generateMultiOrderImage(filteredOrders, date);
            },

            downloadOrderImage(orderId) {
                // Search by docId first (always unique), then orderId as fallback
                const order = this.data.orders.find(o => o.docId === orderId || o.orderId === orderId);
                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }
                this.generateSingleOrderImage(order);
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? 'Generating image (mobile mode)...' : 'Generating image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Mobile optimization: Validate canvas dimensions before proceeding
                    const baseScale = this.data.settings.imageQuality || 2;
                    const optimizedScale = Utils.getOptimalCanvasScale(baseScale);

                    const canvasWidth = Math.round(paperDimensions.width * optimizedScale);
                    const canvasHeight = Math.round(paperDimensions.height * optimizedScale);

                    const validation = Utils.validateCanvasDimensions(canvasWidth, canvasHeight);
                    if (!validation.valid) {
                        this.hideLoading(loading);
                        this.showToast(`âš ï¸ ${validation.reason}. Please reduce image quality in settings.`, 'error');
                        console.error('Canvas validation failed:', validation.reason);
                        return;
                    }

                    if (isMobile && optimizedScale < baseScale) {
                        console.log(`ðŸ“± Mobile device detected (${deviceType}): Quality auto-reduced from ${baseScale} to ${optimizedScale} for better compatibility`);
                    }

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    template.innerHTML = this.buildOrderHTML(order, fontSize, colors, false, bgColor, textColor);
                    template.style.display = 'block';

                    // Increased wait time for mobile devices (they need more time for DOM to settle)
                    await new Promise(r => setTimeout(r, isMobile ? 500 : 300));

                    // Create canvas with optimized scale
                    let canvas;
                    try {
                        canvas = await html2canvas(template, {
                            scale: optimizedScale,
                            backgroundColor: bgColor,
                            width: paperDimensions.width,
                            logging: false,
                            useCORS: true,
                            allowTaint: false,
                            // Mobile-specific optimizations
                            removeContainer: true,
                            imageTimeout: isMobile ? 30000 : 15000
                        });
                    } catch (canvasError) {
                        console.error('html2canvas failed:', canvasError);

                        // Retry with even lower quality for mobile
                        if (isMobile && optimizedScale > 1) {
                            console.log('âš ï¸ Retrying with scale 1 for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Retrying with lower quality...');

                            canvas = await html2canvas(template, {
                                scale: 1,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: 30000
                            });
                        } else {
                            throw canvasError;
                        }
                    }

                    template.style.display = 'none';

                    // Use Promise-based blob creation with better error handling
                    this.updateLoadingMessage(loading, 'Creating download file...');

                    let blob;
                    try {
                        blob = await Utils.canvasToBlobPromise(canvas, 'image/png', 0.95);
                    } catch (blobError) {
                        console.error('PNG blob creation failed:', blobError);

                        // Fallback to JPEG with lower quality for mobile
                        if (isMobile) {
                            console.log('âš ï¸ Retrying with JPEG format for mobile compatibility...');
                            this.updateLoadingMessage(loading, 'Trying alternative format...');
                            blob = await Utils.canvasToBlobPromise(canvas, 'image/jpeg', 0.85);
                        } else {
                            throw blobError;
                        }
                    }

                    // Check blob size
                    const blobSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    console.log(`ðŸ“Š Image size: ${blobSizeMB} MB`);

                    if (blob.size > 50 * 1024 * 1024 && isMobile) {
                        this.hideLoading(loading);
                        this.showToast('âš ï¸ Image too large for mobile device. Please reduce quality in settings.', 'error');
                        return;
                    }

                    // Create download
                    try {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        const fileExt = blob.type.includes('jpeg') ? 'jpg' : 'png';
                        link.download = `Order_${order.orderId}.${fileExt}`;

                        // Mobile-specific download handling
                        if (isMobile) {
                            // For mobile, add a small delay and use different approach
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        } else {
                            link.click();
                        }

                        // Delay cleanup for mobile browsers
                        setTimeout(() => URL.revokeObjectURL(url), isMobile ? 1000 : 100);

                        this.hideLoading(loading);
                        this.showToast(`âœ… Image downloaded! (${blobSizeMB} MB)`);
                    } catch (downloadError) {
                        console.error('Download failed:', downloadError);
                        this.hideLoading(loading);
                        this.showToast('âŒ Download failed: ' + downloadError.message, 'error');
                    }
                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Image generation error:', error);

                    // Mobile-friendly error message
                    if (isMobile) {
                        this.showToast(`âŒ Failed on ${deviceType}: ${error.message}. Try reducing image quality in settings.`, 'error');
                    } else {
                        this.showToast('âŒ Error: ' + error.message, 'error');
                    }
                }
            },

            async generateMultiOrderImage(orders, date) {
                console.log(`\nðŸŽ¯ ========== GENERATE MULTI ORDER IMAGE CALLED ==========`);
                console.log(`ðŸ“… Date: ${date}`);
                console.log(`ðŸ“¦ Number of orders: ${orders.length}`);
                console.log(`ðŸ“‹ Orders:`, orders.map(o => ({
                    orderId: o.orderId,
                    clientName: o.clientName,
                    isMultiDay: o.isMultiDay,
                    hasDayWiseData: !!(o.dayWiseData && o.dayWiseData.length > 0),
                    dayWiseDataCount: o.dayWiseData ? o.dayWiseData.length : 0,
                    hasItems: !!(o.items && o.items.length > 0),
                    itemsCount: o.items ? o.items.length : 0
                })));
                console.log(`========================================\n`);

                const isMobile = Utils.isMobileDevice();
                const deviceType = Utils.getDeviceType();
                const loading = this.showLoading(isMobile ? `Generating PDF (mobile mode, ${orders.length} orders)...` : 'Generating multi-page PDF...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 26;
                    const bgColor = this.data.settings.printBgColor || '#ffffff';
                    const textColor = this.data.settings.printTextColor || '#000000';

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    // Smart quality adjustment for multi-order images to prevent memory issues
                    let baseQualityScale = this.data.settings.imageQuality || 2;

                    // Apply mobile optimizations first
                    let qualityScale = Utils.getOptimalCanvasScale(baseQualityScale);

                    // Further reduce quality based on number of orders
                    if (orders.length > 5) {
                        qualityScale = Math.min(qualityScale, 2); // Limit to scale 2 for more than 5 orders
                        console.log('âš ï¸ Quality reduced to scale 2 due to multiple orders to prevent memory issues');
                    }
                    if (orders.length > 10) {
                        qualityScale = Math.min(qualityScale, 1.5); // Further reduce for very large sets
                        console.log('âš ï¸ Quality further reduced to scale 1.5 for large order set');
                    }

                    // Extra reduction for mobile with many orders
                    if (isMobile) {
                        if (orders.length > 3) {
                            qualityScale = Math.min(qualityScale, 1);
                            console.log(`ðŸ“± Mobile with ${orders.length} orders: Quality capped at scale 1`);
                        }
                        if (orders.length > 10) {
                            this.hideLoading(loading);
                            this.showToast(`âš ï¸ ${orders.length} orders may be too many for mobile device. Consider downloading fewer orders at once.`, 'error');
                            return;
                        }
                    }

                    if (isMobile && qualityScale < baseQualityScale) {
                        console.log(`ðŸ“± ${deviceType}: Quality auto-adjusted from ${baseQualityScale} to ${qualityScale}`);
                    }

                    // Use fontSize from settings, but slightly smaller for compact multi-order view
                    const compactFontSize = Math.max(16, fontSize - 6);

                    console.log(`ðŸš€ Starting PDF generation for ${orders.length} orders`);

                    // Calculate grand totals for all orders (needed early for page height calculations)
                    let grandTotalDryIce = 0;
                    let grandTotalFlowers = 0;
                    let grandTotalElectricity = 0;
                    let grandTotalDryMachines = 0;
                    let grandTotalFlowerMachines = 0;

                    orders.forEach(order => {
                        const requirements = this.calculateOrderRequirements(order);
                        console.log(`  â†’ Order ${order.orderId} requirements:`, requirements);
                        grandTotalDryIce += requirements.dryIceNeeded;
                        grandTotalFlowers += requirements.flowersNeeded;
                        grandTotalElectricity += requirements.totalElectricityKV;
                        grandTotalDryMachines += requirements.dryMachines;
                        grandTotalFlowerMachines += requirements.flowerShowerMachines;
                    });

                    console.log(`\nðŸ“Š Grand Totals Calculated: DryIce=${grandTotalDryIce}kg, Flowers=${grandTotalFlowers}kg, Electricity=${grandTotalElectricity}KV, DryMachines=${grandTotalDryMachines}, FlowerMachines=${grandTotalFlowerMachines}\n`);

                    // NEW ALGORITHM: Dynamic page building with actual measurements
                    // This ensures ALL orders are included and pages are packed optimally

                    // CRITICAL: Use 'static' positioning for accurate measurements
                    // Using 'absolute' causes grid/flexbox layouts to collapse and gives wrong scrollHeight
                    template.style.height = 'auto';
                    template.style.minHeight = '0';
                    template.style.maxHeight = 'none';
                    template.style.overflow = 'visible';
                    template.style.display = 'block';
                    template.style.visibility = 'hidden'; // Hidden but still in document flow
                    template.style.position = 'static'; // Keep in document flow for accurate measurement
                    template.style.opacity = '0'; // Extra insurance it's not visible

                    const headerHeight = 75; // Header height for date (reduced for better space utilization)
                    const separatorHeight = 15; // Space between orders (reduced for better space utilization)
                    const bottomMargin = 10; // Bottom margin for page (optimized for space utilization)
                    const safetyMargin = 15; // Safety buffer for rendering differences (optimized for maximum space usage)

                    // Measure the actual grand total summary height instead of estimating
                    const hasGrandTotalSummary = (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0);
                    let grandTotalSummaryHeight = 0;

                    if (hasGrandTotalSummary) {
                        // Render the actual summary to measure its real height
                        const summaryHtml = `
                            <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">ðŸ“Š Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                    ${grandTotalDryIce > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">â„ï¸</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalFlowers > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">ðŸŒ¸</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                    </div>
                                    ` : ''}
                                    ${grandTotalElectricity > 0 ? `
                                    <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                            <div style="font-size: 40px;">âš¡</div>
                                            <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                        </div>
                                        <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;

                        // Temporarily render to measure (use static positioning for accurate height)
                        template.innerHTML = summaryHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Increased wait for layout calculation
                        grandTotalSummaryHeight = template.scrollHeight;
                        console.log(`ðŸ“Š Measured grand total summary height: ${grandTotalSummaryHeight}px`);
                        template.style.display = 'none';
                        template.style.opacity = '1';
                    }

                    const maxContentHeightFirstPage = paperDimensions.height - headerHeight - bottomMargin - safetyMargin - grandTotalSummaryHeight;
                    const maxContentHeightOtherPages = paperDimensions.height - headerHeight - bottomMargin - safetyMargin;

                    console.log(`ðŸ“ Page constraints: Paper=${paperDimensions.height}px, Header=${headerHeight}px, Margins=${bottomMargin + safetyMargin}px, GrandTotal=${grandTotalSummaryHeight}px`);
                    console.log(`ðŸ“Š Max content: First page=${maxContentHeightFirstPage}px, Other pages=${maxContentHeightOtherPages}px`);

                    const pages = [];
                    let processedOrders = new Set(); // Track which orders we've added

                    // Helper function to check if a single order fits on a page
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const checkSingleOrderFits = async (order, maxHeight) => {
                        const testHtml = this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                        template.innerHTML = testHtml;
                        // Ensure template is visible for measurement (but hidden from user)
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100)); // Wait for layout
                        const height = template.scrollHeight;
                        return { fits: height <= maxHeight, height: height };
                    };

                    // Helper function to measure multiple orders together
                    // NOTE: We DON'T include the header here because maxHeight already accounts for it
                    const measureOrdersHeight = async (ordersList) => {
                        let testHtml = '';
                        ordersList.forEach((o, idx) => {
                            testHtml += this.buildOrderHTML(o, compactFontSize, colors, true, bgColor, textColor);
                            if (idx < ordersList.length - 1) {
                                testHtml += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });
                        template.innerHTML = testHtml;
                        template.style.display = 'block';
                        template.style.visibility = 'hidden';
                        template.style.position = 'static';
                        template.style.opacity = '0';
                        await new Promise(r => setTimeout(r, 100));
                        return template.scrollHeight;
                    };

                    // STEP 1: Measure all orders individually first
                    console.log('ðŸ“ Measuring all orders for optimal packing...');
                    const orderHeights = [];
                    for (let i = 0; i < orders.length; i++) {
                        const check = await checkSingleOrderFits(orders[i], maxContentHeightOtherPages);
                        orderHeights.push({
                            order: orders[i],
                            height: check.height,
                            originalIndex: i
                        });
                    }

                    // STEP 2: Sort orders by height (descending) - First Fit Decreasing algorithm
                    orderHeights.sort((a, b) => b.height - a.height);
                    console.log('ðŸ“Š Order heights (sorted descending):', orderHeights.map(oh => `${oh.order.clientName || oh.order.orderId}: ${oh.height}px`).join(', '));

                    // STEP 3: Use First Fit Decreasing bin-packing algorithm
                    for (let i = 0; i < orderHeights.length; i++) {
                        const { order, height, originalIndex } = orderHeights[i];

                        // Check if this single order is too large for any page by itself
                        const fitsOnFirstPage = height <= maxContentHeightFirstPage;
                        const fitsOnOtherPage = height <= maxContentHeightOtherPages;

                        // If order doesn't fit on any page by itself, handle special case
                        if (!fitsOnOtherPage) {
                            // Check if this is a multifunction/multiday order that can be split
                            if (order.dayWiseData && order.dayWiseData.length > 0) {
                                // Try to split by function groups
                                let remainingFunctions = [];
                                order.dayWiseData.forEach(day => {
                                    if (day.functions && day.functions.length > 0) {
                                        day.functions.forEach((func, funcIdx) => {
                                            remainingFunctions.push({
                                                dayNumber: day.dayNumber,
                                                date: day.date,
                                                function: func,
                                                functionIndex: funcIdx
                                            });
                                        });
                                    }
                                });

                                // Split functions across multiple pages
                                while (remainingFunctions.length > 0) {
                                    let currentFunctionSet = [];

                                    for (let f = 0; f < remainingFunctions.length; f++) {
                                        const testFunctions = [...currentFunctionSet, remainingFunctions[f]];

                                        // Create a partial order with only these functions
                                        const partialOrder = {
                                            ...order,
                                            dayWiseData: testFunctions.map(tf => ({
                                                dayNumber: tf.dayNumber,
                                                date: tf.date,
                                                functions: [tf.function]
                                            }))
                                        };

                                        // Test if it fits
                                        const partialCheck = await checkSingleOrderFits(partialOrder, maxContentHeightOtherPages);

                                        if (partialCheck.fits) {
                                            currentFunctionSet.push(remainingFunctions[f]);
                                        } else {
                                            // Can't add more functions, save current set
                                            break;
                                        }
                                    }

                                    // If we couldn't fit even one function, we need to add it anyway
                                    if (currentFunctionSet.length === 0 && remainingFunctions.length > 0) {
                                        currentFunctionSet.push(remainingFunctions[0]);
                                    }

                                    // Create page with current function set
                                    const pageOrder = {
                                        ...order,
                                        orderId: `${order.orderId} (Part ${pages.length + 1})`,
                                        dayWiseData: currentFunctionSet.map(tf => ({
                                            dayNumber: tf.dayNumber,
                                            date: tf.date,
                                            functions: [tf.function]
                                        }))
                                    };

                                    pages.push([pageOrder]);

                                    // Remove processed functions
                                    remainingFunctions = remainingFunctions.slice(currentFunctionSet.length);
                                }

                                processedOrders.add(originalIndex);
                                continue;
                            } else {
                                // Not a multifunction order, add it anyway and let it scale or overflow
                                pages.push([order]);
                                processedOrders.add(originalIndex);
                                continue;
                            }
                        }

                        // FIRST FIT: Try to fit this order in existing pages
                        let placed = false;
                        for (let pageIdx = 0; pageIdx < pages.length; pageIdx++) {
                            const pageOrders = pages[pageIdx];
                            const isFirstPage = pageIdx === 0;
                            const maxHeight = isFirstPage ? maxContentHeightFirstPage : maxContentHeightOtherPages;

                            // Measure current page content
                            const currentHeight = pageOrders.length > 0 ? await measureOrdersHeight(pageOrders) : 0;
                            const availableSpace = maxHeight - currentHeight;

                            // Try adding this order to this page
                            const testOrders = [...pageOrders, order];
                            const testHeight = await measureOrdersHeight(testOrders);
                            const willFit = testHeight <= maxHeight;

                            console.log(`ðŸ“ Page ${pageIdx + 1} (${isFirstPage ? 'FIRST' : 'other'}): has ${pageOrders.length} order(s), used ${currentHeight}px, available ${availableSpace}px/${maxHeight}px`);
                            console.log(`   â†’ Testing "${order.clientName || order.orderId}" (${height}px): total would be ${testHeight}px, fits = ${willFit}`);

                            if (willFit) {
                                // Fits! Add to this page
                                pages[pageIdx].push(order);
                                processedOrders.add(originalIndex);
                                placed = true;
                                console.log(`âœ… Placed order "${order.clientName || order.orderId}" on page ${pageIdx + 1}`);
                                break;
                            }
                        }

                        // If didn't fit in any existing page, create a new page
                        if (!placed) {
                            pages.push([order]);
                            processedOrders.add(originalIndex);
                            console.log(`ðŸ“„ Created new page ${pages.length} for order "${order.clientName || order.orderId}"`);
                        }
                    }

                    // Reset template to normal state
                    template.style.display = 'none';
                    template.style.visibility = 'visible';
                    template.style.position = 'static';
                    template.style.opacity = '1';

                    // VERIFICATION: Check all orders were processed
                    // Note: totalOrdersInPages may be > orders.length due to split multifunction orders
                    if (processedOrders.size !== orders.length) {
                        throw new Error(`Missing orders in PDF! Expected ${orders.length}, but only ${processedOrders.size} were processed.`);
                    }

                    const totalPages = pages.length;
                    console.log(`âœ… Generated ${totalPages} pages for ${orders.length} orders`);

                    // STEP 3: Generate multi-page PDF
                    this.updateLoadingMessage(loading, 'Creating PDF document...');

                    // Initialize jsPDF with exact dimensions matching our measurements (300 DPI)
                    const { jsPDF } = window.jspdf;

                    // CRITICAL FIX: Use the same paperDimensions we used for measurement
                    // This ensures content measured to fit will actually fit in the PDF
                    const pdf = new jsPDF({
                        orientation: 'p', // We handle orientation in paperDimensions
                        unit: 'px',
                        format: [paperDimensions.width, paperDimensions.height], // Use exact dimensions at 300 DPI
                        compress: true
                    });

                    // Get PDF page dimensions (should match paperDimensions)
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    console.log(`ðŸ“ PDF dimensions: ${pdfWidth} x ${pdfHeight} px (should match measurement dimensions)`);
                    console.log(`ðŸ“ Paper dimensions used for measurement: ${paperDimensions.width} x ${paperDimensions.height} px`);

                    // Generate each page and add to PDF
                    for (let pageNum = 0; pageNum < totalPages; pageNum++) {
                        this.updateLoadingMessage(loading, `Adding page ${pageNum + 1} of ${totalPages} to PDF...`);

                        const pageOrders = pages[pageNum];

                        // Build HTML for this page
                        let html = `
                            <div style="text-align: center; margin-bottom: 15px; padding: 8px 0;">
                                <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 10px; margin: 0; font-size: 24px;">
                                    Orders for <span style="font-size: 60px;">${Utils.formatDate(date)}</span> - Page ${pageNum + 1} of ${totalPages}
                                </h1>
                            </div>
                        `;

                        // Add summary section on first page only
                        console.log(`ðŸ” Page ${pageNum}: Checking grand total condition - DryIce=${grandTotalDryIce}, Flowers=${grandTotalFlowers}, Electricity=${grandTotalElectricity}`);
                        if (pageNum === 0 && (grandTotalDryIce > 0 || grandTotalFlowers > 0 || grandTotalElectricity > 0)) {
                            console.log(`âœ… Adding grand total summary to first page`);
                            html += `
                                <div style="background: white; color: black; padding: 5px; margin-bottom: 8px; border: 2px solid #000; border-radius: 4px;">
                                    <h3 style="margin: 0 0 4px 0; font-size: 13px; text-align: center; font-weight: bold;">ðŸ“Š Grand Total Requirements for ${Utils.formatDate(date)}</h3>
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
                                        ${grandTotalDryIce > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Dry Ice Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">â„ï¸</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalDryIce} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalDryMachines} machine${grandTotalDryMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalFlowers > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Flowers Needed</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">ðŸŒ¸</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalFlowers} kg</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${grandTotalFlowerMachines} machine${grandTotalFlowerMachines !== 1 ? 's' : ''} Ã— 20 kg</div>
                                        </div>
                                        ` : ''}
                                        ${grandTotalElectricity > 0 ? `
                                        <div style="background: white; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                            <div style="font-size: 40px; font-weight: bold; margin-bottom: 2px;">Electricity Required</div>
                                            <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                                <div style="font-size: 40px;">âš¡</div>
                                                <div style="font-size: 40px; font-weight: 700;">${grandTotalElectricity} KV</div>
                                            </div>
                                            <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">Total power needed</div>
                                        </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }

                        pageOrders.forEach((order, i) => {
                            html += this.buildOrderHTML(order, compactFontSize, colors, true, bgColor, textColor);
                            if (i < pageOrders.length - 1) {
                                html += `<div style="margin: ${separatorHeight}px 0; border-top: 2px dashed #ddd;"></div>`;
                            }
                        });

                        template.innerHTML = html;
                        template.style.display = 'block';
                        template.style.visibility = 'visible';
                        template.style.position = 'static';
                        template.style.height = 'auto';

                        // Increased wait time for mobile devices
                        await new Promise(r => setTimeout(r, isMobile ? 500 : 200));

                        // Validate canvas dimensions before creation
                        const expectedWidth = Math.round(paperDimensions.width * qualityScale);
                        const expectedHeight = Math.round(paperDimensions.height * qualityScale);
                        const validation = Utils.validateCanvasDimensions(expectedWidth, expectedHeight);

                        if (!validation.valid) {
                            throw new Error(`Page ${pageNum + 1}: ${validation.reason}`);
                        }

                        // Convert HTML to canvas with error handling
                        let canvas;
                        try {
                            canvas = await html2canvas(template, {
                                scale: qualityScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        } catch (canvasError) {
                            console.error('Canvas generation failed, retrying with lower quality:', canvasError);

                            // Retry with lower quality scale
                            const retryScale = isMobile ? 0.75 : 1;
                            console.log(`âš ï¸ Retrying page ${pageNum + 1} with scale ${retryScale}...`);

                            canvas = await html2canvas(template, {
                                scale: retryScale,
                                backgroundColor: bgColor,
                                width: paperDimensions.width,
                                logging: false,
                                useCORS: true,
                                allowTaint: false,
                                removeContainer: true,
                                imageTimeout: isMobile ? 30000 : 15000
                            });
                        }

                        template.style.display = 'none';

                        // Convert canvas to image and add to PDF with error handling
                        let imgData;
                        try {
                            imgData = canvas.toDataURL('image/png', 0.92);
                        } catch (pngError) {
                            console.error('PNG conversion failed, retrying with JPEG:', pngError);
                            // Fallback to JPEG if PNG fails
                            try {
                                imgData = canvas.toDataURL('image/jpeg', 0.85);
                            } catch (jpegError) {
                                console.error('JPEG conversion also failed:', jpegError);
                                if (isMobile) {
                                    throw new Error('Canvas conversion failed on mobile device. Try reducing image quality or downloading fewer orders.');
                                } else {
                                    throw jpegError;
                                }
                            }
                        }

                        // Check data URL size for mobile
                        if (isMobile && imgData.length > 10 * 1024 * 1024) {
                            console.warn(`âš ï¸ Page ${pageNum + 1} is large (${(imgData.length / 1024 / 1024).toFixed(2)} MB)`);
                        }
                        let imgWidth = pdfWidth;
                        let imgHeight = (canvas.height * pdfWidth) / canvas.width;

                        // Add new page if not first page
                        if (pageNum > 0) {
                            pdf.addPage();
                        }

                        // Check if image is too tall - if so, add it without scaling to preserve quality
                        // The content should have been properly split in the page allocation phase
                        if (imgHeight > pdfHeight) {
                            console.warn(`âš ï¸ Page ${pageNum + 1} image height (${imgHeight}px) exceeds PDF height (${pdfHeight}px)`);
                            console.warn(`   This should not happen - the page allocation should have split the content properly`);

                            // Calculate scale factor needed
                            const scaleFactor = pdfHeight / imgHeight;
                            console.warn(`   Content will be scaled down to ${(scaleFactor * 100).toFixed(1)}% to fit the page`);

                            // Scale to fit as last resort
                            imgHeight = pdfHeight;
                            imgWidth = (canvas.width * pdfHeight) / canvas.height;
                        }

                        // Add image to PDF page (centered if scaled down)
                        const xOffset = (pdfWidth - imgWidth) / 2;
                        pdf.addImage(imgData, 'PNG', xOffset, 0, imgWidth, imgHeight, undefined, 'FAST');
                    }

                    // Save the PDF
                    this.updateLoadingMessage(loading, 'Saving PDF...');
                    pdf.save(`Orders_${date}.pdf`);

                    this.hideLoading(loading);
                    this.showToast(`âœ… PDF generated with ${totalPages} page(s)! (${orders.length} orders)`);

                } catch (error) {
                    this.hideLoading(loading);
                    console.error('Error generating multi-order images:', error);

                    // Mobile-friendly error messages
                    if (isMobile) {
                        this.showToast(`âŒ Failed on ${deviceType}: ${error.message}. Try reducing quality in settings or downloading fewer orders.`, 'error');
                    } else {
                        this.showToast('âŒ Error: ' + error.message, 'error');
                    }
                }
            },

            // Helper to update loading message dynamically
            updateLoadingMessage(loadingElement, message) {
                if (loadingElement && loadingElement.querySelector('.loading-text')) {
                    loadingElement.querySelector('.loading-text').textContent = message;
                }
            },

            // Get paper dimensions based on format and orientation
            getPaperDimensions() {
                const format = this.data.settings.paperFormat || 'A4';
                const orientation = this.data.settings.paperOrientation || 'portrait';

                // Paper dimensions in pixels (at 300 DPI)
                const formats = {
                    'A4': { width: 2480, height: 3508 },
                    'Legal': { width: 2550, height: 4200 },
                    'Letter': { width: 2550, height: 3300 },
                    'A3': { width: 3508, height: 4960 },
                    'A5': { width: 1748, height: 2480 },
                    'Tabloid': { width: 3300, height: 5100 }
                };

                let dimensions = formats[format] || formats['A4'];

                // Swap dimensions for landscape
                if (orientation === 'landscape') {
                    return {
                        width: dimensions.height,
                        height: dimensions.width
                    };
                }

                return dimensions;
            },

            // Calculate dry ice, flowers, and electricity requirements for a single order
            calculateOrderRequirements(order) {
                const items = [];

                // Collect all items from the order
                // Check for dayWiseData first (handles both multiday and filtered single-day orders)
                if (order.dayWiseData && Array.isArray(order.dayWiseData) && order.dayWiseData.length > 0) {
                    console.log(`ðŸ“‹ Order ${order.orderId || order.clientName}: Processing dayWiseData (${order.dayWiseData.length} days)`);
                    order.dayWiseData.forEach(day => {
                        if (day.functions && Array.isArray(day.functions)) {
                            day.functions.forEach(func => {
                                if (func.items && Array.isArray(func.items)) {
                                    const funcName = func.functionName || func.name || '(unnamed function)';
                                    console.log(`  â†’ Adding ${func.items.length} items from function "${funcName}"`);
                                    items.push(...func.items);
                                }
                            });
                        }
                    });
                } else if (order.items && Array.isArray(order.items)) {
                    console.log(`ðŸ“‹ Order ${order.orderId || order.clientName}: Processing items array (${order.items.length} items)`);
                    items.push(...order.items);
                }

                console.log(`  â†’ Total items collected: ${items.length}`);

                // DEBUG: Log all item names to understand what we're working with
                if (items.length > 0) {
                    console.log(`  â†’ Item details:`);
                    items.forEach((item, idx) => {
                        console.log(`     ${idx + 1}. Name: "${item.name}" | Pcs: ${item.quantity || 0}`);
                    });
                }

                // Calculate dry ice requirements
                const dryMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = name.includes('dry ice');
                    if (matches) {
                        console.log(`     âœ… DRY ICE MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Calculate flower requirements
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name?.toLowerCase() || '';
                    const matches = flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                    if (matches) {
                        console.log(`     âœ… FLOWER SHOWER MATCH: "${item.name}" (qty: ${item.quantity || 0})`);
                    }
                    return matches;
                }).reduce((sum, item) => sum + (item.quantity || 0), 0);
                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name?.toLowerCase() || '';
                    const qty = item.quantity || 0;

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     âœ… ELECTRICITY 3KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 3}KV)`);
                        totalElectricityKV += qty * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        console.log(`     âœ… ELECTRICITY 1KV MATCH: "${item.name}" (qty: ${qty}, total: ${qty * 1}KV)`);
                        totalElectricityKV += qty * 1;
                    }
                });

                const result = {
                    dryIceNeeded,
                    dryMachines,
                    flowersNeeded,
                    flowerShowerMachines,
                    totalElectricityKV,
                    items
                };

                // DEBUG: Log the calculated requirements
                console.log(`  â†’ ðŸ“Š Calculated: DryIce=${dryIceNeeded}kg (${dryMachines} machines), Flowers=${flowersNeeded}kg (${flowerShowerMachines} machines), Electricity=${totalElectricityKV}KV`);

                return result;
            },

            buildOrderHTML(order, fontSize, colors, compact = false, bgColor = '#ffffff', textColor = '#000000') {
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                const functionColor = this.data.settings.functionColor || '#667eea';

                // Calculate requirements for this order
                const requirements = this.calculateOrderRequirements(order);

                return `
                    <div style="margin-bottom: ${compact ? '25px' : '60px'}; ${compact ? 'border: 2px solid ' + colors.tableBorder + '; padding: 15px;' : ''}; color: ${textColor}; background: ${bgColor};">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px; color: ${textColor};">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : ''}

                        <!-- FP- Field at center/top -->
                        <div style="text-align: center; margin-bottom: ${compact ? '15px' : '25px'}; margin-top: ${compact ? '10px' : '0'};">
                            <div style="display: inline-block; border: 2px solid ${textColor}; padding: 8px 25px; font-size: ${fontSize + 4}px; font-weight: bold; color: #000000; background: #ffeb3b;">
                                FP-<span style="display: inline-block; min-width: 150px; border-bottom: 2px solid ${textColor}; margin-left: 10px; white-space: nowrap;">${order.orderId && order.orderId.startsWith('FP') ? order.orderId.substring(2) : ''}</span>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ${compact ? '12px' : '20px'}; font-size: ${fontSize}px; margin-bottom: ${compact ? '12px' : '20px'}; color: ${textColor};">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong style="color: ${textColor};">Start Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.startDate) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">End Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.endDate) || 'N/A'}</span><br>
                                ` : `
                                    <strong style="color: ${textColor};">Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.date) || 'N/A'}</span><br>
                                    <strong style="color: ${textColor};">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${order.readyTime || '-'}</span><br>
                                `}
                                <strong style="color: ${textColor};">Client:</strong> ${order.clientName || '-'}<br>
                                <strong style="color: ${textColor};">Contact:</strong> ${order.contact || '-'}<br>
                                <strong style="color: ${textColor};">Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Dry Ice: ${requirements.dryIceNeeded > 0 ? requirements.dryIceNeeded + ' kg (' + requirements.dryMachines + ' machine' + (requirements.dryMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Flowers: ${requirements.flowersNeeded > 0 ? requirements.flowersNeeded + ' kg (' + requirements.flowerShowerMachines + ' machine' + (requirements.flowerShowerMachines !== 1 ? 's' : '') + ')' : ''}</div>
                                <div style="font-size: 50px; font-weight: bold; color: ${textColor};">Electricity: ${requirements.totalElectricityKV > 0 ? requirements.totalElectricityKV + ' KV' : ''}</div>
                                <strong style="color: ${textColor};">Transport:</strong> ${order.transport || '-'}<br>
                                <strong style="color: ${textColor};">Driver:</strong> ${order.driverName || '-'}<br>
                                ${order.transport2 ? `<strong style="color: ${textColor};">Transport 2:</strong> ${order.transport2}<br>` : ''}
                                ${order.driverName2 ? `<strong style="color: ${textColor};">Driver 2:</strong> ${order.driverName2}<br>` : ''}
                            </div>
                            <div>
                                <strong style="color: ${textColor};">Event:</strong> ${order.eventType || '-'}<br>
                                <strong style="color: ${textColor};">Operator:</strong> ${order.operator || '-'}<br>
                                <strong style="color: ${textColor};">Helper(s):</strong> ${order.helper || '-'}
                            </div>
                        </div>

                        <!-- Dividing line between top info and items -->
                        <div style="border-top: 3px solid ${textColor}; margin: ${compact ? '15px' : '25px'} 0;"></div>

                            ${order.dayWiseData && order.dayWiseData.length > 0 ?
                            '<div style="margin-top: ' + (compact ? '15px' : '30px') + ';">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: ' + (compact ? '10px' : '15px') + '; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) =>
                                    '<div style="margin-top: ' + (compact ? '12px' : '25px') + '; border: 2px solid ' + colors.tableBorder + '; padding: ' + (compact ? '10px' : '15px') + '; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: ' + (compact ? '8px' : '15px') + ';">Day ' + day.dayNumber + ' - <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + Utils.formatDate(day.date) + '</span></h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: ' + bgColor + '; padding: ' + (compact ? '10px' : '15px') + '; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? (compact ? '8px' : '15px') : '0') + '; color: ' + textColor + ';">' +
                                                    '<h5 style="color: ' + functionColor + '; margin-bottom: ' + (compact ? '6px' : '10px') + '; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: ' + (compact ? '8px' : '12px') + '; font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';">' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + (func.timeSlot || '-') + '</span>' +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                            '<strong style="color: ' + textColor + ';">Operator:</strong> ' + (func.operator || '-') +
                                                        '</div>' +
                                                        '<div>' +
                                                            '<strong style="color: ' + textColor + ';">Helper:</strong> ' + (func.helper || '-') +
                                                        '</div>' +
                                                    '</div>' +
                                                    (func.notes ? '<div style="font-size: ' + fontSize + 'px; margin-bottom: ' + (compact ? '6px' : '10px') + '; color: ' + textColor + ';"><strong style="color: ' + textColor + ';">Notes:</strong> ' + func.notes + '</div>' : '') +
                                                    (func.items && func.items.length > 0 ?
                                                        '<div style="font-size: ' + (fontSize - 4) + 'px; color: ' + textColor + '; margin-top: ' + (compact ? '8px' : '12px') + ';">' +
                                                            func.items.map((item, i) =>
                                                                '<div style="padding: ' + (compact ? '4px' : '6px') + ' 0; color: ' + textColor + ';">' +
                                                                    '<span style="color: ' + textColor + ';">' + (i + 1) + '. ' + item.name + ' - ' + item.quantity + (item.quantity == 1 ? ' Pc' : ' Pcs') + (item.remarks ? ' - Remarks: ' + item.remarks : '') + '</span>' +
                                                                '</div>'
                                                            ).join('') +
                                                        '</div>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '6px' : '10px') + ';">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <div style="font-size: ${fontSize - 4}px; margin-top: ${compact ? '12px' : '20px'}; color: ${textColor};">
                                ${order.items.map((item, i) => `
                                    <div style="padding: ${compact ? '4px' : '6px'} 0; color: ${textColor};">
                                        <span style="color: ${textColor};">${i + 1}. ${item.name} - ${item.quantity} ${item.quantity == 1 ? 'Pc' : 'Pcs'}${item.remarks ? ' - Remarks: ' + item.remarks : ''}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: ' + (compact ? '12px' : '20px') + ';">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: ${compact ? '10px' : '20px'}; font-size: ${fontSize}px; color: ${textColor};">
                                <strong style="color: ${textColor};">Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: ${compact ? '10px' : '15px'}; border: 1px solid ${colors.tableBorder}; color: ${textColor};">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            renderCalendar(date = new Date()) {
                const year = date.getFullYear();
                const month = date.getMonth();

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                let html = `
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(-1)">${this.t('previousMonth')}</button>
                                <h3>${monthNames[month]} ${year}</h3>
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(1)">${this.t('nextMonth')}</button>
                            </div>
                            <button class="btn btn-secondary btn-small" onclick="OMS.showToday()">${this.t('today')}</button>
                        </div>
                        <div class="calendar-grid">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day =>
                                `<div class="calendar-day-header">${day}</div>`
                            ).join('')}
                            ${Array(firstDay).fill('').map(() => '<div class="calendar-day"></div>').join('')}
                            ${Array.from({length: daysInMonth}, (_, i) => {
                                const day = i + 1;
                                const dateStr = Utils.toDateString(new Date(year, month, day));
                                const today = Utils.toDateString(new Date());

                                // ENHANCED CALENDAR FILTERING with fuzzy date matching
                                const orders = this.data.orders.filter(o => {
                                    if (o.isMultiDay) {
                                        // Use fuzzy date matcher for multi-day range check
                                        if (o.startDate && o.endDate) {
                                            return fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate);
                                        }
                                    }
                                    // Use fuzzy date matcher for single-day check
                                    return o.date && fuzzyDateMatcher.matches(o.date, dateStr);
                                });
                                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                                const festival = this.festivals[dateStr];

                                let classes = 'calendar-day';
                                if (dateStr === today) classes += ' today';
                                if (orders.length) classes += ' has-orders';
                                if (tasks.length) classes += ' has-tasks';
                                if (festival) classes += ' has-festival';

                                // Get color indicators for this day's orders
                                const orderColorDots = orders.slice(0, 3).map(o => {
                                    const color = this.getOrderColor(o);
                                    return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin:0 2px;"></span>`;
                                }).join('');

                                return `
                                    <div class="${classes}" onclick="OMS.showDayDetails('${dateStr}')">
                                        <div class="calendar-day-number">${day}</div>
                                        ${festival ? `<div class="festival-text">${festival[1]}</div>` : ''}
                                        ${orders.length ? `<div class="order-count" title="${orders.length} ${this.t('ordersText')}">${orderColorDots}${orders.length > 3 ? '+' : ''}</div>` : ''}
                                        ${tasks.length ? `<div class="calendar-day-content">${tasks.length} ${tasks.length > 1 ? this.t('ordersText') : this.t('order')}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="card">
                        <h3 class="card-title">${this.t('calendar')}</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <input type="date" id="taskDate" class="form-input" value="${Utils.toDateString(new Date())}">
                            </div>
                            <div class="form-group">
                                <input type="text" id="taskDescription" class="form-input" placeholder="${this.t('enterNotes')}">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-primary" onclick="OMS.addTask()">${this.t('add')}</button>
                            </div>
                        </div>
                    </div>
                `;

                return html;
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const date = Utils.getLocalDate(dateStr);

                // ============ ENHANCED FILTERING WITH LOGGING ============
                const startTime = performance.now();
                const normalizedDate = fuzzyDateMatcher.normalize(dateStr);

                filterLogger.log('showDayDetails_started', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    normalizedDate,
                    totalOrdersAvailable: this.data.orders.length
                });

                const matchedOrders = [];
                const orders = this.data.orders.filter(o => {
                    if (o.isMultiDay) {
                        // Use fuzzy date matcher for multi-day range check
                        if (o.startDate && o.endDate && fuzzyDateMatcher.isInRange(dateStr, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    // Use fuzzy date matcher for single-day check
                    if (o.date && fuzzyDateMatcher.matches(o.date, dateStr)) {
                        matchedOrders.push(o);
                        return true;
                    }
                    return false;
                });

                const filterTime = (performance.now() - startTime).toFixed(2);

                // Log and learn from this filter
                filterLogger.log('showDayDetails_completed', {
                    operation: 'showDayDetails',
                    filterDate: dateStr,
                    matchedCount: orders.length,
                    filterTimeMs: filterTime
                });

                patternLearner.recordFilterResult(normalizedDate, orders.length, this.data.orders.length, 'showDayDetails');

                // Validate and alert if needed
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: this.data.orders.length,
                    matchedOrders,
                    allOrders: this.data.orders
                });

                if (validationResult.some(a => a.level === 'error' || a.level === 'warning')) {
                    orderValidator.showAlerts(validationResult, dateStr);
                }
                // ============ END ENHANCED FILTERING ============

                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                const festival = this.festivals[dateStr];

                let content = `<h3>${this.t('details')} ${this.t('for')} ${Utils.formatDate(dateStr)}</h3>`;

                if (festival) {
                    content += `<div class="festival-text" style="font-size: 1.2rem; margin: 1rem 0;">ðŸŽ‰ ${festival[1]} (${festival[0]})</div>`;
                }

                if (orders.length > 0) {
                    content += `<h4>${this.t('orders')} (${orders.length})</h4>`;
                    orders.forEach(o => {
                        const color = this.getOrderColor(o);
                        let dateInfo = '';
                        if (o.isMultiDay) {
                            dateInfo = `<br><small style="color:#666;">${this.t('multiDayOrder')}: ${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}</small>`;
                        }
                        content += `
                            <div style="padding:10px;margin:8px 0;border-left:4px solid ${color};background:#f9f9f9;border-radius:4px;">
                                <strong>${o.orderId || '[No ID]'}</strong> - ${o.clientName}
                                <br>
                                <span style="color:${color};font-weight:bold;">${o.eventType || this.t('event')}</span> |
                                <span style="background:${color};color:white;padding:2px 6px;border-radius:3px;font-size:12px;">${this.t(o.status.toLowerCase())}</span>
                                ${dateInfo}
                            </div>
                        `;
                    });
                }

                if (tasks.length > 0) {
                    content += `<h4>${this.t('calendar')} (${tasks.length})</h4><ul>`;
                    tasks.forEach(t => {
                        content += `<li>
                            ${t.description}
                            <button class="btn btn-secondary btn-small" data-action="edit" data-type="task" data-id="${t.id}">${this.t('edit')}</button>
                            <button class="btn btn-danger btn-small" data-action="delete" data-type="task" data-id="${t.id}">${this.t('delete')}</button>
                        </li>`;
                    });
                    content += '</ul>';
                }

                content += `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.addTaskForDate('${dateStr}')">${this.t('add')}</button>
                        <button class="btn btn-secondary" onclick="OMS.createOrderForDate('${dateStr}')">${this.t('orders')}</button>
                    </div>
                `;

                this.showModal(this.t('details'), content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders as CSV
                        const headers = ['Order ID', 'Date', 'Client', 'Contact', 'Venue', 'Status', 'Total Items'];
                        const rows = this.data.orders.map(o => [
                            o.orderId, o.date, o.clientName, o.contact, o.venue, o.status, o.items.length
                        ]);
                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();

                // Create close button
                const closeBtn = Utils.elem('button', { class: 'modal-close' }, ['Ã—']);
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeModal();
                });

                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        closeBtn,
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);

                document.getElementById('modalsContainer').appendChild(modal);

                // Also allow closing by clicking the backdrop
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal();
                    }
                });

                // Add keyboard handler for Escape key
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);

                // Store handler to remove later
                modal._escapeHandler = escapeHandler;
            },

            showToast(message, type = 'success', actions = []) {
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let topOffset = 20; // Initial top position

                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    topOffset = Math.max(topOffset, rect.bottom - document.documentElement.scrollTop + 10);
                });

                // Create action buttons if provided
                const actionButtons = actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' },
                    actions.map(a => {
                        const btn = Utils.elem('button', { class: 'toast-btn' }, [a.label]);
                        btn.addEventListener('click', a.handler);
                        return btn;
                    })
                ) : null;

                const toast = Utils.elem('div', {
                    class: `toast show ${type === 'error' ? 'error' : ''} ${type === 'warning' ? 'warning' : ''}`,
                    style: { top: `${topOffset}px` }
                }, [
                    Utils.elem('div', {}, [message]),
                    actionButtons
                ].filter(Boolean));

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },

            repositionToasts() {
                const toasts = document.querySelectorAll('.toast');
                let topOffset = 20;

                toasts.forEach(toast => {
                    toast.style.top = `${topOffset}px`;
                    const rect = toast.getBoundingClientRect();
                    topOffset = rect.bottom - document.documentElement.scrollTop + 10;
                });
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', { class: 'loading-text' }, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ RBAC NAVIGATION ============
            async applyRBACToNavigation() {
                const canViewFinancials = await this.canViewFinancials();
                const financialsTab = document.querySelector('[data-tab="financials"]');
                const user = await this.getCurrentUser();

                console.log('ðŸ” RBAC Check:', {
                    userRole: user?.role,
                    canViewFinancials: canViewFinancials,
                    tabExists: !!financialsTab
                });

                if (financialsTab) {
                    if (canViewFinancials) {
                        // Show financials tab for admin/owner users
                        financialsTab.style.display = '';
                        console.log('âœ… Financials tab VISIBLE for admin/owner user');
                    } else {
                        // Hide financials tab for non-admin/owner users
                        financialsTab.style.display = 'none';
                        console.log('ðŸ”’ Financials tab HIDDEN for non-admin/owner user');
                    }
                }

                // Display current user role in header
                if (user) {
                    const userInfoDiv = document.createElement('div');
                    userInfoDiv.id = 'userRoleInfo';
                    userInfoDiv.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: rgba(0,0,0,0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; white-space: nowrap; margin-right: 0.5rem;';
                    userInfoDiv.innerHTML = `
                        <span style="opacity: 0.7; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${user.email}</span>
                        <span style="padding: 0.25rem 0.5rem; background: ${user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3'}; color: white; border-radius: 0.25rem; font-weight: bold; text-transform: uppercase; font-size: 0.75rem;">
                            ${user.role}
                        </span>
                    `;

                    // Add to header-controls instead of directly to header
                    const headerControls = document.querySelector('.header-controls');
                    if (headerControls && !document.getElementById('userRoleInfo')) {
                        // Insert at the beginning of header-controls
                        headerControls.insertBefore(userInfoDiv, headerControls.firstChild);
                    }
                }
            },

            // ============ NAVIGATION ============
            async switchTab(tabName) {
                // Check permissions for financial tab
                if (tabName === 'financials') {
                    const canView = await this.canViewFinancials();
                    if (!canView) {
                        this.showToast('â›” Access Denied: Only Admin and Owner can view Financials', 'error');
                        return;
                    }
                }

                // Clean up preparation weather interval when leaving preparation tab
                if (this.currentTab === 'preparation' && tabName !== 'preparation') {
                    if (this.preparationWeatherInterval) {
                        clearInterval(this.preparationWeatherInterval);
                        this.preparationWeatherInterval = null;
                    }
                }

                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(tabName).classList.add('active');

                this.currentTab = tabName;

                // Render tab content
                setTimeout(() => {
                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') this.renderInventory();
                    else if (tabName === 'itemHistory') this.renderItemHistory();
                    else if (tabName === 'preparation') this.renderPreparation();
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'quotations') this.renderQuotations();
                    else if (tabName === 'team') this.renderTeam();
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'videos') this.renderVideos();
                    else if (tabName === 'advertisements') this.renderAdvertisements();
                    else if (tabName === 'financials') this.renderFinancials();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') {
                        this.initItemSearch();
                        // Always populate events dropdown when orders tab is opened
                        console.log('ðŸ“‹ Orders tab opened - populating events dropdown');
                        this.populateEventsDatalist();
                        // Driver and operator dropdowns are populated when form is rendered
                    }
                }, 50);
            },

            // ============ TAB RENDERERS ============
            renderDashboard() {
                // Filter out merged orders (original orders that were merged into another order)
                const activeOrders = this.data.orders.filter(o => !o.isMerged);
                const todayDate = Utils.toDateString(new Date());

                const stats = [
                    { label: this.t('totalOrders'), value: activeOrders.length, class: '' },
                    { label: this.t('confirmedOrders'), value: activeOrders.filter(o => o.status && o.status.toLowerCase() === 'confirmed').length, class: 'success' },
                    { label: this.t('completedOrders'), value: activeOrders.filter(o => o.status && o.status.toLowerCase() === 'completed').length, class: 'info' },
                    { label: this.t('customers'), value: this.data.customers.length, class: '' },
                    { label: this.t('lowStock'), value: this.data.inventory.items.filter(i => i.quantity <= this.data.settings.lowStockThreshold).length, class: 'warning' },
                    { label: this.t('today'), value: activeOrders.filter(o => {
                        // For single day orders, check date field
                        if (!o.isMultiDay && o.date === todayDate) return true;
                        // For multiday orders, check if today falls within the date range
                        if (o.isMultiDay && o.startDate && o.endDate) {
                            return todayDate >= o.startDate && todayDate <= o.endDate;
                        }
                        return false;
                    }).length, class: 'danger' }
                ];

                document.getElementById('dashboardStats').innerHTML = stats.map(s => `
                    <div class="stat-card ${s.class}">
                        <div class="stat-value">${s.value}</div>
                        <div class="stat-label">${s.label}</div>
                    </div>
                `).join('');

                // Show recent orders (excluding merged orders)
                const recentOrders = activeOrders.slice(-5).reverse();
                this.renderTable('recentOrdersContainer', [
                    { key: 'orderId', label: this.t('orderId'), render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: this.t('client') },
                    { key: 'eventType', label: this.t('event'), render: o => o.eventType || this.t('na') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${o.status}</span>` }
                ], recentOrders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('view')}</button>
                    <button class="btn btn-info btn-small" onclick="OMS.duplicateOrder('${row.docId || row.orderId}')">ðŸ“‹ ${this.t('duplicate')}</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                `);

                // Top customer
                if (this.data.customers.length > 0) {
                    const top = this.data.customers.reduce((prev, curr) =>
                        (prev.totalOrders > curr.totalOrders) ? prev : curr
                    );
                    document.getElementById('topCustomerInfo').innerHTML = `
                        <div style="background: var(--light); padding: 1rem; border-radius: var(--radius);">
                            <strong>${top.name}</strong><br>
                            ${top.contact}<br>
                            <strong>${top.totalOrders} ${this.t('ordersText')}</strong>
                        </div>
                    `;
                }
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('inventoryManagement')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">${this.t('batchUpdate')}</button>
                        </div>
                        <div class="card">
                            <h3>${this.t('categories')}</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="${this.t('enterCategoryName')}">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">${this.t('add')}</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>${this.t('items')}</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="${this.t('enterItemName')}">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="${this.t('quantity')}" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">${this.t('add')}</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;

                this.updateInventoryDisplay();
            },

            renderItemHistory() {
                const container = document.getElementById('itemHistory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ðŸ“œ Item Usage History</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">
                                Track which items were used in which completed orders
                            </p>
                        </div>
                        <div class="form-row" style="margin-bottom: 1rem;">
                            <input type="text" id="itemHistorySearch" class="form-input" placeholder="Search by item name, order ID, or client...">
                            <select id="itemHistoryFilter" class="form-select">
                                <option value="all">All Items</option>
                                ${[...new Set(this.data.itemHistory.map(h => h.itemName))].sort().map(name =>
                                    `<option value="${name}">${name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div id="itemHistoryContainer"></div>
                    </div>
                `;

                this.renderItemHistoryTable();

                // Add search and filter handlers
                document.getElementById('itemHistorySearch')?.addEventListener('input', () => this.renderItemHistoryTable());
                document.getElementById('itemHistoryFilter')?.addEventListener('change', () => this.renderItemHistoryTable());
            },

            renderItemHistoryTable() {
                const searchTerm = document.getElementById('itemHistorySearch')?.value.toLowerCase() || '';
                const filterItem = document.getElementById('itemHistoryFilter')?.value || 'all';

                // Filter history
                let filteredHistory = this.data.itemHistory;

                if (filterItem !== 'all') {
                    filteredHistory = filteredHistory.filter(h => h.itemName === filterItem);
                }

                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(h =>
                        h.itemName.toLowerCase().includes(searchTerm) ||
                        h.orderId.toLowerCase().includes(searchTerm) ||
                        h.clientName.toLowerCase().includes(searchTerm) ||
                        (h.venue && h.venue.toLowerCase().includes(searchTerm))
                    );
                }

                // Sort by most recent first
                filteredHistory.sort((a, b) => new Date(b.usedAt) - new Date(a.usedAt));

                // Render table
                this.renderTable('itemHistoryContainer', [
                    { key: 'itemName', label: 'Item Name' },
                    { key: 'quantity', label: 'Pcs' },
                    { key: 'orderId', label: 'Order ID', render: h => `<span class="order-id-highlight">${h.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'venue', label: 'Venue', render: h => h.venue || 'N/A' },
                    { key: 'eventDate', label: 'Event Date', render: h => Utils.formatDate(h.eventDate) },
                    { key: 'functionType', label: 'Function', render: h => h.functionType || 'N/A' },
                    { key: 'usedAt', label: 'Recorded On', render: h => new Date(h.usedAt).toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }) }
                ], filteredHistory, (row) => ``);
            },

            updateInventoryDisplay() {
                // Populate category dropdown
                const select = document.getElementById('itemCategory');
                if (select) {
                    select.innerHTML = `<option value="">${this.t('selectCategory')}</option>` +
                        this.data.inventory.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
                }

                // Render categories table
                this.renderTable('categoriesContainer', [
                    { key: 'name', label: this.t('category') },
                    { key: 'id', label: this.t('items'), render: c => this.data.inventory.items.filter(i => i.categoryId === c.id).length }
                ], this.data.inventory.categories, (row) => `
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="category" data-id="${row.id}">${this.t('delete')}</button>
                `);

                // Render items table
                this.renderTable('itemsContainer', [
                    { key: 'name', label: this.t('item') },
                    { key: 'categoryId', label: this.t('category'), render: i => this.data.inventory.categories.find(c => c.id === i.categoryId)?.name || this.t('na') },
                    { key: 'quantity', label: this.t('stock') }
                ], this.data.inventory.items, (row) => `
                    <button class="btn btn-success btn-small" onclick="OMS.increaseItemQuantity('${row.id}')">+</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.decreaseItemQuantity('${row.id}')">-</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.editInventoryItem('${row.id}')">âœï¸ ${this.t('edit')}</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="item" data-id="${row.id}">ðŸ—‘ï¸ ${this.t('delete')}</button>
                `);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Pieces</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">ðŸ’¾ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION / FORECAST FUNCTIONS ============

            renderPreparation() {
                const container = document.getElementById('preparation');
                const today = new Date().toISOString().split('T')[0];
                const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                const nextWeek = new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('preparationForecast')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('itemsToPrep')}</p>
                        </div>

                        <div class="card">
                            <h3>${this.t('selectDateRange')}</h3>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('today')">${this.t('today')}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('tomorrow')">${this.t('tomorrow') || 'Tomorrow'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('week')">${this.t('next7Days') || 'Next 7 Days'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('month')">${this.t('next30Days') || 'Next 30 Days'}</button>
                            </div>
                            <div class="form-row">
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('from')}</label>
                                    <input type="date" id="forecastStartDate" class="form-input" value="${today}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('to')}</label>
                                    <input type="date" id="forecastEndDate" class="form-input" value="${tomorrow}">
                                </div>
                                <div style="display: flex; align-items: flex-end;">
                                    <button class="btn btn-primary" onclick="OMS.generateForecast()" style="height: fit-content;">
                                        ðŸ” ${this.t('generateReport')}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="forecastResults"></div>
                    </div>
                `;

                // Auto-generate forecast for tomorrow by default
                setTimeout(() => this.generateForecast(), 100);
            },

            quickForecast(period) {
                const today = new Date();
                const startInput = document.getElementById('forecastStartDate');
                const endInput = document.getElementById('forecastEndDate');

                let start = new Date(today);
                let end = new Date(today);

                switch(period) {
                    case 'today':
                        // Start and end are same (today)
                        break;
                    case 'tomorrow':
                        start.setDate(start.getDate() + 1);
                        end.setDate(end.getDate() + 1);
                        break;
                    case 'week':
                        end.setDate(end.getDate() + 7);
                        break;
                    case 'month':
                        end.setDate(end.getDate() + 30);
                        break;
                }

                startInput.value = start.toISOString().split('T')[0];
                endInput.value = end.toISOString().split('T')[0];

                this.generateForecast();
            },

            async generateForecast() {
                const startDate = Utils.get('forecastStartDate');
                const endDate = Utils.get('forecastEndDate');

                if (!startDate || !endDate) {
                    this.showToast('Please select both start and end dates', 'error');
                    return;
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (end < start) {
                    this.showToast('End date must be after start date', 'error');
                    return;
                }

                // Get orders in date range
                const ordersInRange = this.getOrdersInDateRange(startDate, endDate);

                // Aggregate items from all orders
                const itemsMap = new Map();
                const orderItemsMap = new Map(); // Track which orders use which items

                ordersInRange.forEach(order => {
                    const items = this.getItemsFromOrder(order, startDate, endDate);

                    items.forEach(item => {
                        // Aggregate quantities
                        const current = itemsMap.get(item.name) || 0;
                        itemsMap.set(item.name, current + item.quantity);

                        // Track order references
                        if (!orderItemsMap.has(item.name)) {
                            orderItemsMap.set(item.name, []);
                        }
                        orderItemsMap.get(item.name).push({
                            orderId: order.orderId,
                            clientName: order.clientName,
                            quantity: item.quantity
                        });
                    });
                });

                // Convert to array and sort by quantity (descending)
                const aggregatedItems = Array.from(itemsMap, ([name, quantity]) => {
                    // Find matching inventory item
                    const inventoryItem = this.data.inventory.items.find(i =>
                        i.name.toLowerCase() === name.toLowerCase()
                    );

                    return {
                        name,
                        required: quantity,
                        inStock: inventoryItem ? inventoryItem.quantity : 0,
                        difference: inventoryItem ? inventoryItem.quantity - quantity : -quantity,
                        orders: orderItemsMap.get(name) || []
                    };
                }).sort((a, b) => b.required - a.required);

                // Fetch weather for the start date
                const weatherApiKey = this.data.settings.weatherApiKey || '';
                const defaultCity = this.data.settings.defaultCity || 'Delhi';
                const weatherData = await Utils.getWeatherForecast(defaultCity, startDate, weatherApiKey);

                // Render forecast results
                this.renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate, weatherData);
            },

            getOrdersInDateRange(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);

                return this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day orders, check if any day falls in range
                        const orderStart = new Date(order.startDate);
                        const orderEnd = new Date(order.endDate);

                        // Check for overlap: order overlaps if it starts before range ends AND ends after range starts
                        return orderStart <= end && orderEnd >= start;
                    } else {
                        // For single-day orders
                        const orderDate = new Date(order.date);
                        return orderDate >= start && orderDate <= end;
                    }
                });
            },

            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            renderForecastResults(orders, items, startDate, endDate, weatherData = null) {
                const container = document.getElementById('forecastResults');

                if (orders.length === 0) {
                    container.innerHTML = `
                        <div class="card" style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <h3>ðŸ“­ ${this.t('noOrdersFoundShort')}</h3>
                            <p>${this.t('noOrdersScheduledBetween')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate statistics
                const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
                const pendingOrders = orders.filter(o => o.status !== 'Confirmed' && o.status !== 'Completed').length;
                const completedOrders = orders.filter(o => o.status === 'Completed').length;
                const totalItems = items.reduce((sum, item) => sum + item.required, 0);
                const shortageItems = items.filter(i => i.difference < 0);
                const okItems = items.filter(i => i.difference >= 0);

                // Calculate dry ice, flowers, and electricity requirements
                // Find all dry ice machines (items containing "dry ice")
                const dryMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return name.includes('dry ice');
                }).reduce((sum, item) => sum + item.required, 0);

                const dryIceNeeded = dryMachines * 20; // 20 kg per dry ice machine

                // Find all flower shower machines (items containing "flower shower" or "flower" and "shower")
                const flowerShowerKeywords = ['flower shower', 'flower shower machine'];
                const flowerShowerMachines = items.filter(item => {
                    const name = item.name.toLowerCase();
                    return flowerShowerKeywords.some(keyword => name.includes(keyword)) ||
                           (name.includes('flower') && name.includes('shower'));
                }).reduce((sum, item) => sum + item.required, 0);

                const flowersNeeded = flowerShowerMachines * 20; // 20 kg per flower shower machine

                // Calculate electricity requirements
                const electricity3KV = ['showven sonic boom (co2 jet)', 'dry ice machine', '5 head flame'];
                const electricity1KV = ['sparkular machine', 'spinner machine', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];

                let totalElectricityKV = 0;
                items.forEach(item => {
                    const itemNameLower = item.name.toLowerCase();

                    if (electricity3KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 3;
                    } else if (electricity1KV.some(name => itemNameLower.includes(name))) {
                        totalElectricityKV += item.required * 1;
                    }
                });

                container.innerHTML = `
                    <!-- Summary Cards -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 1.5rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ðŸ“Š ${this.t('summary')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${orders.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalOrders')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${confirmedOrders}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âœ… ${this.t('confirmed')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${items.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('uniqueItems')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${totalItems}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalQuantity')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: ${shortageItems.length > 0 ? '#fca5a5' : '#86efac'};">${shortageItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âš ï¸ ${this.t('shortages')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: #86efac;">${okItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">âœ… ${this.t('sufficient')}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Weather Forecast Card -->
                    ${weatherData ? `
                    <div class="card" style="background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ðŸŒ¤ï¸ Weather Forecast for ${Utils.formatDate(startDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 3rem; margin-bottom: 0.5rem;">${Utils.getWeatherEmoji(weatherData.condition)}</div>
                                <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.25rem;">${weatherData.condition}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${weatherData.description}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ðŸŒ¡ï¸ Temperature</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.temp}Â°C</div>
                                ${weatherData.tempMin && weatherData.tempMax ? `
                                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem;">
                                        ${weatherData.tempMin}Â°C - ${weatherData.tempMax}Â°C
                                    </div>
                                ` : ''}
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ðŸ’§ Humidity</div>
                                <div style="font-size: 2.5rem; font-weight: 700;">${weatherData.humidity}%</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.5rem;">ðŸ“ Location</div>
                                <div style="font-size: 1.2rem; font-weight: 600;">${this.data.settings.defaultCity || 'Delhi'}</div>
                                <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.5rem;">
                                    ${weatherData.temp === 'N/A' ? 'Weather unavailable' : 'Live forecast'}
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Materials Calculation Card -->
                    ${(dryMachines > 0 || flowerShowerMachines > 0 || totalElectricityKV > 0) ? `
                    <div class="card" style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 1.5rem; margin-top: 1rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">ðŸ§Š Materials Required</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                            ${dryMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">â„ï¸</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Dry Ice Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${dryIceNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    ðŸ“¦ ${dryMachines} dry machine(s) Ã— 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${flowerShowerMachines > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">ðŸŒ¸</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Flowers Needed</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${flowersNeeded} kg</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    ðŸŒº ${flowerShowerMachines} flower shower machine(s) Ã— 20 kg each
                                </div>
                            </div>
                            ` : ''}
                            ${totalElectricityKV > 0 ? `
                            <div style="background: rgba(255,255,255,0.2); padding: 1.5rem; border-radius: var(--radius);">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <div style="font-size: 2.5rem;">âš¡</div>
                                    <div>
                                        <div style="font-size: 0.9rem; opacity: 0.9; margin-bottom: 0.25rem;">Electricity Required</div>
                                        <div style="font-size: 2rem; font-weight: 700;">${totalElectricityKV} KV</div>
                                    </div>
                                </div>
                                <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.3);">
                                    âš¡ 3 KV items: ${items.filter(i => electricity3KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs | 1 KV items: ${items.filter(i => electricity1KV.some(name => i.name.toLowerCase().includes(name))).reduce((sum, i) => sum + i.required, 0)} pcs
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Export Buttons -->
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="OMS.printForecast()">ðŸ–¨ï¸ ${this.t('print')}</button>
                        <button class="btn btn-info" onclick="OMS.exportForecastPDF()">${this.t('exportPDF')}</button>
                        <button class="btn btn-warning" onclick="OMS.shareForecastWhatsApp()">${this.t('shareWhatsApp')}</button>
                    </div>

                    <!-- Items Table -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">ðŸ“¦ ${this.t('itemsPreparationList')}</h3>
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th style="width: 5%;">${this.t('sr')}</th>
                                        <th style="width: 25%;">${this.t('itemName')}</th>
                                        <th style="width: 10%;">${this.t('required')}</th>
                                        <th style="width: 10%;">${this.t('inStock')}</th>
                                        <th style="width: 10%;">${this.t('difference')}</th>
                                        <th style="width: 10%;">${this.t('status')}</th>
                                        <th style="width: 30%;">${this.t('usedInOrders')}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${items.map((item, index) => {
                                        const statusBadge = item.difference >= 0
                                            ? `<span style="background: var(--success); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">âœ… ${this.t('ok')}</span>`
                                            : `<span style="background: var(--danger); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">âš ï¸ ${this.t('short')} ${item.difference}</span>`;

                                        const ordersText = item.orders.slice(0, 3).map(o => o.orderId).join(', ') +
                                            (item.orders.length > 3 ? ` +${item.orders.length - 3} ${this.t('more')}` : '');

                                        return `
                                            <tr style="background: ${item.difference < 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'};">
                                                <td>${index + 1}</td>
                                                <td><strong>${item.name}</strong></td>
                                                <td><strong>${item.required}</strong></td>
                                                <td>${item.inStock}</td>
                                                <td style="color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                </td>
                                                <td>${statusBadge}</td>
                                                <td>
                                                    <small style="color: var(--text-gray);">${ordersText}</small>
                                                    <button class="btn btn-secondary btn-small" onclick="OMS.showItemOrderDetails('${item.name.replace(/'/g, "\\'")}')"> ${this.t('details')}</button>
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                                <tfoot>
                                    <tr style="background: var(--light); font-weight: 700;">
                                        <td colspan="2">${this.t('grandTotal')}</td>
                                        <td>${totalItems}</td>
                                        <td>${items.reduce((sum, i) => sum + i.inStock, 0)}</td>
                                        <td style="color: ${items.reduce((sum, i) => sum + i.difference, 0) >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                            ${items.reduce((sum, i) => sum + i.difference, 0)}
                                        </td>
                                        <td colspan="2"></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Orders Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">ðŸ“‹ ${this.t('orderDetailsBreakdown')}</h3>
                        </div>
                        <div style="display: grid; gap: 1rem;">
                            ${orders.map(order => {
                                const items = this.getItemsFromOrder(order, startDate, endDate);
                                const statusColor = {
                                    'Confirmed': 'var(--success)',
                                    'Completed': 'var(--info)',
                                    'Cancelled': 'var(--danger)'
                                }[order.status] || 'var(--warning)';

                                return `
                                    <div style="border: 2px solid var(--border); border-radius: var(--radius); padding: 1rem; background: var(--bg-card);">
                                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                                            <div>
                                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--primary);">${order.orderId}</div>
                                                <div style="color: var(--text-dark); font-weight: 500;">${order.clientName}</div>
                                                <div style="font-size: 0.9rem; color: var(--text-gray);">
                                                    ðŸ“ ${order.venue} |
                                                    ðŸ“… ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)} |
                                                    ðŸ• ${order.readyTime || 'N/A'}
                                                </div>
                                            </div>
                                            <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                ${order.status || 'Pending'}
                                            </span>
                                        </div>
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                                            <strong style="font-size: 0.9rem; color: var(--text-gray);">Items Required:</strong>
                                            <div style="margin-top: 0.25rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                ${items.map(item => `
                                                    <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                        ${item.name}: <strong>${item.quantity}</strong>
                                                    </span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                // Store current forecast data for export
                this.currentForecastData = {
                    orders,
                    items,
                    startDate,
                    endDate,
                    weatherData,
                    stats: {
                        totalOrders: orders.length,
                        confirmed: confirmedOrders,
                        pending: pendingOrders,
                        completed: completedOrders,
                        totalItems: totalItems,
                        shortages: shortageItems.length,
                        sufficient: okItems.length
                    }
                };

                // Set up weather auto-refresh for preparation tab (every 15 minutes)
                if (this.preparationWeatherInterval) {
                    clearInterval(this.preparationWeatherInterval);
                }
                this.preparationWeatherInterval = setInterval(() => this.updatePreparationWeather(), 900000);
            },

            async updatePreparationWeather() {
                if (!this.currentForecastData || !this.currentForecastData.startDate) return;

                try {
                    const weatherApiKey = this.data.settings.weatherApiKey || '';
                    const defaultCity = this.data.settings.defaultCity || 'Delhi';
                    const weatherData = await Utils.getWeatherForecast(defaultCity, this.currentForecastData.startDate, weatherApiKey);

                    // Update the stored weather data
                    this.currentForecastData.weatherData = weatherData;

                    // Re-render the forecast results with updated weather
                    this.renderForecastResults(
                        this.currentForecastData.orders,
                        this.currentForecastData.items,
                        this.currentForecastData.startDate,
                        this.currentForecastData.endDate,
                        weatherData
                    );
                } catch (error) {
                    console.error('Error updating preparation weather:', error);
                }
            },

            showItemOrderDetails(itemName) {
                if (!this.currentForecastData) return;

                const item = this.currentForecastData.items.find(i => i.name === itemName);
                if (!item) return;

                const ordersHtml = item.orders.map(o => `
                    <div style="padding: 0.75rem; border-bottom: 1px solid var(--border);">
                        <div style="font-weight: 600; color: var(--primary);">${o.orderId}</div>
                        <div style="color: var(--text-gray); font-size: 0.9rem;">${o.clientName}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                Pcs: <strong>${o.quantity}</strong>
                            </span>
                        </div>
                    </div>
                `).join('');

                this.showModal(`ðŸ“¦ ${itemName}`, `
                    <div style="margin-bottom: 1rem;">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${item.required}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Required</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);">${item.inStock}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">In Stock</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Difference</div>
                            </div>
                        </div>
                    </div>
                    <h3 style="margin-bottom: 0.5rem;">Used in ${item.orders.length} order(s):</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: var(--radius);">
                        ${ordersHtml}
                    </div>
                `);
            },

            printForecast() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to print', 'error');
                    return;
                }

                const { items, orders, startDate, endDate, stats } = this.currentForecastData;

                const printWindow = window.open('', '', 'width=800,height=600');
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Preparation Forecast - ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #667eea; margin-top: 20px; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #667eea; color: white; }
                            .shortage { background: #fee; color: #c00; font-weight: bold; }
                            .ok { background: #efe; color: #060; font-weight: bold; }
                            .summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
                            .summary-card { border: 2px solid #667eea; padding: 15px; border-radius: 8px; text-align: center; }
                            .summary-card .value { font-size: 2rem; font-weight: bold; color: #667eea; }
                            .summary-card .label { color: #666; margin-top: 5px; }
                            @media print {
                                button { display: none; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>ðŸ“‹ Preparation & Forecast Report</h1>
                        <p><strong>Period:</strong> ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</p>
                        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

                        <div class="summary">
                            <div class="summary-card">
                                <div class="value">${stats.totalOrders}</div>
                                <div class="label">Total Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${items.length}</div>
                                <div class="label">Unique Items</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.totalItems}</div>
                                <div class="label">Total Pieces</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.confirmed}</div>
                                <div class="label">Confirmed Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: ${stats.shortages > 0 ? '#c00' : '#060'};">${stats.shortages}</div>
                                <div class="label">Items Short</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: #060;">${stats.sufficient}</div>
                                <div class="label">Items OK</div>
                            </div>
                        </div>

                        <h2>ðŸ“¦ Items Preparation List</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Sr</th>
                                    <th>Item Name</th>
                                    <th>Required</th>
                                    <th>In Stock</th>
                                    <th>Difference</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr class="${item.difference < 0 ? 'shortage' : ''}">
                                        <td>${index + 1}</td>
                                        <td><strong>${item.name}</strong></td>
                                        <td>${item.required}</td>
                                        <td>${item.inStock}</td>
                                        <td class="${item.difference >= 0 ? 'ok' : 'shortage'}">
                                            ${item.difference >= 0 ? '+' : ''}${item.difference}
                                        </td>
                                        <td>${item.difference >= 0 ? 'âœ… OK' : 'âš ï¸ SHORT'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <h2>ðŸ“‹ Orders Summary</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order ID</th>
                                    <th>Client</th>
                                    <th>Venue</th>
                                    <th>Date</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${orders.map(order => `
                                    <tr>
                                        <td>${order.orderId}</td>
                                        <td>${order.clientName}</td>
                                        <td>${order.venue}</td>
                                        <td>${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}</td>
                                        <td>${order.status || 'Pending'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <button onclick="window.print()" style="background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-top: 20px;">
                            ðŸ–¨ï¸ Print This Report
                        </button>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            },

            exportForecastPDF() {
                this.showToast('PDF export coming soon! Use Print for now.', 'info');
                // Future: Implement PDF generation using jsPDF or similar
            },

            shareForecastWhatsApp() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to share', 'error');
                    return;
                }

                const { items, startDate, endDate, stats } = this.currentForecastData;

                // Create WhatsApp message
                let message = `ðŸ“‹ *PREPARATION FORECAST*\n\n`;
                message += `ðŸ“… *Period:* ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}\n\n`;
                message += `ðŸ“Š *SUMMARY*\n`;
                message += `â€¢ Total Orders: ${stats.totalOrders}\n`;
                message += `â€¢ Confirmed: ${stats.confirmed}\n`;
                message += `â€¢ Total Items: ${items.length}\n`;
                message += `â€¢ Total Pieces: ${stats.totalItems}\n`;
                message += `â€¢ Shortages: ${stats.shortages}\n\n`;

                message += `ðŸ“¦ *ITEMS NEEDED*\n`;
                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;

                items.forEach((item, index) => {
                    const status = item.difference >= 0 ? 'âœ…' : 'âš ï¸';
                    message += `${index + 1}. ${item.name}\n`;
                    message += `   Required: ${item.required} | Stock: ${item.inStock} | ${item.difference >= 0 ? '+' : ''}${item.difference} ${status}\n`;
                });

                message += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                message += `Generated: ${new Date().toLocaleString()}\n`;
                message += `\n_Powered by FirepowerSFX Admin_`;

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCustomers() {
                const container = document.getElementById('customers');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('customers')}</h2>
                        </div>
                        <div class="form-row">
                            <input type="text" id="customerSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}">
                            <button class="btn btn-primary" onclick="OMS.refreshCustomerDatabase()">ðŸ”„ ${this.t('reset')}</button>
                        </div>
                        <div id="customersContainer"></div>
                    </div>
                `;

                // Initial render with all customers
                this.filterAndDisplayCustomers('');

                // Add real-time search listener (only once)
                setTimeout(() => {
                    const searchInput = document.getElementById('customerSearch');
                    if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                            this.filterAndDisplayCustomers(e.target.value);
                        });
                    }
                }, 100);
            },

            filterAndDisplayCustomers(searchQuery) {
                // Filter customers based on search query
                let filteredCustomers = this.data.customers;
                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredCustomers = this.data.customers.filter(customer => {
                        return (
                            (customer.name && customer.name.toLowerCase().includes(query)) ||
                            (customer.contact && customer.contact.toLowerCase().includes(query)) ||
                            (customer.email && customer.email.toLowerCase().includes(query))
                        );
                    });
                }

                // Only re-render the table, not the entire page
                this.renderTable('customersContainer', [
                    { key: 'name', label: this.t('customerName') },
                    { key: 'contact', label: this.t('contact') },
                    { key: 'totalOrders', label: this.t('totalOrdersCount') },
                    { key: 'lastOrderDate', label: this.t('lastOrder'), render: c => Utils.formatDate(c.lastOrderDate) }
                ], filteredCustomers, (row) => `
                    <button class="btn btn-secondary btn-small" onclick="OMS.viewCustomerOrders('${row.id}')">${this.t('viewOrders')}</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.createOrderForCustomer('${row.id}')">${this.t('orders')}</button>
                `);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            async viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) {
                    this.showToast('Customer not found!', 'error');
                    return;
                }

                // Get all orders for this customer
                const customerOrders = this.data.orders.filter(o =>
                    o.clientName === customer.name || o.contact === customer.contact
                ).sort((a, b) => {
                    // Sort by date, newest first
                    const dateA = new Date(a.orderDate || a.createdAt || 0);
                    const dateB = new Date(b.orderDate || b.createdAt || 0);
                    return dateB - dateA;
                });

                // Calculate customer lifetime stats
                const totalSpent = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.grandTotal || o.totalAmount || 0), 0);
                const totalPaid = customerOrders.reduce((sum, o) => sum + parseFloat(o.financials?.advancePaid || 0), 0);
                const totalPending = totalSpent - totalPaid;
                const fullyPaidOrders = customerOrders.filter(o => parseFloat(o.financials?.balanceDue || 0) === 0).length;

                // Check if user can view financials
                const canViewFinancials = await this.canViewFinancials();

                const modalHTML = `
                    <div class="modal show" id="customerProfileModal" onclick="if(event.target === this) OMS.closeModal('customerProfileModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('customerProfileModal')">Ã—</button>
                            <h2>ðŸ‘¤ Customer Profile</h2>

                            <!-- Customer Info -->
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <h3 style="margin: 0 0 0.5rem 0; font-size: 1.75rem;">${customer.name}</h3>
                                        <p style="margin: 0.25rem 0; opacity: 0.9;">ðŸ“ž ${customer.contact || 'N/A'}</p>
                                        ${customer.email ? `<p style="margin: 0.25rem 0; opacity: 0.9;">ðŸ“§ ${customer.email}</p>` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 1.25rem; font-weight: bold;">Total Orders: ${customerOrders.length}</div>
                                        ${canViewFinancials ? `<div style="font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem;">Lifetime Value: â‚¹${totalSpent.toLocaleString('en-IN')}</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            ${canViewFinancials ? `
                                <!-- Lifetime Stats -->
                                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                                    <div style="background: #e8f5e9; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #4caf50;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #2e7d32;">â‚¹${totalSpent.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Spent</div>
                                    </div>
                                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #2196f3;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #1565c0;">â‚¹${totalPaid.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Total Paid</div>
                                    </div>
                                    <div style="background: #ffebee; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #f44336;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #c62828;">â‚¹${totalPending.toLocaleString('en-IN')}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Pending</div>
                                    </div>
                                    <div style="background: #f3e5f5; padding: 1rem; border-radius: 8px; text-align: center; border: 2px solid #9c27b0;">
                                        <div style="font-size: 1.5rem; font-weight: bold; color: #6a1b9a;">${fullyPaidOrders}/${customerOrders.length}</div>
                                        <div style="color: #666; font-size: 0.85rem; margin-top: 0.25rem;">Fully Paid</div>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- All Orders -->
                            <div>
                                <h3 style="margin: 0 0 1rem 0;">ðŸ“‹ All Orders</h3>
                                ${customerOrders.length === 0 ? '<p style="text-align: center; color: #999; padding: 2rem;">No orders found for this customer.</p>' : customerOrders.map(order => {
                                    const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                                    const totalPaid = parseFloat(order.financials?.advancePaid || 0);
                                    const balanceDue = parseFloat(order.financials?.balanceDue || 0);
                                    const paymentProgress = orderTotal > 0 ? (totalPaid / orderTotal) * 100 : 0;
                                    const paymentStatus = order.financials?.paymentStatus || 'pending';

                                    // Get payment history for this order
                                    const orderPayments = this.data.payments.filter(p => p.orderDocId === order.docId || p.orderId === order.orderId);

                                    // Get items
                                    let items = [];
                                    if (order.isMultiDay && order.dayWiseData) {
                                        order.dayWiseData.forEach(day => {
                                            if (day.functions) {
                                                day.functions.forEach(func => {
                                                    if (func.items) {
                                                        items.push(...func.items);
                                                    }
                                                });
                                            }
                                        });
                                    } else if (order.items) {
                                        items = order.items;
                                    }

                                    const statusColors = {
                                        'confirmed': '#2196f3',
                                        'pending': '#ff9800',
                                        'completed': '#4caf50',
                                        'cancelled': '#f44336'
                                    };
                                    const statusColor = statusColors[order.status?.toLowerCase()] || '#9e9e9e';

                                    return `
                                        <div style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem; background: white;">
                                            <!-- Order Header -->
                                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                                                <div>
                                                    <h4 style="margin: 0 0 0.5rem 0; color: #667eea; font-size: 1.1rem;">${order.orderId || 'Pending'}</h4>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        ðŸ“… ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}
                                                    </p>
                                                    <p style="margin: 0.25rem 0; color: #666; font-size: 0.9rem;">
                                                        ðŸ“ ${order.venue || 'N/A'}
                                                    </p>
                                                </div>
                                                <div style="text-align: right;">
                                                    <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.85rem; font-weight: 600;">${order.status || 'Pending'}</span>
                                                    ${canViewFinancials ? `
                                                        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
                                                            Total: <strong style="color: #667eea;">â‚¹${orderTotal.toLocaleString('en-IN')}</strong>
                                                        </div>
                                                    ` : ''}
                                                </div>
                                            </div>

                                            ${canViewFinancials ? `
                                                <!-- Payment Progress -->
                                                <div style="background: #f5f5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                                        <span style="font-size: 0.9rem; font-weight: 600;">Payment Status</span>
                                                        <span style="font-size: 0.9rem; font-weight: bold; color: ${paymentProgress === 100 ? '#4caf50' : '#667eea'};">
                                                            ${paymentProgress.toFixed(0)}% (â‚¹${totalPaid.toLocaleString('en-IN')} / â‚¹${orderTotal.toLocaleString('en-IN')})
                                                        </span>
                                                    </div>
                                                    <div style="width: 100%; height: 10px; background: #e0e0e0; border-radius: 5px; overflow: hidden;">
                                                        <div style="width: ${paymentProgress}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                                                    </div>
                                                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                                                        <span>âœ… Paid: â‚¹${totalPaid.toLocaleString('en-IN')}</span>
                                                        <span>â³ Due: â‚¹${balanceDue.toLocaleString('en-IN')}</span>
                                                    </div>
                                                </div>

                                                <!-- Payment History -->
                                                ${orderPayments.length > 0 ? `
                                                    <details style="margin-bottom: 1rem;">
                                                        <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">ðŸ’³ Payment History (${orderPayments.length} payments)</summary>
                                                        <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                            ${orderPayments.map(payment => `
                                                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #eee;">
                                                                    <div>
                                                                        <div style="font-weight: 600; color: #333;">${payment.paymentType || 'Payment'}</div>
                                                                        <div style="font-size: 0.85rem; color: #666;">${Utils.formatDate(payment.paymentDate || payment.timestamp?.toDate?.())} â€¢ ${payment.paymentMethod}</div>
                                                                    </div>
                                                                    <div style="font-weight: bold; color: #4caf50;">â‚¹${parseFloat(payment.amount).toLocaleString('en-IN')}</div>
                                                                </div>
                                                            `).join('')}
                                                        </div>
                                                    </details>
                                                ` : '<p style="font-size: 0.85rem; color: #999; margin-bottom: 1rem;">No payments recorded yet.</p>'}
                                            ` : ''}

                                            <!-- Order Items -->
                                            <details>
                                                <summary style="cursor: pointer; font-weight: 600; color: #667eea; padding: 0.5rem 0;">ðŸ“¦ Items (${items.length})</summary>
                                                <div style="margin-top: 0.75rem; padding-left: 1rem;">
                                                    ${items.map(item => `
                                                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0;">
                                                            <span style="color: #333;">${item.name}</span>
                                                            <span style="font-weight: 600; color: #667eea;">x${item.quantity}</span>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </details>
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid #e0e0e0;">
                                <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('customerProfileModal')">Close</button>
                                <button type="button" class="btn btn-primary" onclick="OMS.createOrderForCustomer('${customerId}'); OMS.closeModal('customerProfileModal');">âž• New Order</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ QUOTATIONS MANAGEMENT ============

            renderQuotations() {
                const container = document.getElementById('quotations');

                // Initialize quotations data if not exists
                if (!this.data.quotations) {
                    this.data.quotations = [];
                }

                const viewMode = this.quotationViewMode || 'list'; // 'list' or 'create'

                if (viewMode === 'create' || viewMode === 'edit') {
                    this.renderQuotationForm();
                } else {
                    this.renderQuotationsList();
                }
            },

            renderQuotationsList() {
                const container = document.getElementById('quotations');
                const quotations = this.data.quotations || [];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ðŸ“„ Quotations</h2>
                            <button class="btn btn-success" onclick="OMS.createNewQuotation()">âž• Create New Quotation</button>
                        </div>

                        <div class="form-row">
                            <input type="text" id="quotationSearch" class="form-input" placeholder="Search quotations by customer, date...">
                        </div>

                        <div id="quotationsListContainer">
                            ${quotations.length === 0 ? `
                                <div style="text-align: center; padding: 3rem; color: #999;">
                                    <h3>ðŸ“„ No Quotations Yet</h3>
                                    <p>Create your first quotation to get started</p>
                                    <button class="btn btn-primary" onclick="OMS.createNewQuotation()">Create Quotation</button>
                                </div>
                            ` : this.renderQuotationsTable(quotations)}
                        </div>
                    </div>
                `;

                // Add search listener
                setTimeout(() => {
                    const searchInput = document.getElementById('quotationSearch');
                    if (searchInput) {
                        searchInput.addEventListener('input', (e) => {
                            this.filterQuotations(e.target.value);
                        });
                    }
                }, 100);
            },

            renderQuotationsTable(quotations) {
                const sortedQuotations = quotations.sort((a, b) =>
                    new Date(b.createdAt) - new Date(a.createdAt)
                );

                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Customer</th>
                                    <th>Event Date</th>
                                    <th>Amount</th>
                                    <th>Status</th>
                                    <th>Created</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedQuotations.map(q => `
                                    <tr>
                                        <td>
                                            <strong>${q.customer.name}</strong><br>
                                            <small>${q.customer.contact}</small>
                                        </td>
                                        <td>${Utils.formatDate(q.customer.eventDate)}</td>
                                        <td><strong>â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <span class="status-badge ${q.status === 'converted' ? 'success' : q.status === 'sent' ? 'info' : 'warning'}">
                                                ${q.status === 'converted' ? 'âœ“ Converted' : q.status === 'sent' ? 'ðŸ“¤ Sent' : 'ðŸ“ Draft'}
                                            </span>
                                        </td>
                                        <td><small>${Utils.formatDate(q.createdAt)}</small></td>
                                        <td>
                                            <div class="btn-group">
                                                <button class="btn btn-info btn-small" onclick="OMS.viewQuotationPDF('${q.id}')" title="View PDF">ðŸ‘ï¸</button>
                                                <button class="btn btn-primary btn-small" onclick="OMS.editQuotation('${q.id}')" title="Edit">âœï¸</button>
                                                <button class="btn btn-success btn-small" onclick="OMS.sendQuotationWhatsApp('${q.id}')" title="Send WhatsApp">ðŸ“±</button>
                                                ${q.status !== 'converted' ? `<button class="btn btn-warning btn-small" onclick="OMS.convertQuotationToOrder('${q.id}')" title="Convert to Order">ðŸ”„</button>` : ''}
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteQuotation('${q.id}')" title="Delete">ðŸ—‘ï¸</button>
                                            </div>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            filterQuotations(searchQuery) {
                const quotations = this.data.quotations || [];
                let filteredQuotations = quotations;

                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredQuotations = quotations.filter(q => {
                        return (
                            (q.customer.name && q.customer.name.toLowerCase().includes(query)) ||
                            (q.customer.contact && q.customer.contact.includes(query)) ||
                            (q.customer.eventVenue && q.customer.eventVenue.toLowerCase().includes(query)) ||
                            (q.quotationNumber && q.quotationNumber.toLowerCase().includes(query))
                        );
                    });
                }

                document.getElementById('quotationsListContainer').innerHTML = this.renderQuotationsTable(filteredQuotations);
            },

            createNewQuotation() {
                this.editingQuotationId = null;
                this.currentQuotation = {
                    orderType: 'single', // 'single', 'multifunction', 'multiday'
                    items: [],
                    functions: [], // For multifunction single day
                    days: [], // For multiday orders
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                this.quotationViewMode = 'create';
                this.renderQuotations();
            },

            renderQuotationForm() {
                const container = document.getElementById('quotations');
                const q = this.currentQuotation || {
                    items: [],
                    customer: {},
                    discount: { type: 'percentage', value: 0, amount: 0 },
                    financials: { subtotal: 0, discountAmount: 0, grandTotal: 0 }
                };
                const isEditing = !!this.editingQuotationId;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h2 class="card-title">ðŸ“ ${isEditing ? 'Edit' : 'Create'} Quotation</h2>
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">â† Back to List</button>
                            </div>
                        </div>

                        <!-- Order Type Selection -->
                        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h3 style="color: white; margin: 0 0 1rem 0;">ðŸ“‹ Order Type</h3>
                            <p style="color: rgba(255,255,255,0.9); margin-bottom: 1rem; font-size: 0.9rem;">Select the type of quotation you want to create</p>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                                <button type="button" class="order-type-btn ${!q.orderType || q.orderType === 'single' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('single')" style="padding: 1.5rem; background: ${!q.orderType || q.orderType === 'single' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${!q.orderType || q.orderType === 'single' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">ðŸ“</div>
                                    <div>Single Function</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">One event, one day</div>
                                </button>
                                <button type="button" class="order-type-btn ${q.orderType === 'multifunction' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('multifunction')" style="padding: 1.5rem; background: ${q.orderType === 'multifunction' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${q.orderType === 'multifunction' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">ðŸ“‹</div>
                                    <div>Multiple Functions</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">Same day, different events</div>
                                </button>
                                <button type="button" class="order-type-btn ${q.orderType === 'multiday' ? 'active' : ''}" onclick="OMS.setQuotationOrderType('multiday')" style="padding: 1.5rem; background: ${q.orderType === 'multiday' ? 'white' : 'rgba(255,255,255,0.2)'}; color: ${q.orderType === 'multiday' ? '#667eea' : 'white'}; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">ðŸ“…</div>
                                    <div>Multiple Days</div>
                                    <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">Multiple days & functions</div>
                                </button>
                            </div>
                        </div>

                        <div class="card" style="background: #f9f9f9;">
                            <!-- Customer Details -->
                            <h3 style="margin: 0 0 1rem 0;">ðŸ‘¤ Customer Details</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label required">Customer Name</label>
                                    <input type="text" id="quotCustomerName" class="form-input" value="${q.customer.name || ''}" required placeholder="Enter customer name" list="customerNamesList" oninput="OMS.autoFillQuotationCustomer(this.value)">
                                    <datalist id="customerNamesList">
                                        ${this.data.customers.map(c => `<option value="${c.name}" data-contact="${c.contact}">`).join('')}
                                    </datalist>
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Contact Number</label>
                                    <input type="tel" id="quotCustomerContact" class="form-input" value="${q.customer.contact || ''}" required placeholder="Enter contact number">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Email (Optional)</label>
                                    <input type="email" id="quotCustomerEmail" class="form-input" value="${q.customer.email || ''}" placeholder="Enter email">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Event Date</label>
                                    <input type="date" id="quotEventDate" class="form-input" value="${q.customer.eventDate || ''}" required>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Event Venue</label>
                                <textarea id="quotEventVenue" class="form-input" rows="2" placeholder="Enter event venue address">${q.customer.eventVenue || ''}</textarea>
                            </div>
                        </div>

                        <!-- Items/Functions Section - Conditional based on order type -->
                        ${!q.orderType || q.orderType === 'single' ? `
                        <!-- Single Function Items -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">ðŸ“¦ Items</h3>
                            <div class="form-group" style="position: relative;">
                                <input type="text" id="quotItemSearch" class="form-input quotItemSearch" data-context="single" placeholder="ðŸ” Search items from inventory or add custom...">
                                <div id="quotItemSearchResults" class="search-dropdown" style="display: none;"></div>
                            </div>

                            <div id="quotationItemsContainer">
                                ${q.items && q.items.length === 0 ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No items added yet. Search and add items above.</p>
                                    </div>
                                ` : this.renderQuotationItems(q.items || [])}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addCustomQuotationItem()">âž• Add Custom Item</button>
                        </div>
                        ` : ''}

                        ${q.orderType === 'multifunction' ? `
                        <!-- Multiple Functions - Same Day -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">ðŸ“‹ Functions</h3>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">Add multiple functions for the same day event</p>

                            <div id="quotMultiFunctionsContainer">
                                ${(q.functions || []).map((func, idx) => this.renderQuotationFunction(func, idx)).join('')}
                                ${(!q.functions || q.functions.length === 0) ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No functions added yet. Click below to add your first function.</p>
                                    </div>
                                ` : ''}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addQuotationFunction()">âž• Add Function</button>
                        </div>
                        ` : ''}

                        ${q.orderType === 'multiday' ? `
                        <!-- Multiple Days -->
                        <div class="card">
                            <h3 style="margin: 0 0 1rem 0;">ðŸ“… Days & Functions</h3>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">Add days with functions and items for each day</p>

                            <div id="quotMultiDaysContainer">
                                ${(q.days || []).map((day, idx) => this.renderQuotationDay(day, idx)).join('')}
                                ${(!q.days || q.days.length === 0) ? `
                                    <div style="text-align: center; padding: 2rem; color: #999;">
                                        <p>No days added yet. Click below to add your first day.</p>
                                    </div>
                                ` : ''}
                            </div>

                            <button type="button" class="btn btn-primary" onclick="OMS.addQuotationDay()">âž• Add Day</button>
                        </div>
                        ` : ''}

                        <!-- Discount Section -->
                        <div class="card" style="background: #fff3cd;">
                            <h3 style="margin: 0 0 1rem 0;">ðŸ’° Discount</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Discount Type</label>
                                    <select id="quotDiscountType" class="form-select" onchange="OMS.updateQuotationDiscount()">
                                        <option value="percentage" ${q.discount.type === 'percentage' ? 'selected' : ''}>Percentage (%)</option>
                                        <option value="fixed" ${q.discount.type === 'fixed' ? 'selected' : ''}>Fixed Amount (â‚¹)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Discount Value</label>
                                    <input type="number" id="quotDiscountValue" class="form-input" value="${q.discount.value || 0}" min="0" step="0.01" oninput="OMS.updateQuotationDiscount()">
                                </div>
                            </div>
                        </div>

                        <!-- Financial Summary -->
                        <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h3 style="color: white; margin: 0 0 1.5rem 0;">ðŸ’µ Financial Summary</h3>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Subtotal:</span>
                                    <strong id="quotSubtotal">â‚¹0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Discount:</span>
                                    <strong id="quotDiscountAmount">- â‚¹0</strong>
                                </div>
                                <hr style="border-color: rgba(255,255,255,0.3);">
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0; font-size: 1.25rem;">
                                    <span><strong>Grand Total:</strong></span>
                                    <strong id="quotGrandTotal">â‚¹0</strong>
                                </div>
                            </div>

                            <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 8px;">
                                <h4 style="color: white; margin: 0 0 1rem 0; font-size: 1rem;">Payment Schedule:</h4>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Booking Amount (40%):</span>
                                    <strong id="quotBooking40">â‚¹0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Event Day Payment (40%):</span>
                                    <strong id="quotEventDay40">â‚¹0</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding: 0.5rem 0;">
                                    <span>Post-Event Payment (20%):</span>
                                    <strong id="quotPostEvent20">â‚¹0</strong>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div class="card">
                            <div class="btn-group">
                                <button class="btn btn-secondary" onclick="OMS.cancelQuotationEdit()">Cancel</button>
                                <button class="btn btn-info" onclick="OMS.previewQuotationPDF()">ðŸ‘ï¸ Preview PDF</button>
                                <button class="btn btn-primary" onclick="OMS.saveQuotation('draft')">ðŸ’¾ Save as Draft</button>
                                <button class="btn btn-success" onclick="OMS.saveAndSendQuotation()">ðŸ“± Save & Send WhatsApp</button>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize item search after render
                setTimeout(() => {
                    this.initQuotationItemSearch();
                    this.recalculateQuotation();
                }, 100);
            },

            renderQuotationItems(items) {
                return `
                    <div class="table-container">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th style="width: 5%;">#</th>
                                    <th style="width: 35%;">Item Name</th>
                                    <th style="width: 15%;">Quantity</th>
                                    <th style="width: 20%;">Rate (â‚¹)</th>
                                    <th style="width: 20%;">Subtotal</th>
                                    <th style="width: 5%;"></th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr>
                                        <td>${index + 1}</td>
                                        <td>
                                            <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationItem(${index}, 'name', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.quantity}" min="1" onchange="OMS.updateQuotationItem(${index}, 'quantity', this.value)" style="width: 100%;">
                                        </td>
                                        <td>
                                            <input type="number" class="form-input" value="${item.rate}" min="0" step="0.01" onchange="OMS.updateQuotationItem(${index}, 'rate', this.value)" style="width: 100%;">
                                        </td>
                                        <td><strong>â‚¹${item.subtotal.toLocaleString('en-IN')}</strong></td>
                                        <td>
                                            <button class="btn btn-danger btn-small" onclick="OMS.removeQuotationItem(${index})" title="Remove">Ã—</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            },

            initQuotationItemSearch() {
                // Setup search for all quotItemSearch inputs using event delegation
                const container = document.getElementById('quotations');
                if (!container) return;

                // Remove old listeners
                const oldSearchInputs = container.querySelectorAll('.quotItemSearch');
                oldSearchInputs.forEach(input => {
                    const clone = input.cloneNode(true);
                    input.parentNode.replaceChild(clone, input);
                });

                // Add listeners to all search inputs
                container.addEventListener('input', (e) => {
                    if (!e.target.classList.contains('quotItemSearch')) return;

                    const searchInput = e.target;
                    const query = searchInput.value.toLowerCase().trim();
                    const context = searchInput.dataset.context;
                    const funcIndex = searchInput.dataset.funcIndex;
                    const dayIndex = searchInput.dataset.dayIndex;

                    // Create or get dropdown
                    let dropdown = searchInput.parentElement.querySelector('.search-dropdown');
                    if (!dropdown) {
                        dropdown = document.createElement('div');
                        dropdown.className = 'search-dropdown';
                        dropdown.style.cssText = 'position: absolute; top: 100%; left: 0; right: 0; margin-top: 4px; z-index: 1000; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-height: 250px; overflow-y: auto; display: none;';
                        searchInput.parentElement.style.position = 'relative';
                        searchInput.parentElement.appendChild(dropdown);
                    }

                    if (query.length < 2) {
                        dropdown.style.display = 'none';
                        return;
                    }

                    // Search from inventory
                    const items = this.data.inventory?.items || [];
                    const matches = items.filter(item =>
                        item.name.toLowerCase().includes(query)
                    ).slice(0, 10);

                    if (matches.length > 0) {
                        dropdown.innerHTML = matches.map(item => {
                            const onclickHandler = context === 'single'
                                ? `OMS.selectQuotationItem('${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`
                                : context === 'multifunction'
                                ? `OMS.selectQuotationFunctionItem(${funcIndex}, '${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`
                                : `OMS.selectQuotationDayFunctionItem(${dayIndex}, ${funcIndex}, '${item.name.replace(/'/g, "\\'")}', ${item.defaultPrice || 0})`;

                            return `
                                <div onclick="${onclickHandler}"
                                     style="padding: 0.75rem 1rem; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s;"
                                     onmouseover="this.style.background='#f5f5f5'"
                                     onmouseout="this.style.background='white'">
                                    <div style="font-weight: 500;">${item.name}</div>
                                    <div style="font-size: 0.85rem; color: #666;">
                                        ${item.category ? `Category: ${item.category} â€¢ ` : ''}
                                        Price: â‚¹${(item.defaultPrice || 0).toLocaleString('en-IN')}
                                    </div>
                                </div>
                            `;
                        }).join('');
                        dropdown.style.display = 'block';
                    } else {
                        dropdown.style.display = 'none';
                    }
                });

                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('quotItemSearch')) {
                        container.querySelectorAll('.search-dropdown').forEach(d => d.style.display = 'none');
                    }
                });
            },

            selectQuotationFunctionItem(funcIndex, itemName, price) {
                if (!this.currentQuotation.functions[funcIndex].items) {
                    this.currentQuotation.functions[funcIndex].items = [];
                }
                this.currentQuotation.functions[funcIndex].items.push({
                    name: itemName,
                    quantity: 1,
                    price: price || 0
                });
                this.renderQuotations();
            },

            selectQuotationDayFunctionItem(dayIndex, funcIndex, itemName, price) {
                if (!this.currentQuotation.days[dayIndex].functions[funcIndex].items) {
                    this.currentQuotation.days[dayIndex].functions[funcIndex].items = [];
                }
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.push({
                    name: itemName,
                    quantity: 1,
                    price: price || 0
                });
                this.renderQuotations();
            },

            selectQuotationItem(itemName, price) {
                const dropdown = document.getElementById('quotItemSearchDropdown');
                const searchInput = document.getElementById('quotItemSearch');

                if (dropdown) dropdown.style.display = 'none';
                if (searchInput) searchInput.value = '';

                // Add item with price from inventory
                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: price || 0,
                    subtotal: price || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addQuotationItemByName(itemName) {
                // Search in inventory first
                const inventoryItem = this.data.inventory?.items?.find(i =>
                    i.name.toLowerCase() === itemName.toLowerCase()
                );

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: inventoryItem?.defaultPrice || 0,
                    subtotal: inventoryItem?.defaultPrice || 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            addCustomQuotationItem() {
                const itemName = prompt('Enter item name:');
                if (!itemName) return;

                const newItem = {
                    name: itemName,
                    quantity: 1,
                    rate: 0,
                    subtotal: 0
                };

                this.currentQuotation.items.push(newItem);
                this.updateQuotationDisplay();
            },

            updateQuotationItem(index, field, value) {
                if (!this.currentQuotation.items[index]) return;

                this.currentQuotation.items[index][field] = field === 'name' ? value : parseFloat(value) || 0;

                // Recalculate subtotal
                const item = this.currentQuotation.items[index];
                item.subtotal = item.quantity * item.rate;

                this.recalculateQuotation();
                this.updateQuotationDisplay();
            },

            removeQuotationItem(index) {
                this.currentQuotation.items.splice(index, 1);
                this.updateQuotationDisplay();
            },

            updateQuotationDiscount() {
                const type = Utils.get('quotDiscountType');
                const value = parseFloat(Utils.get('quotDiscountValue')) || 0;

                this.currentQuotation.discount = { type, value, amount: 0 };
                this.recalculateQuotation();
            },

            recalculateQuotation() {
                const q = this.currentQuotation;
                if (!q) return;

                // Calculate subtotal
                q.financials.subtotal = q.items.reduce((sum, item) => sum + item.subtotal, 0);

                // Calculate discount
                if (q.discount.type === 'percentage') {
                    q.financials.discountAmount = (q.financials.subtotal * q.discount.value) / 100;
                } else {
                    q.financials.discountAmount = q.discount.value;
                }

                // Calculate grand total
                q.financials.grandTotal = Math.max(0, q.financials.subtotal - q.financials.discountAmount);

                // Calculate payment schedule
                q.financials.booking40 = (q.financials.grandTotal * 0.4).toFixed(2);
                q.financials.eventDay40 = (q.financials.grandTotal * 0.4).toFixed(2);
                q.financials.postEvent20 = (q.financials.grandTotal * 0.2).toFixed(2);

                // Update display
                this.updateFinancialDisplay();
            },

            updateFinancialDisplay() {
                const q = this.currentQuotation;
                if (!q) return;

                const subtotalEl = document.getElementById('quotSubtotal');
                const discountEl = document.getElementById('quotDiscountAmount');
                const grandTotalEl = document.getElementById('quotGrandTotal');
                const booking40El = document.getElementById('quotBooking40');
                const eventDay40El = document.getElementById('quotEventDay40');
                const postEvent20El = document.getElementById('quotPostEvent20');

                if (subtotalEl) subtotalEl.textContent = `â‚¹${q.financials.subtotal.toLocaleString('en-IN')}`;
                if (discountEl) discountEl.textContent = `- â‚¹${q.financials.discountAmount.toLocaleString('en-IN')}`;
                if (grandTotalEl) grandTotalEl.textContent = `â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}`;
                if (booking40El) booking40El.textContent = `â‚¹${parseFloat(q.financials.booking40).toLocaleString('en-IN')}`;
                if (eventDay40El) eventDay40El.textContent = `â‚¹${parseFloat(q.financials.eventDay40).toLocaleString('en-IN')}`;
                if (postEvent20El) postEvent20El.textContent = `â‚¹${parseFloat(q.financials.postEvent20).toLocaleString('en-IN')}`;
            },

            updateQuotationDisplay() {
                const container = document.getElementById('quotationItemsContainer');
                if (container && this.currentQuotation) {
                    container.innerHTML = this.currentQuotation.items.length === 0 ?
                        `<div style="text-align: center; padding: 2rem; color: #999;"><p>No items added yet. Search and add items above.</p></div>` :
                        this.renderQuotationItems(this.currentQuotation.items);
                }
                this.recalculateQuotation();
            },

            autoFillQuotationCustomer(customerName) {
                // Find customer by name and auto-fill contact
                const customer = this.data.customers.find(c => c.name === customerName);
                if (customer) {
                    document.getElementById('quotCustomerContact').value = customer.contact || '';
                    if (customer.email) {
                        document.getElementById('quotCustomerEmail').value = customer.email;
                    }
                }
            },

            setQuotationOrderType(type) {
                if (!this.currentQuotation) return;
                this.currentQuotation.orderType = type;

                // Initialize appropriate data structures
                if (type === 'single') {
                    if (!this.currentQuotation.items) this.currentQuotation.items = [];
                } else if (type === 'multifunction') {
                    if (!this.currentQuotation.functions) this.currentQuotation.functions = [];
                } else if (type === 'multiday') {
                    if (!this.currentQuotation.days) this.currentQuotation.days = [];
                }

                this.renderQuotations();
            },

            renderQuotationFunction(func, index) {
                const items = func.items || [];
                return `
                    <div class="card" style="background: #f9f9f9; margin-bottom: 1rem; border-left: 4px solid var(--primary);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0;">Function ${index + 1}: ${func.name || 'Unnamed Function'}</h4>
                            <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationFunction(${index})">ðŸ—‘ï¸ Remove</button>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Function Type</label>
                            <input type="text" class="form-input" value="${func.name || ''}" list="quotFunctionsList"
                                   onchange="OMS.updateQuotationFunctionName(${index}, this.value)"
                                   placeholder="e.g., Sangeet, Reception, Haldi">
                            <datalist id="quotFunctionsList">
                                ${this.data.eventsList.map(event => `<option value="${event}">`).join('')}
                            </datalist>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Items</label>
                            <input type="text" class="form-input quotItemSearch" data-func-index="${index}" data-context="multifunction" placeholder="ðŸ” Search items from inventory..." style="margin-bottom: 0.5rem;">
                            <div id="quotFunctionItems_${index}">
                                ${items.map((item, itemIdx) => `
                                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'name', this.value)" placeholder="Item name">
                                        <input type="number" class="form-input" value="${item.quantity}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'quantity', this.value)" placeholder="Qty">
                                        <input type="number" class="form-input" value="${item.price}" onchange="OMS.updateQuotationFunctionItem(${index}, ${itemIdx}, 'price', this.value)" placeholder="Price">
                                        <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationFunctionItem(${index}, ${itemIdx})">Ã—</button>
                                    </div>
                                `).join('')}
                            </div>
                            <button type="button" class="btn btn-secondary btn-small" onclick="OMS.addQuotationFunctionItem(${index})">+ Add Item</button>
                        </div>
                    </div>
                `;
            },

            renderQuotationDay(day, dayIndex) {
                const functions = day.functions || [];
                return `
                    <div class="card" style="background: #e8f4f8; margin-bottom: 1rem; border-left: 4px solid #2196F3;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0;">ðŸ“… Day ${dayIndex + 1}: ${day.date || 'No date set'}</h4>
                            <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDay(${dayIndex})">ðŸ—‘ï¸ Remove Day</button>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Date</label>
                            <input type="date" class="form-input" value="${day.date || ''}" onchange="OMS.updateQuotationDayDate(${dayIndex}, this.value)">
                        </div>
                        <h5 style="margin: 1rem 0;">Functions for this day:</h5>
                        <div id="quotDayFunctions_${dayIndex}">
                            ${functions.map((func, funcIdx) => `
                                <div class="card" style="background: white; margin-bottom: 0.5rem;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <input type="text" class="form-input" style="flex: 1; margin-right: 0.5rem;" value="${func.name || ''}" list="quotFunctionsList_${dayIndex}_${funcIdx}"
                                               onchange="OMS.updateQuotationDayFunctionName(${dayIndex}, ${funcIdx}, this.value)"
                                               placeholder="Function type">
                                        <datalist id="quotFunctionsList_${dayIndex}_${funcIdx}">
                                            ${this.data.eventsList.map(event => `<option value="${event}">`).join('')}
                                        </datalist>
                                        <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDayFunction(${dayIndex}, ${funcIdx})">Ã—</button>
                                    </div>
                                    <input type="text" class="form-input quotItemSearch" data-day-index="${dayIndex}" data-func-index="${funcIdx}" data-context="multiday" placeholder="ðŸ” Search items..." style="margin-bottom: 0.5rem;">
                                    <div id="quotDayFunctionItems_${dayIndex}_${funcIdx}">
                                        ${(func.items || []).map((item, itemIdx) => `
                                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 0.5rem; margin-bottom: 0.5rem;">
                                                <input type="text" class="form-input" value="${item.name}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'name', this.value)" placeholder="Item">
                                                <input type="number" class="form-input" value="${item.quantity}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'quantity', this.value)" placeholder="Qty">
                                                <input type="number" class="form-input" value="${item.price}" onchange="OMS.updateQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx}, 'price', this.value)" placeholder="Price">
                                                <button type="button" class="btn btn-danger btn-small" onclick="OMS.removeQuotationDayFunctionItem(${dayIndex}, ${funcIdx}, ${itemIdx})">Ã—</button>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button type="button" class="btn btn-secondary btn-small" onclick="OMS.addQuotationDayFunctionItem(${dayIndex}, ${funcIdx})">+ Add Item</button>
                                </div>
                            `).join('')}
                        </div>
                        <button type="button" class="btn btn-primary btn-small" onclick="OMS.addQuotationDayFunction(${dayIndex})">+ Add Function</button>
                    </div>
                `;
            },

            addQuotationFunction() {
                if (!this.currentQuotation.functions) this.currentQuotation.functions = [];
                this.currentQuotation.functions.push({ name: '', items: [] });
                this.renderQuotations();
            },

            addQuotationDay() {
                if (!this.currentQuotation.days) this.currentQuotation.days = [];
                this.currentQuotation.days.push({ date: '', functions: [] });
                this.renderQuotations();
            },

            removeQuotationFunction(index) {
                if (confirm('Remove this function?')) {
                    this.currentQuotation.functions.splice(index, 1);
                    this.renderQuotations();
                }
            },

            removeQuotationDay(index) {
                if (confirm('Remove this day?')) {
                    this.currentQuotation.days.splice(index, 1);
                    this.renderQuotations();
                }
            },

            updateQuotationFunctionName(funcIndex, value) {
                this.currentQuotation.functions[funcIndex].name = value;
                this.recalculateQuotation();
            },

            addQuotationFunctionItem(funcIndex) {
                if (!this.currentQuotation.functions[funcIndex].items) {
                    this.currentQuotation.functions[funcIndex].items = [];
                }
                this.currentQuotation.functions[funcIndex].items.push({ name: '', quantity: 1, price: 0 });
                this.renderQuotations();
            },

            removeQuotationFunctionItem(funcIndex, itemIndex) {
                this.currentQuotation.functions[funcIndex].items.splice(itemIndex, 1);
                this.renderQuotations();
            },

            updateQuotationFunctionItem(funcIndex, itemIndex, field, value) {
                this.currentQuotation.functions[funcIndex].items[itemIndex][field] = field === 'name' ? value : parseFloat(value) || 0;
                this.recalculateQuotation();
            },

            updateQuotationDayDate(dayIndex, value) {
                this.currentQuotation.days[dayIndex].date = value;
            },

            addQuotationDayFunction(dayIndex) {
                if (!this.currentQuotation.days[dayIndex].functions) {
                    this.currentQuotation.days[dayIndex].functions = [];
                }
                this.currentQuotation.days[dayIndex].functions.push({ name: '', items: [] });
                this.renderQuotations();
            },

            removeQuotationDayFunction(dayIndex, funcIndex) {
                this.currentQuotation.days[dayIndex].functions.splice(funcIndex, 1);
                this.renderQuotations();
            },

            updateQuotationDayFunctionName(dayIndex, funcIndex, value) {
                this.currentQuotation.days[dayIndex].functions[funcIndex].name = value;
            },

            addQuotationDayFunctionItem(dayIndex, funcIndex) {
                if (!this.currentQuotation.days[dayIndex].functions[funcIndex].items) {
                    this.currentQuotation.days[dayIndex].functions[funcIndex].items = [];
                }
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.push({ name: '', quantity: 1, price: 0 });
                this.renderQuotations();
            },

            removeQuotationDayFunctionItem(dayIndex, funcIndex, itemIndex) {
                this.currentQuotation.days[dayIndex].functions[funcIndex].items.splice(itemIndex, 1);
                this.renderQuotations();
            },

            updateQuotationDayFunctionItem(dayIndex, funcIndex, itemIndex, field, value) {
                this.currentQuotation.days[dayIndex].functions[funcIndex].items[itemIndex][field] = field === 'name' ? value : parseFloat(value) || 0;
                this.recalculateQuotation();
            },

            cancelQuotationEdit() {
                this.quotationViewMode = 'list';
                this.editingQuotationId = null;
                this.currentQuotation = null;
                this.renderQuotations();
            },

            async saveQuotation(status = 'draft') {
                const q = this.currentQuotation;
                if (!q) return;

                // Validate
                const customerName = Utils.get('quotCustomerName');
                const customerContact = Utils.get('quotCustomerContact');
                const eventDate = Utils.get('quotEventDate');

                if (!customerName || !customerContact || !eventDate) {
                    this.showToast('Please fill customer name, contact, and event date', 'error');
                    return;
                }

                if (q.items.length === 0) {
                    this.showToast('Please add at least one item', 'error');
                    return;
                }

                // Gather data
                q.customer = {
                    name: customerName,
                    contact: customerContact,
                    email: Utils.get('quotCustomerEmail'),
                    eventDate: eventDate,
                    eventVenue: Utils.get('quotEventVenue')
                };

                const quotationData = {
                    ...q,
                    status: status,
                    updatedAt: new Date().toISOString()
                };

                try {
                    if (this.editingQuotationId) {
                        // Update existing
                        quotationData.id = this.editingQuotationId;
                        quotationData.quotationNumber = q.quotationNumber;
                        quotationData.createdAt = q.createdAt;

                        await db.collection('quotations').doc(this.editingQuotationId).update(quotationData);
                        this.showToast('âœ… Quotation updated!', 'success');
                    } else {
                        // Create new
                        quotationData.quotationNumber = await this.generateQuotationNumber();
                        quotationData.createdAt = new Date().toISOString();
                        quotationData.quotationDate = new Date().toISOString().split('T')[0];
                        quotationData.validUntil = this.calculateValidUntil();

                        const docRef = await db.collection('quotations').add(quotationData);
                        quotationData.id = docRef.id;

                        this.showToast('âœ… Quotation saved!', 'success');
                    }

                    // Reload quotations
                    await this.loadQuotationsFromFirestore();

                    // Return to list
                    this.quotationViewMode = 'list';
                    this.renderQuotations();

                    return quotationData;
                } catch (error) {
                    console.error('Error saving quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async generateQuotationNumber() {
                const year = new Date().getFullYear();
                const quotations = this.data.quotations || [];
                const thisYearQuotations = quotations.filter(q =>
                    q.quotationNumber && q.quotationNumber.startsWith(`QT-${year}`)
                );

                const nextNumber = thisYearQuotations.length + 1;
                return `QT-${year}-${String(nextNumber).padStart(3, '0')}`;
            },

            calculateValidUntil() {
                const date = new Date();
                date.setDate(date.getDate() + 15); // Valid for 15 days
                return date.toISOString().split('T')[0];
            },

            async saveAndSendQuotation() {
                const quotation = await this.saveQuotation('sent');
                if (quotation) {
                    await this.sendQuotationWhatsApp(quotation.id);
                }
            },

            async editQuotation(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) {
                    this.showToast('Quotation not found', 'error');
                    return;
                }

                this.editingQuotationId = quotationId;
                this.currentQuotation = JSON.parse(JSON.stringify(quotation)); // Deep copy
                this.quotationViewMode = 'edit';
                this.renderQuotations();
            },

            async deleteQuotation(quotationId) {
                if (!confirm('Delete this quotation?')) return;

                try {
                    await db.collection('quotations').doc(quotationId).delete();
                    this.showToast('âœ… Quotation deleted', 'success');

                    await this.loadQuotationsFromFirestore();
                    this.renderQuotations();
                } catch (error) {
                    console.error('Error deleting quotation:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async loadQuotationsFromFirestore() {
                try {
                    const snapshot = await db.collection('quotations').orderBy('createdAt', 'desc').get();
                    const quotations = [];

                    snapshot.forEach(doc => {
                        quotations.push({ id: doc.id, ...doc.data() });
                    });

                    this.data.quotations = quotations;
                    console.log(`âœ… Loaded ${quotations.length} quotations`);
                } catch (error) {
                    console.error('Error loading quotations:', error);
                }
            },

            async viewQuotationPDF(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                this.generateAndShowPDF(quotation);
            },

            async previewQuotationPDF() {
                const q = this.currentQuotation;
                if (!q || q.items.length === 0) {
                    this.showToast('Add items first to preview', 'error');
                    return;
                }

                // Create temporary quotation object for preview
                const tempQuotation = {
                    ...q,
                    customer: {
                        name: Utils.get('quotCustomerName') || 'Customer Name',
                        contact: Utils.get('quotCustomerContact') || '0000000000',
                        email: Utils.get('quotCustomerEmail') || '',
                        eventDate: Utils.get('quotEventDate') || '',
                        eventVenue: Utils.get('quotEventVenue') || ''
                    },
                    quotationDate: new Date().toISOString().split('T')[0],
                    validUntil: this.calculateValidUntil()
                };

                this.generateAndShowPDF(tempQuotation);
            },

            generateAndShowPDF(quotation) {
                // This will use jsPDF or html2pdf - for now, show preview in modal
                const modalHTML = `
                    <div class="modal show" id="pdfPreviewModal" onclick="if(event.target === this) OMS.closeModal('pdfPreviewModal')" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                            <button class="modal-close" onclick="OMS.closeModal('pdfPreviewModal')">Ã—</button>
                            <h2>ðŸ“„ Quotation Preview</h2>

                            ${this.renderQuotationPDFContent(quotation)}

                            <div style="margin-top: 2rem; text-align: center;">
                                <button class="btn btn-primary" onclick="OMS.downloadQuotationPDF('${quotation.id}')">ðŸ“¥ Download PDF</button>
                                <button class="btn btn-success" onclick="OMS.sendQuotationWhatsApp('${quotation.id}')">ðŸ“± Send WhatsApp</button>
                                <button class="btn btn-secondary" onclick="OMS.closeModal('pdfPreviewModal')">Close</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            renderQuotationPDFContent(q) {
                return `
                    <div id="quotationPDFContent" style="background: white; padding: 3rem; font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; border: 2px solid #ddd;">
                        <!-- Header -->
                        <div style="text-align: center; margin-bottom: 2rem; border-bottom: 3px solid #667eea; padding-bottom: 1.5rem;">
                            <h1 style="margin: 0; font-size: 2.5rem; color: #667eea;">QUOTATION</h1>
                            <div style="margin-top: 1rem; color: #666;">
                                <div>Date: ${Utils.formatDate(q.quotationDate || new Date().toISOString().split('T')[0])}</div>
                                <div>Valid Until: ${Utils.formatDate(q.validUntil || this.calculateValidUntil())}</div>
                                <div style="margin-top: 0.5rem; font-weight: bold; font-size: 1.1rem;">
                                    ðŸ“± 98984 96111 / 76984 96111
                                </div>
                            </div>
                        </div>

                        <!-- Customer Details -->
                        <div style="background: #f9f9f9; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">Customer Details</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold; width: 150px;">Name:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.name}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Contact:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.contact}</td>
                                </tr>
                                ${q.customer.email ? `
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Email:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.email}</td>
                                </tr>
                                ` : ''}
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold;">Event Date:</td>
                                    <td style="padding: 0.5rem 0;">${Utils.formatDate(q.customer.eventDate)}</td>
                                </tr>
                                ${q.customer.eventVenue ? `
                                <tr>
                                    <td style="padding: 0.5rem 0; font-weight: bold; vertical-align: top;">Venue:</td>
                                    <td style="padding: 0.5rem 0;">${q.customer.eventVenue}</td>
                                </tr>
                                ` : ''}
                            </table>
                        </div>

                        <!-- Items Table -->
                        <div style="margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #667eea;">Items</h3>
                            <table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;">
                                <thead style="background: #667eea; color: white;">
                                    <tr>
                                        <th style="padding: 0.75rem; text-align: left; border: 1px solid #ddd;">#</th>
                                        <th style="padding: 0.75rem; text-align: left; border: 1px solid #ddd;">Item Name</th>
                                        <th style="padding: 0.75rem; text-align: center; border: 1px solid #ddd;">Qty</th>
                                        <th style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">Rate (â‚¹)</th>
                                        <th style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">Amount (â‚¹)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${q.items.map((item, index) => `
                                        <tr>
                                            <td style="padding: 0.75rem; border: 1px solid #ddd;">${index + 1}</td>
                                            <td style="padding: 0.75rem; border: 1px solid #ddd;">${item.name}</td>
                                            <td style="padding: 0.75rem; text-align: center; border: 1px solid #ddd;">${item.quantity}</td>
                                            <td style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">â‚¹${item.rate.toLocaleString('en-IN')}</td>
                                            <td style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">â‚¹${item.subtotal.toLocaleString('en-IN')}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>

                        <!-- Financial Summary -->
                        <div style="margin-bottom: 2rem; border: 2px solid #667eea; border-radius: 8px; padding: 1.5rem; background: #f9f9ff;">
                            <table style="width: 100%; max-width: 400px; margin-left: auto;">
                                <tr>
                                    <td style="padding: 0.5rem; text-align: right;">Subtotal:</td>
                                    <td style="padding: 0.5rem; text-align: right; font-weight: bold;">â‚¹${q.financials.subtotal.toLocaleString('en-IN')}</td>
                                </tr>
                                ${q.financials.discountAmount > 0 ? `
                                <tr>
                                    <td style="padding: 0.5rem; text-align: right;">Discount:</td>
                                    <td style="padding: 0.5rem; text-align: right; color: #f44336; font-weight: bold;">- â‚¹${q.financials.discountAmount.toLocaleString('en-IN')}</td>
                                </tr>
                                ` : ''}
                                <tr style="border-top: 2px solid #667eea;">
                                    <td style="padding: 0.75rem; text-align: right; font-size: 1.25rem; font-weight: bold;">Grand Total:</td>
                                    <td style="padding: 0.75rem; text-align: right; font-size: 1.25rem; font-weight: bold; color: #667eea;">â‚¹${q.financials.grandTotal.toLocaleString('en-IN')}</td>
                                </tr>
                            </table>
                        </div>

                        <!-- Payment Schedule -->
                        <div style="background: #e8f5e9; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
                            <h3 style="margin: 0 0 1rem 0; color: #2e7d32;">Payment Schedule</h3>
                            <ul style="list-style: none; padding: 0; margin: 0;">
                                <li style="padding: 0.5rem 0; border-bottom: 1px solid #ddd;">
                                    <strong>Booking Amount (50%):</strong>
                                    <span style="float: right; font-weight: bold;">â‚¹${(q.financials.grandTotal * 0.5).toLocaleString('en-IN')}</span>
                                </li>
                                <li style="padding: 0.5rem 0;">
                                    <strong>Remaining Amount Before Event (50%):</strong>
                                    <span style="float: right; font-weight: bold;">â‚¹${(q.financials.grandTotal * 0.5).toLocaleString('en-IN')}</span>
                                </li>
                            </ul>
                        </div>

                        <!-- Terms & Conditions -->
                        <div style="background: #fff3e0; padding: 1.5rem; border-radius: 8px; font-size: 0.9rem; line-height: 1.6;">
                            <h3 style="margin: 0 0 1rem 0; color: #e65100;">Terms & Conditions</h3>

                            <p style="margin: 0 0 0.5rem 0;"><strong>PAYMENT TERMS:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>50% booking amount required to confirm order</li>
                                <li>Remaining 50% payment before event starts</li>
                            </ul>

                            <p style="margin: 0 0 0.5rem 0;"><strong>INCLUSIONS:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>Generator for electricity provision</li>
                            </ul>

                            <p style="margin: 0 0 0.5rem 0;"><strong>CUSTOMER RESPONSIBILITIES:</strong></p>
                            <ul style="margin: 0 0 1rem 0; padding-left: 1.5rem;">
                                <li>Fire safety permissions and Fire NOC</li>
                                <li>Venue/ground permissions</li>
                                <li>AMC (Amusement Park) permissions</li>
                                <li>First aid provision arrangements</li>
                                <li>Resource/facility manager approval</li>
                                <li>Proof of contractor competence</li>
                                <li>Security clearance for restricted materials</li>
                            </ul>

                            <p style="margin: 0;"><strong>VALIDITY:</strong> 15 days from quotation date</p>
                        </div>

                        <!-- Footer -->
                        <div style="text-align: center; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid #ddd; color: #666;">
                            <p style="margin: 0;">For any queries, please contact:</p>
                            <p style="margin: 0.5rem 0; font-weight: bold; font-size: 1.1rem; color: #667eea;">ðŸ“± 98984 96111 / 76984 96111</p>
                        </div>
                    </div>
                `;
            },

            async downloadQuotationPDF(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                try {
                    // Access jsPDF from global window object
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 20;
                    let yPos = 20;

                    // Purple color theme
                    const primaryColor = [102, 126, 234]; // #667eea
                    const darkText = [31, 41, 55];
                    const grayText = [107, 114, 128];

                    // === HEADER SECTION ===
                    // Business Name (left)
                    doc.setFontSize(20);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Business', margin, yPos);
                    doc.setFontSize(16);
                    doc.text('Name.', margin, yPos + 7);

                    // QUOTATION Title (right)
                    doc.setFontSize(28);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('QUOTATION', pageWidth - margin, yPos, { align: 'right' });

                    // Date info (right side)
                    yPos += 10;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...grayText);
                    doc.text(`Date: ${Utils.formatDate(quotation.quotationDate || new Date().toISOString().split('T')[0])}`, pageWidth - margin, yPos, { align: 'right' });
                    yPos += 5;
                    doc.text(`Valid Until: ${Utils.formatDate(quotation.validUntil || this.calculateValidUntil())}`, pageWidth - margin, yPos, { align: 'right' });

                    // Contact numbers (centered, prominent)
                    yPos += 10;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('ðŸ“± 98984 96111 / 76984 96111', pageWidth / 2, yPos, { align: 'center' });

                    // Purple line separator
                    yPos += 5;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(2);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    // === CUSTOMER DETAILS BOX ===
                    yPos += 10;
                    doc.setFillColor(249, 249, 249);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 30, 'F');

                    yPos += 7;
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Customer Details', margin + 5, yPos);

                    yPos += 6;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('Name:', margin + 5, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.name, margin + 25, yPos);

                    yPos += 5;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Contact:', margin + 5, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(quotation.customer.contact, margin + 25, yPos);

                    yPos += 5;
                    doc.setFont('helvetica', 'bold');
                    doc.text('Event Date:', margin + 5, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(Utils.formatDate(quotation.customer.eventDate), margin + 25, yPos);

                    if (quotation.customer.eventVenue) {
                        yPos += 5;
                        doc.setFont('helvetica', 'bold');
                        doc.text('Venue:', margin + 5, yPos);
                        doc.setFont('helvetica', 'normal');
                        const venueText = doc.splitTextToSize(quotation.customer.eventVenue, pageWidth - margin - 35);
                        doc.text(venueText, margin + 25, yPos);
                    }

                    // === ITEMS TABLE ===
                    yPos += 15;
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('Items', margin, yPos);

                    yPos += 5;

                    // Table header
                    doc.setFillColor(...primaryColor);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 8, 'F');

                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text('#', margin + 2, yPos + 5);
                    doc.text('Item Description', margin + 10, yPos + 5);
                    doc.text('Qty', margin + 100, yPos + 5);
                    doc.text('Rate (â‚¹)', margin + 120, yPos + 5);
                    doc.text('Total (â‚¹)', pageWidth - margin - 20, yPos + 5, { align: 'right' });

                    yPos += 8;

                    // Table rows
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    quotation.items.forEach((item, index) => {
                        if (yPos > pageHeight - 60) {
                            doc.addPage();
                            yPos = 20;
                        }

                        // Alternating row colors
                        if (index % 2 === 0) {
                            doc.setFillColor(248, 249, 250);
                            doc.rect(margin, yPos, pageWidth - 2 * margin, 7, 'F');
                        }

                        doc.setFontSize(9);
                        doc.text((index + 1).toString(), margin + 2, yPos + 5);

                        const itemName = doc.splitTextToSize(item.name, 85);
                        doc.text(itemName, margin + 10, yPos + 5);

                        doc.text(item.quantity.toString(), margin + 100, yPos + 5);
                        doc.text(`â‚¹${item.rate.toLocaleString('en-IN')}`, margin + 120, yPos + 5);
                        doc.text(`â‚¹${item.subtotal.toLocaleString('en-IN')}`, pageWidth - margin - 2, yPos + 5, { align: 'right' });

                        yPos += 7;
                    });

                    // Table bottom border
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    // === FINANCIAL SUMMARY BOX ===
                    yPos += 10;

                    const summaryBoxX = pageWidth - margin - 70;
                    const summaryBoxWidth = 70;

                    // Subtotal
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('Subtotal:', summaryBoxX, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(`â‚¹${quotation.financials.subtotal.toLocaleString('en-IN')}`, pageWidth - margin - 2, yPos, { align: 'right' });

                    // Discount
                    if (quotation.financials.discountAmount > 0) {
                        yPos += 6;
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(239, 68, 68); // red
                        doc.text('Discount:', summaryBoxX, yPos);
                        doc.setFont('helvetica', 'bold');
                        doc.text(`- â‚¹${quotation.financials.discountAmount.toLocaleString('en-IN')}`, pageWidth - margin - 2, yPos, { align: 'right' });
                    }

                    // Grand Total
                    yPos += 8;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(1.5);
                    doc.line(summaryBoxX, yPos - 2, pageWidth - margin, yPos - 2);

                    yPos += 4;
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('TOTAL:', summaryBoxX, yPos);
                    doc.setFontSize(14);
                    doc.text(`â‚¹${quotation.financials.grandTotal.toLocaleString('en-IN')}`, pageWidth - margin - 2, yPos, { align: 'right' });

                    // === PAYMENT SCHEDULE BOX ===
                    yPos += 12;
                    doc.setFillColor(232, 245, 233);
                    doc.rect(margin, yPos, pageWidth - 2 * margin, 25, 'F');

                    yPos += 7;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(46, 125, 50);
                    doc.text('Payment Schedule', margin + 5, yPos);

                    yPos += 6;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...darkText);
                    doc.text('â€¢ Booking Amount (40%):', margin + 5, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(`â‚¹${parseFloat(quotation.financials.booking40).toLocaleString('en-IN')}`, pageWidth - margin - 5, yPos, { align: 'right' });

                    yPos += 5;
                    doc.setFont('helvetica', 'normal');
                    doc.text('â€¢ Event Day Payment (40%):', margin + 5, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(`â‚¹${parseFloat(quotation.financials.eventDay40).toLocaleString('en-IN')}`, pageWidth - margin - 5, yPos, { align: 'right' });

                    yPos += 5;
                    doc.setFont('helvetica', 'normal');
                    doc.text('â€¢ Post-Event Payment (20%):', margin + 5, yPos);
                    doc.setFont('helvetica', 'bold');
                    doc.text(`â‚¹${parseFloat(quotation.financials.postEvent20).toLocaleString('en-IN')}`, pageWidth - margin - 5, yPos, { align: 'right' });

                    // === TERMS & CONDITIONS ===
                    yPos += 12;
                    if (yPos > pageHeight - 80) {
                        doc.addPage();
                        yPos = 20;
                    }

                    doc.setFillColor(255, 243, 224);
                    const termsHeight = 70;
                    doc.rect(margin, yPos, pageWidth - 2 * margin, termsHeight, 'F');

                    yPos += 7;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(230, 81, 0);
                    doc.text('Terms & Conditions', margin + 5, yPos);

                    yPos += 6;
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...darkText);
                    doc.text('PAYMENT TERMS:', margin + 5, yPos);

                    yPos += 4;
                    doc.setFont('helvetica', 'normal');
                    doc.text('â€¢ 40% booking amount required to confirm order', margin + 7, yPos);
                    yPos += 3.5;
                    doc.text('â€¢ 40% payment on event day before event starts', margin + 7, yPos);
                    yPos += 3.5;
                    doc.text('â€¢ 20% payment after event completion on same day', margin + 7, yPos);

                    yPos += 5;
                    doc.setFont('helvetica', 'bold');
                    doc.text('INCLUSIONS:', margin + 5, yPos);
                    yPos += 4;
                    doc.setFont('helvetica', 'normal');
                    doc.text('â€¢ Generator for electricity provision', margin + 7, yPos);

                    yPos += 5;
                    doc.setFont('helvetica', 'bold');
                    doc.text('CUSTOMER RESPONSIBILITIES:', margin + 5, yPos);
                    yPos += 4;
                    doc.setFont('helvetica', 'normal');
                    const responsibilities = [
                        'â€¢ Fire safety permissions and Fire NOC',
                        'â€¢ Venue/ground permissions',
                        'â€¢ AMC permissions',
                        'â€¢ First aid provision',
                        'â€¢ Resource/facility manager approval',
                        'â€¢ Proof of contractor competence',
                        'â€¢ Security clearance'
                    ];
                    responsibilities.forEach(resp => {
                        doc.text(resp, margin + 7, yPos);
                        yPos += 3.5;
                    });

                    yPos += 3;
                    doc.setFont('helvetica', 'bold');
                    doc.text('VALIDITY:', margin + 5, yPos);
                    doc.setFont('helvetica', 'normal');
                    doc.text(' 15 days from quotation date', margin + 21, yPos);

                    // === FOOTER ===
                    yPos = pageHeight - 20;
                    doc.setDrawColor(...primaryColor);
                    doc.setLineWidth(2);
                    doc.line(margin, yPos, pageWidth - margin, yPos);

                    yPos += 5;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...grayText);
                    doc.text('For any queries, please contact:', pageWidth / 2, yPos, { align: 'center' });

                    yPos += 5;
                    doc.setFontSize(11);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...primaryColor);
                    doc.text('ðŸ“± 98984 96111 / 76984 96111', pageWidth / 2, yPos, { align: 'center' });

                    // Save PDF
                    const fileName = `Quotation_${quotation.customer.name.replace(/\s+/g, '_')}_${quotation.quotationDate || 'draft'}.pdf`;
                    doc.save(fileName);

                    this.showToast('âœ… PDF downloaded successfully!', 'success');
                } catch (error) {
                    console.error('Error generating PDF:', error);
                    this.showToast('Error generating PDF: ' + error.message, 'error');
                }
            },

            async sendQuotationWhatsApp(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                const message = `Hi ${quotation.customer.name}!

Thank you for your interest. Please find your quotation details:

*Event Date:* ${Utils.formatDate(quotation.customer.eventDate)}
*Total Amount:* â‚¹${quotation.financials.grandTotal.toLocaleString('en-IN')}

*Payment Schedule:*
â€¢ Booking (40%): â‚¹${parseFloat(quotation.financials.booking40).toLocaleString('en-IN')}
â€¢ Event Day (40%): â‚¹${parseFloat(quotation.financials.eventDay40).toLocaleString('en-IN')}
â€¢ Post-Event (20%): â‚¹${parseFloat(quotation.financials.postEvent20).toLocaleString('en-IN')}

Valid until: ${Utils.formatDate(quotation.validUntil)}

Contact: ðŸ“± 98984 96111 / 76984 96111`;

                const whatsappURL = `https://wa.me/91${quotation.customer.contact.replace(/\D/g, '')}?text=${encodeURIComponent(message)}`;
                window.open(whatsappURL, '_blank');

                // Update status to sent
                if (quotation.status === 'draft') {
                    await db.collection('quotations').doc(quotationId).update({
                        status: 'sent',
                        sentAt: new Date().toISOString()
                    });

                    await this.loadQuotationsFromFirestore();
                    if (this.quotationViewMode === 'list') {
                        this.renderQuotations();
                    }
                }

                this.showToast('âœ… Opening WhatsApp...', 'success');
            },

            async convertQuotationToOrder(quotationId) {
                const quotation = this.data.quotations.find(q => q.id === quotationId);
                if (!quotation) return;

                if (!confirm(`Convert quotation to order for ${quotation.customer.name}?`)) return;

                // Switch to orders tab and prefill with quotation data
                this.switchTab('orders');

                setTimeout(() => {
                    // Fill customer details
                    Utils.set('clientName', quotation.customer.name);
                    Utils.set('contact', quotation.customer.contact);
                    if (quotation.customer.eventVenue) Utils.set('venue', quotation.customer.eventVenue);
                    if (quotation.customer.eventDate) {
                        Utils.set('date', quotation.customer.eventDate);
                        Utils.set('startDate', quotation.customer.eventDate);
                    }

                    // TODO: Add items to order (requires integration with order form)
                    // For now, just navigate to orders tab with customer info prefilled

                    this.showToast('âœ… Order form prefilled with quotation data', 'success');
                }, 200);

                // Mark quotation as converted
                try {
                    await db.collection('quotations').doc(quotationId).update({
                        status: 'converted',
                        convertedAt: new Date().toISOString()
                    });

                    await this.loadQuotationsFromFirestore();
                } catch (error) {
                    console.error('Error updating quotation status:', error);
                }
            },

            // ============ TEAM MANAGEMENT ============

            renderTeam() {
                const container = document.getElementById('team');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('teamManagement')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('teamManagement')}</p>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('addTeamMember')}</h3>
                            </div>
                            <div class="form-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="form-group">
                                    <label class="form-label required">${this.t('memberName')}</label>
                                    <input type="text" id="teamMemberName" class="form-input" placeholder="e.g., Rajesh Kumar">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('phoneNumber')}</label>
                                    <input type="tel" id="teamMemberWhatsApp" class="form-input" placeholder="e.g., +91 98765 43210">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('email')}</label>
                                    <input type="email" id="teamMemberEmail" class="form-input" placeholder="e.g., rajesh@example.com">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('status')}</label>
                                    <select id="teamMemberStatus" class="form-select">
                                        <option value="Active">${this.t('active')}</option>
                                        <option value="Inactive">${this.t('inactive')}</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label required">${this.t('roles')}</label>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleDriver" value="Driver" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ðŸš— ${this.t('driver')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleOperator" value="Operator" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>âš™ï¸ ${this.t('operator')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleHelper" value="Helper" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ðŸ¤ ${this.t('helpers')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleManager" value="Manager" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ðŸ‘” Manager</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleSupervisor" value="Supervisor" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ðŸ“‹ Supervisor</span>
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">${this.t('roles')}</label>
                                <input type="text" id="teamMemberSkills" class="form-input" placeholder="e.g., Wedding Expert, Corporate Events, Sound Systems">
                                <small style="color: var(--text-gray);">${this.t('multipleHelpersSeparated')}</small>
                            </div>

                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="OMS.addTeamMember()">${this.t('addTeamMember')}</button>
                                <button class="btn btn-secondary" onclick="OMS.clearTeamForm()">${this.t('clearForm')}</button>
                            </div>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('team')}</h3>
                            </div>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <select id="teamRoleFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('roles')}</option>
                                    <option value="Driver">ðŸš— ${this.t('driver')}</option>
                                    <option value="Operator">âš™ï¸ ${this.t('operator')}</option>
                                    <option value="Helper">ðŸ¤ ${this.t('helpers')}</option>
                                    <option value="Manager">ðŸ‘” Manager</option>
                                    <option value="Supervisor">ðŸ“‹ Supervisor</option>
                                </select>
                                <select id="teamStatusFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('status')}</option>
                                    <option value="Active">${this.t('active')}</option>
                                    <option value="Inactive">${this.t('inactive')}</option>
                                </select>
                                <input type="text" id="teamSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}" oninput="OMS.renderTeamTable()">
                            </div>
                            <div id="teamMembersContainer"></div>
                        </div>

                        <div class="card" id="userRolesCard">
                            <div class="card-header">
                                <h3 class="card-title">ðŸ” User Access Control</h3>
                                <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage user roles and access permissions</p>
                            </div>
                            <div id="userRolesContainer"></div>
                        </div>
                    </div>
                `;

                this.renderTeamTable();
                this.renderUserRoles();
            },

            renderTeamTable() {
                const container = document.getElementById('teamMembersContainer');
                if (!container) return;

                // Get filter values
                const roleFilter = document.getElementById('teamRoleFilter')?.value || '';
                const statusFilter = document.getElementById('teamStatusFilter')?.value || '';
                const searchQuery = document.getElementById('teamSearch')?.value.toLowerCase() || '';

                // Filter team members
                let filteredTeam = this.data.team.filter(member => {
                    const matchesRole = !roleFilter || member.roles.includes(roleFilter);
                    const matchesStatus = !statusFilter || member.status === statusFilter;
                    const matchesSearch = !searchQuery || member.name.toLowerCase().includes(searchQuery);
                    return matchesRole && matchesStatus && matchesSearch;
                });

                if (filteredTeam.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>${this.t('noOrdersFound')}</p>
                        </div>
                    `;
                    return;
                }

                // Render table
                const tableHtml = `
                    <div style="overflow-x: auto;">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>${this.t('memberName')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('phoneNumber')}</th>
                                    <th>${this.t('email')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('status')}</th>
                                    <th>${this.t('actions')}</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${filteredTeam.map(member => {
                                    const roleIcons = {
                                        'Driver': 'ðŸš—',
                                        'Operator': 'âš™ï¸',
                                        'Helper': 'ðŸ¤',
                                        'Manager': 'ðŸ‘”',
                                        'Supervisor': 'ðŸ“‹'
                                    };
                                    const roleBadges = member.roles.map(role =>
                                        `<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; margin-right: 0.25rem;">${roleIcons[role] || ''} ${role}</span>`
                                    ).join('');

                                    const statusColor = member.status === 'Active' ? 'var(--success)' : 'var(--text-gray)';
                                    const statusBadge = `<span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">${this.t(member.status.toLowerCase())}</span>`;

                                    return `
                                        <tr>
                                            <td><strong>${member.name}</strong></td>
                                            <td>${roleBadges}</td>
                                            <td>
                                                <a href="https://wa.me/${member.whatsApp.replace(/[^0-9]/g, '')}" target="_blank" style="color: var(--success);">
                                                    ${member.whatsApp}
                                                </a>
                                            </td>
                                            <td>${member.email || '-'}</td>
                                            <td><small>${member.skills && member.skills.length > 0 ? member.skills.join(', ') : '-'}</small></td>
                                            <td>${statusBadge}</td>
                                            <td>
                                                <button class="btn btn-info btn-small" onclick="OMS.editTeamMember('${member.id}')">${this.t('edit')}</button>
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteTeamMember('${member.id}')">${this.t('delete')}</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                container.innerHTML = tableHtml;
            },

            addTeamMember() {
                const name = Utils.get('teamMemberName');
                const whatsApp = Utils.get('teamMemberWhatsApp');
                const email = Utils.get('teamMemberEmail');
                const status = Utils.get('teamMemberStatus');
                const skillsStr = Utils.get('teamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('roleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('roleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('roleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('roleManager')?.checked) roles.push('Manager');
                if (document.getElementById('roleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill Name, WhatsApp, and select at least one Role', 'error');
                    return;
                }

                // Parse skills
                const skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // Create team member object
                const teamMember = {
                    id: Utils.generateId(),
                    name,
                    roles,
                    whatsApp,
                    email: email || '',
                    skills,
                    status,
                    createdAt: new Date().toISOString()
                };

                this.data.team.push(teamMember);
                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(teamMember).then(success => {
                    if (success) {
                        this.showToast(`${name} added to team and synced!`, 'success');
                    } else {
                        this.showToast(`${name} added locally, but sync failed`, 'warning');
                    }
                });

                this.renderTeamTable();
                this.clearTeamForm();
            },

            clearTeamForm() {
                Utils.set('teamMemberName', '');
                Utils.set('teamMemberWhatsApp', '');
                Utils.set('teamMemberEmail', '');
                Utils.set('teamMemberSkills', '');
                Utils.set('teamMemberStatus', 'Active');

                // Uncheck all role checkboxes
                ['roleDriver', 'roleOperator', 'roleHelper', 'roleManager', 'roleSupervisor'].forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) checkbox.checked = false;
                });
            },

            editTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                // Show edit modal
                this.showModal('Edit Team Member', `
                    <div class="form-group">
                        <label class="form-label required">Name</label>
                        <input type="text" id="editTeamMemberName" class="form-input" value="${member.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">WhatsApp Number</label>
                        <input type="tel" id="editTeamMemberWhatsApp" class="form-input" value="${member.whatsApp}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" id="editTeamMemberEmail" class="form-input" value="${member.email || ''}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Status</label>
                        <select id="editTeamMemberStatus" class="form-select">
                            <option value="Active" ${member.status === 'Active' ? 'selected' : ''}>Active</option>
                            <option value="Inactive" ${member.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Roles</label>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleDriver" value="Driver" ${member.roles.includes('Driver') ? 'checked' : ''}>
                                ðŸš— Driver
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleOperator" value="Operator" ${member.roles.includes('Operator') ? 'checked' : ''}>
                                âš™ï¸ Operator
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleHelper" value="Helper" ${member.roles.includes('Helper') ? 'checked' : ''}>
                                ðŸ¤ Helper
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleManager" value="Manager" ${member.roles.includes('Manager') ? 'checked' : ''}>
                                ðŸ‘” Manager
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleSupervisor" value="Supervisor" ${member.roles.includes('Supervisor') ? 'checked' : ''}>
                                ðŸ“‹ Supervisor
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Skills (comma-separated)</label>
                        <input type="text" id="editTeamMemberSkills" class="form-input" value="${member.skills && member.skills.length > 0 ? member.skills.join(', ') : ''}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTeamMemberEdit('${id}')">ðŸ’¾ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveTeamMemberEdit(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                const name = Utils.get('editTeamMemberName');
                const whatsApp = Utils.get('editTeamMemberWhatsApp');
                const email = Utils.get('editTeamMemberEmail');
                const status = Utils.get('editTeamMemberStatus');
                const skillsStr = Utils.get('editTeamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('editRoleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('editRoleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('editRoleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('editRoleManager')?.checked) roles.push('Manager');
                if (document.getElementById('editRoleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update member
                member.name = name;
                member.whatsApp = whatsApp;
                member.email = email;
                member.status = status;
                member.roles = roles;
                member.skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];
                member.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(member).then(success => {
                    if (success) {
                        this.showToast('Team member updated and synced!', 'success');
                    } else {
                        this.showToast('Team member updated locally, but sync failed', 'warning');
                    }
                });

                this.renderTeamTable();
                this.closeModal();
            },

            deleteTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                if (confirm(`Are you sure you want to delete ${member.name} from the team?`)) {
                    const index = this.data.team.findIndex(m => m.id === id);
                    if (index !== -1) {
                        const memberName = member.name;

                        this.data.team.splice(index, 1);
                        this.saveToStorage();

                        // Delete from Firestore
                        this.deleteTeamMemberFromFirestore(id).then(success => {
                            if (success) {
                                this.showToast(`${memberName} removed from team and synced!`, 'success');
                            } else {
                                this.showToast(`${memberName} removed locally, but sync failed`, 'warning');
                            }
                        });

                        this.renderTeamTable();
                    }
                }
            },

            // ============ USER ROLES MANAGEMENT (RBAC) ============

            async renderUserRoles() {
                const container = document.getElementById('userRolesContainer');
                if (!container) return;

                const isAdmin = await this.isAdminOrOwner();

                if (!isAdmin) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>â›” Only Admin and Owner can manage user roles</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = '<div style="text-align: center; padding: 1rem;">Loading users...</div>';

                try {
                    // Fetch all user roles from Firestore
                    const userRolesSnapshot = await db.collection('user_roles').get();
                    const users = [];

                    userRolesSnapshot.forEach(doc => {
                        users.push({
                            uid: doc.id,
                            ...doc.data()
                        });
                    });

                    if (users.length === 0) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                                <p>No users found. Users will appear here after they log in.</p>
                            </div>
                        `;
                        return;
                    }

                    // Render users table
                    const tableHtml = `
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Email</th>
                                        <th>Name</th>
                                        <th>Current Role</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${users.map(user => {
                                        const roleColor = user.role === 'admin' ? '#f44336' : user.role === 'owner' ? '#ff9800' : '#2196f3';
                                        const roleBadge = `<span style="background: ${roleColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem; text-transform: uppercase;">${user.role || 'staff'}</span>`;

                                        return `
                                            <tr>
                                                <td><strong>${user.email}</strong></td>
                                                <td>${user.name || '-'}</td>
                                                <td>${roleBadge}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        <div style="margin-top: 1rem; padding: 1rem; background: #fff9c4; border-left: 4px solid #fbc02d; border-radius: 0.25rem;">
                            <strong>âš ï¸ Role Permissions:</strong>
                            <ul style="margin: 0.5rem 0 0 1.5rem; line-height: 1.8;">
                                <li><strong>Admin</strong> - Full access to all features including financials</li>
                                <li><strong>Owner</strong> - Full access to all features including financials</li>
                                <li><strong>Staff</strong> - Limited access (no financial data or payment information)</li>
                            </ul>
                        </div>
                    `;

                    container.innerHTML = tableHtml;

                } catch (error) {
                    console.error('Error loading user roles:', error);
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--danger);">
                            <p>Error loading users: ${error.message}</p>
                        </div>
                    `;
                }
            },

            // ============ TEAM ALLOCATION & NOTIFICATIONS ============

            populateTeamDropdowns() {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');

                // Populate Driver dropdown
                const driverSelect = document.getElementById('driverName');
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">ðŸš— ${d.name}</option>`).join('');
                }

                // Populate Driver 2 dropdown
                const driver2Select = document.getElementById('driverName2');
                if (driver2Select) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driver2Select.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">ðŸš— ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown
                const operatorSelect = document.getElementById('operator');
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}">âš™ï¸ ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');
                const functionId = `day${dayIndex}func${functionIndex}`;

                // Populate Driver multi-select for this function
                const driverSelect = document.getElementById(`${functionId}Driver`);
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    const currentValues = Array.from(driverSelect.selectedOptions).map(opt => opt.value);
                    driverSelect.innerHTML = drivers.map(d =>
                        `<option value="${d.name}" data-id="${d.id}" ${currentValues.includes(d.name) ? 'selected' : ''}>ðŸš— ${d.name}</option>`
                    ).join('');
                }

                // Populate Operator dropdown for this function
                const operatorSelect = document.getElementById(`${functionId}Operator`);
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    const currentValue = operatorSelect.value;
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}" ${o.name === currentValue ? 'selected' : ''}>âš™ï¸ ${o.name}</option>`).join('');
                }

                // Helper field is now a text input - no population needed
            },

            updateTeamDropdowns() {
                // Update single-day order form dropdowns
                this.populateTeamDropdowns();

                // Update multiday function dropdowns if they exist
                const multidayData = this.data.multidayOrders || [];
                multidayData.forEach((day, dayIndex) => {
                    if (day.functions) {
                        day.functions.forEach((func, functionIndex) => {
                            this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
                        });
                    }
                });
            },

            notifyAllocatedTeam() {
                // Get current order form data
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v) : [];

                // Get order details
                const orderId = Utils.get('orderId') || 'NEW';
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const venueMapLink = Utils.get('venueMapLink');
                const date = Utils.get('orderDate');
                const readyTime = Utils.get('readyTime');
                const contact = Utils.get('contact');

                if (!clientName || !venue || !date) {
                    this.showToast('Please fill Order ID, Client Name, Venue, and Date first', 'error');
                    return;
                }

                // Get items from current order
                const items = this.currentOrderItems || [];

                // Collect all team members to notify
                const teamToNotify = [];

                // Prepare team list for messages
                const teamListForMessage = [
                    driverName ? `Driver: ${driverName}` : null,
                    operatorName ? `Operator: ${operatorName}` : null,
                    helperNames.length > 0 ? `Helper(s): ${helperNames.join(', ')}` : null
                ].filter(Boolean).join(', ');

                // Add Driver
                if (driverName) {
                    const driver = this.data.team.find(m => m.name === driverName);
                    if (driver && driver.whatsApp) {
                        teamToNotify.push({ member: driver, role: 'Driver' });
                    }
                }

                // Add Operator
                if (operatorName) {
                    const operator = this.data.team.find(m => m.name === operatorName);
                    if (operator && operator.whatsApp) {
                        teamToNotify.push({ member: operator, role: 'Operator' });
                    }
                }

                // Add ALL Helpers
                if (helperNames.length > 0) {
                    helperNames.forEach(helperName => {
                        const helper = this.data.team.find(m => m.name === helperName);
                        if (helper && helper.whatsApp) {
                            teamToNotify.push({ member: helper, role: 'Helper' });
                        }
                    });
                }

                if (teamToNotify.length === 0) {
                    this.showToast('No team members selected or no WhatsApp numbers found', 'warning');
                    return;
                }

                // Send notifications with delay to prevent popup blocking
                teamToNotify.forEach((item, index) => {
                    setTimeout(() => {
                        this.sendTeamMemberNotification(item.member, item.role, {
                            orderId, clientName, venue, venueMapLink, date, readyTime, contact, items,
                            teamList: teamListForMessage
                        });
                    }, index * 500); // 500ms delay between each window
                });

                this.showToast(`Opening WhatsApp for ${teamToNotify.length} team member(s): ${teamToNotify.map(t => t.member.name).join(', ')}`, 'success');

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'team_allocation',
                    orderId,
                    recipients: teamToNotify.map(t => t.member.name),
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);
            },

            sendTeamMemberNotification(teamMember, role, orderDetails) {
                const { orderId, clientName, venue, date, readyTime, contact, items, teamList, venueMapLink } = orderDetails;

                // Format items list
                const itemsList = items && items.length > 0
                    ? items.map(item => `â€¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}`).join('\n')
                    : 'â€¢ No items added yet';

                // Create WhatsApp message
                let message = `ðŸŽ‰ *NEW ORDER ASSIGNED TO YOU*\n\n`;
                message += `ðŸ“‹ *Order ID:* ${orderId}\n`;
                message += `ðŸ‘¤ *Client:* ${clientName}\n`;
                message += `ðŸ“ *Venue:* ${venue}\n`;
                if (venueMapLink) {
                    message += `ðŸ—ºï¸ *Location:* ${venueMapLink}\n`;
                }
                message += `ðŸ“… *Date:* ${Utils.formatDate(date)}\n`;
                message += `ðŸ• *Ready Time:* ${readyTime || 'TBD'}\n\n`;
                message += `ðŸŽ­ *Your Role:* ${role.toUpperCase()}\n\n`;

                if (teamList) {
                    message += `ðŸ‘· *Team Members:*\n${teamList}\n\n`;
                }

                message += `ðŸ“¦ *Items Required:*\n${itemsList}\n\n`;

                if (contact) {
                    message += `ðŸ“ž *Client Contact:* ${contact}\n\n`;
                }

                message += `âš¡ Please confirm receipt by replying "OK"\n\n`;
                message += `--\n_FirepowerSFX Order Management_`;

                // Encode and open WhatsApp
                const phoneNumber = teamMember.whatsApp.replace(/[^0-9]/g, '');
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
            },

            sendManagerReport() {
                // Get all managers
                const managers = this.data.team.filter(m => m.roles.includes('Manager') && m.status === 'Active');

                if (managers.length === 0) {
                    this.showToast('No managers found in team. Add a team member with Manager role first.', 'warning');
                    return;
                }

                // Get the current order data from the form
                const currentOrderId = Utils.get('orderId');
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const venueMapLink = Utils.get('venueMapLink');
                const currentOrderDate = Utils.get('orderDate');
                const currentStartDate = Utils.get('startDate');
                const eventType = Utils.get('eventTypeSelect');
                const isMultiDay = eventType === 'multi';
                const readyTime = Utils.get('readyTime');
                const status = Utils.get('orderStatus');
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get helpers from text input (comma-separated)
                const helperInput = document.getElementById('helper');
                const helperNames = helperInput ? helperInput.value.trim() : '';

                // Check if we have order data in the form
                if (!clientName || !venue) {
                    this.showToast('Please open/select an order first to send report', 'warning');
                    return;
                }

                // Use the order date from the form
                const targetDate = isMultiDay ? currentStartDate : currentOrderDate;

                if (!targetDate) {
                    this.showToast('Order date is missing', 'error');
                    return;
                }

                // Build manager report for THIS SPECIFIC ORDER ONLY
                let message = `ðŸ“Š *ORDER REPORT*\n`;
                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

                message += `*ORDER ID:* ${currentOrderId || 'NEW'}\n`;
                message += `ðŸ‘¤ *Client:* ${clientName}\n`;
                message += `ðŸ“ *Venue:* ${venue}\n`;
                if (venueMapLink) {
                    message += `ðŸ—ºï¸ *Location:* ${venueMapLink}\n`;
                }
                message += `ðŸ“… *Date:* ${Utils.formatDate(targetDate)}\n`;
                message += `ðŸ• *Ready Time:* ${readyTime || 'TBD'}\n`;
                message += `ðŸ“Š *Status:* ${status || 'Pending'}\n\n`;

                if (driverName || operatorName || helperNames) {
                    message += `ðŸ‘· *Team Allocation:*\n`;
                    if (driverName) message += `  â€¢ Driver: ${driverName}\n`;
                    if (operatorName) message += `  â€¢ Operator: ${operatorName}\n`;
                    if (helperNames) message += `  â€¢ Helper(s): ${helperNames}\n`;
                } else {
                    message += `âš ï¸ *Team Not Allocated Yet*\n`;
                }

                message += `\n`;

                // Get items from current order
                const items = this.currentOrderItems || [];
                if (items.length > 0) {
                    message += `ðŸ“¦ *Items Required:*\n`;
                    items.forEach(item => {
                        message += `  â€¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}\n`;
                    });
                    message += `\n`;
                }

                message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                message += `--\n_FirepowerSFX Admin_`;

                // Filter managers with valid WhatsApp numbers
                const managersWithWhatsApp = managers.filter(m => m.whatsApp && m.whatsApp.trim() !== '');

                if (managersWithWhatsApp.length === 0) {
                    this.showToast('No managers have WhatsApp numbers configured', 'warning');
                    return;
                }

                // Send to all managers with delay to prevent popup blocking
                const encodedMessage = encodeURIComponent(message);
                const managerNames = [];

                managersWithWhatsApp.forEach((manager, index) => {
                    const phoneNumber = manager.whatsApp.replace(/[^0-9]/g, '');
                    if (phoneNumber) {
                        managerNames.push(manager.name);
                        // Add delay between each window to prevent popup blocking
                        setTimeout(() => {
                            window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
                        }, index * 500); // 500ms delay between each window
                    }
                });

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'manager_report',
                    recipients: managerNames,
                    orderId: currentOrderId,
                    targetDate: targetDate,
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);

                this.showToast(`Opening WhatsApp for ${managerNames.length} manager(s): ${managerNames.join(', ')}`, 'success');
            },

            // WhatsApp Date Filter Methods
            filterOrdersByDate(selectedDate) {
                if (!selectedDate) return [];

                // Filter orders that match the selected date
                const filteredOrders = this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day events, check if selected date falls within the range
                        const startDate = new Date(order.startDate);
                        const endDate = new Date(order.endDate);
                        const checkDate = new Date(selectedDate);
                        return checkDate >= startDate && checkDate <= endDate;
                    } else {
                        // For single-day events, match the exact date
                        return order.date === selectedDate;
                    }
                });

                // Sort by order ID or creation time
                return filteredOrders.sort((a, b) => {
                    const aId = a.orderId || '';
                    const bId = b.orderId || '';
                    return aId.localeCompare(bId);
                });
            },

            generateWhatsAppOrdersMessage(orders, selectedDate) {
                if (!orders || orders.length === 0) return '';

                // Header with date (only once for entire message)
                let message = `ðŸ“… ${Utils.formatDate(selectedDate)}\n`;
                message += `Total Orders: ${orders.length}\n\n`;

                // Collect special items for RAW MATERIAL calculations (like preparation tab)
                let totalDryIceMachines = 0;
                let totalFlowerShowerMachines = 0;
                let totalElectricityKV = 0;

                orders.forEach((order, index) => {
                    // Collect all items from this order
                    let orderItems = [];

                    // Find specific day data for multi-day orders
                    let specificDayData = null;
                    if (order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0) {
                        specificDayData = order.dayWiseData.find(dayData => dayData.date === selectedDate);
                    }

                    // Collect items from order
                    if (specificDayData && specificDayData.functions) {
                        specificDayData.functions.forEach(func => {
                            if (func.items && func.items.length > 0) {
                                orderItems = orderItems.concat(func.items);
                            }
                        });
                    } else if (order.items && order.items.length > 0) {
                        orderItems = order.items;
                    }

                    // Calculate dry ice machines (20kg per machine)
                    orderItems.forEach(item => {
                        const itemNameLower = item.name?.toLowerCase() || '';
                        const qty = item.quantity || 0;

                        // Dry ice machines
                        if (itemNameLower.includes('dry ice')) {
                            totalDryIceMachines += qty;
                        }

                        // Flower shower machines
                        if ((itemNameLower.includes('flower') && itemNameLower.includes('shower')) ||
                            itemNameLower.includes('flower shower machine')) {
                            totalFlowerShowerMachines += qty;
                        }

                        // Electricity - 3KV machines
                        const electricity3KV = ['showven sonic boom (co2 jet)', 'sonic boom', 'dry ice machine', '5 head flame'];
                        if (electricity3KV.some(name => itemNameLower.includes(name))) {
                            totalElectricityKV += qty * 3;
                        }
                        // Electricity - 1KV machines
                        else {
                            const electricity1KV = ['sparkular', 'spinner', 'cyclone', 'waver', 'circle flame', 'snow machine', 'fan wheel'];
                            if (electricity1KV.some(name => itemNameLower.includes(name))) {
                                totalElectricityKV += qty * 1;
                            }
                        }
                    });

                    // Order details (compact format)
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `${order.clientName || 'N/A'}\n`;
                    message += `Contact: ${order.contact || 'N/A'}\n`;

                    // Venue with location combined
                    if (order.venue && order.venue !== 'N/A') {
                        message += `Venue: ${order.venue}`;

                        // DEBUG: Log venue location data
                        console.log(`ðŸ—ºï¸ Order ${order.orderId} venue data:`, {
                            venue: order.venue,
                            venueLocation: order.venueLocation,
                            venueMapLink: order.venueMapLink
                        });

                        // Add Google Maps location link - check all possible sources
                        let mapsUrl = null;

                        // Priority 1: venueLocation with coordinates
                        if (order.venueLocation && order.venueLocation.lat && order.venueLocation.lng) {
                            if (order.venueLocation.place_id) {
                                mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}&query_place_id=${order.venueLocation.place_id}`;
                                console.log(`âœ… Using place_id link for ${order.orderId}`);
                            } else {
                                mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(order.venue)}+${order.venueLocation.lat},${order.venueLocation.lng}`;
                                console.log(`âœ… Using lat/lng link for ${order.orderId}`);
                            }
                        }
                        // Priority 2: venueMapLink (stored link)
                        else if (order.venueMapLink && order.venueMapLink.trim()) {
                            mapsUrl = order.venueMapLink;
                            console.log(`âœ… Using venueMapLink for ${order.orderId}`);
                        } else {
                            console.warn(`âš ï¸ No location data found for ${order.orderId}`);
                        }

                        if (mapsUrl) {
                            message += `\nðŸ“ ${mapsUrl}`;
                        }
                        message += `\n`;
                    }

                    message += `Time: ${order.readyTime || 'TBD'}\n`;

                    // Functions and items (compact format - no "Items:" label)
                    if (specificDayData && specificDayData.functions) {
                        specificDayData.functions.forEach((func, funcIdx) => {
                            if (func.items && func.items.length > 0) {
                                // Function name
                                if (func.functionType) {
                                    message += `Function - ${func.functionType}`;
                                    if (func.timeSlot) message += ` (${func.timeSlot})`;
                                    message += `\n`;
                                } else if (specificDayData.functions.length > 1) {
                                    message += `Function ${funcIdx + 1}`;
                                    if (func.timeSlot) message += ` (${func.timeSlot})`;
                                    message += `\n`;
                                }

                                // Items directly (no "Items:" label)
                                func.items.forEach(item => {
                                    message += `${item.name} ${item.quantity}`;
                                    if (item.remarks) message += ` (${item.remarks})`;
                                    message += `\n`;
                                });
                            }
                        });
                    } else if (order.items && order.items.length > 0) {
                        // Single-day order items
                        order.items.forEach(item => {
                            message += `${item.name} ${item.quantity}`;
                            if (item.remarks) message += ` (${item.remarks})`;
                            message += `\n`;
                        });
                    }

                    message += `\n`;
                });

                // RAW MATERIALS GRAND TOTAL summary (calculated like preparation tab)
                if (totalDryIceMachines > 0) {
                    const dryIceNeeded = totalDryIceMachines * 20; // 20kg per machine
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `ðŸ§Š DRY ICE - GRAND TOTAL: ${dryIceNeeded}kg\n`;
                    message += `(${totalDryIceMachines} machine${totalDryIceMachines !== 1 ? 's' : ''} Ã— 20kg)\n\n`;
                }

                if (totalFlowerShowerMachines > 0) {
                    const flowersNeeded = totalFlowerShowerMachines * 20; // 20kg per machine
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `ðŸŒ¸ FLOWERS - GRAND TOTAL: ${flowersNeeded}kg\n`;
                    message += `(${totalFlowerShowerMachines} machine${totalFlowerShowerMachines !== 1 ? 's' : ''} Ã— 20kg)\n\n`;
                }

                if (totalElectricityKV > 0) {
                    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
                    message += `âš¡ ELECTRICITY - GRAND TOTAL: ${totalElectricityKV}KV\n\n`;
                }

                message += `FirepowerSFX Order Management`;

                return message;
            },

            updateWhatsAppDateFilter() {
                const dateInput = document.getElementById('whatsappFilterDate');
                const previewDiv = document.getElementById('whatsappOrdersPreview');
                const noOrdersDiv = document.getElementById('whatsappNoOrders');
                const ordersListDiv = document.getElementById('whatsappOrdersList');
                const orderCountSpan = document.getElementById('whatsappOrderCount');

                if (!dateInput || !dateInput.value) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'none';
                    return;
                }

                const selectedDate = dateInput.value;
                const filteredOrders = this.filterOrdersByDate(selectedDate);

                if (filteredOrders.length === 0) {
                    previewDiv.style.display = 'none';
                    noOrdersDiv.style.display = 'block';
                    return;
                }

                // Show preview
                noOrdersDiv.style.display = 'none';
                previewDiv.style.display = 'block';
                orderCountSpan.textContent = filteredOrders.length;

                // Generate and display message preview
                const message = this.generateWhatsAppOrdersMessage(filteredOrders, selectedDate);
                ordersListDiv.textContent = message;

                // Store message for sending
                this.whatsappCurrentMessage = message;
            },

            sendWhatsAppOrdersReport() {
                if (!this.whatsappCurrentMessage) {
                    this.showToast('Please select a date first', 'warning');
                    return;
                }

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(this.whatsappCurrentMessage);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCalendarTab() {
                document.getElementById('calendar').innerHTML = this.renderCalendar(this.currentCalendarDate || new Date());
            },

            async renderHistory() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('orderHistory')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">${this.t('export')}</button>
                            <button class="btn btn-primary" id="mergeSelectedBtn" style="display: none;" onclick="OMS.showMergeModal()">ðŸ”— Merge Selected Orders</button>
                        </div>
                        <div class="form-group" style="margin: 20px 0; position: relative;">
                            <label class="form-label">ðŸ” Search Orders</label>
                            <input type="text" id="historySearch" class="form-input" placeholder="Search by client name, order ID, date, or venue...">
                            <div id="historySearchResults" class="search-dropdown"></div>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;

                // Add search functionality
                this.setupHistorySearch();

                // Initialize selected orders array
                this.selectedOrdersForMerge = [];

                // Check if user can manage financials
                const canManageFinancials = await this.canViewFinancials();

                // IMPORTANT: Filter out orders that have been merged into other orders
                // Only show orders that are NOT marked as isMerged
                const visibleOrders = this.data.orders.filter(o => !o.isMerged);
                console.log(`ðŸ“‹ History: Showing ${visibleOrders.length} orders (filtered out ${this.data.orders.length - visibleOrders.length} merged orders)`);

                this.renderTable('historyContainer', [
                    { key: 'select', label: 'â˜‘ï¸', render: o => {
                        const isMergedOrder = o.mergedFrom && o.mergedFrom.length > 0;
                        return `<input type="checkbox" class="order-select-checkbox" data-order-id="${o.docId || o.orderId}" ${isMergedOrder ? 'disabled' : ''} onchange="OMS.toggleOrderSelection('${o.docId || o.orderId}')">`;
                    }},
                    { key: 'orderId', label: this.t('orderId'), render: o => {
                        const mergeStatus = o.mergedFrom && o.mergedFrom.length > 0
                            ? `<span style="color: #667eea; font-weight: bold;">ðŸ”— MERGED (${o.mergedFrom.length} orders)</span>`
                            : '';
                        return `<span class="order-id-highlight">${o.orderId}</span> ${mergeStatus}`;
                    }},
                    { key: 'clientName', label: this.t('client') },
                    { key: 'venue', label: this.t('venue') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${this.t(o.status.toLowerCase())}</span>` }
                ], visibleOrders, (row) => {
                    const isMergedOrder = row.mergedFrom && row.mergedFrom.length > 0;
                    const unmergeBtn = isMergedOrder ? `<button class="btn btn-info btn-small" onclick="OMS.unmergeOrder('${row.docId || row.orderId}')">ðŸ”“ Unmerge</button>` : '';
                    const paymentExpenseButtons = canManageFinancials ? `
                        <button class="btn btn-primary btn-small" onclick="OMS.addPaymentForOrder('${row.docId || row.orderId}')">ðŸ’µ Payment</button>
                        <button class="btn btn-warning btn-small" onclick="OMS.addExpenseForOrder('${row.docId || row.orderId}')">ðŸ’¸ Expense</button>
                    ` : '';
                    return `
                        <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('edit')}</button>
                        <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                        ${paymentExpenseButtons}
                        ${unmergeBtn}
                        <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.docId || row.orderId}">${this.t('delete')}</button>
                    `;
                });
            },

            setupHistorySearch() {
                const searchInput = document.getElementById('historySearch');
                const searchResults = document.getElementById('historySearchResults');

                if (!searchInput || !searchResults) return;

                let searchTimeout;

                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim().toLowerCase();

                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        searchResults.innerHTML = '';
                        return;
                    }

                    searchTimeout = setTimeout(() => {
                        // Search through all orders
                        const results = this.data.orders.filter(order => {
                            const clientName = (order.clientName || '').toLowerCase();
                            const orderId = (order.orderId || '').toLowerCase();
                            const venue = (order.venue || '').toLowerCase();
                            const date = order.isMultiDay
                                ? `${Utils.formatDate(order.startDate)} ${Utils.formatDate(order.endDate)}`.toLowerCase()
                                : Utils.formatDate(order.date).toLowerCase();

                            return clientName.includes(query) ||
                                   orderId.includes(query) ||
                                   venue.includes(query) ||
                                   date.includes(query);
                        }); // Show all matching results (no limit)

                        if (results.length === 0) {
                            searchResults.innerHTML = '<div class="search-dropdown-item">No orders found</div>';
                            searchResults.style.display = 'block';
                        } else {
                            searchResults.innerHTML = results.map(order => {
                                const dateDisplay = order.isMultiDay
                                    ? `${Utils.formatDate(order.startDate)} - ${Utils.formatDate(order.endDate)}`
                                    : Utils.formatDate(order.date);
                                const statusClass = `status-${order.status.toLowerCase()}`;

                                return `
                                    <div class="search-dropdown-item" data-order-id="${order.docId || order.orderId}" style="cursor: pointer; padding: 10px; border-bottom: 1px solid var(--border-color);">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <strong>${order.orderId || '[No ID]'}</strong> - ${order.clientName}
                                                <br>
                                                <small style="color: var(--text-gray);">
                                                    ðŸ“… ${dateDisplay} | ðŸ“ ${order.venue || 'N/A'}
                                                </small>
                                            </div>
                                            <span class="status-badge ${statusClass}">${order.status}</span>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                            searchResults.style.display = 'block';

                            // Add click handlers to search results
                            searchResults.querySelectorAll('.search-dropdown-item').forEach(item => {
                                const orderId = item.getAttribute('data-order-id');
                                if (orderId && orderId !== 'null') {
                                    item.addEventListener('click', () => {
                                        // Find the order
                                        const order = this.data.orders.find(o =>
                                            o.docId === orderId || o.orderId === orderId
                                        );

                                        if (order) {
                                            // Switch to orders tab
                                            this.switchTab('orders');
                                            // Load order into form for editing
                                            this.loadOrderToForm(order);
                                            // Clear search
                                            searchInput.value = '';
                                            searchResults.style.display = 'none';
                                        }
                                    });
                                }
                            });
                        }
                    }, 300); // Debounce 300ms
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            },

            // ============ MERGE/UNMERGE ORDERS ============
            toggleOrderSelection(orderId) {
                const checkbox = document.querySelector(`.order-select-checkbox[data-order-id="${orderId}"]`);
                if (!checkbox) return;

                if (checkbox.checked) {
                    if (!this.selectedOrdersForMerge.includes(orderId)) {
                        this.selectedOrdersForMerge.push(orderId);
                    }
                } else {
                    this.selectedOrdersForMerge = this.selectedOrdersForMerge.filter(id => id !== orderId);
                }

                // Show/hide merge button based on selection count
                const mergeBtn = document.getElementById('mergeSelectedBtn');
                if (mergeBtn) {
                    mergeBtn.style.display = this.selectedOrdersForMerge.length >= 2 ? 'inline-block' : 'none';
                    mergeBtn.textContent = `ðŸ”— Merge Selected Orders (${this.selectedOrdersForMerge.length})`;
                }
            },

            showMergeModal() {
                if (this.selectedOrdersForMerge.length < 2) {
                    alert('Please select at least 2 orders to merge');
                    return;
                }

                // Get selected orders
                const selectedOrders = this.selectedOrdersForMerge.map(id =>
                    this.data.orders.find(o => (o.docId || o.orderId) === id)
                ).filter(o => o);

                if (selectedOrders.length < 2) {
                    alert('Error: Could not find selected orders');
                    return;
                }

                // Create modal HTML
                const modalHTML = `
                    <div class="modal show" id="mergeModalOverlay" onclick="if(event.target === this) document.getElementById('mergeModalOverlay').remove();">
                        <div class="modal-content" style="max-width: 600px;">
                            <div class="modal-header">
                                <h2>ðŸ”— Merge Orders</h2>
                            </div>
                            <div class="modal-body">
                                <p style="margin-bottom: 1rem; color: #666;">Select which order to keep as the base. All other orders' content will be merged into it.</p>

                                <div class="form-group">
                                    <label class="form-label">Select Base Order:</label>
                                    <select id="mergeBaseOrder" class="form-select" onchange="OMS.updateMergeOrderId()">
                                        ${selectedOrders.map(order => `
                                            <option value="${order.docId || order.orderId}">
                                                ${order.orderId} - ${order.clientName} (${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)})
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Merged Order ID (editable):</label>
                                    <input type="text" id="mergedOrderId" class="form-input" value="${selectedOrders[0].orderId}">
                                    <small style="color: #666;">You can change the Order ID for the merged order</small>
                                </div>

                                <div style="background: #f0f0f0; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                                    <h4 style="margin: 0 0 0.5rem 0;">Orders to be merged:</h4>
                                    <ul style="margin: 0; padding-left: 1.5rem;">
                                        ${selectedOrders.map(order => `
                                            <li>${order.orderId} - ${order.clientName}</li>
                                        `).join('')}
                                    </ul>
                                    <p style="margin-top: 0.5rem; font-size: 0.9em; color: #666;">
                                        Original orders will be marked as "merged" and can be unmerged later.
                                    </p>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" onclick="document.getElementById('mergeModalOverlay').remove()">Cancel</button>
                                <button class="btn btn-primary" onclick="OMS.performMerge()">ðŸ”— Merge Orders</button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML('beforeend', modalHTML);
            },

            updateMergeOrderId() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');
                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const baseOrder = this.data.orders.find(o => (o.docId || o.orderId) === baseOrderId);
                if (baseOrder) {
                    orderIdInput.value = baseOrder.orderId;
                }
            },

            async performMerge() {
                const baseOrderSelect = document.getElementById('mergeBaseOrder');
                const orderIdInput = document.getElementById('mergedOrderId');

                if (!baseOrderSelect || !orderIdInput) return;

                const baseOrderId = baseOrderSelect.value;
                const newOrderId = orderIdInput.value.trim();

                if (!newOrderId) {
                    alert('Please enter an Order ID for the merged order');
                    return;
                }

                try {
                    // Get all selected orders
                    const ordersToMerge = this.selectedOrdersForMerge.map(id =>
                        this.data.orders.find(o => (o.docId || o.orderId) === id)
                    ).filter(o => o);

                    // Get base order
                    const baseOrder = ordersToMerge.find(o => (o.docId || o.orderId) === baseOrderId);
                    const otherOrders = ordersToMerge.filter(o => (o.docId || o.orderId) !== baseOrderId);

                    if (!baseOrder) {
                        alert('Error: Base order not found');
                        return;
                    }

                    // Store original orders data for unmerge
                    const mergedFromData = ordersToMerge.map(order => ({
                        docId: order.docId,
                        orderId: order.orderId,
                        orderData: JSON.parse(JSON.stringify(order)) // Deep copy
                    }));

                    // Create merged order by combining content
                    const mergedOrder = JSON.parse(JSON.stringify(baseOrder)); // Deep copy
                    mergedOrder.orderId = newOrderId;
                    mergedOrder.mergedFrom = mergedFromData;
                    mergedOrder.mergedAt = new Date().toISOString();

                    // Merge items from other orders (for single-day orders)
                    if (!mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (!order.isMultiDay && order.items && order.items.length > 0) {
                                mergedOrder.items = [...(mergedOrder.items || []), ...order.items];
                            }
                        });
                    }

                    // Merge day-wise data for multi-day orders
                    if (mergedOrder.isMultiDay) {
                        otherOrders.forEach(order => {
                            if (order.isMultiDay && order.dayWiseData) {
                                // Merge dayWiseData intelligently
                                order.dayWiseData.forEach(dayData => {
                                    const existingDayIndex = mergedOrder.dayWiseData.findIndex(d => d.date === dayData.date);
                                    if (existingDayIndex >= 0) {
                                        // Merge functions for same date
                                        mergedOrder.dayWiseData[existingDayIndex].functions = [
                                            ...(mergedOrder.dayWiseData[existingDayIndex].functions || []),
                                            ...(dayData.functions || [])
                                        ];
                                    } else {
                                        // Add new date
                                        mergedOrder.dayWiseData.push(dayData);
                                    }
                                });
                            }
                        });
                    }

                    // Merge notes
                    const allNotes = ordersToMerge.map(o => o.notes).filter(n => n && n.trim()).join('\n---\n');
                    if (allNotes) {
                        mergedOrder.notes = allNotes;
                    }

                    // Update merged order in Firebase
                    await this.updateOrderInFirebase(mergedOrder, baseOrder.docId);

                    // Mark other orders as merged
                    for (const order of otherOrders) {
                        const updatedOrder = { ...order, isMerged: true, mergedInto: newOrderId };
                        await this.updateOrderInFirebase(updatedOrder, order.docId);
                    }

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Close modal
                    document.getElementById('mergeModalOverlay')?.remove();

                    // Clear selection
                    this.selectedOrdersForMerge = [];

                    // Refresh history view
                    this.renderHistory();

                    alert(`âœ… Successfully merged ${ordersToMerge.length} orders into ${newOrderId}`);

                } catch (error) {
                    console.error('Error merging orders:', error);
                    alert('Error merging orders: ' + error.message);
                }
            },

            async unmergeOrder(orderId) {
                if (!confirm('Are you sure you want to unmerge this order? This will restore all original separate orders.')) {
                    return;
                }

                try {
                    // Find the merged order
                    const mergedOrder = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                    if (!mergedOrder || !mergedOrder.mergedFrom) {
                        alert('Error: This is not a merged order');
                        return;
                    }

                    // Restore all original orders
                    for (const originalData of mergedOrder.mergedFrom) {
                        const restoredOrder = originalData.orderData;
                        delete restoredOrder.isMerged;
                        delete restoredOrder.mergedInto;

                        await this.updateOrderInFirebase(restoredOrder, originalData.docId);
                    }

                    // Delete the merged order
                    await this.deleteOrderByDocId(mergedOrder.docId || mergedOrder.orderId);

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Refresh history view
                    this.renderHistory();

                    alert(`âœ… Successfully unmerged order. ${mergedOrder.mergedFrom.length} original orders restored.`);

                } catch (error) {
                    console.error('Error unmerging order:', error);
                    alert('Error unmerging order: ' + error.message);
                }
            },

            async updateOrderInFirebase(orderData, docId) {
                if (!docId) {
                    throw new Error('Document ID is required for update');
                }

                const orderRef = firebase.firestore().collection('orders').doc(docId);
                await orderRef.update(orderData);

                console.log(`Order ${docId} updated in Firebase`);
            },

            renderAnalytics() {
    const container = document.getElementById('analytics');
    const trackingData = this.data.trackingData || [];
    const orders = this.data.orders || [];

    // Website visitor analytics
    const pageViews = trackingData.filter(t => t.type === 'page_view').length;
    const cartActions = trackingData.filter(t => t.type === 'cart_add' || t.type === 'cart_remove').length;
    const uniqueSessions = [...new Set(trackingData.map(t => t.sessionId))].length;

    // Get device breakdown
    const devices = {};
    trackingData.forEach(t => {
        const device = t.userInfo?.device || 'Unknown';
        devices[device] = (devices[device] || 0) + 1;
    });

    // Get location breakdown
    const locations = {};
    trackingData.forEach(t => {
        const city = t.userInfo?.city || 'Unknown';
        locations[city] = (locations[city] || 0) + 1;
    });

    // Order-based analytics
    const totalOrders = orders.length;
    const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
    const completedOrders = orders.filter(o => o.status === 'Completed').length;
    const cancelledOrders = orders.filter(o => o.status === 'Cancelled').length;

    // Get event type breakdown
    const eventTypes = {};
    orders.forEach(o => {
        const type = o.eventType || 'Other';
        eventTypes[type] = (eventTypes[type] || 0) + 1;
    });

    container.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analyticsReport')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card info">
                    <div class="stat-value">${pageViews}</div>
                    <div class="stat-label">${this.t('analytics')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${uniqueSessions}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${cartActions}</div>
                    <div class="stat-label">${this.t('actions')}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${trackingData.length}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(devices).length > 0 ? Object.entries(devices).map(([device, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${device}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(locations).length > 0 ? Object.entries(locations).slice(0, 8).map(([city, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${city}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('history')}</h3>
            <div class="table-container">
                ${trackingData.length > 0 ? `
                <table class="table">
                    <thead>
                        <tr>
                            <th>${this.t('readyTime')}</th>
                            <th>${this.t('eventType')}</th>
                            <th>${this.t('status')}</th>
                            <th>${this.t('venue')}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${trackingData.slice(0, 20).map(t => {
                            const date = t.timestamp instanceof Date ? t.timestamp : new Date(t.timestamp);
                            const formattedDate = date.toLocaleDateString('en-GB') + ' ' + date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                            const formattedType = (t.type || 'unknown').replace(/_/g, ' ').split(' ').map(word =>
                                word.charAt(0).toUpperCase() + word.slice(1)
                            ).join(' ');

                            return `
                                <tr>
                                    <td>${formattedDate}</td>
                                    <td><span class="status-badge">${formattedType}</span></td>
                                    <td>${t.userInfo?.device || this.t('na')}</td>
                                    <td>${t.userInfo?.city || this.t('na')}${t.userInfo?.country ? ', ' + t.userInfo.country : ''}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
                ` : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analytics')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${totalOrders}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${confirmedOrders}</div>
                    <div class="stat-label">${this.t('confirmedOrders')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${completedOrders}</div>
                    <div class="stat-label">${this.t('completedOrders')}</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value">${cancelledOrders}</div>
                    <div class="stat-label">${this.t('cancelledOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('eventType')}</h3>
            <div class="stats-grid">
                ${Object.entries(eventTypes).length > 0 ? Object.entries(eventTypes).map(([type, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${type}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('customers')}</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${this.data.customers.length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders > 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders === 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${this.data.customers.length > 0 ? Math.round(orders.length / this.data.customers.length * 10) / 10 : 0}</div>
                    <div class="stat-label">${this.t('totalOrdersCount')}</div>
                </div>
            </div>
        </div>
    `;
},

            async renderFinancials() {
    const container = document.getElementById('financials');
    const orders = this.data.orders || [];
    const expenses = this.data.expenses || [];
    const payments = this.data.payments || [];

    // Check if user can view financials
    const canManageFinancials = await this.canViewFinancials();

    // Initialize default date range (current month)
    const now = new Date();
    const defaultStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
    const defaultEndDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    // Calculate financial metrics
    const calculateFinancials = (startDate, endDate) => {
        const start = startDate ? new Date(startDate) : defaultStartDate;
        const end = endDate ? new Date(endDate) : defaultEndDate;
        end.setHours(23, 59, 59, 999); // Include the entire end date

        // Filter orders by date range
        const filteredOrders = orders.filter(o => {
            const orderDate = o.orderDate ? new Date(o.orderDate) : new Date(o.createdAt || 0);
            return orderDate >= start && orderDate <= end;
        });

        // Filter expenses by date range
        const filteredExpenses = expenses.filter(e => {
            const expenseDate = e.date ? new Date(e.date) : new Date(e.timestamp?.toDate?.() || 0);
            return expenseDate >= start && expenseDate <= end;
        });

        // Filter payments by date range
        const filteredPayments = payments.filter(p => {
            const paymentDate = p.paymentDate ? new Date(p.paymentDate) : new Date(p.timestamp?.toDate?.() || 0);
            return paymentDate >= start && paymentDate <= end;
        });

        // Calculate revenue
        const totalRevenue = filteredOrders.reduce((sum, o) => {
            const amount = parseFloat(o.financials?.grandTotal || o.totalAmount || 0);
            return sum + amount;
        }, 0);

        // Calculate payments received (filtered by date range)
        const paymentsReceived = filteredPayments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);

        // Calculate total payments received (all time)
        const totalPaymentsReceived = payments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);

        // Calculate outstanding dues
        const outstandingDues = filteredOrders.reduce((sum, o) => {
            const balanceDue = parseFloat(o.financials?.balanceDue || 0);
            return sum + balanceDue;
        }, 0);

        // Calculate total costs
        const directCosts = filteredOrders.reduce((sum, o) => {
            const costs = o.financials?.directCosts?.total || 0;
            return sum + parseFloat(costs);
        }, 0);

        const indirectCosts = filteredExpenses.reduce((sum, e) => {
            if (e.category !== 'Materials Purchase') {
                return sum + parseFloat(e.amount || 0);
            }
            return sum;
        }, 0);

        const totalCosts = directCosts + indirectCosts;

        // Calculate profit (FIXED: Use actual payments received, not promised revenue)
        // Profit = Cash Received - Costs (Cash accounting method)
        const grossProfit = paymentsReceived - directCosts;
        const netProfit = paymentsReceived - totalCosts;
        const profitMargin = paymentsReceived > 0 ? ((netProfit / paymentsReceived) * 100).toFixed(2) : 0;

        return {
            totalRevenue,
            paymentsReceived,
            totalPaymentsReceived,
            outstandingDues,
            directCosts,
            indirectCosts,
            totalCosts,
            grossProfit,
            netProfit,
            profitMargin,
            ordersCount: filteredOrders.length,
            expensesCount: filteredExpenses.length,
            paymentsCount: filteredPayments.length,
            filteredOrders,
            filteredExpenses,
            filteredPayments
        };
    };

    const metrics = calculateFinancials();

    // Check if user has no financial data - might indicate permission issues
    const hasNoFinancialData = expenses.length === 0 && payments.length === 0;
    const roleSetupWarning = hasNoFinancialData ? `
        <div class="card" style="background: #fff3e0; border-left: 4px solid #ff9800; margin-bottom: 1.5rem;">
            <div style="padding: 1.5rem;">
                <h3 style="color: #f57c00; margin: 0 0 0.5rem 0;">âš ï¸ No Financial Data Found</h3>
                <p style="margin: 0.5rem 0; color: #666;">
                    If you're seeing this message and can't load expenses or payments, you might not have the proper role configured in Firestore.
                </p>
                <p style="margin: 0.5rem 0; color: #666;">
                    <strong>Check the browser console for permission errors.</strong>
                </p>
                <button onclick="OMS.showRoleSetupDialog()"
                        style="background: #ff9800; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem;">
                    ðŸ” Setup Your Role
                </button>
                <button onclick="window.location.href='setup-admin-users.html'"
                        style="background: #2196F3; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem; margin-left: 0.5rem;">
                    ðŸ“– View Setup Guide
                </button>
            </div>
        </div>
    ` : '';

    container.innerHTML = `
        ${roleSetupWarning}
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">ðŸ’° Financial Management</h2>
            </div>

            <!-- Date Range Selector -->
            <div class="card" style="background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: white;">
                <h3 style="color: white; margin-bottom: 1rem;">ðŸ“… Date Range Selection</h3>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label" style="color: white;">From Date</label>
                        <input type="date" id="finStartDate" class="form-input" value="${Utils.toDateString(defaultStartDate)}">
                    </div>
                    <div class="form-group">
                        <label class="form-label" style="color: white;">To Date</label>
                        <input type="date" id="finEndDate" class="form-input" value="${Utils.toDateString(defaultEndDate)}">
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('today')">ðŸ“† Today</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('week')">ðŸ“† This Week</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('month')">ðŸ“† This Month</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('quarter')">ðŸ“† This Quarter</button>
                    <button class="btn btn-secondary" onclick="OMS.setFinancialRange('year')">ðŸ“† This Year</button>
                    <button class="btn btn-success" onclick="OMS.applyFinancialRange()">ðŸ” Apply Range</button>
                </div>
            </div>

            <!-- Financial Dashboard -->
            <div class="stats-grid">
                <div class="stat-card success">
                    <div class="stat-value">â‚¹${metrics.totalRevenue.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Total Revenue</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">â‚¹${metrics.paymentsReceived.toLocaleString('en-IN')} / â‚¹${metrics.totalPaymentsReceived.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Payments Received (Period / All Time)</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">â‚¹${metrics.outstandingDues.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Outstanding Dues</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value">â‚¹${metrics.totalCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Total Costs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">â‚¹${metrics.directCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Direct Costs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">â‚¹${metrics.indirectCosts.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Indirect/Overhead Costs</div>
                </div>
                <div class="stat-card ${metrics.grossProfit >= 0 ? 'success' : 'danger'}">
                    <div class="stat-value">â‚¹${metrics.grossProfit.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Gross Profit</div>
                </div>
                <div class="stat-card ${metrics.netProfit >= 0 ? 'success' : 'danger'}">
                    <div class="stat-value">â‚¹${metrics.netProfit.toLocaleString('en-IN')}</div>
                    <div class="stat-label">Net Profit</div>
                </div>
                <div class="stat-card ${metrics.profitMargin >= 20 ? 'success' : metrics.profitMargin >= 10 ? 'warning' : 'danger'}">
                    <div class="stat-value">${metrics.profitMargin}%</div>
                    <div class="stat-label">Profit Margin</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${metrics.ordersCount}</div>
                    <div class="stat-label">Orders</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${metrics.paymentsCount} / ${payments.length}</div>
                    <div class="stat-label">Payments (Period / Total)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${metrics.expensesCount} / ${expenses.length}</div>
                    <div class="stat-label">Expenses (Period / Total)</div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="btn-group">
                ${canManageFinancials ? `
                    <button class="btn btn-success" onclick="OMS.showAddPaymentModal()">ðŸ’µ Add Payment</button>
                    <button class="btn btn-warning" onclick="OMS.showAddExpenseModal()">ðŸ’¸ Add Expense</button>
                ` : ''}
                <button class="btn btn-info" onclick="OMS.exportFinancialReport()">ðŸ“Š Export Report</button>
                <button class="btn btn-primary" onclick="OMS.showMonthlyComparison()">ðŸ“ˆ Monthly Comparison</button>
            </div>
        </div>

        <!-- Payments Section -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">ðŸ’µ Payment History</h3>
            </div>
            <div class="table-container">
                ${payments.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Order ID</th>
                                <th>Customer</th>
                                <th>Payment Type</th>
                                <th>Amount</th>
                                <th>Method</th>
                                <th>Transaction ID</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${payments.slice(0, 50).map(p => {
                                const hasBreakdown = p.itemBreakdown && p.itemBreakdown.length > 0;
                                const paymentTypeDisplay = p.paymentType || 'N/A';
                                return `
                                <tr>
                                    <td>${Utils.formatDate(p.paymentDate || p.timestamp?.toDate?.())}</td>
                                    <td>${p.orderId || 'N/A'}</td>
                                    <td>${p.customerName || 'N/A'}</td>
                                    <td><strong>${paymentTypeDisplay}</strong></td>
                                    <td>
                                        â‚¹${parseFloat(p.amount || 0).toLocaleString('en-IN')}
                                        ${hasBreakdown ? '<br><button class="btn btn-info btn-small" style="margin-top: 0.25rem;" onclick="OMS.togglePaymentBreakdown(\'' + p.id + '\')">ðŸ“‹ View Details</button>' : ''}
                                    </td>
                                    <td>${p.paymentMethod || 'N/A'}</td>
                                    <td>${p.transactionId || 'N/A'}</td>
                                    <td>
                                        ${canManageFinancials ? `
                                            <button class="btn btn-info btn-small" onclick="OMS.editPayment('${p.id}')">Edit</button>
                                            <button class="btn btn-danger btn-small" onclick="OMS.deletePayment('${p.id}')">Delete</button>
                                        ` : '<span style="color: var(--text-gray); font-style: italic;">View Only</span>'}
                                    </td>
                                </tr>
                                ${hasBreakdown ? `
                                <tr id="breakdown_${p.id}" style="display: none; background: #f5f5f5;">
                                    <td colspan="8" style="padding: 1rem;">
                                        <div style="background: white; padding: 1rem; border-radius: 8px; border: 2px solid #667eea;">
                                            <h4 style="margin: 0 0 1rem 0; color: #667eea;">ðŸ“‹ Item-wise Breakdown</h4>
                                            <table style="width: 100%; border-collapse: collapse;">
                                                <thead>
                                                    <tr style="background: #f0f0f0;">
                                                        <th style="padding: 0.5rem; text-align: left; border: 1px solid #ddd;">Item Name</th>
                                                        <th style="padding: 0.5rem; text-align: center; border: 1px solid #ddd;">Quantity</th>
                                                        <th style="padding: 0.5rem; text-align: right; border: 1px solid #ddd;">Price/Unit</th>
                                                        <th style="padding: 0.5rem; text-align: right; border: 1px solid #ddd;">Total</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    ${p.itemBreakdown.map(item => `
                                                        <tr>
                                                            <td style="padding: 0.5rem; border: 1px solid #ddd;">${item.itemName}</td>
                                                            <td style="padding: 0.5rem; text-align: center; border: 1px solid #ddd;">${item.quantity}</td>
                                                            <td style="padding: 0.5rem; text-align: right; border: 1px solid #ddd;">â‚¹${parseFloat(item.pricePerUnit).toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                                                            <td style="padding: 0.5rem; text-align: right; border: 1px solid #ddd; font-weight: bold;">â‚¹${parseFloat(item.itemTotal).toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                                                        </tr>
                                                    `).join('')}
                                                    <tr style="background: #e8eaf6; font-weight: bold;">
                                                        <td colspan="3" style="padding: 0.75rem; text-align: right; border: 1px solid #ddd;">Grand Total:</td>
                                                        <td style="padding: 0.75rem; text-align: right; border: 1px solid #ddd; font-size: 1.1em; color: #667eea;">â‚¹${parseFloat(p.amount).toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </td>
                                </tr>
                                ` : ''}
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No payment records found. Click "Add Payment" to get started.</p>`}
            </div>
        </div>

        <!-- Credit Reminders Section -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">â° Credit Payment Reminders</h3>
            </div>
            ${(() => {
                // Get all payments with credit due dates
                const paymentsWithCredit = payments.filter(p => p.creditDueDate && p.remainingBalance > 0);

                if (paymentsWithCredit.length === 0) {
                    return '<div style="padding: 2rem; text-align: center; color: var(--text-gray);">No pending credit payments. All orders are up to date!</div>';
                }

                // Calculate stats
                const today = new Date();
                const dueThisWeek = [];
                const overdue = [];
                const upcoming = [];

                ordersWithSchedules.forEach(order => {
                    order.paymentSchedule.forEach(inst => {
                        if (inst.isPaid) return; // Skip paid installments

                        const dueDate = new Date(inst.dueDate);
                        const sevenDaysFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

                        if (dueDate < today) {
                            overdue.push({ order, installment: inst });
                        } else if (dueDate <= sevenDaysFromNow) {
                            dueThisWeek.push({ order, installment: inst });
                        } else {
                            upcoming.push({ order, installment: inst });
                        }
                    });
                });

                const totalOverdue = overdue.reduce((sum, item) => sum + parseFloat(item.installment.amount), 0);
                const totalDueThisWeek = dueThisWeek.reduce((sum, item) => sum + parseFloat(item.installment.amount), 0);
                const totalUpcoming = upcoming.reduce((sum, item) => sum + parseFloat(item.installment.amount), 0);

                return `
                    <!-- Quick Stats -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                        <div style="background: linear-gradient(135deg, #f44336 0%, #e91e63 100%); color: white; padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold;">â‚¹${totalOverdue.toLocaleString('en-IN')}</div>
                            <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.9;">ðŸ”´ Overdue (${overdue.length} payments)</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #ff9800 0%, #ffc107 100%); color: white; padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold;">â‚¹${totalDueThisWeek.toLocaleString('en-IN')}</div>
                            <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.9;">â³ Due This Week (${dueThisWeek.length} payments)</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%); color: white; padding: 1.5rem; border-radius: 8px; text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold;">â‚¹${totalUpcoming.toLocaleString('en-IN')}</div>
                            <div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.9;">â±ï¸ Upcoming (${upcoming.length} payments)</div>
                        </div>
                    </div>

                    <!-- Orders with Payment Timelines -->
                    <div style="max-height: 600px; overflow-y: auto;">
                        ${ordersWithSchedules.map(order => {
                            const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                            const totalPaid = parseFloat(order.financials?.advancePaid || 0);
                            const balanceDue = parseFloat(order.financials?.balanceDue || 0);
                            const paymentProgress = orderTotal > 0 ? (totalPaid / orderTotal) * 100 : 0;

                            // Sort schedule by due date
                            const sortedSchedule = (order.paymentSchedule || []).sort((a, b) =>
                                new Date(a.dueDate) - new Date(b.dueDate)
                            );

                            return `
                                <div style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; background: white;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                        <div>
                                            <h4 style="margin: 0 0 0.5rem 0; color: #667eea;">${order.orderId || 'Pending'} - ${order.clientName}</h4>
                                            <p style="margin: 0; color: #666; font-size: 0.9rem;">
                                                Event: ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}
                                            </p>
                                        </div>
                                        <button class="btn btn-info btn-small" onclick="OMS.showPaymentScheduleModal('${order.docId || order.orderId}')">ðŸ“… Manage Schedule</button>
                                    </div>

                                    <!-- Payment Progress Bar -->
                                    <div style="margin-bottom: 1rem;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                            <span style="font-size: 0.9rem; color: #666;">Payment Progress</span>
                                            <span style="font-size: 0.9rem; font-weight: bold; color: ${paymentProgress === 100 ? '#4caf50' : '#667eea'};">
                                                ${paymentProgress.toFixed(0)}% (â‚¹${totalPaid.toLocaleString('en-IN')} / â‚¹${orderTotal.toLocaleString('en-IN')})
                                            </span>
                                        </div>
                                        <div style="width: 100%; height: 12px; background: #e0e0e0; border-radius: 6px; overflow: hidden;">
                                            <div style="width: ${paymentProgress}%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s ease;"></div>
                                        </div>
                                    </div>

                                    <!-- Payment Timeline -->
                                    <div style="background: #f9f9f9; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                                        <h5 style="margin: 0 0 1rem 0; font-size: 0.95rem; color: #666;">Payment Timeline</h5>
                                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                            ${sortedSchedule.map((inst, idx) => {
                                                const dueDate = new Date(inst.dueDate);
                                                const isOverdue = !inst.isPaid && dueDate < today;
                                                const isDueSoon = !inst.isPaid && dueDate >= today && dueDate <= new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

                                                let bgColor = '';
                                                let icon = '';
                                                if (inst.isPaid) {
                                                    bgColor = '#4caf50';
                                                    icon = 'âœ…';
                                                } else if (isOverdue) {
                                                    bgColor = '#f44336';
                                                    icon = 'ðŸ”´';
                                                } else if (isDueSoon) {
                                                    bgColor = '#ff9800';
                                                    icon = 'â³';
                                                } else {
                                                    bgColor = '#9e9e9e';
                                                    icon = 'â±ï¸';
                                                }

                                                return `
                                                    <div style="flex: 1; min-width: 150px; background: ${bgColor}; color: white; padding: 0.75rem; border-radius: 6px; font-size: 0.85rem;">
                                                        <div style="font-weight: bold; margin-bottom: 0.25rem;">${icon} ${inst.paymentType}</div>
                                                        <div style="opacity: 0.9;">â‚¹${parseFloat(inst.amount).toLocaleString('en-IN')}</div>
                                                        <div style="opacity: 0.9; font-size: 0.75rem; margin-top: 0.25rem;">${Utils.formatDate(inst.dueDate)}</div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>

                                    <!-- Installments Details -->
                                    <details style="margin-top: 1rem;">
                                        <summary style="cursor: pointer; font-weight: 600; color: #667eea;">View Detailed Schedule (${sortedSchedule.length} installments)</summary>
                                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                                            <thead>
                                                <tr style="background: #f0f0f0; border-bottom: 2px solid #ddd;">
                                                    <th style="padding: 0.5rem; text-align: left;">Type</th>
                                                    <th style="padding: 0.5rem; text-align: right;">Amount</th>
                                                    <th style="padding: 0.5rem; text-align: center;">Due Date</th>
                                                    <th style="padding: 0.5rem; text-align: center;">Status</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${sortedSchedule.map(inst => {
                                                    const dueDate = new Date(inst.dueDate);
                                                    const isOverdue = !inst.isPaid && dueDate < today;
                                                    const isDueSoon = !inst.isPaid && dueDate >= today && dueDate <= new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

                                                    let statusBadge = '';
                                                    if (inst.isPaid) {
                                                        statusBadge = '<span style="background: #4caf50; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">âœ… PAID</span>';
                                                    } else if (isOverdue) {
                                                        statusBadge = '<span style="background: #f44336; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">ðŸ”´ OVERDUE</span>';
                                                    } else if (isDueSoon) {
                                                        statusBadge = '<span style="background: #ff9800; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">â³ DUE SOON</span>';
                                                    } else {
                                                        statusBadge = '<span style="background: #9e9e9e; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">â±ï¸ PENDING</span>';
                                                    }

                                                    return `
                                                        <tr style="border-bottom: 1px solid #eee;">
                                                            <td style="padding: 0.5rem;"><strong>${inst.paymentType}</strong></td>
                                                            <td style="padding: 0.5rem; text-align: right;">â‚¹${parseFloat(inst.amount).toLocaleString('en-IN')}</td>
                                                            <td style="padding: 0.5rem; text-align: center;">${Utils.formatDate(inst.dueDate)}</td>
                                                            <td style="padding: 0.5rem; text-align: center;">${statusBadge}</td>
                                                        </tr>
                                                    `;
                                                }).join('')}
                                            </tbody>
                                        </table>
                                    </details>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            })()}
        </div>

        <!-- Expenses Section -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">ðŸ’¸ Expenses</h3>
            </div>
            <div class="table-container">
                ${expenses.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Category</th>
                                <th>Description</th>
                                <th>Amount</th>
                                <th>Vendor</th>
                                <th>Payment Method</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${expenses.slice(0, 50).map(e => `
                                <tr>
                                    <td>${Utils.formatDate(e.date || e.timestamp?.toDate?.())}</td>
                                    <td><span class="badge">${e.category || 'N/A'}</span></td>
                                    <td>${e.description || 'N/A'}</td>
                                    <td>â‚¹${parseFloat(e.amount || 0).toLocaleString('en-IN')}</td>
                                    <td>${e.vendor || 'N/A'}</td>
                                    <td>${e.paymentMethod || 'N/A'}</td>
                                    <td>
                                        ${canManageFinancials ? `
                                            <button class="btn btn-info btn-small" onclick="OMS.editExpense('${e.id}')">Edit</button>
                                            <button class="btn btn-danger btn-small" onclick="OMS.deleteExpense('${e.id}')">Delete</button>
                                        ` : '<span style="color: var(--text-gray); font-style: italic;">View Only</span>'}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No expense records found. Click "Add Expense" to get started.</p>`}
            </div>
        </div>

        <!-- Order Financial Details -->
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">ðŸ“Š Order-wise Financial Breakdown</h3>
            </div>
            <div class="table-container">
                ${orders.length > 0 ? `
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Order ID</th>
                                <th>Date</th>
                                <th>Customer</th>
                                <th>Revenue</th>
                                <th>Costs</th>
                                <th>Profit</th>
                                <th>Margin %</th>
                                <th>Payment Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${orders.filter(o => o.status === 'Completed' || o.status === 'Confirmed').slice(0, 50).map(o => {
                                const revenue = parseFloat(o.financials?.grandTotal || o.totalAmount || 0);
                                const costs = parseFloat(o.financials?.directCosts?.total || 0);
                                const profit = revenue - costs;
                                const margin = revenue > 0 ? ((profit / revenue) * 100).toFixed(1) : 0;
                                const balanceDue = parseFloat(o.financials?.balanceDue || 0);
                                const paymentStatus = balanceDue === 0 ? 'Paid' : balanceDue >= revenue ? 'Pending' : 'Partial';

                                return `
                                <tr>
                                    <td>${o.orderId || 'Pending'}</td>
                                    <td>${Utils.formatDate(o.orderDate)}</td>
                                    <td>${o.clientName || 'N/A'}</td>
                                    <td>â‚¹${revenue.toLocaleString('en-IN')}</td>
                                    <td>â‚¹${costs.toLocaleString('en-IN')}</td>
                                    <td class="${profit >= 0 ? 'success' : 'danger'}">â‚¹${profit.toLocaleString('en-IN')}</td>
                                    <td class="${margin >= 20 ? 'success' : margin >= 10 ? 'warning' : 'danger'}">${margin}%</td>
                                    <td><span class="badge ${paymentStatus === 'Paid' ? 'success' : paymentStatus === 'Partial' ? 'warning' : 'danger'}">${paymentStatus}</span></td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                ` : `<p style="text-align: center; padding: 2rem; color: var(--text-gray);">No orders found for the selected period.</p>`}
            </div>
        </div>
    `;

    // Add event listeners for date inputs
    setTimeout(() => {
        const startDateInput = document.getElementById('finStartDate');
        const endDateInput = document.getElementById('finEndDate');

        if (startDateInput && endDateInput) {
            startDateInput.addEventListener('change', () => OMS.applyFinancialRange());
            endDateInput.addEventListener('change', () => OMS.applyFinancialRange());
        }
    }, 100);
},

            // ========== VIDEOS MODULE ==========
            renderVideos() {
                const container = document.getElementById('videos');
                const videos = this.data.videos || [];

                const html = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ðŸŽ¥ Video Management</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage videos displayed on your quotation website</p>
                            <button class="btn btn-primary" onclick="OMS.showAddVideoModal()">âž• Add New Video</button>
                        </div>

                        <div id="videos-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 24px; margin-top: 24px;">
                            ${videos.length === 0 ? `
                                <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px;">
                                    <div style="font-size: 80px; margin-bottom: 20px;">ðŸŽ¬</div>
                                    <h3 style="font-size: 24px; color: #333; margin-bottom: 8px;">No Videos Yet</h3>
                                    <p style="font-size: 16px; color: #6c757d; margin-bottom: 24px;">Add YouTube or Instagram videos to showcase on your website</p>
                                    <button class="btn btn-primary" onclick="OMS.showAddVideoModal()">Add First Video</button>
                                </div>
                            ` : videos.map((video, index) => {
                                const embedUrl = this.getVideoEmbedUrl(video.url);

                                // Skip invalid Instagram URLs
                                if (!embedUrl) {
                                    console.warn('âš ï¸ Skipping invalid video URL:', video.url);
                                    return `
                                        <div class="video-card" style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 16px; padding: 20px;">
                                            <div style="color: #856404;">
                                                <strong>âš ï¸ Invalid URL</strong><br>
                                                <small>${video.url}</small><br>
                                                <button class="btn btn-danger" onclick="OMS.deleteVideo(${index})" style="margin-top: 10px;">Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }

                                // Determine platform and aspect ratio
                                const isYouTube = video.url.includes('youtube.com') || video.url.includes('youtu.be');
                                const isInstagramReel = video.url.includes('/reel/') || video.url.includes('/tv/');
                                const isInstagramPost = video.url.includes('/p/');

                                let platform, aspectRatio;
                                if (isYouTube) {
                                    platform = 'ðŸ“º YouTube';
                                    aspectRatio = '56.25%'; // 16:9
                                } else if (isInstagramReel) {
                                    platform = 'ðŸ“· Instagram Reel';
                                    aspectRatio = '177.78%'; // 9:16 vertical
                                } else if (isInstagramPost) {
                                    platform = 'ðŸ“· Instagram Post';
                                    aspectRatio = '100%'; // 1:1 square
                                } else {
                                    platform = 'ðŸ“· Instagram';
                                    aspectRatio = '100%'; // Default to square
                                }

                                const createdDate = new Date(video.createdAt).toLocaleDateString();

                                return `
                                    <div class="video-card" style="background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%); border-radius: 16px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); transition: all 0.3s ease; border: 1px solid #e9ecef;">
                                        <div style="position: relative; width: 100%; padding-bottom: ${aspectRatio}; background: #000; overflow: hidden;">
                                            <iframe
                                                src="${embedUrl}"
                                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                                allowfullscreen
                                                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;">
                                            </iframe>
                                            <div style="position: absolute; top: 12px; right: 12px; background: rgba(0, 0, 0, 0.7); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; z-index: 10;">${platform}</div>
                                        </div>
                                        <div style="padding: 20px;">
                                            <div style="font-size: 18px; font-weight: 600; color: #333; margin-bottom: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${video.title || 'Untitled Video'}</div>
                                            <div style="font-size: 14px; color: #6c757d; margin-bottom: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${video.url}</div>
                                            <div style="display: flex; gap: 12px; margin-bottom: 16px; font-size: 13px; color: #6c757d;">
                                                <span>ðŸ“… ${createdDate}</span>
                                                <span>ðŸ‘ï¸ Visible: ${video.visible ? 'Yes' : 'No'}</span>
                                            </div>
                                            <div style="display: flex; gap: 8px;">
                                                <button class="btn btn-primary" onclick="OMS.editVideo(${index})" style="flex: 1;">âœï¸ Edit</button>
                                                <button class="btn btn-danger" onclick="OMS.deleteVideo(${index})" style="flex: 1;">ðŸ—‘ï¸ Delete</button>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            },

            getVideoEmbedUrl(url) {
                if (!url) return '';

                // YouTube
                if (url.includes('youtube.com') || url.includes('youtu.be')) {
                    let videoId = '';
                    if (url.includes('youtube.com/watch?v=')) {
                        videoId = url.split('v=')[1]?.split('&')[0];
                    } else if (url.includes('youtu.be/')) {
                        videoId = url.split('youtu.be/')[1]?.split('?')[0];
                    } else if (url.includes('youtube.com/embed/')) {
                        return url;
                    }
                    return videoId ? `https://www.youtube.com/embed/${videoId}` : url;
                }

                // Instagram - IMPROVED VALIDATION
                if (url.includes('instagram.com')) {
                    // Remove trailing slash
                    let cleanUrl = url.replace(/\/$/, '');

                    // Extract post/reel ID using regex
                    // Matches: /p/ABC123 or /reel/ABC123 or /tv/ABC123
                    const match = cleanUrl.match(/\/(p|reel|tv)\/([A-Za-z0-9_-]+)/);

                    if (match) {
                        const type = match[1]; // 'p', 'reel', or 'tv'
                        const id = match[2];   // post/reel ID

                        // Return proper embed URL
                        return `https://www.instagram.com/${type}/${id}/embed/`;
                    }

                    // If no valid post/reel found, return error indicator
                    console.warn('âš ï¸ Invalid Instagram URL format:', url);
                    return null; // Signal that this is invalid
                }

                return url;
            },

            showAddVideoModal() {
                const modalHtml = `
                    <div class="modal show" id="videoModal" onclick="if(event.target === this) OMS.closeVideoModal()" style="z-index: 10000;">
                        <div class="modal-content" style="max-width: 500px;">
                            <button class="modal-close" onclick="OMS.closeVideoModal()">Ã—</button>
                            <h2>âž• Add New Video</h2>

                            <div class="form-group" style="margin-top: 1.5rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Video Title</label>
                                <input type="text" id="videoTitle" class="form-input" placeholder="e.g., Wedding Sparklers Showcase">
                            </div>

                            <div class="form-group" style="margin-top: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Video URL *</label>
                                <input type="url" id="videoUrl" class="form-input" placeholder="https://www.instagram.com/reel/ABC123/">
                                <small style="display: block; margin-top: 0.25rem; color: var(--text-gray); font-size: 0.875rem;">
                                    <strong>Supported URLs:</strong><br>
                                    â€¢ YouTube: youtube.com/watch?v=...<br>
                                    â€¢ Instagram Post: instagram.com/p/ABC123/<br>
                                    â€¢ Instagram Reel: instagram.com/reel/ABC123/
                                </small>
                            </div>

                            <div class="form-group" style="margin-top: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <input type="checkbox" id="videoVisible" checked>
                                    <span>Show on website</span>
                                </label>
                            </div>

                            <div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="OMS.closeVideoModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="OMS.saveVideo()">Save Video</button>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHtml;
            },

            closeVideoModal() {
                document.getElementById('modalsContainer').innerHTML = '';
            },

            async saveVideo() {
                const title = Utils.get('videoTitle');
                const url = Utils.get('videoUrl');
                const visible = document.getElementById('videoVisible').checked;

                if (!url) {
                    this.showToast('Please enter a video URL', 'error');
                    return;
                }

                // VALIDATE URL BEFORE SAVING
                const embedUrl = this.getVideoEmbedUrl(url);

                if (url.includes('instagram.com') && !embedUrl) {
                    this.showToast('âŒ Invalid Instagram URL! Use format: instagram.com/p/ABC123/ or instagram.com/reel/ABC123/', 'error');
                    return;
                }

                if (!embedUrl || embedUrl === url) {
                    // For non-Instagram URLs that don't convert, that's OK
                    // But for Instagram, we need a proper embed URL
                    if (url.includes('instagram.com')) {
                        this.showToast('âŒ Invalid Instagram URL! Please copy the link from a specific post or reel.', 'error');
                        return;
                    }
                }

                const video = {
                    title: title || 'Untitled Video',
                    url,
                    visible,
                    createdAt: new Date().toISOString()
                };

                if (!this.data.videos) {
                    this.data.videos = [];
                }

                this.data.videos.push(video);

                try {
                    await this.saveVideosToFirestore();
                    this.closeVideoModal();
                    this.renderVideos();
                    this.showToast('âœ… Video added successfully!');
                } catch (error) {
                    console.error('Error saving video:', error);
                    this.showToast('âŒ Error saving video. Please try again.', 'error');
                }
            },

            editVideo(index) {
                const video = this.data.videos[index];
                this.showAddVideoModal();

                setTimeout(() => {
                    Utils.set('videoTitle', video.title || '');
                    Utils.set('videoUrl', video.url || '');
                    document.getElementById('videoVisible').checked = video.visible !== false;

                    const saveBtn = document.querySelector('.modal-content .btn-primary');
                    saveBtn.textContent = 'Update Video';
                    saveBtn.onclick = () => this.updateVideo(index);
                }, 100);
            },

            async updateVideo(index) {
                const title = Utils.get('videoTitle');
                const url = Utils.get('videoUrl');
                const visible = document.getElementById('videoVisible').checked;

                if (!url) {
                    this.showToast('Please enter a video URL', 'error');
                    return;
                }

                this.data.videos[index] = {
                    ...this.data.videos[index],
                    title: title || 'Untitled Video',
                    url,
                    visible
                };

                try {
                    await this.saveVideosToFirestore();
                    this.closeVideoModal();
                    this.renderVideos();
                    this.showToast('âœ… Video updated successfully!');
                } catch (error) {
                    console.error('Error updating video:', error);
                    this.showToast('âŒ Error updating video. Please try again.', 'error');
                }
            },

            async deleteVideo(index) {
                if (!confirm('Are you sure you want to delete this video?')) {
                    return;
                }

                this.data.videos.splice(index, 1);

                try {
                    await this.saveVideosToFirestore();
                    this.renderVideos();
                    this.showToast('âœ… Video deleted successfully!');
                } catch (error) {
                    console.error('Error deleting video:', error);
                    this.showToast('âŒ Error deleting video. Please try again.', 'error');
                }
            },

            // ========== ADVERTISEMENTS MODULE ==========
            renderAdvertisements() {
                const container = document.getElementById('advertisements');
                const ads = this.data.advertisements || [];

                // Filter stats
                const activeAds = ads.filter(ad => ad.status === 'active').length;
                const scheduledAds = ads.filter(ad => ad.status === 'scheduled').length;
                const inactiveAds = ads.filter(ad => ad.status === 'inactive').length;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ðŸ“¢ Ad Manager</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage advertisements displayed on your quotation website</p>
                            <button class="btn btn-primary" onclick="OMS.showCreateAdModal()">âž• Create New Ad</button>
                        </div>

                        <!-- Stats Cards -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                            <div class="stat-card" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${activeAds}</div>
                                <div style="opacity: 0.9;">Active Ads</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${scheduledAds}</div>
                                <div style="opacity: 0.9;">Scheduled</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${inactiveAds}</div>
                                <div style="opacity: 0.9;">Inactive</div>
                            </div>
                            <div class="stat-card" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 1.5rem; border-radius: 12px;">
                                <div style="font-size: 2rem; font-weight: bold;">${ads.length}</div>
                                <div style="opacity: 0.9;">Total Ads</div>
                            </div>
                        </div>

                        <!-- Ads List -->
                        <div class="table-container">
                            ${ads.length === 0 ? `
                                <div style="text-align: center; padding: 3rem;">
                                    <div style="font-size: 4rem; margin-bottom: 1rem;">ðŸ“¢</div>
                                    <h3>No Advertisements Yet</h3>
                                    <p style="color: var(--text-gray); margin-bottom: 1.5rem;">Create your first ad to display on your quotation website</p>
                                    <button class="btn btn-primary" onclick="OMS.showCreateAdModal()">Create First Ad</button>
                                </div>
                            ` : `
                                <table class="data-table">
                                    <thead>
                                        <tr>
                                            <th>Title</th>
                                            <th>Type</th>
                                            <th>Animation</th>
                                            <th>Position</th>
                                            <th>Status</th>
                                            <th>Views</th>
                                            <th>Clicks</th>
                                            <th>CTR</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${ads.map((ad, index) => {
                                            const views = ad.analytics?.views || 0;
                                            const clicks = ad.analytics?.clicks || 0;
                                            const ctr = views > 0 ? ((clicks / views) * 100).toFixed(1) : 0;
                                            const statusColors = {
                                                active: '#10b981',
                                                scheduled: '#f59e0b',
                                                inactive: '#6b7280'
                                            };
                                            const typeIcons = {
                                                image: 'ðŸ–¼ï¸',
                                                text: 'ðŸ“',
                                                video: 'ðŸŽ¥'
                                            };

                                            return `
                                                <tr>
                                                    <td><strong>${ad.title}</strong></td>
                                                    <td>${typeIcons[ad.type]} ${ad.type.charAt(0).toUpperCase() + ad.type.slice(1)}</td>
                                                    <td>${ad.type === 'text' && ad.content?.animation ? `<span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 4px 10px; border-radius: 8px; font-size: 0.8rem;">âœ¨ ${ad.content.animation}</span>` : '<span style="color: var(--text-gray);">â€”</span>'}</td>
                                                    <td>${ad.placement?.position || 'header'}</td>
                                                    <td>
                                                        <span style="background: ${statusColors[ad.status]}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.85rem;">
                                                            ${ad.status.charAt(0).toUpperCase() + ad.status.slice(1)}
                                                        </span>
                                                    </td>
                                                    <td>${views}</td>
                                                    <td>${clicks}</td>
                                                    <td>${ctr}%</td>
                                                    <td>
                                                        <button class="btn btn-sm" onclick="OMS.toggleAdStatus('${ad.id}', ${index})" style="background: ${ad.status === 'active' ? '#f59e0b' : '#10b981'}; color: white; margin-right: 0.5rem;">
                                                            ${ad.status === 'active' ? 'â¸ï¸' : 'â–¶ï¸'}
                                                        </button>
                                                        <button class="btn btn-sm btn-secondary" onclick="OMS.editAd(${index})" style="margin-right: 0.5rem;">âœï¸</button>
                                                        <button class="btn btn-sm" onclick="OMS.deleteAd('${ad.id}', ${index})" style="background: var(--danger); color: white;">ðŸ—‘ï¸</button>
                                                    </td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            `}
                        </div>
                    </div>
                `;
            },

            showCreateAdModal() {
                const modalHtml = `
                    <div class="modal-overlay" onclick="OMS.closeAdModal()"></div>
                    <div class="modal-dialog" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>âž• Create New Advertisement</h3>
                            <button class="modal-close" onclick="OMS.closeAdModal()">âœ•</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Ad Type *</label>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem;">
                                    <button type="button" class="type-btn active" data-type="image" onclick="OMS.selectAdType('image')" style="padding: 1rem; border: 2px solid var(--primary); background: var(--primary); color: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        ðŸ–¼ï¸ Image
                                    </button>
                                    <button type="button" class="type-btn" data-type="text" onclick="OMS.selectAdType('text')" style="padding: 1rem; border: 2px solid var(--border); background: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        ðŸ“ Text
                                    </button>
                                    <button type="button" class="type-btn" data-type="video" onclick="OMS.selectAdType('video')" style="padding: 1rem; border: 2px solid var(--border); background: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
                                        ðŸŽ¥ Video
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Ad Title *</label>
                                <input type="text" id="adTitle" class="form-control" placeholder="e.g., Summer Special Offer">
                            </div>

                            <!-- Image Ad Fields -->
                            <div id="imageAdFields" class="ad-type-fields">
                                <div class="form-group">
                                    <label>Image URL *</label>
                                    <input type="url" id="adImageUrl" class="form-control" placeholder="https://example.com/image.jpg">
                                    <small style="color: var(--text-gray);">Enter the full URL of your image (must be publicly accessible)</small>
                                </div>
                                <div class="form-group">
                                    <label>Link URL</label>
                                    <input type="url" id="adImageLink" class="form-control" placeholder="https://example.com">
                                </div>
                                <div class="form-group">
                                    <label>Alt Text</label>
                                    <input type="text" id="adImageAlt" class="form-control" placeholder="Promotional banner">
                                </div>

                                <!-- Image Style Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">ðŸŽ¨ Image Style Settings</h4>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Max Width: <span id="imageWidthValue">100</span>%</label>
                                            <input type="range" id="adImageWidth" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('imageWidthValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Border Radius: <span id="imageBorderRadiusValue">12</span>px</label>
                                            <input type="range" id="adImageBorderRadius" class="form-control" min="0" max="50" step="2" value="12"
                                                   oninput="document.getElementById('imageBorderRadiusValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Opacity: <span id="imageOpacityValue">100</span>%</label>
                                            <input type="range" id="adImageOpacity" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('imageOpacityValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Shadow Intensity</label>
                                            <select id="adImageShadow" class="form-control">
                                                <option value="none">None</option>
                                                <option value="sm">Small</option>
                                                <option value="md" selected>Medium</option>
                                                <option value="lg">Large</option>
                                                <option value="xl">Extra Large</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div class="form-group">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <input type="checkbox" id="adImageHoverEffect" checked>
                                            Enable Hover Effect (scale on hover)
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- Text Ad Fields -->
                            <div id="textAdFields" class="ad-type-fields" style="display: none;">
                                <div class="form-group">
                                    <label>Headline *</label>
                                    <input type="text" id="adTextHeadline" class="form-control" placeholder="Get 20% Off!">
                                </div>
                                <div class="form-group">
                                    <label>Description</label>
                                    <textarea id="adTextDescription" class="form-control" rows="3" placeholder="Limited time offer..."></textarea>
                                </div>
                                <div class="form-group">
                                    <label>Button Text</label>
                                    <input type="text" id="adTextButton" class="form-control" placeholder="Learn More">
                                </div>
                                <div class="form-group">
                                    <label>Button Link</label>
                                    <input type="url" id="adTextLink" class="form-control" placeholder="https://example.com">
                                </div>
                                <div class="form-group">
                                    <label>ðŸŽ¨ Text Color (for all text elements)</label>
                                    <input type="color" id="adTextColor" class="form-control" value="#ffffff">
                                </div>
                                <div class="form-group">
                                    <label>âœ¨ Animation Effect</label>
                                    <select id="adTextAnimation" class="form-control">
                                        <option value="none">None</option>
                                        <optgroup label="ðŸŽ¨ Fade Effects">
                                            <option value="fadeIn">Fade In</option>
                                            <option value="fadeOut">Fade Out</option>
                                        </optgroup>
                                        <optgroup label="ðŸ“Š Slide Effects">
                                            <option value="slideInLeft">Slide In from Left</option>
                                            <option value="slideInRight">Slide In from Right</option>
                                            <option value="slideInTop">Slide In from Top</option>
                                            <option value="slideInBottom">Slide In from Bottom</option>
                                        </optgroup>
                                        <optgroup label="ðŸŒŸ Zoom Effects">
                                            <option value="zoomIn">Zoom In</option>
                                            <option value="zoomOut">Zoom Out</option>
                                        </optgroup>
                                        <optgroup label="ðŸ”„ Rotation Effects">
                                            <option value="rotateIn">Rotate In</option>
                                            <option value="swing">Swing</option>
                                        </optgroup>
                                        <optgroup label="ðŸ’« Motion Effects">
                                            <option value="bounce">Bounce</option>
                                            <option value="shake">Shake</option>
                                            <option value="wave">Wave</option>
                                            <option value="rubberBand">Rubber Band</option>
                                        </optgroup>
                                        <optgroup label="âœ¨ Special Effects">
                                            <option value="pulse">Pulse</option>
                                            <option value="glow">Glow</option>
                                            <option value="sparkle">Sparkle</option>
                                            <option value="flipIn">Flip In</option>
                                            <option value="flipX">Flip X</option>
                                        </optgroup>
                                    </select>
                                    <small style="color: var(--text-gray); margin-top: 0.5rem; display: block;">Choose an animation effect for your text ad</small>
                                </div>

                                <!-- Typography Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">ðŸ”¤ Typography Settings</h4>

                                    <div class="form-group">
                                        <label>Headline Font Size: <span id="headlineSizeValue">2</span>rem</label>
                                        <input type="range" id="adTextHeadlineSize" class="form-control" min="1" max="6" step="0.1" value="2"
                                               oninput="document.getElementById('headlineSizeValue').textContent = this.value"
                                               style="width: 100%;">
                                        <small style="color: var(--text-gray);">Adjust headline text size</small>
                                    </div>

                                    <div class="form-group">
                                        <label>Description Font Size: <span id="descSizeValue">1.1</span>rem</label>
                                        <input type="range" id="adTextDescSize" class="form-control" min="0.5" max="3" step="0.1" value="1.1"
                                               oninput="document.getElementById('descSizeValue').textContent = this.value"
                                               style="width: 100%;">
                                        <small style="color: var(--text-gray);">Adjust description text size</small>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Font Weight</label>
                                            <select id="adTextFontWeight" class="form-control">
                                                <option value="300">Light (300)</option>
                                                <option value="400">Normal (400)</option>
                                                <option value="500">Medium (500)</option>
                                                <option value="600">Semi-Bold (600)</option>
                                                <option value="700" selected>Bold (700)</option>
                                                <option value="800">Extra-Bold (800)</option>
                                                <option value="900">Black (900)</option>
                                            </select>
                                        </div>

                                        <div class="form-group">
                                            <label>Text Alignment</label>
                                            <select id="adTextAlign" class="form-control">
                                                <option value="left">Left</option>
                                                <option value="center" selected>Center</option>
                                                <option value="right">Right</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Letter Spacing: <span id="letterSpaceValue">0</span>px</label>
                                            <input type="range" id="adTextLetterSpacing" class="form-control" min="-2" max="10" step="0.5" value="0"
                                                   oninput="document.getElementById('letterSpaceValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Line Height: <span id="lineHeightValue">1.5</span></label>
                                            <input type="range" id="adTextLineHeight" class="form-control" min="1" max="3" step="0.1" value="1.5"
                                                   oninput="document.getElementById('lineHeightValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div class="form-group">
                                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                                            <input type="checkbox" id="adTextShadow">
                                            Add Text Shadow (improves readability)
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- Video Ad Fields -->
                            <div id="videoAdFields" class="ad-type-fields" style="display: none;">
                                <div class="form-group">
                                    <label>Video URL *</label>
                                    <input type="url" id="adVideoUrl" class="form-control" placeholder="YouTube or Instagram URL">
                                    <small style="color: var(--text-gray);">Paste a YouTube or Instagram video URL</small>
                                </div>
                                <div class="form-group">
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="checkbox" id="adVideoAutoplay" checked>
                                        Autoplay video
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                                        <input type="checkbox" id="adVideoMuted" checked>
                                        Muted by default
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                                        <input type="checkbox" id="adVideoLoop">
                                        Loop video continuously
                                    </label>
                                </div>

                                <!-- Video Style Settings -->
                                <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                    <h4 style="margin-bottom: 1rem;">ðŸŽ¬ Video Style Settings</h4>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Max Width: <span id="videoWidthValue">100</span>%</label>
                                            <input type="range" id="adVideoWidth" class="form-control" min="50" max="100" step="5" value="100"
                                                   oninput="document.getElementById('videoWidthValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>

                                        <div class="form-group">
                                            <label>Border Radius: <span id="videoBorderRadiusValue">12</span>px</label>
                                            <input type="range" id="adVideoBorderRadius" class="form-control" min="0" max="50" step="2" value="12"
                                                   oninput="document.getElementById('videoBorderRadiusValue').textContent = this.value"
                                                   style="width: 100%;">
                                        </div>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Aspect Ratio</label>
                                            <select id="adVideoAspectRatio" class="form-control">
                                                <option value="16/9" selected>16:9 (Widescreen)</option>
                                                <option value="9/16">9:16 (Vertical)</option>
                                                <option value="4/3">4:3 (Standard)</option>
                                                <option value="1/1">1:1 (Square)</option>
                                            </select>
                                        </div>

                                        <div class="form-group">
                                            <label>Shadow Intensity</label>
                                            <select id="adVideoShadow" class="form-control">
                                                <option value="none">None</option>
                                                <option value="sm">Small</option>
                                                <option value="md" selected>Medium</option>
                                                <option value="lg">Large</option>
                                                <option value="xl">Extra Large</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Placement -->
                            <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1.5rem;">
                                <h4 style="margin-bottom: 1rem;">ðŸ“ Placement Settings</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div class="form-group">
                                        <label>Position *</label>
                                        <select id="adPosition" class="form-control">
                                            <option value="header">Header Banner</option>
                                            <option value="sidebar">Sidebar</option>
                                            <option value="footer">Footer</option>
                                            <option value="popup">Popup/Modal</option>
                                            <option value="between-sections">Between Sections</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Display On *</label>
                                        <select id="adPage" class="form-control">
                                            <option value="all">All Pages</option>
                                            <option value="home">Home Page Only</option>
                                            <option value="quotation">Quotation Page Only</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Schedule -->
                            <div style="background: var(--light); padding: 1.5rem; border-radius: 12px; margin-top: 1rem;">
                                <h4 style="margin-bottom: 1rem;">â° Schedule Settings</h4>
                                <div class="form-group">
                                    <label>Status *</label>
                                    <select id="adStatus" class="form-control" onchange="OMS.toggleScheduleFields()">
                                        <option value="active">Active Now</option>
                                        <option value="scheduled">Schedule for Later</option>
                                        <option value="inactive">Inactive (Draft)</option>
                                    </select>
                                </div>
                                <div id="scheduleFields" style="display: none;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                        <div class="form-group">
                                            <label>Start Date</label>
                                            <input type="datetime-local" id="adStartDate" class="form-control">
                                        </div>
                                        <div class="form-group">
                                            <label>End Date</label>
                                            <input type="datetime-local" id="adEndDate" class="form-control">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group" style="margin-top: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem;">
                                    <input type="checkbox" id="adVisible" checked>
                                    Show ad on website
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="OMS.closeAdModal()">Cancel</button>
                            <button class="btn btn-primary" onclick="OMS.saveAd()" id="saveAdBtn">Create Ad</button>
                        </div>
                    </div>
                `;

                const existing = document.querySelector('.modal-overlay');
                if (existing) existing.remove();

                document.body.insertAdjacentHTML('beforeend', modalHtml);
            },

            selectAdType(type) {
                document.querySelectorAll('.type-btn').forEach(btn => {
                    if (btn.dataset.type === type) {
                        btn.style.background = 'var(--primary)';
                        btn.style.borderColor = 'var(--primary)';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.borderColor = 'var(--border)';
                        btn.style.color = 'var(--text-dark)';
                    }
                });

                document.getElementById('imageAdFields').style.display = type === 'image' ? 'block' : 'none';
                document.getElementById('textAdFields').style.display = type === 'text' ? 'block' : 'none';
                document.getElementById('videoAdFields').style.display = type === 'video' ? 'block' : 'none';
            },

            toggleScheduleFields() {
                const status = document.getElementById('adStatus').value;
                document.getElementById('scheduleFields').style.display = status === 'scheduled' ? 'block' : 'none';
            },

            closeAdModal() {
                const overlay = document.querySelector('.modal-overlay');
                const dialog = document.querySelector('.modal-dialog');
                if (overlay) overlay.remove();
                if (dialog) dialog.remove();
            },

            async saveAd() {
                try {
                    console.log('ðŸ’¾ saveAd() called');

                    const activeTypeBtn = document.querySelector('.type-btn[style*="rgb(102, 126, 234)"], .type-btn[style*="#667eea"]') ||
                                        document.querySelector('.type-btn[style*="--primary"]') ||
                                        document.querySelector('.type-btn');
                    const adType = activeTypeBtn?.dataset.type || 'image';

                    console.log('ðŸ“ Ad type:', adType);

                    const title = document.getElementById('adTitle').value.trim();
                    if (!title) {
                        alert('Please enter an ad title');
                        return;
                    }

                    console.log('ðŸ“ Ad title:', title);

                    let content = {};

                    if (adType === 'image') {
                        const imageUrl = document.getElementById('adImageUrl').value.trim();
                        if (!imageUrl) {
                            alert('Please enter an image URL');
                            return;
                        }
                        content = {
                            imageUrl,
                            link: document.getElementById('adImageLink').value.trim(),
                            altText: document.getElementById('adImageAlt').value.trim(),
                            width: document.getElementById('adImageWidth').value,
                            borderRadius: document.getElementById('adImageBorderRadius').value,
                            opacity: document.getElementById('adImageOpacity').value,
                            shadow: document.getElementById('adImageShadow').value,
                            hoverEffect: document.getElementById('adImageHoverEffect').checked
                        };
                    } else if (adType === 'text') {
                        const headline = document.getElementById('adTextHeadline').value.trim();
                        if (!headline) {
                            alert('Please enter a headline');
                            return;
                        }
                        content = {
                            headline,
                            description: document.getElementById('adTextDescription').value.trim(),
                            buttonText: document.getElementById('adTextButton').value.trim(),
                            buttonLink: document.getElementById('adTextLink').value.trim(),
                            backgroundColor: 'transparent',
                            textColor: document.getElementById('adTextColor').value,
                            animation: document.getElementById('adTextAnimation').value || 'none',
                            headlineSize: document.getElementById('adTextHeadlineSize').value,
                            descSize: document.getElementById('adTextDescSize').value,
                            fontWeight: document.getElementById('adTextFontWeight').value,
                            textAlign: document.getElementById('adTextAlign').value,
                            letterSpacing: document.getElementById('adTextLetterSpacing').value,
                            lineHeight: document.getElementById('adTextLineHeight').value,
                            textShadow: document.getElementById('adTextShadow').checked
                        };
                    } else if (adType === 'video') {
                        const videoUrl = document.getElementById('adVideoUrl').value.trim();
                        if (!videoUrl) {
                            alert('Please enter a video URL');
                            return;
                        }
                        content = {
                            videoUrl,
                            platform: videoUrl.includes('youtube') ? 'youtube' : 'instagram',
                            autoplay: document.getElementById('adVideoAutoplay').checked,
                            muted: document.getElementById('adVideoMuted').checked,
                            loop: document.getElementById('adVideoLoop').checked,
                            width: document.getElementById('adVideoWidth').value,
                            borderRadius: document.getElementById('adVideoBorderRadius').value,
                            aspectRatio: document.getElementById('adVideoAspectRatio').value,
                            shadow: document.getElementById('adVideoShadow').value
                        };
                    }

                    console.log('ðŸ“ Ad content:', content);

                    const status = document.getElementById('adStatus').value;
                    const schedule = {};
                    if (status === 'scheduled') {
                        schedule.startDate = document.getElementById('adStartDate').value;
                        schedule.endDate = document.getElementById('adEndDate').value;
                    }

                    const ad = {
                        id: 'ad_' + Date.now(),
                        type: adType,
                        title,
                        status,
                        content,
                        placement: {
                            position: document.getElementById('adPosition').value,
                            page: document.getElementById('adPage').value,
                            displayOrder: 1
                        },
                        schedule,
                        analytics: {
                            views: 0,
                            clicks: 0,
                            impressions: 0
                        },
                        isVisible: document.getElementById('adVisible').checked,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        createdBy: this.currentUser?.email || 'admin'
                    };

                    console.log('ðŸ“¦ Complete ad object:', ad);

                    if (!this.data.advertisements) {
                        console.log('âš ï¸ Initializing advertisements array');
                        this.data.advertisements = [];
                    }

                    console.log('ðŸ“Š Current advertisements count:', this.data.advertisements.length);
                    this.data.advertisements.push(ad);
                    console.log('ðŸ“Š New advertisements count:', this.data.advertisements.length);

                    console.log('ðŸ’¾ Calling saveAdsToFirestore...');
                    await this.saveAdsToFirestore();
                    console.log('âœ… Save completed successfully');

                    this.closeAdModal();
                    this.renderAdvertisements();
                    this.showToast('âœ… Advertisement created successfully!');
                } catch (error) {
                    console.error('âŒ Error in saveAd():', error);
                    console.error('Error stack:', error.stack);
                    this.showToast('âŒ Error creating advertisement. Check console for details.', 'error');
                }
            },

            async editAd(index) {
                const ad = this.data.advertisements[index];
                this.showCreateAdModal();

                setTimeout(() => {
                    document.getElementById('adTitle').value = ad.title || '';
                    document.getElementById('adStatus').value = ad.status || 'active';
                    document.getElementById('adPosition').value = ad.placement?.position || 'header';
                    document.getElementById('adPage').value = ad.placement?.page || 'all';
                    document.getElementById('adVisible').checked = ad.isVisible !== false;

                    this.selectAdType(ad.type);

                    if (ad.type === 'image') {
                        document.getElementById('adImageUrl').value = ad.content.imageUrl || '';
                        document.getElementById('adImageLink').value = ad.content.link || '';
                        document.getElementById('adImageAlt').value = ad.content.altText || '';
                        document.getElementById('adImageWidth').value = ad.content.width || '100';
                        document.getElementById('adImageBorderRadius').value = ad.content.borderRadius || '12';
                        document.getElementById('adImageOpacity').value = ad.content.opacity || '100';
                        document.getElementById('adImageShadow').value = ad.content.shadow || 'md';
                        document.getElementById('adImageHoverEffect').checked = ad.content.hoverEffect !== false;
                        // Update display values
                        document.getElementById('imageWidthValue').textContent = ad.content.width || '100';
                        document.getElementById('imageBorderRadiusValue').textContent = ad.content.borderRadius || '12';
                        document.getElementById('imageOpacityValue').textContent = ad.content.opacity || '100';
                    } else if (ad.type === 'text') {
                        document.getElementById('adTextHeadline').value = ad.content.headline || '';
                        document.getElementById('adTextDescription').value = ad.content.description || '';
                        document.getElementById('adTextButton').value = ad.content.buttonText || '';
                        document.getElementById('adTextLink').value = ad.content.buttonLink || '';
                        document.getElementById('adTextColor').value = ad.content.textColor || '#ffffff';
                        document.getElementById('adTextAnimation').value = ad.content.animation || 'none';
                        document.getElementById('adTextHeadlineSize').value = ad.content.headlineSize || '2';
                        document.getElementById('adTextDescSize').value = ad.content.descSize || '1.1';
                        document.getElementById('adTextFontWeight').value = ad.content.fontWeight || '700';
                        document.getElementById('adTextAlign').value = ad.content.textAlign || 'center';
                        document.getElementById('adTextLetterSpacing').value = ad.content.letterSpacing || '0';
                        document.getElementById('adTextLineHeight').value = ad.content.lineHeight || '1.5';
                        document.getElementById('adTextShadow').checked = ad.content.textShadow || false;
                        // Update display values
                        document.getElementById('headlineSizeValue').textContent = ad.content.headlineSize || '2';
                        document.getElementById('descSizeValue').textContent = ad.content.descSize || '1.1';
                        document.getElementById('letterSpaceValue').textContent = ad.content.letterSpacing || '0';
                        document.getElementById('lineHeightValue').textContent = ad.content.lineHeight || '1.5';
                    } else if (ad.type === 'video') {
                        document.getElementById('adVideoUrl').value = ad.content.videoUrl || '';
                        document.getElementById('adVideoAutoplay').checked = ad.content.autoplay !== false;
                        document.getElementById('adVideoMuted').checked = ad.content.muted !== false;
                        document.getElementById('adVideoLoop').checked = ad.content.loop || false;
                        document.getElementById('adVideoWidth').value = ad.content.width || '100';
                        document.getElementById('adVideoBorderRadius').value = ad.content.borderRadius || '12';
                        document.getElementById('adVideoAspectRatio').value = ad.content.aspectRatio || '16/9';
                        document.getElementById('adVideoShadow').value = ad.content.shadow || 'md';
                        // Update display values
                        document.getElementById('videoWidthValue').textContent = ad.content.width || '100';
                        document.getElementById('videoBorderRadiusValue').textContent = ad.content.borderRadius || '12';
                    }

                    if (ad.schedule?.startDate) {
                        document.getElementById('adStartDate').value = ad.schedule.startDate;
                    }
                    if (ad.schedule?.endDate) {
                        document.getElementById('adEndDate').value = ad.schedule.endDate;
                    }

                    this.toggleScheduleFields();

                    const saveBtn = document.getElementById('saveAdBtn');
                    saveBtn.textContent = 'Update Ad';
                    saveBtn.onclick = () => this.updateAd(index);
                }, 100);
            },

            async updateAd(index) {
                try {
                    const ad = this.data.advertisements[index];
                    const activeTypeBtn = document.querySelector('.type-btn[style*="rgb(102, 126, 234)"], .type-btn[style*="#667eea"]') ||
                                        document.querySelector('.type-btn[style*="--primary"]') ||
                                        document.querySelector('.type-btn');
                    const adType = activeTypeBtn?.dataset.type || ad.type;

                    ad.title = document.getElementById('adTitle').value.trim();
                    ad.status = document.getElementById('adStatus').value;
                    ad.placement.position = document.getElementById('adPosition').value;
                    ad.placement.page = document.getElementById('adPage').value;
                    ad.isVisible = document.getElementById('adVisible').checked;
                    ad.updatedAt = new Date().toISOString();

                    if (ad.type === 'image') {
                        ad.content.imageUrl = document.getElementById('adImageUrl').value.trim();
                        ad.content.link = document.getElementById('adImageLink').value.trim();
                        ad.content.altText = document.getElementById('adImageAlt').value.trim();
                        ad.content.width = document.getElementById('adImageWidth').value;
                        ad.content.borderRadius = document.getElementById('adImageBorderRadius').value;
                        ad.content.opacity = document.getElementById('adImageOpacity').value;
                        ad.content.shadow = document.getElementById('adImageShadow').value;
                        ad.content.hoverEffect = document.getElementById('adImageHoverEffect').checked;
                    } else if (ad.type === 'text') {
                        ad.content.headline = document.getElementById('adTextHeadline').value.trim();
                        ad.content.description = document.getElementById('adTextDescription').value.trim();
                        ad.content.buttonText = document.getElementById('adTextButton').value.trim();
                        ad.content.buttonLink = document.getElementById('adTextLink').value.trim();
                        ad.content.backgroundColor = 'transparent';
                        ad.content.textColor = document.getElementById('adTextColor').value;
                        ad.content.animation = document.getElementById('adTextAnimation').value || 'none';
                        ad.content.headlineSize = document.getElementById('adTextHeadlineSize').value;
                        ad.content.descSize = document.getElementById('adTextDescSize').value;
                        ad.content.fontWeight = document.getElementById('adTextFontWeight').value;
                        ad.content.textAlign = document.getElementById('adTextAlign').value;
                        ad.content.letterSpacing = document.getElementById('adTextLetterSpacing').value;
                        ad.content.lineHeight = document.getElementById('adTextLineHeight').value;
                        ad.content.textShadow = document.getElementById('adTextShadow').checked;
                    } else if (ad.type === 'video') {
                        ad.content.videoUrl = document.getElementById('adVideoUrl').value.trim();
                        ad.content.autoplay = document.getElementById('adVideoAutoplay').checked;
                        ad.content.muted = document.getElementById('adVideoMuted').checked;
                        ad.content.loop = document.getElementById('adVideoLoop').checked;
                        ad.content.width = document.getElementById('adVideoWidth').value;
                        ad.content.borderRadius = document.getElementById('adVideoBorderRadius').value;
                        ad.content.aspectRatio = document.getElementById('adVideoAspectRatio').value;
                        ad.content.shadow = document.getElementById('adVideoShadow').value;
                    }

                    if (ad.status === 'scheduled') {
                        ad.schedule = {
                            startDate: document.getElementById('adStartDate').value,
                            endDate: document.getElementById('adEndDate').value
                        };
                    }

                    await this.saveAdsToFirestore();
                    this.closeAdModal();
                    this.renderAdvertisements();
                    this.showToast('âœ… Advertisement updated successfully!');
                } catch (error) {
                    console.error('Error updating ad:', error);
                    this.showToast('âŒ Error updating advertisement. Please try again.', 'error');
                }
            },

            async toggleAdStatus(adId, index) {
                try {
                    const ad = this.data.advertisements[index];
                    ad.status = ad.status === 'active' ? 'inactive' : 'active';
                    ad.updatedAt = new Date().toISOString();

                    await this.saveAdsToFirestore();
                    this.renderAdvertisements();

                    const statusText = ad.status === 'active' ? 'activated' : 'paused';
                    this.showToast(`âœ… Ad ${statusText} successfully!`);
                } catch (error) {
                    console.error('Error toggling ad status:', error);
                    this.showToast('âŒ Error updating ad status. Please try again.', 'error');
                }
            },

            async deleteAd(adId, index) {
                if (!confirm('Are you sure you want to delete this advertisement? This action cannot be undone.')) {
                    return;
                }

                try {
                    this.data.advertisements.splice(index, 1);
                    await this.saveAdsToFirestore();
                    this.renderAdvertisements();
                    this.showToast('âœ… Advertisement deleted successfully!');
                } catch (error) {
                    console.error('Error deleting ad:', error);
                    this.showToast('âŒ Error deleting advertisement. Please try again.', 'error');
                }
            },

            async saveAdsToFirestore() {
                const database = window.db || this.db;
                if (!database) {
                    console.error('âŒ Database not initialized');
                    console.error('window.db:', window.db);
                    console.error('this.db:', this.db);
                    return;
                }

                try {
                    console.log('ðŸ’¾ Starting to save ads to Firestore...');
                    console.log('âœ… Using database:', database ? 'Connected' : 'Not connected');
                    console.log('ðŸ“Š Ads to save:', this.data.advertisements);

                    const adsRef = database.collection('advertisements');

                    // Delete all existing ads
                    console.log('ðŸ—‘ï¸ Deleting existing ads...');
                    const snapshot = await adsRef.get();
                    console.log('ðŸ“¦ Found', snapshot.size, 'existing ads to delete');

                    const batch = database.batch();
                    snapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    console.log('âœ… Existing ads deleted');

                    // Add all current ads
                    console.log('ðŸ’¾ Adding', this.data.advertisements.length, 'new ads...');
                    const newBatch = database.batch();
                    this.data.advertisements.forEach(ad => {
                        console.log('ðŸ“ Adding ad:', ad.id, ad.title);
                        const docRef = adsRef.doc(ad.id);
                        newBatch.set(docRef, ad);
                    });
                    await newBatch.commit();

                    console.log('âœ… Advertisements saved to Firestore successfully!');
                } catch (error) {
                    console.error('âŒ Error saving ads to Firestore:', error);
                    console.error('Error details:', error.message, error.code);
                    throw error;
                }
            },

            async loadAdsFromFirestore() {
                const database = window.db || this.db;
                if (!database) {
                    console.error('âŒ Database not initialized for loading ads');
                    return;
                }

                try {
                    console.log('ðŸ“¥ Loading advertisements from Firestore...');
                    const snapshot = await database.collection('advertisements').get();
                    this.data.advertisements = snapshot.docs.map(doc => doc.data());
                    console.log('âœ… Advertisements loaded from Firestore:', this.data.advertisements.length);
                    console.log('ðŸ“‹ Loaded ads:', this.data.advertisements);
                } catch (error) {
                    console.error('âŒ Error loading ads from Firestore:', error);
                    console.error('Error details:', error.message, error.code);
                    this.data.advertisements = [];
                }
            },

            renderSettings() {
                const container = document.getElementById('settings');
                const s = this.data.settings;
                const ts = s.tableSettings;
                const colors = s.printColors;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('systemSettings')}</h2>
                        </div>

                        <div class="card">
                            <h3>${this.t('tableLayoutSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('srColumnWidth')}: <span id="srWidthValue">${ts.columnWidthSr}%</span></label>
                                    <input type="range" id="columnWidthSr" class="form-input" min="5" max="25" value="${ts.columnWidthSr}"
                                           oninput="document.getElementById('srWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('itemColumnWidth')}: <span id="itemWidthValue">${ts.columnWidthItem}%</span></label>
                                    <input type="range" id="columnWidthItem" class="form-input" min="15" max="60" value="${ts.columnWidthItem}"
                                           oninput="document.getElementById('itemWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('qtyColumnWidth')}: <span id="qtyWidthValue">${ts.columnWidthQty}%</span></label>
                                    <input type="range" id="columnWidthQty" class="form-input" min="5" max="30" value="${ts.columnWidthQty}"
                                           oninput="document.getElementById('qtyWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('remarksColumnWidth')}: <span id="remarksWidthValue">${ts.columnWidthRemarks}%</span></label>
                                    <input type="range" id="columnWidthRemarks" class="form-input" min="15" max="60" value="${ts.columnWidthRemarks}"
                                           oninput="document.getElementById('remarksWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('leftMarginFiling')}: <span id="leftMarginValue">${ts.leftMargin}mm</span></label>
                                    <input type="range" id="leftMargin" class="form-input" min="30" max="100" value="${ts.leftMargin}"
                                           oninput="document.getElementById('leftMarginValue').textContent = this.value + 'mm'">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('colorCustomization')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerBackground')}</label>
                                    <input type="color" id="printHeaderBg" class="form-input" value="${colors.headerBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerText')}</label>
                                    <input type="color" id="printHeaderText" class="form-input" value="${colors.headerText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdBackground')}</label>
                                    <input type="color" id="printOrderIdBg" class="form-input" value="${colors.orderIdBg || '#667eea'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdText')}</label>
                                    <input type="color" id="printOrderIdText" class="form-input" value="${colors.orderIdText || '#ffffff'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderBackground')}</label>
                                    <input type="color" id="printTableHeaderBg" class="form-input" value="${colors.tableHeaderBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderText')}</label>
                                    <input type="color" id="printTableHeaderText" class="form-input" value="${colors.tableHeaderText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableBorder')}</label>
                                    <input type="color" id="printTableBorder" class="form-input" value="${colors.tableBorder}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('notesBackground')}</label>
                                    <input type="color" id="printNotesBg" class="form-input" value="${colors.notesBg}" style="height: 50px;">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('printSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('fontSize')}: <span id="fontSizeValue">${s.printFontSize}px</span></label>
                                    <input type="range" id="printFontSize" class="form-input" min="16" max="80" value="${s.printFontSize}"
                                           oninput="document.getElementById('fontSizeValue').textContent = this.value + 'px'">
                                    <small style="color: var(--text-gray);">${this.t('multiOrderNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('paperFormat')}</label>
                                    <select id="paperFormat" class="form-select">
                                        <option value="A4" ${s.paperFormat === 'A4' ? 'selected' : ''}>A4 (210 Ã— 297 mm)</option>
                                        <option value="Legal" ${s.paperFormat === 'Legal' ? 'selected' : ''}>Legal (216 Ã— 356 mm)</option>
                                        <option value="Letter" ${s.paperFormat === 'Letter' ? 'selected' : ''}>Letter (216 Ã— 279 mm)</option>
                                        <option value="A3" ${s.paperFormat === 'A3' ? 'selected' : ''}>A3 (297 Ã— 420 mm)</option>
                                        <option value="A5" ${s.paperFormat === 'A5' ? 'selected' : ''}>A5 (148 Ã— 210 mm)</option>
                                        <option value="Tabloid" ${s.paperFormat === 'Tabloid' ? 'selected' : ''}>Tabloid (279 Ã— 432 mm)</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('chooseFormat')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('pageOrientation')}</label>
                                    <select id="paperOrientation" class="form-select">
                                        <option value="portrait" ${s.paperOrientation === 'portrait' ? 'selected' : ''}>${this.t('portrait')}</option>
                                        <option value="landscape" ${s.paperOrientation === 'landscape' ? 'selected' : ''}>${this.t('landscape')}</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('portraitOrLandscape')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('imageQuality')}</label>
                                    <select id="imageQuality" class="form-select">
                                        <option value="1" ${s.imageQuality === 1 ? 'selected' : ''}>${this.t('low')} (${this.t('faster')})</option>
                                        <option value="2" ${s.imageQuality === 2 ? 'selected' : ''}>${this.t('medium')} (${this.t('balanced')})</option>
                                        <option value="3" ${s.imageQuality === 3 ? 'selected' : ''}>${this.t('high')} (${this.t('betterQuality')})</option>
                                        <option value="4" ${s.imageQuality === 4 ? 'selected' : ''}>${this.t('ultra')} (${this.t('bestQuality')})</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('higherQualityNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('functionColor')}</label>
                                    <input type="color" id="functionColor" class="form-input" value="${s.functionColor || '#667eea'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">${this.t('customColorNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Background Color</label>
                                    <input type="color" id="printBgColor" class="form-input" value="${s.printBgColor || '#ffffff'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">Set the background color for downloaded images</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Text Color</label>
                                    <input type="color" id="printTextColor" class="form-input" value="${s.printTextColor || '#000000'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">Set the text color for downloaded images</small>
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('systemPreferences')}</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('defaultOrderStatus')}</label>
                                    <select id="defaultOrderStatus" class="form-select">
                                        <option value="Confirmed" ${s.defaultOrderStatus === 'Confirmed' ? 'selected' : ''}>${this.t('confirmed')}</option>
                                        <option value="Completed" ${s.defaultOrderStatus === 'Completed' ? 'selected' : ''}>${this.t('completed')}</option>
                                        <option value="Cancelled" ${s.defaultOrderStatus === 'Cancelled' ? 'selected' : ''}>${this.t('cancelled')}</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('lowStockThreshold')}</label>
                                    <input type="number" id="lowStockThreshold" class="form-input" value="${s.lowStockThreshold}" min="1">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('language')}</label>
                                    <select id="appLanguage" class="form-select">
                                        <option value="en" ${s.language === 'en' ? 'selected' : ''}>English</option>
                                        <option value="gu" ${s.language === 'gu' ? 'selected' : ''}>àª—à«àªœàª°àª¾àª¤à«€</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('invoiceFormat')}</label>
                                    <select id="invoiceFormat" class="form-select">
                                        <option value="FP" ${s.invoicePrefix === 'FP' ? 'selected' : ''}>FP001</option>
                                        <option value="ORD" ${s.invoicePrefix === 'ORD' ? 'selected' : ''}>ORD001</option>
                                        <option value="INV" ${s.invoicePrefix === 'INV' ? 'selected' : ''}>INV001</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>ðŸŒ¤ï¸ Weather Integration</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">OpenWeatherMap API Key</label>
                                    <input type="text" id="weatherApiKey" class="form-input" value="${s.weatherApiKey || ''}" placeholder="Enter your API key">
                                    <small style="color: var(--text-gray);">Get a free API key from <a href="https://openweathermap.org/api" target="_blank">OpenWeatherMap</a></small>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Default City</label>
                                    <input type="text" id="defaultCity" class="form-input" value="${s.defaultCity || 'Delhi'}" placeholder="Delhi">
                                    <small style="color: var(--text-gray);">Default city for weather data (e.g., Delhi, Mumbai, etc.)</small>
                                </div>
                            </div>
                        </div>

                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="OMS.saveSettings()">${this.t('saveAllSettings')}</button>
                            <button class="btn btn-secondary" onclick="OMS.resetSettings()">${this.t('resetToDefaults')}</button>
                        </div>

                        <div class="card">
                            <h3>${this.t('dataManagement')}</h3>
                            <div class="btn-group">
                                <button class="btn btn-info" data-action="exportData">${this.t('exportJSON')}</button>
                                <button class="btn btn-success" onclick="OMS.exportData('csv')">${this.t('exportCSV')}</button>
                                <button class="btn btn-warning" data-action="importData">${this.t('importBackup')}</button>
                                <button class="btn btn-danger" onclick="OMS.resetAllData()">${this.t('resetAllData')}</button>
                            </div>
                        </div>
                    </div>
                `;
            },

            async saveSettings() {
                // Save table settings
                this.data.settings.tableSettings = {
                    columnWidthSr: parseInt(Utils.get('columnWidthSr')) || 8,
                    columnWidthItem: parseInt(Utils.get('columnWidthItem')) || 40,
                    columnWidthQty: parseInt(Utils.get('columnWidthQty')) || 12,
                    columnWidthRemarks: parseInt(Utils.get('columnWidthRemarks')) || 40,
                    leftMargin: parseInt(Utils.get('leftMargin')) || 50
                };

                // Save colors
                this.data.settings.printColors = {
                    headerBg: Utils.get('printHeaderBg') || '#667eea',
                    headerText: Utils.get('printHeaderText') || '#ffffff',
                    orderIdBg: Utils.get('printOrderIdBg') || '#667eea',
                    orderIdText: Utils.get('printOrderIdText') || '#ffffff',
                    tableHeaderBg: Utils.get('printTableHeaderBg') || '#f8f9fa',
                    tableHeaderText: Utils.get('printTableHeaderText') || '#333333',
                    tableBorder: Utils.get('printTableBorder') || '#333333',
                    notesBg: Utils.get('printNotesBg') || '#f9f9f9'
                };

                // Save other settings
                this.data.settings.printFontSize = parseInt(Utils.get('printFontSize')) || 26;
                this.data.settings.printBgColor = Utils.get('printBgColor') || '#ffffff';
                this.data.settings.printTextColor = Utils.get('printTextColor') || '#000000';
                this.data.settings.defaultOrderStatus = Utils.get('defaultOrderStatus') || 'Confirmed';
                this.data.settings.lowStockThreshold = parseInt(Utils.get('lowStockThreshold')) || 5;
                this.data.settings.language = Utils.get('appLanguage') || 'en';
                this.data.settings.invoicePrefix = Utils.get('invoiceFormat') || 'FP';

                // Save new print settings
                this.data.settings.paperFormat = Utils.get('paperFormat') || 'A4';
                this.data.settings.paperOrientation = Utils.get('paperOrientation') || 'portrait';
                this.data.settings.imageQuality = parseInt(Utils.get('imageQuality')) || 2;
                this.data.settings.functionColor = Utils.get('functionColor') || '#667eea';

                // Save weather settings
                this.data.settings.weatherApiKey = Utils.get('weatherApiKey') || '';
                this.data.settings.defaultCity = Utils.get('defaultCity') || 'Delhi';

                // Save to localStorage
                this.saveToStorage();

                // Save to Firestore for persistence across devices
                const saved = await this.saveSettingsToFirestore();

                if (saved) {
                    this.refreshOrderId();
                    this.showToast('All settings saved successfully!');
                } else {
                    this.showToast('Settings saved locally, but Firestore sync failed. Check permissions.');
                }
            },

            resetAllData() {
                if (!confirm('âš ï¸ This will delete ALL data permanently. Are you absolutely sure?')) return;
                if (!confirm('Last chance! This action CANNOT be undone. Confirm data reset?')) return;
                
                localStorage.removeItem('oms_data');
                this.showToast('Data reset! Reloading...');
                setTimeout(() => location.reload(), 1000);
            },

            resetSettings() {
                if (!confirm('Reset all settings?')) return;

                this.data.settings = {
                    printFontSize: 26,
                    printBgColor: '#ffffff',
                    printTextColor: '#000000',
                    orderIdCounter: this.data.settings.orderIdCounter,
                    invoicePrefix: 'FP',
                    lowStockThreshold: 5,
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    weatherApiKey: '',
                    defaultCity: 'Delhi',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9'
                    },
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                };

                this.saveToStorage();
                this.renderSettings();
                this.showToast('Settings reset!');
            },

            // ============ ITEM SEARCH ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Prevent duplicate event listener registration
                if (itemSearch.dataset.searchInitialized === 'true') return;
                itemSearch.dataset.searchInitialized = 'true';

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                // Capture OMS context
                const self = this;

                const handleSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const items = self.data.inventory.items.filter(i =>
                            i.name.toLowerCase().includes(query)
                        );

                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                itemSearch.addEventListener('input', Utils.debounce(handleSearch, 300));

                // Initialize client name search with autocomplete
                this.initClientSearch();
            },

            initClientSearch() {
                const clientInput = document.getElementById('clientName');
                const dropdown = document.getElementById('clientSearchDropdown');

                if (!clientInput || !dropdown) return;

                // Prevent duplicate event listener registration
                if (clientInput.dataset.searchInitialized === 'true') return;
                clientInput.dataset.searchInitialized = 'true';

                // Capture OMS context
                const self = this;

                const handleClientSearch = (e) => {
                    const query = e.target.value.toLowerCase().trim();

                    if (query.length > 0) {
                        const customers = self.data.customers.filter(c =>
                            c.name.toLowerCase().includes(query)
                        );

                        if (customers.length > 0) {
                            dropdown.innerHTML = customers.map(c => `
                                <div class="search-item" onclick="OMS.selectCustomer('${c.id}')">
                                    <span>${c.name}</span>
                                    <span style="color: var(--text-gray);">${c.contact}</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                };

                clientInput.addEventListener('input', Utils.debounce(handleClientSearch, 300));

                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!clientInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            },

            selectCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;

                // Auto-fill customer name and contact
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);

                // Hide dropdown
                document.getElementById('clientSearchDropdown').classList.remove('show');

                this.showToast(`Selected: ${customer.name}`, 'success');
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;
                
                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }
                
                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;
                
                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }
                
                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Pcs</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)" 
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}" 
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">ðŸ—‘ï¸</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ FINANCIAL MANAGEMENT ============

            setFinancialRange(range) {
                const now = new Date();
                let startDate, endDate;

                switch(range) {
                    case 'today':
                        startDate = endDate = now;
                        break;
                    case 'week':
                        startDate = new Date(now.setDate(now.getDate() - now.getDay()));
                        endDate = new Date(now.setDate(startDate.getDate() + 6));
                        break;
                    case 'month':
                        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        break;
                    case 'quarter':
                        const quarter = Math.floor(now.getMonth() / 3);
                        startDate = new Date(now.getFullYear(), quarter * 3, 1);
                        endDate = new Date(now.getFullYear(), quarter * 3 + 3, 0);
                        break;
                    case 'year':
                        startDate = new Date(now.getFullYear(), 0, 1);
                        endDate = new Date(now.getFullYear(), 11, 31);
                        break;
                }

                Utils.set('finStartDate', Utils.toDateString(startDate));
                Utils.set('finEndDate', Utils.toDateString(endDate));
            },

            applyFinancialRange() {
                this.renderFinancials();
            },

            async showAddPaymentModal() {
                const orders = this.data.orders.filter(o => o.status !== 'Cancelled');
                console.log(`ðŸ’³ Opening payment modal with ${orders.length} active orders`);

                const modalHTML = `
                    <div class="modal show" id="paymentModal" onclick="if(event.target === this) OMS.closeModal('paymentModal')">
                        <div class="modal-content" style="max-width: 800px;">
                            <button class="modal-close" onclick="OMS.closeModal('paymentModal')">Ã—</button>
                            <h2>ðŸ’µ Add Payment</h2>
                            <form id="paymentForm" onsubmit="OMS.savePayment(event)" style="display: block;">
                                <div class="form-group" style="margin-bottom: 1.5rem;">
                                    <label class="form-label required">Select Order</label>
                                    <select id="paymentOrderId" class="form-select" required onchange="OMS.loadOrderForPayment()" style="width: 100%; padding: 0.75rem;">
                                        <option value="">-- Select an Order --</option>
                                        ${orders.map(o => {
                                            const total = parseFloat(o.financials?.grandTotal || o.totalAmount || 0);
                                            const paid = parseFloat(o.financials?.advancePaid || 0);
                                            const due = parseFloat(o.financials?.balanceDue || total);
                                            return `<option value="${o.docId || o.orderId}">${o.orderId || 'Pending'} - ${o.clientName} (â‚¹${due.toLocaleString('en-IN')} due)</option>`;
                                        }).join('')}
                                    </select>
                                </div>

                                <div id="orderDetailsSection" style="display: none;">
                                    <!-- Set Order Total -->
                                    <div style="background: #e3f2fd; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #2196f3;">
                                        <h4 style="margin: 0 0 1rem 0; font-size: 1rem; color: #1976d2;">ðŸ’° Set Order Total Amount</h4>
                                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1rem; align-items: end;">
                                            <div class="form-group" style="margin: 0;">
                                                <label class="form-label">Total Order Amount (â‚¹)</label>
                                                <input type="number" id="orderTotalAmount" class="form-input" min="0" step="0.01" placeholder="Enter total amount" style="width: 100%; padding: 0.75rem; font-size: 1.1rem; font-weight: bold;" oninput="OMS.updateOrderTotalFromInput()">
                                                <small style="color: #666;">Set the total amount for this order</small>
                                            </div>
                                            <button type="button" class="btn btn-primary" onclick="OMS.saveOrderTotal()" style="height: fit-content;">ðŸ’¾ Save Total</button>
                                        </div>
                                    </div>

                                    <!-- Order Items with Price Inputs -->
                                    <div style="background: #f5f5f5; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                        <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">ðŸ“‹ Order Items</h3>
                                        <div style="max-height: 300px; overflow-y: auto; border: 2px solid #e0e0e0; border-radius: 8px; background: white;">
                                            <table style="width: 100%; border-collapse: collapse;" id="paymentItemsTable">
                                                <thead style="position: sticky; top: 0; background: #f9f9f9;">
                                                    <tr style="border-bottom: 2px solid #ddd;">
                                                        <th style="text-align: left; padding: 8px;">Item</th>
                                                        <th style="text-align: center; padding: 8px;">Qty</th>
                                                        <th style="text-align: right; padding: 8px;">Price (â‚¹)</th>
                                                        <th style="text-align: right; padding: 8px;">Total</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="paymentItemsBody">
                                                </tbody>
                                                <tfoot style="background: #e8f5e9; font-weight: bold;">
                                                    <tr>
                                                        <td colspan="3" style="text-align: right; padding: 12px; font-size: 1.1rem;">Grand Total from Items:</td>
                                                        <td style="text-align: right; padding: 12px; font-size: 1.1rem; color: #667eea;">â‚¹<span id="itemsGrandTotal">0</span></td>
                                                    </tr>
                                                </tfoot>
                                            </table>
                                        </div>
                                    </div>

                                    <!-- Payment Summary -->
                                    <div style="background: #e8f5e9; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                            <h4 style="margin: 0; font-size: 1rem; color: #2e7d32;">ðŸ’° Payment Summary</h4>
                                            <button type="button" class="btn btn-warning btn-small" onclick="OMS.recalculateOrderFinancials(Utils.get('paymentOrderId'))" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;" title="Recalculate financial data from actual payment records">
                                                ðŸ”„ Fix Financials
                                            </button>
                                        </div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                                            <div style="text-align: center;">
                                                <div style="color: #666; font-size: 0.9rem;">Order Total</div>
                                                <div style="font-size: 1.5rem; font-weight: bold; color: #667eea;">â‚¹<span id="displayOrderTotal">0</span></div>
                                            </div>
                                            <div style="text-align: center;">
                                                <div style="color: #666; font-size: 0.9rem;">Already Received</div>
                                                <div style="font-size: 1.5rem; font-weight: bold; color: #4caf50;">â‚¹<span id="displayAlreadyPaid">0</span></div>
                                            </div>
                                            <div style="text-align: center;">
                                                <div style="color: #666; font-size: 0.9rem;">Balance Remaining</div>
                                                <div style="font-size: 1.5rem; font-weight: bold; color: #f44336;">â‚¹<span id="displayPendingAmount">0</span></div>
                                            </div>
                                        </div>
                                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border-radius: 4px; font-size: 0.85rem; color: #856404;">
                                            ðŸ’¡ <strong>Tip:</strong> If the "Already Received" amount doesn't match the actual payments below, click "Fix Financials" to recalculate from payment records.
                                        </div>
                                    </div>

                                    <!-- Previous Payments -->
                                    <div id="previousPaymentsSection" style="display: none; background: #fff9e6; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #ffc107;">
                                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: #856404;">ðŸ’° Previous Payments</h4>
                                        <div id="previousPaymentsList" style="font-size: 0.9rem;"></div>
                                    </div>

                                    <!-- New Payment Entry -->
                                    <div style="background: #e3f2fd; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                                        <h4 style="margin: 0 0 1rem 0; font-size: 1rem; color: #1976d2;">âž• Record New Payment</h4>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                            <div class="form-group">
                                                <label class="form-label required">Payment Date</label>
                                                <input type="date" id="paymentDate" class="form-input" value="${Utils.toDateString(new Date())}" required style="width: 100%; padding: 0.75rem;">
                                            </div>
                                            <div class="form-group">
                                                <label class="form-label required">Amount Received (â‚¹)</label>
                                                <input type="number" id="paymentAmount" class="form-input" required min="0" step="0.01" placeholder="0.00" style="width: 100%; padding: 0.75rem;" oninput="OMS.updateRemainingAfterNewPayment()">
                                            </div>
                                        </div>
                                        <div style="background: white; padding: 1rem; border-radius: 4px; margin-bottom: 1rem;">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #666;">After this payment, remaining balance:</span>
                                                <span style="font-size: 1.2rem; font-weight: bold; color: #f44336;" id="newRemainingBalance">â‚¹0</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="paymentMethod" class="form-select" required style="width: 100%; padding: 0.75rem;">
                                            <option value="Cash">Cash</option>
                                            <option value="UPI">UPI</option>
                                            <option value="Bank Transfer">Bank Transfer</option>
                                            <option value="Cheque">Cheque</option>
                                            <option value="Card">Card</option>
                                            <option value="Other">Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="paymentTransactionId" class="form-input" style="width: 100%; padding: 0.75rem;">
                                    </div>
                                </div>

                                <div class="form-group" style="margin-bottom: 1.5rem;">
                                    <label class="form-label">Notes</label>
                                    <textarea id="paymentNotes" class="form-textarea" rows="2" placeholder="e.g., Partial payment, Balance after event, etc." style="width: 100%; padding: 0.75rem;"></textarea>
                                </div>

                                <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid #e0e0e0;">
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('paymentModal')">Cancel</button>
                                    <button type="submit" class="btn btn-success">ðŸ’¾ Save Payment</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
                console.log('âœ… Payment modal created and displayed');
            },

            async loadOrderForPayment() {
                const orderId = Utils.get('paymentOrderId');
                if (!orderId) {
                    document.getElementById('orderDetailsSection').style.display = 'none';
                    return;
                }

                // Reload payments from Firestore to ensure fresh data
                console.log('ðŸ”„ Reloading payments from Firestore...');
                await this.loadPaymentsFromFirestore();

                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);
                if (!order) {
                    console.error('Order not found');
                    return;
                }

                // Store current order for later use
                window.currentPaymentOrder = order;

                // Get all items from order
                let allItems = [];
                let itemsTotal = 0;

                if (order.isMultiDay && order.dayWiseData) {
                    // Multi-day order - collect items from all days
                    order.dayWiseData.forEach(day => {
                        if (day.functions) {
                            day.functions.forEach(func => {
                                if (func.items && func.items.length > 0) {
                                    func.items.forEach(item => {
                                        allItems.push({
                                            name: item.name,
                                            quantity: item.quantity,
                                            price: item.price || 0,
                                            total: (item.price || 0) * (item.quantity || 0)
                                        });
                                        itemsTotal += (item.price || 0) * (item.quantity || 0);
                                    });
                                }
                            });
                        }
                    });
                } else if (order.items && order.items.length > 0) {
                    // Single day order
                    allItems = order.items.map((item, index) => ({
                        name: item.name,
                        quantity: item.quantity,
                        price: item.price || 0,
                        total: (item.price || 0) * (item.quantity || 0),
                        index: index
                    }));
                    itemsTotal = allItems.reduce((sum, item) => sum + item.total, 0);
                }

                // Use financials data if available, otherwise use calculated total
                const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || itemsTotal);
                const alreadyPaid = parseFloat(order.financials?.advancePaid || 0);
                const balanceDue = parseFloat(order.financials?.balanceDue || orderTotal - alreadyPaid);

                // Display total amount input
                document.getElementById('orderTotalAmount').value = orderTotal;

                // Display items with editable price inputs
                const itemsHTML = allItems.length > 0 ? allItems.map((item, index) => `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 8px;">${item.name}</td>
                        <td style="text-align: center; padding: 8px;">${item.quantity}</td>
                        <td style="text-align: right; padding: 8px;">
                            <input type="number"
                                   class="form-input item-price-input"
                                   data-item-index="${index}"
                                   value="${item.price}"
                                   min="0"
                                   step="0.01"
                                   placeholder="0.00"
                                   style="width: 100px; padding: 0.5rem; text-align: right;"
                                   oninput="OMS.calculateItemTotal(${index})">
                        </td>
                        <td style="text-align: right; padding: 8px; font-weight: bold;">â‚¹<span id="itemTotal_${index}">${item.total.toLocaleString('en-IN')}</span></td>
                    </tr>
                `).join('') : '<tr><td colspan="4" style="text-align: center; padding: 1rem; color: #999;">No items found</td></tr>';

                document.getElementById('paymentItemsBody').innerHTML = itemsHTML;
                document.getElementById('itemsGrandTotal').textContent = itemsTotal.toLocaleString('en-IN');

                // Display summary
                document.getElementById('displayOrderTotal').textContent = orderTotal.toLocaleString('en-IN');
                document.getElementById('displayAlreadyPaid').textContent = alreadyPaid.toLocaleString('en-IN');
                document.getElementById('displayPendingAmount').textContent = balanceDue.toLocaleString('en-IN');

                // Get and display previous payments
                console.log('ðŸ” Checking payments for order:', { orderDocId: order.docId, orderId: order.orderId });
                console.log('ðŸ” Total payments in system:', this.data.payments.length);
                console.log('ðŸ” All payment records:', this.data.payments.map(p => ({
                    id: p.id,
                    amount: p.amount,
                    paymentOrderDocId: p.orderDocId,
                    paymentOrderId: p.orderId
                })));

                const previousPayments = this.data.payments.filter(p => p.orderDocId === order.docId || p.orderId === order.orderId);
                console.log('ðŸ” Filtered payments for this order:', previousPayments.length);
                if (previousPayments.length > 0) {
                    console.log('ðŸ” Payment IDs:', previousPayments.map(p => ({ id: p.id, amount: p.amount, orderDocId: p.orderDocId })));
                    const paymentsHTML = previousPayments.map(p => `
                        <div style="padding: 0.75rem 0; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                            <div style="flex: 1;">
                                <div style="margin-bottom: 0.25rem;">
                                    <strong style="color: #1976d2;">${Utils.formatDate(p.paymentDate)}</strong>:
                                    <span style="font-weight: bold; color: #4caf50;">â‚¹${parseFloat(p.amount).toLocaleString('en-IN')}</span>
                                </div>
                                <div style="font-size: 0.85rem; color: #666;">
                                    ${p.paymentMethod}${p.transactionId ? ` - ${p.transactionId}` : ''}${p.notes ? ` - ${p.notes}` : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; flex-shrink: 0;">
                                <button class="btn btn-warning btn-small" onclick="OMS.editPayment('${p.id}')" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;" title="Edit payment">âœï¸ Edit</button>
                                <button class="btn btn-danger btn-small" onclick="OMS.deletePayment('${p.id}')" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;" title="Delete payment">ðŸ—‘ï¸ Delete</button>
                            </div>
                        </div>
                    `).join('');
                    document.getElementById('previousPaymentsList').innerHTML = paymentsHTML;
                    document.getElementById('previousPaymentsSection').style.display = 'block';
                } else {
                    document.getElementById('previousPaymentsSection').style.display = 'none';
                }

                // Store current balance for calculation
                window.currentOrderBalance = balanceDue;

                document.getElementById('orderDetailsSection').style.display = 'block';
                console.log('âœ… Order loaded for payment');
            },

            calculateItemTotal(index) {
                const priceInput = document.querySelector(`input[data-item-index="${index}"]`);
                if (!priceInput) return;

                const order = window.currentPaymentOrder;
                if (!order || !order.items || !order.items[index]) return;

                const price = parseFloat(priceInput.value) || 0;
                const quantity = order.items[index].quantity || 0;
                const total = price * quantity;

                // Update item total display
                const totalElement = document.getElementById(`itemTotal_${index}`);
                if (totalElement) {
                    totalElement.textContent = total.toLocaleString('en-IN');
                }

                // Recalculate grand total from all items
                const allPriceInputs = document.querySelectorAll('.item-price-input');
                let grandTotal = 0;
                allPriceInputs.forEach((input, idx) => {
                    const itemPrice = parseFloat(input.value) || 0;
                    const itemQty = order.items[idx]?.quantity || 0;
                    grandTotal += itemPrice * itemQty;
                });

                // Update grand total display
                document.getElementById('itemsGrandTotal').textContent = grandTotal.toLocaleString('en-IN');

                // Also update the order total input
                document.getElementById('orderTotalAmount').value = grandTotal;

                // Update payment summary
                this.updateOrderTotalFromInput();
            },

            updateOrderTotalFromInput() {
                const orderTotal = parseFloat(document.getElementById('orderTotalAmount')?.value) || 0;
                const order = window.currentPaymentOrder;
                if (!order) return;

                const alreadyPaid = parseFloat(order.financials?.advancePaid || 0);
                const balanceDue = orderTotal - alreadyPaid;

                // Update payment summary
                document.getElementById('displayOrderTotal').textContent = orderTotal.toLocaleString('en-IN');
                document.getElementById('displayPendingAmount').textContent = Math.max(0, balanceDue).toLocaleString('en-IN');

                // Store for use when calculating remaining after payment
                window.currentOrderBalance = balanceDue;

                // Update remaining after payment if payment amount is entered
                this.updateRemainingAfterNewPayment();
            },

            async saveOrderTotal() {
                const order = window.currentPaymentOrder;
                if (!order) {
                    this.showToast('No order selected', 'error');
                    return;
                }

                const orderTotal = parseFloat(document.getElementById('orderTotalAmount')?.value);
                if (!orderTotal || orderTotal <= 0) {
                    this.showToast('Please enter a valid total amount', 'error');
                    return;
                }

                try {
                    // Update order in Firestore
                    await db.collection('orders').doc(order.docId).update({
                        totalAmount: orderTotal,
                        'financials.grandTotal': orderTotal,
                        'financials.balanceDue': orderTotal - (order.financials?.advancePaid || 0)
                    });

                    // Update item prices in Firestore if changed
                    const allPriceInputs = document.querySelectorAll('.item-price-input');
                    const updatedItems = order.items.map((item, index) => {
                        const priceInput = allPriceInputs[index];
                        return {
                            ...item,
                            price: parseFloat(priceInput?.value) || item.price || 0
                        };
                    });

                    await db.collection('orders').doc(order.docId).update({
                        items: updatedItems
                    });

                    this.showToast('âœ… Order total and item prices saved!', 'success');

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Reload the order in the modal
                    this.loadOrderForPayment();
                } catch (error) {
                    console.error('Error saving order total:', error);
                    this.showToast('Error saving: ' + error.message, 'error');
                }
            },

            updateRemainingAfterNewPayment() {
                const paymentAmount = parseFloat(document.getElementById('paymentAmount')?.value) || 0;
                const currentBalance = window.currentOrderBalance || 0;
                const newBalance = Math.max(0, currentBalance - paymentAmount);

                const newRemainingElement = document.getElementById('newRemainingBalance');
                if (newRemainingElement) {
                    newRemainingElement.textContent = `â‚¹${newBalance.toLocaleString('en-IN')}`;

                    // Change color based on payment status
                    if (newBalance === 0) {
                        newRemainingElement.style.color = '#4caf50'; // Green - Fully paid
                    } else if (newBalance < currentBalance) {
                        newRemainingElement.style.color = '#ff9800'; // Orange - Partial payment
                    } else {
                        newRemainingElement.style.color = '#f44336'; // Red - No payment or overpayment
                    }
                }
            },

            async savePayment(event) {
                event.preventDefault();

                const orderId = Utils.get('paymentOrderId');
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                if (!order) {
                    this.showToast('Order not found!', 'error');
                    return;
                }

                const paymentAmount = parseFloat(Utils.get('paymentAmount'));
                if (!paymentAmount || paymentAmount <= 0) {
                    this.showToast('Please enter a valid payment amount!', 'error');
                    return;
                }

                const paymentDate = Utils.get('paymentDate');

                // Calculate current order financials
                const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                const alreadyPaid = parseFloat(order.financials?.advancePaid || 0);
                const currentBalance = parseFloat(order.financials?.balanceDue || orderTotal);
                const newBalance = Math.max(0, currentBalance - paymentAmount);
                const totalPaid = alreadyPaid + paymentAmount;

                // Calculate credit due date (1 month after event date)
                let creditDueDate = null;
                if (newBalance > 0) {
                    // If balance remains, calculate credit period from event date
                    const eventDate = new Date(order.isMultiDay ? order.endDate : order.date);
                    creditDueDate = new Date(eventDate);
                    creditDueDate.setMonth(creditDueDate.getMonth() + 1);
                    creditDueDate = Utils.toDateString(creditDueDate);
                }

                const payment = {
                    orderId: order.orderId || 'Pending',
                    orderDocId: order.docId,
                    customerName: order.clientName,
                    eventDate: order.isMultiDay ? order.endDate : order.date,
                    amount: paymentAmount,
                    orderTotal: orderTotal,
                    totalPaid: totalPaid,
                    remainingBalance: newBalance,
                    paymentDate: paymentDate,
                    paymentMethod: Utils.get('paymentMethod'),
                    transactionId: Utils.get('paymentTransactionId'),
                    notes: Utils.get('paymentNotes'),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    createdAt: new Date().toISOString()
                };

                try {
                    // Save payment to Firestore
                    const docRef = await db.collection('payments').add(payment);
                    payment.id = docRef.id;

                    // Update order financials in Firestore
                    const updateData = {
                        'financials.advancePaid': totalPaid,
                        'financials.balanceDue': newBalance,
                        'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < orderTotal ? 'partial' : 'pending',
                        'financials.lastPaymentDate': paymentDate
                    };

                    // Add credit due date only if balance remains
                    if (creditDueDate) {
                        updateData['financials.creditDueDate'] = creditDueDate;
                    }

                    await db.collection('orders').doc(order.docId).update(updateData);

                    this.showToast('âœ… Payment recorded successfully!', 'success');
                    this.closeModal('paymentModal');

                    // Reload orders from Firestore to ensure data consistency
                    await this.loadOrdersFromFirestore();

                    // Now update displays with fresh data
                    this.renderFinancials();
                    if (this.currentTab === 'history') {
                        this.renderHistory();
                    }
                } catch (error) {
                    console.error('Error saving payment:', error);
                    this.showToast('Error saving payment: ' + error.message, 'error');
                }
            },

            togglePaymentBreakdown(paymentId) {
                const breakdownRow = document.getElementById(`breakdown_${paymentId}`);
                if (breakdownRow) {
                    if (breakdownRow.style.display === 'none') {
                        breakdownRow.style.display = 'table-row';
                    } else {
                        breakdownRow.style.display = 'none';
                    }
                }
            },

            async deletePayment(paymentId) {
                const payment = this.data.payments.find(p => p.id === paymentId);
                if (!payment) {
                    this.showToast('Payment not found!', 'error');
                    return;
                }

                if (!confirm(`Delete payment of â‚¹${parseFloat(payment.amount).toLocaleString('en-IN')} dated ${Utils.formatDate(payment.paymentDate)}?`)) {
                    return;
                }

                try {
                    // Delete payment from Firestore
                    await db.collection('payments').doc(paymentId).delete();
                    console.log('âœ… Payment deleted from Firestore');

                    // Recalculate order financials
                    const order = this.data.orders.find(o => o.docId === payment.orderDocId || o.orderId === payment.orderId);
                    if (order) {
                        // Get all remaining payments for this order (excluding the deleted one)
                        const remainingPayments = this.data.payments.filter(p =>
                            p.id !== paymentId && (p.orderDocId === order.docId || p.orderId === order.orderId)
                        );

                        // Calculate new totals
                        const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                        const newTotalPaid = remainingPayments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);
                        const newBalance = orderTotal - newTotalPaid;

                        // Calculate credit due date if balance remains
                        let creditDueDate = null;
                        if (newBalance > 0) {
                            const eventDate = new Date(order.isMultiDay ? order.endDate : order.date);
                            creditDueDate = new Date(eventDate);
                            creditDueDate.setMonth(creditDueDate.getMonth() + 1);
                            creditDueDate = Utils.toDateString(creditDueDate);
                        }

                        // Update order financials in Firestore
                        const updateData = {
                            'financials.advancePaid': newTotalPaid,
                            'financials.balanceDue': newBalance,
                            'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < orderTotal ? 'partial' : 'pending'
                        };

                        if (creditDueDate) {
                            updateData['financials.creditDueDate'] = creditDueDate;
                        } else {
                            // Remove credit due date if fully paid
                            updateData['financials.creditDueDate'] = firebase.firestore.FieldValue.delete();
                        }

                        // Update last payment date if there are remaining payments
                        if (remainingPayments.length > 0) {
                            const lastPayment = remainingPayments.reduce((latest, p) =>
                                new Date(p.paymentDate) > new Date(latest.paymentDate) ? p : latest
                            );
                            updateData['financials.lastPaymentDate'] = lastPayment.paymentDate;
                        } else {
                            updateData['financials.lastPaymentDate'] = firebase.firestore.FieldValue.delete();
                        }

                        await db.collection('orders').doc(order.docId).update(updateData);
                        console.log('âœ… Order financials updated after payment deletion');
                    }

                    this.showToast('âœ… Payment deleted successfully!', 'success');

                    // Reload data from Firestore
                    await this.loadPaymentsFromFirestore();
                    await this.loadOrdersFromFirestore();

                    // Refresh the payment modal if open
                    if (window.currentPaymentOrder) {
                        await this.loadOrderForPayment();
                    }

                    // Update all displays
                    this.renderFinancials();
                    if (this.currentTab === 'history') {
                        this.renderHistory();
                    }
                } catch (error) {
                    console.error('Error deleting payment:', error);
                    this.showToast('Error deleting payment: ' + error.message, 'error');
                }
            },

            async editPayment(paymentId) {
                const payment = this.data.payments.find(p => p.id === paymentId);
                if (!payment) {
                    this.showToast('Payment not found!', 'error');
                    return;
                }

                const order = this.data.orders.find(o => o.docId === payment.orderDocId || o.orderId === payment.orderId);

                const modalHTML = `
                    <div class="modal show" id="editPaymentModal" onclick="if(event.target === this) OMS.closeModal('editPaymentModal')">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('editPaymentModal')">Ã—</button>
                            <h2>âœï¸ Edit Payment</h2>
                            <form id="editPaymentForm" onsubmit="OMS.saveEditedPayment(event, '${paymentId}')" style="display: block;">
                                <div class="form-group">
                                    <label class="form-label">Order</label>
                                    <input type="text" class="form-input" value="${order ? (order.orderId || 'Pending') + ' - ' + order.clientName : 'Unknown'}" readonly style="background: #f5f5f5;">
                                </div>

                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="editPaymentDate" class="form-input" value="${payment.paymentDate}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount (â‚¹)</label>
                                        <input type="number" id="editPaymentAmount" class="form-input" value="${payment.amount}" min="0" step="0.01" required>
                                    </div>
                                </div>

                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="editPaymentMethod" class="form-select" required>
                                            <option value="Cash" ${payment.paymentMethod === 'Cash' ? 'selected' : ''}>Cash</option>
                                            <option value="UPI" ${payment.paymentMethod === 'UPI' ? 'selected' : ''}>UPI</option>
                                            <option value="Bank Transfer" ${payment.paymentMethod === 'Bank Transfer' ? 'selected' : ''}>Bank Transfer</option>
                                            <option value="Cheque" ${payment.paymentMethod === 'Cheque' ? 'selected' : ''}>Cheque</option>
                                            <option value="Card" ${payment.paymentMethod === 'Card' ? 'selected' : ''}>Card</option>
                                            <option value="Other" ${payment.paymentMethod === 'Other' ? 'selected' : ''}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="editPaymentTransactionId" class="form-input" value="${payment.transactionId || ''}" placeholder="Optional">
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="editPaymentNotes" class="form-input" rows="3" placeholder="Optional notes">${payment.notes || ''}</textarea>
                                </div>

                                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                                    <button type="submit" class="btn btn-primary" style="flex: 1;">ðŸ’¾ Save Changes</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('editPaymentModal')" style="flex: 1;">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async saveEditedPayment(event, paymentId) {
                event.preventDefault();

                const payment = this.data.payments.find(p => p.id === paymentId);
                if (!payment) {
                    this.showToast('Payment not found!', 'error');
                    return;
                }

                const oldAmount = parseFloat(payment.amount);
                const newAmount = parseFloat(Utils.get('editPaymentAmount'));

                if (!newAmount || newAmount <= 0) {
                    this.showToast('Please enter a valid payment amount!', 'error');
                    return;
                }

                try {
                    // Update payment in Firestore
                    const updateData = {
                        amount: newAmount,
                        paymentDate: Utils.get('editPaymentDate'),
                        paymentMethod: Utils.get('editPaymentMethod'),
                        transactionId: Utils.get('editPaymentTransactionId') || '',
                        notes: Utils.get('editPaymentNotes') || ''
                    };

                    await db.collection('payments').doc(paymentId).update(updateData);
                    console.log('âœ… Payment updated in Firestore');

                    // If amount changed, recalculate order financials
                    if (oldAmount !== newAmount) {
                        const order = this.data.orders.find(o => o.docId === payment.orderDocId || o.orderId === payment.orderId);
                        if (order) {
                            // Reload payments to get fresh data
                            await this.loadPaymentsFromFirestore();

                            // Get all payments for this order
                            const orderPayments = this.data.payments.filter(p =>
                                p.orderDocId === order.docId || p.orderId === order.orderId
                            );

                            // Calculate new totals
                            const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                            const totalPaid = orderPayments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);
                            const newBalance = orderTotal - totalPaid;

                            // Calculate credit due date if balance remains
                            let creditDueDate = null;
                            if (newBalance > 0) {
                                const eventDate = new Date(order.isMultiDay ? order.endDate : order.date);
                                creditDueDate = new Date(eventDate);
                                creditDueDate.setMonth(creditDueDate.getMonth() + 1);
                                creditDueDate = Utils.toDateString(creditDueDate);
                            }

                            // Update order financials
                            const orderUpdateData = {
                                'financials.advancePaid': totalPaid,
                                'financials.balanceDue': newBalance,
                                'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < orderTotal ? 'partial' : 'pending'
                            };

                            if (creditDueDate) {
                                orderUpdateData['financials.creditDueDate'] = creditDueDate;
                            } else {
                                orderUpdateData['financials.creditDueDate'] = firebase.firestore.FieldValue.delete();
                            }

                            // Update last payment date
                            const lastPayment = orderPayments.reduce((latest, p) =>
                                new Date(p.paymentDate) > new Date(latest.paymentDate) ? p : latest
                            );
                            orderUpdateData['financials.lastPaymentDate'] = lastPayment.paymentDate;

                            await db.collection('orders').doc(order.docId).update(orderUpdateData);
                            console.log('âœ… Order financials updated after payment edit');
                        }
                    }

                    this.showToast('âœ… Payment updated successfully!', 'success');
                    this.closeModal('editPaymentModal');

                    // Reload data from Firestore
                    await this.loadPaymentsFromFirestore();
                    await this.loadOrdersFromFirestore();

                    // Refresh the payment modal if open
                    if (window.currentPaymentOrder) {
                        await this.loadOrderForPayment();
                    }

                    // Update all displays
                    this.renderFinancials();
                    if (this.currentTab === 'history') {
                        this.renderHistory();
                    }
                } catch (error) {
                    console.error('Error updating payment:', error);
                    this.showToast('Error updating payment: ' + error.message, 'error');
                }
            },

            async recalculateOrderFinancials(orderDocId) {
                if (!orderDocId) {
                    this.showToast('Order ID is required', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Recalculating financials for order:', orderDocId);

                    // Get all payments for this order from Firestore
                    const paymentsSnapshot = await db.collection('payments')
                        .where('orderDocId', '==', orderDocId)
                        .get();

                    const orderPayments = [];
                    paymentsSnapshot.forEach(doc => {
                        orderPayments.push({ id: doc.id, ...doc.data() });
                    });

                    console.log(`ðŸ“Š Found ${orderPayments.length} payment records for this order`);

                    // Calculate total paid from actual payment records
                    const totalPaid = orderPayments.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0);

                    // Get order data
                    const order = this.data.orders.find(o => o.docId === orderDocId);
                    if (!order) {
                        this.showToast('Order not found', 'error');
                        return;
                    }

                    const orderTotal = parseFloat(order.financials?.grandTotal || order.totalAmount || 0);
                    const newBalance = orderTotal - totalPaid;

                    // Calculate credit due date if balance remains
                    let creditDueDate = null;
                    if (newBalance > 0) {
                        const eventDate = new Date(order.isMultiDay ? order.endDate : order.date);
                        creditDueDate = new Date(eventDate);
                        creditDueDate.setMonth(creditDueDate.getMonth() + 1);
                        creditDueDate = Utils.toDateString(creditDueDate);
                    }

                    // Update order financials in Firestore
                    const updateData = {
                        'financials.advancePaid': totalPaid,
                        'financials.balanceDue': newBalance,
                        'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < orderTotal ? 'partial' : 'pending'
                    };

                    if (creditDueDate) {
                        updateData['financials.creditDueDate'] = creditDueDate;
                    } else {
                        updateData['financials.creditDueDate'] = firebase.firestore.FieldValue.delete();
                    }

                    // Update last payment date if there are payments
                    if (orderPayments.length > 0) {
                        const lastPayment = orderPayments.reduce((latest, p) =>
                            new Date(p.paymentDate) > new Date(latest.paymentDate) ? p : latest
                        );
                        updateData['financials.lastPaymentDate'] = lastPayment.paymentDate;
                    } else {
                        updateData['financials.lastPaymentDate'] = firebase.firestore.FieldValue.delete();
                    }

                    await db.collection('orders').doc(orderDocId).update(updateData);

                    console.log('âœ… Order financials recalculated successfully');
                    console.log(`   Total Paid: â‚¹${totalPaid.toLocaleString('en-IN')}`);
                    console.log(`   Balance Due: â‚¹${newBalance.toLocaleString('en-IN')}`);

                    this.showToast(`âœ… Financials updated! Total Paid: â‚¹${totalPaid.toLocaleString('en-IN')}, Balance: â‚¹${newBalance.toLocaleString('en-IN')}`, 'success');

                    // Reload data
                    await this.loadOrdersFromFirestore();

                    // Refresh the payment modal if open
                    if (window.currentPaymentOrder) {
                        await this.loadOrderForPayment();
                    }

                    // Update all displays
                    this.renderFinancials();
                    if (this.currentTab === 'history') {
                        this.renderHistory();
                    }
                } catch (error) {
                    console.error('Error recalculating order financials:', error);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async showAddExpenseModal() {
                const modalHTML = `
                    <div class="modal show" id="expenseModal" onclick="if(event.target === this) OMS.closeModal('expenseModal')">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('expenseModal')">Ã—</button>
                            <h2>ðŸ’¸ Add Expense</h2>
                            <form id="expenseForm" onsubmit="OMS.saveExpense(event)">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Date</label>
                                        <input type="date" id="expenseDate" class="form-input" value="${Utils.toDateString(new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="expenseAmount" class="form-input" min="1" step="0.01" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Category</label>
                                        <select id="expenseCategory" class="form-select" required>
                                            <option value="Materials Purchase">Materials Purchase</option>
                                            <option value="Salaries & Wages">Salaries & Wages</option>
                                            <option value="Transportation & Fuel">Transportation & Fuel</option>
                                            <option value="Equipment Maintenance">Equipment Maintenance</option>
                                            <option value="Rent & Utilities">Rent & Utilities</option>
                                            <option value="Marketing & Advertising">Marketing & Advertising</option>
                                            <option value="Office Supplies">Office Supplies</option>
                                            <option value="Insurance">Insurance</option>
                                            <option value="Taxes & Licenses">Taxes & Licenses</option>
                                            <option value="Miscellaneous">Miscellaneous</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Vendor/Supplier</label>
                                        <input type="text" id="expenseVendor" class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Description</label>
                                    <input type="text" id="expenseDescription" class="form-input" required>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Payment Method</label>
                                    <select id="expensePaymentMethod" class="form-select">
                                        <option value="Cash">Cash</option>
                                        <option value="UPI">UPI</option>
                                        <option value="Bank Transfer">Bank Transfer</option>
                                        <option value="Cheque">Cheque</option>
                                        <option value="Card">Card</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">ðŸ’¾ Save Expense</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('expenseModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async saveExpense(event) {
                event.preventDefault();

                const expense = {
                    date: Utils.get('expenseDate'),
                    amount: parseFloat(Utils.get('expenseAmount')),
                    category: Utils.get('expenseCategory'),
                    vendor: Utils.get('expenseVendor'),
                    description: Utils.get('expenseDescription'),
                    paymentMethod: Utils.get('expensePaymentMethod'),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };

                try {
                    const docRef = await db.collection('expenses').add(expense);
                    expense.id = docRef.id;
                    this.data.expenses.push(expense);

                    this.showToast('Expense added successfully!', 'success');
                    this.closeModal('expenseModal');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error saving expense:', error);
                    this.showToast('Error saving expense: ' + error.message, 'error');
                }
            },

            async addPaymentForOrder(orderId) {
                // Open payment modal with pre-selected order
                await this.showAddPaymentModal();

                // Wait for modal to be fully rendered in DOM
                setTimeout(() => {
                    const selectElement = document.getElementById('paymentOrderId');
                    if (selectElement) {
                        selectElement.value = orderId;
                        // Trigger change event and load order details
                        selectElement.dispatchEvent(new Event('change'));
                        this.loadOrderForPayment();
                    } else {
                        console.error('âŒ Payment order select element not found!');
                    }
                }, 100);
            },

            addExpenseForOrder(orderId) {
                // Open expense modal with order info in notes
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);
                this.showAddExpenseModal();
                if (order) {
                    setTimeout(() => {
                        const notes = `Related to Order: ${order.orderId || 'Pending'} - ${order.clientName}`;
                        Utils.set('expenseDescription', notes);
                    }, 100);
                }
            },


            quickAddPayment() {
                // Check if there's a current order being edited or if we need to save first
                const clientName = Utils.get('clientName');
                const orderId = Utils.get('orderId');
                const orderStatus = Utils.get('orderStatus');

                if (!clientName) {
                    this.showToast('âš ï¸ Please fill in client name first', 'warning');
                    return;
                }

                // Show a simplified payment modal for the current order
                const modalHTML = `
                    <div class="modal show" id="quickPaymentModal" onclick="if(event.target === this) OMS.closeModal('quickPaymentModal')">
                        <div class="modal-content" style="max-width: 500px;">
                            <button class="modal-close" onclick="OMS.closeModal('quickPaymentModal')">Ã—</button>
                            <h2>ðŸ’µ Quick Payment</h2>
                            <p style="color: var(--text-gray); margin-bottom: 1rem;">
                                For order: <strong>${orderId || 'New Order'} - ${clientName}</strong>
                            </p>
                            <form id="quickPaymentForm" onsubmit="OMS.saveQuickPayment(event)">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="quickPaymentDate" class="form-input" value="${Utils.toDateString(new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount (â‚¹)</label>
                                        <input type="number" id="quickPaymentAmount" class="form-input" min="1" step="0.01" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="quickPaymentMethod" class="form-select" required>
                                            <option value="Cash">Cash</option>
                                            <option value="UPI">UPI</option>
                                            <option value="Bank Transfer">Bank Transfer</option>
                                            <option value="Cheque">Cheque</option>
                                            <option value="Card">Card</option>
                                            <option value="Other">Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="quickPaymentTransactionId" class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="quickPaymentNotes" class="form-textarea" rows="2"></textarea>
                                </div>
                                <div class="alert" style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                                    <strong>â„¹ï¸ Note:</strong> The order will be saved first before recording the payment.
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">ðŸ’¾ Save Payment</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('quickPaymentModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async saveQuickPayment(event) {
                event.preventDefault();

                try {
                    // First, save the current order if it doesn't have a docId
                    if (!this.editingDocId) {
                        this.showToast('ðŸ“ Saving order first...', 'info');
                        await this.saveOrder();

                        // Wait a bit for the order to be saved and assigned a docId
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        // Check if we have a saved order now
                        const clientName = Utils.get('clientName');
                        const recentOrder = this.data.orders.find(o => o.clientName === clientName);

                        if (!recentOrder || !recentOrder.docId) {
                            this.showToast('âŒ Could not find saved order. Please try again.', 'error');
                            return;
                        }

                        this.editingDocId = recentOrder.docId;
                    }

                    // Now save the payment
                    const order = this.data.orders.find(o => o.docId === this.editingDocId);

                    if (!order) {
                        this.showToast('Order not found!', 'error');
                        return;
                    }

                    const payment = {
                        orderId: order.orderId || 'Pending',
                        orderDocId: order.docId,
                        customerName: order.clientName,
                        amount: parseFloat(Utils.get('quickPaymentAmount')),
                        paymentDate: Utils.get('quickPaymentDate'),
                        paymentMethod: Utils.get('quickPaymentMethod'),
                        transactionId: Utils.get('quickPaymentTransactionId'),
                        notes: Utils.get('quickPaymentNotes'),
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    const docRef = await db.collection('payments').add(payment);
                    payment.id = docRef.id;
                    this.data.payments.push(payment);

                    // Update order balance
                    const currentBalance = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                    const newBalance = currentBalance - payment.amount;
                    const advancePaid = parseFloat(order.financials?.advancePaid || 0) + payment.amount;

                    await db.collection('orders').doc(order.docId).update({
                        'financials.advancePaid': advancePaid,
                        'financials.balanceDue': Math.max(0, newBalance),
                        'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < (order.financials?.grandTotal || order.totalAmount || 0) ? 'partial' : 'pending'
                    });

                    this.showToast('âœ… Payment recorded successfully!', 'success');
                    this.closeModal('quickPaymentModal');
                    await this.loadOrdersFromFirestore();

                } catch (error) {
                    console.error('Error saving quick payment:', error);
                    this.showToast('Error saving payment: ' + error.message, 'error');
                }
            },

            async deletePayment(paymentId) {
                if (!confirm('Are you sure you want to delete this payment record?')) return;

                try {
                    await db.collection('payments').doc(paymentId).delete();
                    this.data.payments = this.data.payments.filter(p => p.id !== paymentId);
                    this.showToast('Payment deleted!', 'success');
                    this.renderFinancials();
                    await this.loadOrdersFromFirestore(); // Reload to update balances
                } catch (error) {
                    console.error('Error deleting payment:', error);
                    this.showToast('Error deleting payment: ' + error.message, 'error');
                }
            },

            async deleteExpense(expenseId) {
                if (!confirm('Are you sure you want to delete this expense record?')) return;

                try {
                    await db.collection('expenses').doc(expenseId).delete();
                    this.data.expenses = this.data.expenses.filter(e => e.id !== expenseId);
                    this.showToast('Expense deleted!', 'success');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error deleting expense:', error);
                    this.showToast('Error deleting expense: ' + error.message, 'error');
                }
            },

            async editPayment(paymentId) {
                const payment = this.data.payments.find(p => p.id === paymentId);
                if (!payment) {
                    this.showToast('Payment not found!', 'error');
                    return;
                }

                const orders = this.data.orders.filter(o => o.status !== 'Cancelled');

                const modalHTML = `
                    <div class="modal show" id="editPaymentModal" onclick="if(event.target === this) OMS.closeModal('editPaymentModal')">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('editPaymentModal')">Ã—</button>
                            <h2>âœï¸ Edit Payment</h2>
                            <form id="editPaymentForm" onsubmit="OMS.updatePayment(event, '${paymentId}')">
                                <div class="form-group">
                                    <label class="form-label required">Order</label>
                                    <select id="editPaymentOrderId" class="form-select" required>
                                        <option value="">Select Order</option>
                                        ${orders.map(o => `<option value="${o.docId || o.orderId}" ${(o.docId || o.orderId) === payment.orderDocId ? 'selected' : ''}>${o.orderId || 'Pending'} - ${o.clientName}</option>`).join('')}
                                    </select>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Date</label>
                                        <input type="date" id="editPaymentDate" class="form-input" value="${payment.paymentDate || Utils.toDateString(payment.timestamp?.toDate?.() || new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="editPaymentAmount" class="form-input" min="1" step="0.01" value="${payment.amount}" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Payment Method</label>
                                        <select id="editPaymentMethod" class="form-select" required>
                                            <option value="Cash" ${payment.paymentMethod === 'Cash' ? 'selected' : ''}>Cash</option>
                                            <option value="UPI" ${payment.paymentMethod === 'UPI' ? 'selected' : ''}>UPI</option>
                                            <option value="Bank Transfer" ${payment.paymentMethod === 'Bank Transfer' ? 'selected' : ''}>Bank Transfer</option>
                                            <option value="Cheque" ${payment.paymentMethod === 'Cheque' ? 'selected' : ''}>Cheque</option>
                                            <option value="Card" ${payment.paymentMethod === 'Card' ? 'selected' : ''}>Card</option>
                                            <option value="Other" ${payment.paymentMethod === 'Other' ? 'selected' : ''}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Transaction ID</label>
                                        <input type="text" id="editPaymentTransactionId" class="form-input" value="${payment.transactionId || ''}">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes</label>
                                    <textarea id="editPaymentNotes" class="form-textarea" rows="3">${payment.notes || ''}</textarea>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">ðŸ’¾ Update Payment</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('editPaymentModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async updatePayment(event, paymentId) {
                event.preventDefault();

                const orderId = Utils.get('editPaymentOrderId');
                const order = this.data.orders.find(o => (o.docId || o.orderId) === orderId);

                if (!order) {
                    this.showToast('Order not found!', 'error');
                    return;
                }

                const oldPayment = this.data.payments.find(p => p.id === paymentId);
                const oldAmount = parseFloat(oldPayment.amount || 0);
                const newAmount = parseFloat(Utils.get('editPaymentAmount'));

                const updatedPayment = {
                    orderId: order.orderId || 'Pending',
                    orderDocId: order.docId,
                    customerName: order.clientName,
                    amount: newAmount,
                    paymentDate: Utils.get('editPaymentDate'),
                    paymentMethod: Utils.get('editPaymentMethod'),
                    transactionId: Utils.get('editPaymentTransactionId'),
                    notes: Utils.get('editPaymentNotes')
                };

                try {
                    await db.collection('payments').doc(paymentId).update(updatedPayment);

                    // Update local data
                    const paymentIndex = this.data.payments.findIndex(p => p.id === paymentId);
                    if (paymentIndex !== -1) {
                        this.data.payments[paymentIndex] = { ...this.data.payments[paymentIndex], ...updatedPayment };
                    }

                    // Update order balance if amount changed
                    if (oldAmount !== newAmount) {
                        const amountDiff = newAmount - oldAmount;
                        const currentBalance = parseFloat(order.financials?.balanceDue || order.totalAmount || 0);
                        const newBalance = currentBalance - amountDiff;
                        const advancePaid = parseFloat(order.financials?.advancePaid || 0) + amountDiff;

                        await db.collection('orders').doc(order.docId).update({
                            'financials.advancePaid': advancePaid,
                            'financials.balanceDue': Math.max(0, newBalance),
                            'financials.paymentStatus': newBalance <= 0 ? 'paid' : newBalance < (order.financials?.grandTotal || order.totalAmount || 0) ? 'partial' : 'pending'
                        });
                    }

                    this.showToast('Payment updated successfully!', 'success');
                    this.closeModal('editPaymentModal');
                    this.renderFinancials();
                    await this.loadOrdersFromFirestore();
                } catch (error) {
                    console.error('Error updating payment:', error);
                    this.showToast('Error updating payment: ' + error.message, 'error');
                }
            },

            async editExpense(expenseId) {
                const expense = this.data.expenses.find(e => e.id === expenseId);
                if (!expense) {
                    this.showToast('Expense not found!', 'error');
                    return;
                }

                const modalHTML = `
                    <div class="modal show" id="editExpenseModal" onclick="if(event.target === this) OMS.closeModal('editExpenseModal')">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close" onclick="OMS.closeModal('editExpenseModal')">Ã—</button>
                            <h2>âœï¸ Edit Expense</h2>
                            <form id="editExpenseForm" onsubmit="OMS.updateExpense(event, '${expenseId}')">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Date</label>
                                        <input type="date" id="editExpenseDate" class="form-input" value="${expense.date || Utils.toDateString(expense.timestamp?.toDate?.() || new Date())}" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label required">Amount</label>
                                        <input type="number" id="editExpenseAmount" class="form-input" min="1" step="0.01" value="${expense.amount}" required>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label required">Category</label>
                                        <select id="editExpenseCategory" class="form-select" required>
                                            <option value="Inventory" ${expense.category === 'Inventory' ? 'selected' : ''}>Inventory</option>
                                            <option value="Equipment" ${expense.category === 'Equipment' ? 'selected' : ''}>Equipment</option>
                                            <option value="Transportation" ${expense.category === 'Transportation' ? 'selected' : ''}>Transportation</option>
                                            <option value="Staff" ${expense.category === 'Staff' ? 'selected' : ''}>Staff</option>
                                            <option value="Marketing" ${expense.category === 'Marketing' ? 'selected' : ''}>Marketing</option>
                                            <option value="Utilities" ${expense.category === 'Utilities' ? 'selected' : ''}>Utilities</option>
                                            <option value="Other" ${expense.category === 'Other' ? 'selected' : ''}>Other</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Vendor</label>
                                        <input type="text" id="editExpenseVendor" class="form-input" value="${expense.vendor || ''}">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Payment Method</label>
                                    <select id="editExpensePaymentMethod" class="form-select">
                                        <option value="Cash" ${expense.paymentMethod === 'Cash' ? 'selected' : ''}>Cash</option>
                                        <option value="UPI" ${expense.paymentMethod === 'UPI' ? 'selected' : ''}>UPI</option>
                                        <option value="Bank Transfer" ${expense.paymentMethod === 'Bank Transfer' ? 'selected' : ''}>Bank Transfer</option>
                                        <option value="Cheque" ${expense.paymentMethod === 'Cheque' ? 'selected' : ''}>Cheque</option>
                                        <option value="Card" ${expense.paymentMethod === 'Card' ? 'selected' : ''}>Card</option>
                                        <option value="Other" ${expense.paymentMethod === 'Other' ? 'selected' : ''}>Other</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Description</label>
                                    <textarea id="editExpenseDescription" class="form-textarea" rows="3">${expense.description || ''}</textarea>
                                </div>
                                <div class="btn-group">
                                    <button type="submit" class="btn btn-success">ðŸ’¾ Update Expense</button>
                                    <button type="button" class="btn btn-secondary" onclick="OMS.closeModal('editExpenseModal')">Cancel</button>
                                </div>
                            </form>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            async updateExpense(event, expenseId) {
                event.preventDefault();

                const updatedExpense = {
                    date: Utils.get('editExpenseDate'),
                    amount: parseFloat(Utils.get('editExpenseAmount')),
                    category: Utils.get('editExpenseCategory'),
                    vendor: Utils.get('editExpenseVendor'),
                    description: Utils.get('editExpenseDescription'),
                    paymentMethod: Utils.get('editExpensePaymentMethod')
                };

                try {
                    await db.collection('expenses').doc(expenseId).update(updatedExpense);

                    // Update local data
                    const expenseIndex = this.data.expenses.findIndex(e => e.id === expenseId);
                    if (expenseIndex !== -1) {
                        this.data.expenses[expenseIndex] = { ...this.data.expenses[expenseIndex], ...updatedExpense };
                    }

                    this.showToast('Expense updated successfully!', 'success');
                    this.closeModal('editExpenseModal');
                    this.renderFinancials();
                } catch (error) {
                    console.error('Error updating expense:', error);
                    this.showToast('Error updating expense: ' + error.message, 'error');
                }
            },

            exportFinancialReport() {
                const startDate = Utils.get('finStartDate');
                const endDate = Utils.get('finEndDate');

                const data = {
                    period: `${startDate} to ${endDate}`,
                    generatedAt: new Date().toISOString(),
                    orders: this.data.orders,
                    payments: this.data.payments,
                    expenses: this.data.expenses
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `financial-report-${startDate}-to-${endDate}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('Financial report exported!', 'success');
            },

            showMonthlyComparison() {
                // Calculate monthly stats for the past 12 months
                const months = [];
                const now = new Date();

                for (let i = 11; i >= 0; i--) {
                    const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    const monthEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);

                    const monthOrders = this.data.orders.filter(o => {
                        const orderDate = new Date(o.orderDate || o.createdAt);
                        return orderDate >= monthDate && orderDate <= monthEnd;
                    });

                    const revenue = monthOrders.reduce((sum, o) => sum + parseFloat(o.financials?.grandTotal || o.totalAmount || 0), 0);

                    months.push({
                        month: monthDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                        revenue: revenue,
                        orders: monthOrders.length
                    });
                }

                const modalHTML = `
                    <div class="modal show" id="monthlyComparisonModal" onclick="if(event.target === this) OMS.closeModal('monthlyComparisonModal')">
                        <div class="modal-content" style="max-width: 900px;">
                            <button class="modal-close" onclick="OMS.closeModal('monthlyComparisonModal')">Ã—</button>
                            <h2>ðŸ“ˆ Monthly Revenue Comparison (Last 12 Months)</h2>
                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Month</th>
                                            <th>Orders</th>
                                            <th>Revenue</th>
                                            <th>Avg per Order</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${months.map(m => `
                                            <tr>
                                                <td>${m.month}</td>
                                                <td>${m.orders}</td>
                                                <td>â‚¹${m.revenue.toLocaleString('en-IN')}</td>
                                                <td>â‚¹${m.orders > 0 ? (m.revenue / m.orders).toFixed(0).toLocaleString('en-IN') : 0}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                    <tfoot>
                                        <tr style="font-weight: bold;">
                                            <td>TOTAL</td>
                                            <td>${months.reduce((sum, m) => sum + m.orders, 0)}</td>
                                            <td>â‚¹${months.reduce((sum, m) => sum + m.revenue, 0).toLocaleString('en-IN')}</td>
                                            <td>â‚¹${(months.reduce((sum, m) => sum + m.revenue, 0) / months.reduce((sum, m) => sum + m.orders, 0)).toFixed(0).toLocaleString('en-IN')}</td>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('modalsContainer').innerHTML = modalHTML;
            },

            closeModal(modalId = 'dynamicModal') {
                const modal = document.getElementById(modalId);
                if (modal) {
                    // Remove escape handler if it exists (for dynamicModal)
                    if (modal._escapeHandler) {
                        document.removeEventListener('keydown', modal._escapeHandler);
                    }
                    modal.remove();
                }
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('ðŸ“¥ Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                itemHistory: [], // Will load from Firestore
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        // Check if user has permission to load financial data
        const canViewFinancials = await this.canViewFinancials();

        const loadPromises = [
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadItemHistoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore(),
            this.loadQuotationsFromFirestore()
        ];

        // Only load financial data if user has permission
        if (canViewFinancials) {
            loadPromises.push(this.loadPaymentsFromFirestore());
            loadPromises.push(this.loadExpensesFromFirestore());
        } else {
            console.log('â„¹ï¸ Skipping financial data - user does not have admin/owner role');
        }

        await Promise.all(loadPromises);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('âœ… All data loaded from Firestore successfully!');

        // Update all displays after data is loaded to ensure dashboard and other tabs show fresh data
        this.updateAllDisplays();

    } catch (error) {
        console.error('âŒ Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('ðŸ“¥ Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`âš ï¸ Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                console.warn(`   Customer: ${customer.name}, Date: ${customer.dates}`);
                skippedDeleted++;
                return;
            }

            // IMPORTANT: Include ALL fields from Firestore
            const loadedOrder = {
                ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                // Legacy field mappings for backwards compatibility
                date: orderData.date || Utils.convertDateFormat(customer.dates) || '',
                readyTime: orderData.readyTime || customer.timeSlot || '',
                clientName: orderData.clientName || customer.name || '',
                contact: orderData.contact || customer.phone || '',
                venue: orderData.venue || customer.venue || '',
                eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                // Normalize items to use consistent field names
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.quantity || item.qty || 0,
                    remarks: item.remarks || item.desc || '',
                    price: item.price || 0
                }))
            };

            // Debug log multi-day and merged orders
            if (orderData.isMultiDay) {
                console.log(`ðŸ“… Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }
            if (orderData.isMerged) {
                console.log(`ðŸ”— Loaded merged order ${orderId}:`, {
                    isMerged: loadedOrder.isMerged,
                    mergedInto: loadedOrder.mergedInto
                });
            }
            if (orderData.mergedFrom) {
                console.log(`ðŸ”— Loaded MERGED result order ${orderId}:`, {
                    mergedFrom: loadedOrder.mergedFrom?.length || 0,
                    mergedAt: loadedOrder.mergedAt
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`âœ… Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('âŒ Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('ðŸ“Š Loading tracking data from Firestore...');

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('âš ï¸ Not authenticated yet - skipping tracking data load');
            this.data.trackingData = [];
            return;
        }

        // Load without orderBy to avoid index requirement
        // We'll sort in JavaScript instead
        const trackingSnapshot = await db.collection('tracking')
            .limit(500)  // Get more data, will sort client-side
            .get();

        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });

        // Sort by timestamp in JavaScript (newest first)
        this.data.trackingData.sort((a, b) => b.timestamp - a.timestamp);

        console.log(`âœ… Loaded ${this.data.trackingData.length} tracking events from website`);
        console.log(`ðŸ“ Sample data:`, this.data.trackingData.slice(0, 3));

    } catch (error) {
        console.error('âŒ Error loading tracking data:', error);
        console.error('Error details:', error.code, error.message);

        // If permissions error, log it but don't retry
        // (retrying won't help if Firestore rules don't allow access)
        if (error.code === 'permission-denied') {
            console.warn('âš ï¸ Insufficient permissions to access tracking data. Please check Firestore security rules.');
        }

        this.data.trackingData = [];
    }
},

async loadEventsListFromFirestore() {
    try {
        console.log('ðŸ“‹ Loading events list from Firestore...');

        // Ensure eventsList has a default value if not already set
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            console.log('ðŸ“ Initializing default events list');
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
            console.log('âœ… Default events list initialized with', this.data.eventsList.length, 'events');
        }

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('âš ï¸ Not authenticated yet - using default events list');
            return;
        }

        const eventsDoc = await db.collection('settings').doc('eventsList').get();

        if (eventsDoc.exists) {
            const data = eventsDoc.data();
            if (data.events && Array.isArray(data.events)) {
                this.data.eventsList = data.events;
                console.log(`âœ… Loaded ${this.data.eventsList.length} events from Firestore`);
            }
        } else {
            console.log('ðŸ“ No events list in Firestore yet - saving default list');
            // Save the default list to Firestore
            await db.collection('settings').doc('eventsList').set({
                events: this.data.eventsList,
                createdAt: new Date().toISOString()
            });
            console.log('âœ… Saved default events list to Firestore');
        }

    } catch (error) {
        console.error('âŒ Error loading events list:', error);
        console.warn('âš ï¸ Using default events list');
        // Ensure default list is available even on error
        if (!this.data.eventsList || !Array.isArray(this.data.eventsList) || this.data.eventsList.length === 0) {
            this.data.eventsList = [
                'Haldi', 'Mehendi', 'Barat', 'Carnival', 'Varmala', 'Sangeet',
                'Entry of groom', 'Entry of Bride', 'Entry of Couple', 'Bride Welcome',
                'Surprise Barat', 'Reception', 'Wedding', 'Mameru', 'Gotreju', 'Sufi Night',
                'Birthday', 'Party', 'New Year Party', 'Anniversary', 'Shobha yatra',
                'Ganesh Agman', 'Ganesh Visarjan'
            ];
        }
    }
},

// ============ TEAM FIRESTORE SYNC ============

async saveTeamMemberToFirestore(teamMember) {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('âŒ No user logged in');
            return false;
        }

        await db.collection('team').doc(teamMember.id).set({
            ...teamMember,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('âœ… Team member saved to Firestore:', teamMember.name);
        return true;
    } catch (error) {
        console.error('âŒ Error saving team member to Firestore:', error);
        this.showToast('Failed to sync team member: ' + error.message, 'error');
        return false;
    }
},

async loadTeamFromFirestore() {
    try {
        console.log('ðŸ‘· Loading team from Firestore...');

        const teamSnapshot = await db.collection('team')
            .orderBy('createdAt', 'desc')
            .get();

        this.data.team = [];
        teamSnapshot.forEach(doc => {
            this.data.team.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`âœ… Loaded ${this.data.team.length} team members from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading team from Firestore:', error);
        // Try to load from localStorage as fallback
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data.team = parsed.team || [];
            console.log('ðŸ“¦ Loaded team from localStorage backup');
        }
        return false;
    }
},

async deleteTeamMemberFromFirestore(teamMemberId) {
    try {
        await db.collection('team').doc(teamMemberId).delete();
        console.log('âœ… Team member deleted from Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error deleting team member from Firestore:', error);
        return false;
    }
},

// ============ VIDEOS FIRESTORE SYNC ============

async saveVideosToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('âŒ No user logged in');
            return false;
        }

        // Save videos to admin/data document
        await db.collection('admin').doc('data').set({
            videos: this.data.videos || [],
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        console.log('âœ… Videos saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving videos to Firestore:', error);
        return false;
    }
},

async loadVideosFromFirestore() {
    try {
        console.log('ðŸŽ¥ Loading videos from Firestore...');

        const dataDoc = await db.collection('admin').doc('data').get();

        if (dataDoc.exists) {
            const data = dataDoc.data();
            this.data.videos = data.videos || [];
            console.log(`âœ… Loaded ${this.data.videos.length} videos from Firestore`);
        } else {
            this.data.videos = [];
            console.log('ðŸ“ No videos found in Firestore - initialized empty array');
        }

        return true;
    } catch (error) {
        console.error('âŒ Error loading videos from Firestore:', error);
        this.data.videos = [];
        return false;
    }
},

// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('ðŸ“¦ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`ðŸ“¦ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`ðŸ“¦ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`âœ… Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`âœ… Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`âš ï¸ Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('ðŸ”„ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('âœ… Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('âš ï¸âš ï¸ Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('âŒâŒ CRITICAL: Both Firestore AND local are empty!');
            console.error('âŒ ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('âŒ Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('âš ï¸ Keeping existing local inventory due to error');
        return false;
    }
},

async loadItemHistoryFromFirestore() {
    try {
        console.log('ðŸ“œ Loading item history from Firestore...');

        const snapshot = await db.collection('itemHistory').orderBy('usedAt', 'desc').get();
        const history = [];
        snapshot.forEach(doc => {
            history.push({ id: doc.id, ...doc.data() });
        });

        this.data.itemHistory = history;
        console.log(`âœ… Loaded ${history.length} item history records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading item history from Firestore:', error);
        return false;
    }
},

async loadPaymentsFromFirestore() {
    try {
        console.log('ðŸ’µ Loading payments from Firestore...');

        const snapshot = await db.collection('payments').orderBy('timestamp', 'desc').get();
        const payments = [];
        snapshot.forEach(doc => {
            payments.push({ id: doc.id, ...doc.data() });
        });

        this.data.payments = payments;
        console.log(`âœ… Loaded ${payments.length} payment records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading payments from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('ðŸ”’ Permission Denied: You need admin/owner role to access financial data');
            console.error('ðŸ’¡ Solution: Run the setup script or create your user_roles document manually');
            console.error('ðŸ“– Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async loadExpensesFromFirestore() {
    try {
        console.log('ðŸ’¸ Loading expenses from Firestore...');

        const snapshot = await db.collection('expenses').orderBy('timestamp', 'desc').get();
        const expenses = [];
        snapshot.forEach(doc => {
            expenses.push({ id: doc.id, ...doc.data() });
        });

        this.data.expenses = expenses;
        console.log(`âœ… Loaded ${expenses.length} expense records from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading expenses from Firestore:', error);

        // Check if it's a permission error
        if (error.code === 'permission-denied') {
            console.error('ðŸ”’ Permission Denied: You need admin/owner role to access financial data');
            console.error('ðŸ’¡ Solution: Run the setup script or create your user_roles document manually');
            console.error('ðŸ“– Visit admin/setup-admin-users.html for help');
        }
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('âœ… Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('âœ… Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('âœ… Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('âŒ Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('âœ… Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('ðŸ”” Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`âœ… Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('âŒ Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ SETTINGS FIRESTORE SYNC ============

async saveSettingsToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) return false;

        await db.collection('settings').doc('app_settings').set({
            ...this.data.settings,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('âœ… Settings saved to Firestore');
        return true;
    } catch (error) {
        console.error('âŒ Error saving settings to Firestore:', error);
        return false;
    }
},

async loadSettingsFromFirestore() {
    try {
        console.log('âš™ï¸ Loading settings from Firestore...');

        const settingsDoc = await db.collection('settings').doc('app_settings').get();

        if (settingsDoc.exists) {
            const firestoreSettings = settingsDoc.data();
            // Merge with default settings
            this.data.settings = {
                ...this.data.settings,
                ...firestoreSettings
            };
            console.log('âœ… Settings loaded from Firestore');
            return true;
        } else {
            console.log('ðŸ“ No settings in Firestore, using defaults');
            // Save default settings to Firestore
            await this.saveSettingsToFirestore();
            return false;
        }
    } catch (error) {
        console.error('âŒ Error loading settings from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('âš ï¸ All listeners already active');
        return;
    }

    console.log('ðŸ”„ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('ðŸ‘· Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                    console.log('ðŸ‘· Team member updated:', teamMember.name);
                }
                // Update UI in real-time - always render when data changes
                this.renderTeamTable();
                // Also update dropdowns in order form
                this.updateTeamDropdowns();
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('ðŸ‘· Team member removed:', teamMember.name);
                    // Update UI in real-time
                    this.renderTeamTable();
                    this.updateTeamDropdowns();
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('ðŸ“¦ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`âš ï¸âš ï¸ BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if category was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedCategories &&
                                      this.data.inventory.deletedCategories.includes(category.id);
                    if (wasDeleted) {
                        console.warn('âš ï¸ Category was previously deleted - ignoring:', category.name);
                        return;
                    }

                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`ðŸ“ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        // Track deleted categories to prevent re-addition
                        if (!this.data.inventory.deletedCategories) {
                            this.data.inventory.deletedCategories = [];
                        }
                        if (!this.data.inventory.deletedCategories.includes(category.id)) {
                            this.data.inventory.deletedCategories.push(category.id);
                        }
                        console.log(`ðŸ—‘ï¸ Category removed:`, category.name);
                    }
                }
            });

            console.log(`ðŸ“¦ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('ðŸ“¦ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`âš ï¸âš ï¸ BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    // Check if item was marked as deleted locally
                    const wasDeleted = this.data.inventory.deletedItems &&
                                      this.data.inventory.deletedItems.includes(item.id);
                    if (wasDeleted) {
                        console.warn('âš ï¸ Inventory item was previously deleted - ignoring:', item.name);
                        return;
                    }

                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`ðŸ“¦ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        // Track deleted items to prevent re-addition
                        if (!this.data.inventory.deletedItems) {
                            this.data.inventory.deletedItems = [];
                        }
                        if (!this.data.inventory.deletedItems.includes(item.id)) {
                            this.data.inventory.deletedItems.push(item.id);
                        }
                        console.log(`ðŸ—‘ï¸ Item removed:`, item.name);
                    }
                }
            });

            console.log(`ðŸ“¦ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            } else if (this.currentTab === 'dashboard') {
                // Update dashboard in real-time when inventory changes (for low stock count)
                this.renderDashboard();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('âš™ï¸ Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    // Payments real-time listener
    this.paymentsUnsubscribe = db.collection('payments').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const payment = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index === -1) {
                    this.data.payments.push(payment);
                    console.log('ðŸ’µ Payment added:', payment.id);
                } else {
                    this.data.payments[index] = payment;
                    console.log('ðŸ’µ Payment updated:', payment.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.payments.findIndex(p => p.id === payment.id);
                if (index !== -1) {
                    this.data.payments.splice(index, 1);
                    console.log('ðŸ’µ Payment removed:', payment.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    // Expenses real-time listener
    this.expensesUnsubscribe = db.collection('expenses').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const expense = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index === -1) {
                    this.data.expenses.push(expense);
                    console.log('ðŸ’¸ Expense added:', expense.id);
                } else {
                    this.data.expenses[index] = expense;
                    console.log('ðŸ’¸ Expense updated:', expense.id);
                }
                // Update financials tab in real-time
                if (this.currentTab === 'financials') {
                    this.renderFinancials();
                }
            } else if (change.type === 'removed') {
                const index = this.data.expenses.findIndex(e => e.id === expense.id);
                if (index !== -1) {
                    this.data.expenses.splice(index, 1);
                    console.log('ðŸ’¸ Expense removed:', expense.id);
                    // Update financials tab in real-time
                    if (this.currentTab === 'financials') {
                        this.renderFinancials();
                    }
                }
            }
        });
        this.saveToStorage();
    });

    console.log('âœ… All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('âš ï¸ Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('ðŸ›‘ Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('ðŸ”„ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`ðŸ“‹ Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('âš ï¸ Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('ðŸ†• New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    // IMPORTANT: Include ALL fields from Firestore
                    const newOrder = {
                        ...orderData, // Include ALL fields (isMerged, mergedFrom, financials, etc.)
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        // Legacy field mappings for backwards compatibility
                        date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
                        readyTime: orderData.readyTime || customer.timeSlot || '',
                        clientName: orderData.clientName || customer.name || '',
                        contact: orderData.contact || customer.phone || '',
                        venue: orderData.venue || customer.venue || '',
                        eventType: orderData.eventType || orderData.functionType || customer.functionType || '',
                        // Normalize items to use consistent field names
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.quantity || item.qty || 0,
                            remarks: item.remarks || item.desc || '',
                            price: item.price || 0
                        }))
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        // Update dashboard statistics in real-time
                        if (this.currentTab === 'dashboard') {
                            this.renderDashboard();
                        }
                        this.showToast(`ðŸ†• New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('âœï¸ Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // IMPORTANT: Preserve ALL fields from Firebase including merged data and financials
        this.data.orders[index] = {
            ...orderData, // Include ALL fields from Firebase
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            // Legacy field mappings for backwards compatibility
            date: orderData.date || (orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || '')),
            readyTime: orderData.readyTime || customer.timeSlot || '',
            clientName: orderData.clientName || customer.name || '',
            contact: orderData.contact || customer.phone || '',
            venue: orderData.venue || customer.venue || '',
            eventType: orderData.eventType || orderData.functionType || customer.functionType || ''
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();

        // Force update all tabs in real-time
        if (this.currentTab === 'dashboard') {
            this.renderDashboard();
        } else if (this.currentTab === 'history') {
            this.renderHistory();
        } else if (this.currentTab === 'calendar') {
            this.renderCalendarTab();
        } else if (this.currentTab === 'financials') {
            this.renderFinancials();
        }

        console.log('âœ… Real-time update applied successfully');
        this.showToast(`âœï¸ Order updated: ${this.data.orders[index].clientName}`, 'info', 3000);
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('âš ï¸ Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('âš ï¸ Modified order not found locally, adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                console.log('ðŸ—‘ï¸ Order removed from Firestore:', orderData.orderId || change.doc.id);
                const index = this.data.orders.findIndex(o => o.orderId === (orderData.orderId || change.doc.id));
                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();

                    // Update dashboard in real-time when order is deleted
                    if (this.currentTab === 'dashboard') {
                        this.renderDashboard();
                    }

                    this.showToast(`ðŸ—‘ï¸ Order deleted: ${deleted.orderId}`, 'success');
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`âœ… Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('âœ… Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('ðŸ“‹ Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('âš ï¸ Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('âš ï¸ Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('ðŸ“‹ No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('âœ… Demo data loaded for first-time user');
    } else {
        console.log('âœ… Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') this.updateInventoryDisplay();
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();
        else if (this.currentTab === 'financials') this.renderFinancials();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `âš ï¸ OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'ðŸ”¥ TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = 'âš¡ TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `â° In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `ðŸ“… In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    âœ“ Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            this.loadOrderToForm(order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('âœ… Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('âŒ Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('âŒ Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // Expose OMS globally for console access and backward compatibility
        window.OMS = OMS;
        window.appManager = OMS;

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`âœ… Cleared ${count} entries from deletedOrders list`);
                console.log('ðŸ”„ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('âœ… Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('ðŸ”„ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('âœ… Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`ðŸ“‹ Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('âŒ Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`âœ… Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`âœ… Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`âš ï¸ Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('âŒ Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('âœ… No demo orders found!');
                        return [];
                    }

                    console.log(`âš ï¸ Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`âœ… Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('âŒ Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('âœ… Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`ðŸ“‹ Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Restore a specific order (remove from deletedOrders list)
            async restoreDeletedOrder(orderId) {
                console.log(`ðŸ”„ Attempting to restore order: ${orderId}`);

                // Find the order in deletedOrders list
                const deletedOrder = OMS.data.deletedOrders.find(o => o.orderId === orderId || o.docId === orderId);

                if (!deletedOrder) {
                    console.warn(`âš ï¸ Order ${orderId} not found in deletedOrders list`);
                    console.log('ðŸ’¡ Run AdminUtils.viewDeletedOrders() to see all deleted orders');
                    return false;
                }

                console.log(`âœ… Found deleted order: ${deletedOrder.orderId || orderId}`);
                console.log(`   Client: ${deletedOrder.clientName || 'N/A'}`);
                console.log(`   Deleted at: ${deletedOrder.deletedAt || 'N/A'}`);

                // Remove from deletedOrders list
                const beforeCount = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o =>
                    o.orderId !== orderId && o.docId !== orderId
                );
                const afterCount = OMS.data.deletedOrders.length;

                // Save to localStorage
                OMS.saveToStorage();
                console.log(`âœ… Removed from deletedOrders list (${beforeCount} â†’ ${afterCount})`);

                // Reload orders from Firestore
                console.log('ðŸ”„ Reloading orders from Firestore...');
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();

                // Check if order is now visible
                const restoredOrder = OMS.data.orders.find(o => o.orderId === orderId || o.docId === orderId);
                if (restoredOrder) {
                    console.log(`âœ…âœ… SUCCESS! Order ${orderId} has been restored and is now visible!`);
                    console.log(`   Client: ${restoredOrder.clientName}`);
                    console.log(`   Status: ${restoredOrder.status}`);
                    return true;
                } else {
                    console.warn(`âš ï¸ Order removed from block list, but not found in Firestore.`);
                    console.log(`ðŸ’¡ The order may have been permanently deleted from Firestore.`);
                    console.log(`ðŸ’¡ If you saved it again, try refreshing the page or run:`);
                    console.log(`   await AdminUtils.forceFullSync()`);
                    return false;
                }
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('ðŸ”„ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('ðŸ“¦ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('âŒ Firestore inventory is empty! Nothing to recover.');
                        console.log('ðŸ’¡ Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('âœ… Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('âŒ Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('âŒ No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('âŒ No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('ðŸ“¦ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('âœ… Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('âŒ Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('ðŸ“¦ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('ðŸ” Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`ðŸ“ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`ðŸ“¦ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('âŒ Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`ðŸ“‹ Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('âŒ Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`âœ… Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`âœ… Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`âš ï¸ Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('âŒ Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('ðŸ‘» Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('âœ… No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`ðŸ‘» Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nðŸ’¡ These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('âŒ Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('âš ï¸ This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('âŒ Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('âœ… Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`ðŸ—‘ï¸ Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`âš ï¸ Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('ðŸ” Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`ðŸ”¥ Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('âœ… Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('âœ… Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('âš ï¸ Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('âŒ Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('âœ… Added to deletedOrders block list');
                } else {
                    console.log('â„¹ï¸ Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\nâœ… Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  âœ“ Firestore database');
                console.log('  âœ“ Local data');
                console.log('  âœ“ Added to block list (deletedOrders)');
                console.log('  âœ“ Saved to localStorage');
                console.log('\nðŸ›¡ï¸ This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('ðŸ” Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('ðŸ“Š ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`âš ï¸ Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('âœ… Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nðŸ“¦ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('âŒ CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('ðŸ§¹ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`âš ï¸ Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`âœ… Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`ðŸ“‹ Deleted orders list: ${before} â†’ ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('âœ… No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('ðŸ”ðŸ”ðŸ” COMPREHENSIVE SYSTEM DIAGNOSTIC ðŸ”ðŸ”ðŸ”\n');

                // 1. Check localStorage
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('1ï¸âƒ£ LOCALSTORAGE CHECK');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('âœ… localStorage exists');
                    console.log(`  ðŸ“¦ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  ðŸ“¦ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  ðŸ“‹ Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  ðŸ—‘ï¸ Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('âŒ NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('2ï¸âƒ£ CURRENT MEMORY (OMS.data)');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log(`  ðŸ“¦ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  ðŸ“¦ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  ðŸ“‹ Orders: ${OMS.data.orders.length}`);
                console.log(`  ðŸ—‘ï¸ Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('3ï¸âƒ£ FIRESTORE CHECK');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  ðŸ“‹ Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  ðŸ“¦ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  ðŸ“¦ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('4ï¸âƒ£ MISMATCH ANALYSIS');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  âš ï¸ Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  âŒ DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  âœ… ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  âš ï¸ Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('5ï¸âƒ£ RECOMMENDATIONS');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  âŒ INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  ðŸ’¡ Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  âŒ INVENTORY EMPTY IN MEMORY!');
                    console.log('  ðŸ’¡ Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  ðŸ’¡ Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\nâœ… Diagnostic complete!\n');
            },

            // ============ FILTERING DIAGNOSTICS ============

            // View filter logs
            viewFilterLogs(count = 50) {
                const logs = filterLogger.getRecentLogs(count);
                console.group(`ðŸ“Š Recent Filter Logs (${logs.length})`);
                console.table(logs.map(log => ({
                    Time: new Date(log.timestamp).toLocaleString(),
                    Operation: log.operation,
                    Date: log.filterDate,
                    Matched: log.matchedCount,
                    Total: log.totalAvailable,
                    Time_ms: log.filterTimeMs
                })));
                console.groupEnd();
                return logs;
            },

            // View learned patterns
            viewLearnedPatterns() {
                const patterns = patternLearner.patterns;
                console.group('ðŸ§  Learned Patterns');

                console.log('\nðŸ“… Date-specific patterns:');
                const datePatterns = Object.entries(patterns.datePatterns)
                    .sort((a, b) => new Date(b[0]) - new Date(a[0]))
                    .slice(0, 20);
                console.table(datePatterns.map(([date, data]) => ({
                    Date: date,
                    AvgOrders: data.avgCount.toFixed(1),
                    Observations: data.counts.length,
                    LastSeen: new Date(data.lastSeen).toLocaleDateString()
                })));

                console.log('\nðŸ“Š Typical order counts:');
                console.table({
                    Weekday: {
                        Min: patterns.typicalOrderCounts.weekday.min,
                        Avg: patterns.typicalOrderCounts.weekday.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekday.max,
                        Samples: patterns.typicalOrderCounts.weekday.samples
                    },
                    Weekend: {
                        Min: patterns.typicalOrderCounts.weekend.min,
                        Avg: patterns.typicalOrderCounts.weekend.avg.toFixed(1),
                        Max: patterns.typicalOrderCounts.weekend.max,
                        Samples: patterns.typicalOrderCounts.weekend.samples
                    }
                });

                console.log('\nðŸ”„ Learned date formats:');
                const dateFormats = Object.entries(patterns.dateFormats).slice(0, 10);
                if (dateFormats.length > 0) {
                    console.table(dateFormats.map(([original, data]) => ({
                        Original: original,
                        Normalized: data.normalized,
                        Count: data.count
                    })));
                } else {
                    console.log('  No custom date formats learned yet');
                }

                console.groupEnd();
                return patterns;
            },

            // Clear all filter logs
            clearFilterLogs() {
                const count = filterLogger.logs.length;
                filterLogger.logs = [];
                filterLogger.saveLogs();
                console.log(`âœ… Cleared ${count} filter logs`);
            },

            // Reset learned patterns
            resetLearnedPatterns() {
                const confirmed = confirm('Reset all learned patterns? This cannot be undone.');
                if (confirmed) {
                    localStorage.removeItem('oms_filter_patterns');
                    location.reload();
                    console.log('âœ… Patterns reset. Page reloading...');
                }
            },

            // Test filter accuracy for a specific date
            async testFilterAccuracy(date) {
                console.group(`ðŸ§ª Testing Filter Accuracy for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                console.log(`ðŸ“… Normalized date: ${normalizedDate}`);

                // Test all date variations
                const variations = fuzzyDateMatcher.getVariations(date);
                console.log(`ðŸ”„ Testing ${variations.length} date variations:`, variations);

                // Run the actual filter
                const startTime = performance.now();
                const matchedOrders = [];
                const orders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) {
                            matchedOrders.push(o);
                            return true;
                        }
                    }
                    return false;
                });
                const filterTime = (performance.now() - startTime).toFixed(2);

                console.log(`âœ… Found ${orders.length} orders in ${filterTime}ms`);

                // Show expected count
                const expectedCount = patternLearner.getExpectedCount(normalizedDate);
                if (expectedCount !== null) {
                    console.log(`ðŸ§  Expected based on learning: ~${expectedCount} orders`);
                    const deviation = Math.abs(orders.length - expectedCount);
                    if (deviation > 0) {
                        console.log(`ðŸ“Š Deviation: ${deviation} orders (${((deviation / Math.max(expectedCount, 1)) * 100).toFixed(1)}%)`);
                    }
                }

                // Run validation
                const validationResult = orderValidator.validate({
                    date: normalizedDate,
                    orderCount: orders.length,
                    totalAvailable: OMS.data.orders.length,
                    matchedOrders,
                    allOrders: OMS.data.orders
                });

                if (validationResult.length > 0) {
                    console.log(`\nâš ï¸ Validation Issues (${validationResult.length}):`);
                    validationResult.forEach(alert => {
                        console.log(`  ${alert.level.toUpperCase()}: ${alert.message}`);
                    });
                } else {
                    console.log('\nâœ… No validation issues detected');
                }

                console.log(`\nðŸ“‹ Matched orders:`);
                console.table(orders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    Date: o.date || `${o.startDate} to ${o.endDate}`,
                    Status: o.status,
                    MultiDay: o.isMultiDay ? 'Yes' : 'No'
                })));

                console.groupEnd();
                return { orders, validationResult, filterTime };
            },

            // Show filtering statistics
            showFilteringStats() {
                console.group('ðŸ“Š Filtering System Statistics');

                const logs = filterLogger.logs;
                const patterns = patternLearner.patterns;

                console.log(`ðŸ“ Total filter operations logged: ${logs.length}`);
                console.log(`ðŸ§  Patterns learned for ${Object.keys(patterns.datePatterns).length} dates`);
                console.log(`ðŸ“… Date formats learned: ${Object.keys(patterns.dateFormats).length}`);
                console.log(`ðŸ“ˆ Filter results history: ${patterns.filterResults.length} entries`);

                if (logs.length > 0) {
                    const avgTime = logs
                        .filter(l => l.filterTimeMs)
                        .reduce((sum, l) => sum + parseFloat(l.filterTimeMs), 0) / logs.filter(l => l.filterTimeMs).length;
                    console.log(`âš¡ Average filter time: ${avgTime.toFixed(2)}ms`);
                }

                console.log('\nðŸ’¡ Available commands:');
                console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
                console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
                console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a date');
                console.log('  - AdminUtils.clearFilterLogs() - Clear all logs');
                console.log('  - AdminUtils.resetLearnedPatterns() - Reset all patterns');

                console.groupEnd();
            },

            // ============ RATING & LEARNING UTILITIES ============

            // Show rating UI for last filter result
            rateLastFilter() {
                if (!filterRatingSystem.currentFilterContext) {
                    console.warn('âš ï¸ No filter result available to rate. Run a filter first.');
                    return;
                }
                filterRatingSystem.showRatingUI(OMS);
            },

            // View all ratings
            viewRatings(count = 20) {
                const ratings = filterRatingSystem.ratings.slice(-count);
                if (ratings.length === 0) {
                    console.log('ðŸ“­ No ratings yet. Use AdminUtils.rateLastFilter() after filtering orders.');
                    return;
                }

                console.group(`â­ Recent Ratings (${ratings.length})`);
                console.table(ratings.map(r => ({
                    Date: r.date,
                    Rating: typeof r.rating === 'number' ? 'â­'.repeat(r.rating) : r.rating,
                    Matched: r.matchedOrders.length,
                    WrongIncluded: r.feedback.incorrectlyIncluded.length,
                    WrongExcluded: r.feedback.incorrectlyExcluded.length,
                    Tags: r.feedback.tags.join(', '),
                    RatedAt: new Date(r.ratedAt).toLocaleString()
                })));

                const stats = filterRatingSystem.getStats();
                console.log(`\nðŸ“Š Overall Statistics:`);
                console.log(`  Average Rating: ${stats.avgRating} / 5`);
                console.log(`  Total Ratings: ${stats.totalRatings}`);
                console.log(`  Sentiment Trend: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' â†’ ')}`);

                console.groupEnd();
            },

            // View learning rules
            viewLearningRules(date = null) {
                const rules = date
                    ? filterRatingSystem.getLearningRules(date)
                    : JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (rules.length === 0) {
                    console.log(`ðŸ“­ No learning rules${date ? ' for ' + date : ''}.`);
                    return;
                }

                console.group(`ðŸ§  Learning Rules${date ? ' for ' + date : ''} (${rules.length})`);
                console.table(rules.map(r => ({
                    Type: r.type,
                    Date: r.targetDate,
                    OrderID: r.orderId || 'N/A',
                    Reason: r.reason,
                    Weight: r.weight
                })));
                console.groupEnd();
            },

            // View rating statistics
            getRatingStats() {
                const stats = filterRatingSystem.getStats();
                console.group('ðŸ“Š Rating System Statistics');
                console.log(`Average Rating: ${stats.avgRating} / 5`);
                console.log(`Total Ratings: ${stats.totalRatings}`);
                console.log(`Recent Sentiment: ${stats.sentimentTrend.slice(-5).map(s => (s * 5).toFixed(1)).join(' â†’ ')}`);

                const learningRules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');
                console.log(`\nLearning Rules: ${learningRules.length}`);
                console.log(`  - Exclusions: ${learningRules.filter(r => r.type === 'exclusion').length}`);
                console.log(`  - Inclusions: ${learningRules.filter(r => r.type === 'inclusion').length}`);
                console.log(`  - Anomalies: ${learningRules.filter(r => r.type === 'anomaly').length}`);

                console.log('\nðŸ’¡ Available commands:');
                console.log('  - AdminUtils.rateLastFilter() - Rate the last filter result');
                console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
                console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
                console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
                console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');

                console.groupEnd();
            },

            // Test learning corrections for a date
            testLearning(date) {
                console.group(`ðŸ§ª Testing Learning Corrections for ${date}`);

                const normalizedDate = fuzzyDateMatcher.normalize(date);
                const learningRules = filterRatingSystem.getLearningRules(normalizedDate);

                if (learningRules.length === 0) {
                    console.log('ðŸ“­ No learning rules for this date yet. Rate a filter result first.');
                    console.groupEnd();
                    return;
                }

                console.log(`ðŸ§  Found ${learningRules.length} learning rules`);
                console.table(learningRules);

                // Run filter without corrections
                const originalOrders = OMS.data.orders.filter(o => {
                    if (!o.isMultiDay && o.date) {
                        if (fuzzyDateMatcher.matches(o.date, date)) return true;
                    }
                    if (o.isMultiDay && o.startDate && o.endDate) {
                        if (fuzzyDateMatcher.isInRange(date, o.startDate, o.endDate)) return true;
                    }
                    return false;
                });

                console.log(`\nðŸ“‹ Original filter: ${originalOrders.length} orders`);

                // Apply learning corrections
                const result = filterRatingSystem.applyLearningRules(normalizedDate, originalOrders, OMS.data.orders);

                console.log(`ðŸ§  After learning: ${result.orders.length} orders`);
                console.log(`âœ… Corrections applied: ${result.corrections.length}`);

                if (result.corrections.length > 0) {
                    console.log('\nðŸ“ Corrections:');
                    console.table(result.corrections.map(c => ({
                        Type: c.type,
                        OrderID: c.order.orderId,
                        Client: c.order.clientName,
                        Reason: c.reason
                    })));
                }

                console.groupEnd();
                return result;
            },

            // Clear all ratings and learning rules
            clearAllRatings() {
                const confirmed = confirm('Clear all ratings and learning rules? This cannot be undone.');
                if (confirmed) {
                    filterRatingSystem.clearAllRatings();
                    console.log('âœ… All ratings and learning rules cleared');
                }
            },

            // Export ratings and learning data
            exportLearningData() {
                const data = {
                    ratings: filterRatingSystem.ratings,
                    learningRules: JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]'),
                    patterns: patternLearner.patterns,
                    exportedAt: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `filter-learning-data-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                console.log('âœ… Learning data exported');
            },

            // Import ratings and learning data
            async importLearningData() {
                return new Promise((resolve, reject) => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';

                    input.onchange = async (e) => {
                        try {
                            const file = e.target.files[0];
                            const text = await file.text();
                            const data = JSON.parse(text);

                            if (data.ratings) {
                                filterRatingSystem.ratings = data.ratings;
                                filterRatingSystem.saveRatings();
                            }

                            if (data.learningRules) {
                                localStorage.setItem('oms_filter_learning_rules', JSON.stringify(data.learningRules));
                            }

                            if (data.patterns) {
                                localStorage.setItem('oms_filter_patterns', JSON.stringify(data.patterns));
                            }

                            console.log('âœ… Learning data imported successfully');
                            console.log(`  - Ratings: ${data.ratings?.length || 0}`);
                            console.log(`  - Learning Rules: ${data.learningRules?.length || 0}`);

                            resolve(data);
                        } catch (error) {
                            console.error('âŒ Failed to import learning data:', error);
                            reject(error);
                        }
                    };

                    input.click();
                });
            },

            // Enable ML corrections
            enableML() {
                localStorage.setItem('oms_ml_enabled', 'true');
                console.log('âœ… ML Corrections ENABLED');
                console.log('ðŸ§  The system will now apply learned corrections from previous ratings');
                console.log('ðŸ’¡ To disable: AdminUtils.disableML()');
                console.log('ðŸ’¡ To clear learned rules: AdminUtils.clearAllRatings()');
                return true;
            },

            // Disable ML corrections
            disableML() {
                localStorage.setItem('oms_ml_enabled', 'false');
                console.log('âœ… ML Corrections DISABLED');
                console.log('ðŸ“Š Filter will now use ONLY the original logic (no ML modifications)');
                console.log('ðŸ’¡ To enable: AdminUtils.enableML()');
                console.log('âš ï¸ Note: This does NOT clear learned rules, just stops applying them');
                return true;
            },

            // Check ML status
            checkMLStatus() {
                const enabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const ratings = JSON.parse(localStorage.getItem('oms_filter_ratings') || '[]');
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                console.log('ðŸ¤– ML System Status:');
                console.log(`  Status: ${enabled ? 'âœ… ENABLED' : 'ðŸ”‡ DISABLED'}`);
                console.log(`  Ratings stored: ${ratings.length}`);
                console.log(`  Learning rules: ${rules.length}`);

                if (enabled && rules.length > 0) {
                    console.log('\nâš ï¸ WARNING: ML is ACTIVE and will modify filter results');
                    console.log('ðŸ’¡ To disable: AdminUtils.disableML()');
                    console.log('ðŸ’¡ To clear rules: AdminUtils.clearAllRatings()');
                } else if (!enabled) {
                    console.log('\nâœ… ML is disabled - using original filter logic only');
                } else {
                    console.log('\nðŸ“‹ ML is enabled but no learning rules stored yet');
                }

                return { enabled, ratingsCount: ratings.length, rulesCount: rules.length };
            },

            // Quick fix: Disable ML and clear all learned rules
            resetMLSystem() {
                const confirmed = confirm('This will:\n1. Disable ML corrections\n2. Clear all ratings and learning rules\n\nContinue?');
                if (confirmed) {
                    this.disableML();
                    filterRatingSystem.clearAllRatings();
                    console.log('\nâœ… ML System Reset Complete!');
                    console.log('ðŸ“Š Filter will now use ONLY original logic');
                    console.log('ðŸ’¡ To re-enable: AdminUtils.enableML()');
                    return true;
                }
                return false;
            }
        };

        console.log('ðŸ› ï¸ Admin utilities loaded. Available commands:');
        console.log('\nðŸ“‹ ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - â­ PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nðŸ“¦ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - â­ LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nðŸ” DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - â­ FULL SYSTEM DIAGNOSTIC (find all bugs)');
        console.log('\nðŸŽ¯ FILTERING DIAGNOSTICS:');
        console.log('  - AdminUtils.showFilteringStats() - Show filtering system overview');
        console.log('  - AdminUtils.viewFilterLogs() - View recent filter operations');
        console.log('  - AdminUtils.viewLearnedPatterns() - View learned patterns');
        console.log('  - AdminUtils.testFilterAccuracy("2024-12-25") - Test filter for a specific date');
        console.log('  - AdminUtils.clearFilterLogs() - Clear all filter logs');
        console.log('  - AdminUtils.resetLearnedPatterns() - Reset learned patterns');
        console.log('\nâ­ RATING & LEARNING SYSTEM:');
        console.log('  - AdminUtils.rateLastFilter() - â­ Rate the last filter result');
        console.log('  - AdminUtils.viewRatings(20) - View recent ratings');
        console.log('  - AdminUtils.getRatingStats() - View rating statistics and trends');
        console.log('  - AdminUtils.viewLearningRules("2024-12-25") - View learning rules for a date');
        console.log('  - AdminUtils.testLearning("2024-12-25") - Test learning corrections for a date');
        console.log('  - AdminUtils.clearAllRatings() - Clear all ratings and learning rules');
        console.log('  - AdminUtils.exportLearningData() - Export learning data to JSON');
        console.log('  - await AdminUtils.importLearningData() - Import learning data from JSON');
        console.log('\nðŸ¤– ML SYSTEM CONTROLS:');
        console.log('  - AdminUtils.checkMLStatus() - â­ Check if ML is enabled/disabled and view stats');
        console.log('  - AdminUtils.disableML() - â­ DISABLE ML corrections (use original filter only)');
        console.log('  - AdminUtils.enableML() - Enable ML corrections');
        console.log('  - AdminUtils.resetMLSystem() - â­ DISABLE ML + clear all learned rules');

        // ============ GOOGLE MAPS INITIALIZATION ============
        // Global variable to store selected place from autocomplete
        let selectedPlaceData = null;

        // This function is called when Google Maps API finishes loading
        function initGoogleMaps() {
            console.log('Google Maps API loaded successfully');

            const venueInput = document.getElementById('venue');
            const mapLinkInput = document.getElementById('venueMapLink');

            if (!venueInput) {
                console.error('Venue input field not found');
                return;
            }

            try {
                // Initialize Autocomplete with new Places API
                const autocomplete = new google.maps.places.Autocomplete(venueInput, {
                    componentRestrictions: { country: 'in' },
                    fields: ['name', 'formatted_address', 'geometry', 'place_id'],
                    types: ['establishment', 'geocode']
                });

                // Listen for place selection
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace();

                    if (!place.geometry || !place.geometry.location) {
                        console.warn('No location details available for selected place');
                        selectedPlaceData = null;
                        return;
                    }

                    // Store place data globally
                    selectedPlaceData = {
                        name: place.name || place.formatted_address || venueInput.value,
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        formatted_address: place.formatted_address || '',
                        place_id: place.place_id || '',
                        source: 'google_autocomplete'
                    };

                    console.log('Place selected from autocomplete:', selectedPlaceData);

                    // Update venue input with selected place name
                    venueInput.value = selectedPlaceData.name;

                    // Auto-fill the venueMapLink field with Google Maps URL
                    if (mapLinkInput && selectedPlaceData.lat && selectedPlaceData.lng) {
                        const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${selectedPlaceData.lat},${selectedPlaceData.lng}&query_place_id=${selectedPlaceData.place_id}`;
                        mapLinkInput.value = mapsUrl;
                    }
                });

                console.log('Google Maps Autocomplete initialized successfully');
            } catch (error) {
                console.error('Error initializing Google Maps Autocomplete:', error);
            }
        }

        // Make function globally accessible
        window.initGoogleMaps = initGoogleMaps;

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Check ML status on page load
            setTimeout(() => {
                const mlEnabled = localStorage.getItem('oms_ml_enabled') !== 'false';
                const rules = JSON.parse(localStorage.getItem('oms_filter_learning_rules') || '[]');

                if (mlEnabled && rules.length > 0) {
                    console.warn('âš ï¸ ML SYSTEM IS ACTIVE! The filter may automatically modify results based on previous feedback.');
                    console.warn(`ðŸ“Š ${rules.length} learning rules are stored and will be applied.`);
                    console.warn('ðŸ’¡ To disable: AdminUtils.disableML()');
                    console.warn('ðŸ’¡ To check status: AdminUtils.checkMLStatus()');
                    console.warn('ðŸ’¡ To reset everything: AdminUtils.resetMLSystem()');
                } else if (!mlEnabled) {
                    console.log('âœ… ML corrections are DISABLED - using original filter logic only');
                    console.log('ðŸ’¡ To enable: AdminUtils.enableML()');
                }
            }, 1000);

            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'grid';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Set required fields for single day
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;

            // Show event type field for single-day
            document.getElementById('eventType').parentElement.style.display = 'block';

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Set required fields for multi-day
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;

            // Show event type field for multi-day
            document.getElementById('eventType').parentElement.style.display = 'block';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });

        // Initialize required attributes based on default state (single day)
        if (eventTypeSelect && eventTypeSelect.value === 'single') {
            document.getElementById('orderDate').required = true;
            document.getElementById('startDate').required = false;
            document.getElementById('endDate').required = false;
        } else if (eventTypeSelect && eventTypeSelect.value === 'multi') {
            document.getElementById('orderDate').required = false;
            document.getElementById('startDate').required = true;
            document.getElementById('endDate').required = true;
        }
    }

    // WhatsApp Date Filter Event Listeners
    const whatsappFilterDate = document.getElementById('whatsappFilterDate');
    const sendWhatsAppOrdersBtn = document.getElementById('sendWhatsAppOrdersBtn');

    if (whatsappFilterDate) {
        whatsappFilterDate.addEventListener('change', () => {
            OMS.updateWhatsAppDateFilter();
        });
    }

    if (sendWhatsAppOrdersBtn) {
        sendWhatsAppOrdersBtn.addEventListener('click', () => {
            OMS.sendWhatsAppOrdersReport();
        });
    }

    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">âš ï¸ End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">âš ï¸ Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // Initialize Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyC5c2BmVHnbWlBwwHtFwll97nq_xOdqxCc",
                authDomain: "firepowersfx-2558.firebaseapp.com",
                projectId: "firepowersfx-2558",
                storageBucket: "firepowersfx-2558.firebasestorage.app",
                messagingSenderId: "723483292867",
                appId: "1:723483292867:web:d6d83a79ba87cd2dee5e76"
            };

            firebase.initializeApp(firebaseConfig);
            window.auth = firebase.auth();
            window.db = firebase.firestore();
            console.log('âœ… Firebase initialized successfully!');

            // Track token refresh errors to prevent infinite loops
            let tokenErrorCount = 0;
            let lastTokenError = 0;
            const TOKEN_ERROR_THRESHOLD = 3; // Sign out after 3 consecutive errors
            const TOKEN_ERROR_WINDOW = 10000; // 10 seconds window

            // Monitor for token refresh errors
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                return originalFetch.apply(this, args).catch(error => {
                    // Check if this is a token refresh error
                    if (args[0] && typeof args[0] === 'string' && args[0].includes('securetoken.googleapis.com')) {
                        const now = Date.now();

                        // Reset counter if errors are not consecutive (more than 10s apart)
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`âš ï¸ Firebase token refresh failed (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive errors, sign out user to force fresh login
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('âŒ Multiple token refresh failures detected. Signing out to force fresh login...');
                            tokenErrorCount = 0; // Reset counter

                            // Sign out user
                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    }
                    throw error;
                }).then(response => {
                    // Check for 403 errors on token refresh
                    if (args[0] && typeof args[0] === 'string' &&
                        args[0].includes('securetoken.googleapis.com') &&
                        response.status === 403) {

                        const now = Date.now();

                        // Reset counter if errors are not consecutive
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`âš ï¸ Firebase token refresh 403 error (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive 403 errors, sign out user
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('âŒ Multiple 403 token errors detected. Signing out to force fresh login...');
                            tokenErrorCount = 0;

                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    } else {
                        // Reset counter on successful non-token requests
                        if (response.ok) {
                            tokenErrorCount = 0;
                        }
                    }
                    return response;
                });
            };

            // Check if user is logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    // User is logged in
                    console.log('âœ… User logged in:', user.email);
                    tokenErrorCount = 0; // Reset error counter on successful auth
                    document.getElementById('loginScreen').style.display = 'none';
                    document.querySelector('.app-container').style.display = 'flex';
                    OMS.init().then(() => OMS.updateAllDisplays());
                } else {
                    // User is logged out
                    console.log('âŒ User not logged in');
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.querySelector('.app-container').style.display = 'none';
                }
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');
                
                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';
                
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('âœ… Login successful!');

                    // ðŸŽ† FIREPOWER SFX LOGIN SUCCESS!
                    loginBtn.textContent = 'âœ… Success!';
                    loginBtn.style.background = 'linear-gradient(135deg, #00c853 0%, #00e676 100%)';

                    // Confetti Blast!
                    if (typeof confetti !== 'undefined') {
                        const count = 200;
                        const defaults = {
                            origin: { y: 0.7 },
                            colors: ['#FFD700', '#FFA500', '#FF6347', '#8B00FF', '#00BFFF']
                        };

                        function fire(particleRatio, opts) {
                            confetti(Object.assign({}, defaults, opts, {
                                particleCount: Math.floor(count * particleRatio)
                            }));
                        }

                        fire(0.25, { spread: 26, startVelocity: 55 });
                        fire(0.2, { spread: 60 });
                        fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8 });
                        fire(0.1, { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2 });
                        fire(0.1, { spread: 120, startVelocity: 45 });
                    }
                } catch (error) {
                    console.error('âŒ Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

            // Transport 2 custom field
            document.getElementById('transport2').addEventListener('change', (e) => {
                const group = document.getElementById('customTransport2Group');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });

    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('âœ… Date restrictions removed - can add orders from any date');

    // ============ FIREPOWER SFX LOGIN THEME ANIMATIONS ============

    // Floating Particles Background
    const canvas = document.getElementById('particles-canvas');
    const ctx = canvas ? canvas.getContext('2d') : null;

    if (canvas && ctx) {
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const particles = [];
        const particleCount = 50;

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.speedX = Math.random() * 0.5 - 0.25;
                this.speedY = Math.random() * -1 - 0.5;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = ['#ffd700', '#ffa500', '#ff6347'][Math.floor(Math.random() * 3)];
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.y < 0 || this.x < 0 || this.x > canvas.width) {
                    this.reset();
                    this.y = canvas.height;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Create particles
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animateParticles() {
            if (loginScreen.style.display === 'flex') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animateParticles);
            } else {
                // Clear canvas when login screen hidden
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Start animation when login screen is visible
        const particleObserver = new MutationObserver(() => {
            if (loginScreen.style.display === 'flex') {
                animateParticles();
            }
        });

        particleObserver.observe(loginScreen, { attributes: true, attributeFilter: ['style'] });
    }

    // Login Background Slideshow with 3-second timing
    const slides = document.querySelectorAll('.login-slideshow-slide');
    let currentSlide = 0;
    let slideshowInterval;

    function showNextSlide() {
        // Remove active class from current slide
        slides[currentSlide].classList.remove('active');

        // Move to next slide
        currentSlide = (currentSlide + 1) % slides.length;

        // Add active class to next slide
        slides[currentSlide].classList.add('active');
    }

    // Start slideshow when login screen is visible
    const slideshowObserver = new MutationObserver(() => {
        if (loginScreen.style.display === 'flex') {
            // Start slideshow
            if (!slideshowInterval) {
                slideshowInterval = setInterval(showNextSlide, 3000); // 3 seconds
            }
        } else {
            // Stop slideshow when login screen is hidden
            if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
        }
    });

    slideshowObserver.observe(loginScreen, { attributes: true, attributeFilter: ['style'] });

    console.log('ðŸŽ† Firepower SFX Login Theme Activated!');

        });

    </script>
</body>
</html>
