<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --light: #f8fafc;
            --white: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        /* Light Theme Variables */
        :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-hover: rgba(102, 126, 234, 0.05);
            --bg-input: #ffffff;
            --table-header-bg: #f8f9fa;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Noto Sans Gujarati', sans-serif;
            background: var(--bg-body);
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Layout */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        
        .app-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--white);
            padding: 1rem 0;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .company-name { font-size: 1.8rem; font-weight: 700; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .search-global {
            position: relative;
            width: 300px;
        }

        .search-global input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        .search-global-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            margin-top: 0.25rem;
            box-shadow: var(--shadow-lg);
        }

        .search-results.show { display: block; }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-dark);
        }

        .search-result-item:hover { background: var(--bg-hover); }

        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-gray);
            text-transform: uppercase;
        }

        /* Navigation */
        .nav-tabs {
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            padding: 0 1rem;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-gray);
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tab:hover { color: var(--primary); background: var(--bg-hover); }
        .nav-tab.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg-hover); }

        .main-content {
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
            width: 100%;
        }

        .tab-content { display: none; animation: fadeIn 0.3s ease-in; }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .card-header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Forms */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        .form-label.required::after { content: ' *'; color: var(--danger); }

        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--bg-input);
            color: var(--text-dark);
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Highlighted Date & Time Fields */
        .highlight-datetime {
            background-color: #fef3c7 !important;
            font-weight: 500;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Noto Sans Gujarati', sans-serif;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: var(--white); }
        .btn-secondary { background: var(--white); color: var(--primary); border: 2px solid var(--primary); }
        .btn-success { background: var(--success); color: var(--white); }
        .btn-warning { background: var(--warning); color: var(--white); }
        .btn-danger { background: var(--danger); color: var(--white); }
        .btn-info { background: var(--info); color: var(--white); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.info { border-left-color: var(--info); }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-gray);
            font-weight: 500;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th, .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-dark);
        }

        .table tr:hover { background: var(--bg-hover); }
        .table tr:last-child td { border-bottom: none; }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-confirmed { background: rgba(16, 185, 129, 0.1); color: var(--success); }
        .status-completed { background: rgba(102, 126, 234, 0.1); color: var(--primary); }
        .status-cancelled { background: rgba(239, 68, 68, 0.1); color: var(--danger); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2000;
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-left: 4px solid var(--success);
            padding: 1rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            transform: translateX(400px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            color: var(--text-dark);
        }

        .toast.show { transform: translateX(0); }
        .toast.error { border-left-color: var(--danger); }
        .toast.warning { border-left-color: #ff9800; }
        .toast-actions { display: flex; gap: 0.5rem; }
        .toast-btn { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            text-align: center;
            color: var(--text-dark);
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Calendar */
        .calendar-container {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .calendar-day-header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .calendar-day {
            background: var(--bg-card);
            min-height: 100px;
            padding: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .calendar-day:hover { background: var(--bg-hover); }
        .calendar-day.today { background: rgba(102, 126, 234, 0.2); }
        .calendar-day.has-orders { border-left: 4px solid var(--success); }
        .calendar-day.has-tasks { border-right: 4px solid var(--warning); }
        .calendar-day.has-festival { border-top: 4px solid var(--danger); }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .calendar-day-content {
            font-size: 0.8rem;
            color: var(--text-gray);
        }

        .festival-text {
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .order-count {
            background: var(--success);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
        }

        /* Quantity Controls */
        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Search Dropdown */
        .search-container { position: relative; margin-bottom: 1rem; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-dropdown.show { display: block; }

        .search-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-dark);
        }

        .search-item:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.3s ease;
        }

        /* Order ID Highlight */
        .order-id-highlight {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }

        /* Print Template - Force Light Theme Colors */
        .print-template {
            display: none;
            width: 2480px;
            min-height: 3508px;
            background: white !important;
            color: #000000 !important;
            padding: 80px 80px 80px 590px;
            font-family: 'Noto Sans Gujarati', Arial, sans-serif;
            font-size: 32px;
            line-height: 1.4;
            /* Force light theme - prevent dark theme inheritance */
            --text-dark: #1f2937 !important;
            --text-gray: #6b7280 !important;
            --border: #e5e7eb !important;
        }

        /* Ensure all text within print template is black */
        .print-template * {
            color: inherit;
        }

        /* Undo Bar */
        .undo-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: transform 0.3s ease;
        }

        .undo-bar.show { transform: translateX(-50%) translateY(0); }

        .undo-btn {
            background: var(--white);
            color: var(--text-dark);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Quick Action Menu */
        .quick-menu {
            position: absolute;
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 0.5rem 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .quick-menu.show { display: block; }

        .quick-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quick-menu-item:hover { background: var(--light); }

        /* Keyboard Shortcuts Panel */
        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 2500;
            max-width: 600px;
            display: none;
        }

        .shortcuts-panel.show { display: block; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-key {
            background: var(--light);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Drag Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .form-grid { grid-template-columns: 1fr; }
            .form-row { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: 1fr; }
            .calendar-day { min-height: 80px; }
            .search-global { width: 200px; }
            .header-content { flex-direction: column; gap: 1rem; }
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: 0.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }
    </style>
    <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
</head>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 3rem; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h1 style="text-align: center; color: #667eea; margin-bottom: 2rem; font-size: 2rem;">üîê Admin Login</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="üîç Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <span id="currentOrderId" style="font-weight: bold;">Next: FP001</span>
                    <button class="btn btn-info btn-small" onclick="OMS.toggleLanguage()" id="languageToggle" title="Switch Language">
                        üåê EN
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">‚å®Ô∏è</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">üö™ Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">üìä Dashboard</button>
                <button class="nav-tab" data-tab="orders">üìù Orders</button>
                <button class="nav-tab" data-tab="inventory">üì¶ Inventory</button>
                <button class="nav-tab" data-tab="preparation">üìã Preparation</button>
                <button class="nav-tab" data-tab="customers">üë• Customers</button>
                <button class="nav-tab" data-tab="team">üë∑ Team</button>
                <button class="nav-tab" data-tab="calendar">üóìÔ∏è Calendar</button>
                <button class="nav-tab" data-tab="history">üìö History</button>
                <button class="nav-tab" data-tab="analytics">üìà Analytics</button>
                <button class="nav-tab" data-tab="settings">‚öôÔ∏è Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">üîî Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üçï Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìù Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
    <label class="form-label required">Event Type</label>
    <select id="eventTypeSelect" class="form-select" required>
        <option value="single">Single Day Event</option>
        <option value="multi">Multi-Day Event</option>
    </select>
</div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-group">
    <label class="form-label required">Event Date</label>
    <input type="date" id="orderDate" class="form-input highlight-datetime" required>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" class="form-input highlight-datetime">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">üìÖ Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>
                            <div class="form-group">
                                <label class="form-label required">Ready Time</label>
                                <select id="readyTime" class="form-select highlight-datetime" required></select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Contact</label>
                                <input type="tel" id="contact" class="form-input" required>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Venue</label>
                                <input type="text" id="venue" class="form-input">
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <input type="text" id="eventType" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Transport</label>
                                <select id="transport" class="form-select">
                                    <option value="">Select</option>
                                    <option value="Bolero">Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper(s)</label>
                                <select id="helper" class="form-select" multiple style="min-height: 80px;">
                                    <option value="">Select Helper(s)</option>
                                </select>
                                <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple helpers</small>
                            </div>
                        </div>

                        <div class="btn-group" style="margin-top: 0.5rem;">
                            <button type="button" class="btn btn-success" onclick="OMS.notifyAllocatedTeam()">üì± Notify Allocated Team</button>
                            <button type="button" class="btn btn-info" onclick="OMS.sendManagerReport()">üìä Send Manager Report</button>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">üì¶ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="üîç Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">üíæ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">üëÅÔ∏è Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">üìã Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">üìÖ Same Day</button>
                            <button type="button" class="btn btn-danger" data-action="clear">üóëÔ∏è Clear (Ctrl+D)</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">√ó</button>
        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Clear Form</span>
                <span class="shortcut-key">Ctrl + D</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <script>
        
        // ============ UTILITIES ============
        const Utils = {
            get: (id, defaultValue = '') => {
                const el = document.getElementById(id);
                return el ? (el.value || '').toString().trim() : defaultValue;
            },

            set: (id, value) => {
                const el = document.getElementById(id);
                if (el) el.value = value;
            },

            elem: (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.entries(props).forEach(([key, val]) => {
                    if (key === 'class') el.className = val;
                    else if (key === 'style') Object.assign(el.style, val);
                    else if (key.startsWith('on')) el.addEventListener(key.slice(2), val);
                    else if (key.startsWith('data-')) el.dataset[key.slice(5)] = val;
                    else el[key] = val;
                });
                children.forEach(child => {
                    el.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
                });
                return el;
            },

            formatDate: (dateStr) => {
    if (!dateStr) return 'N/A';
    try {
        const date = new Date(dateStr + 'T00:00:00');
        return date.toLocaleDateString('en-GB');
    } catch {
        return dateStr;
    }
},

convertDateFormat: (dateStr) => {
    if (!dateStr) return '';
    try {
        // Convert DD/MM/YYYY to YYYY-MM-DD
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            const day = parts[0].padStart(2, '0');
            const month = parts[1].padStart(2, '0');
            const year = parts[2];
            return `${year}-${month}-${day}`;
        }
        return dateStr;
    } catch {
        return dateStr;
    }
},

getLocalDate: (dateStr) => {
    if (!dateStr) return new Date();
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day);
},

toDateString: (date) => {
    const d = date instanceof Date ? date : new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
},

generateId: () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

debounce: (func, wait) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
},

            validateRequired: (fields) => {
                const errors = [];
                fields.forEach(field => {
                    const value = Utils.get(field);
                    if (!value) errors.push(field);
                });
                return errors;
            }
        };

        // ============ TRANSLATIONS ============
        const translations = {
            en: {
                // Header
                companyName: 'Order Management System',
                searchPlaceholder: 'üîç Search everything...',
                next: 'Next',
                logout: 'üö™ Logout',

                // Tabs
                dashboard: 'üìä Dashboard',
                orders: 'üìã Orders',
                inventory: 'üì¶ Inventory',
                preparation: 'üç≥ Preparation',
                customers: 'üë• Customers',
                team: 'üë®‚Äçüíº Team',
                calendar: 'üìÖ Calendar',
                history: 'üïí History',
                analytics: 'üìà Analytics',
                settings: '‚öôÔ∏è Settings',

                // Common Buttons
                save: 'Save',
                cancel: 'Cancel',
                edit: 'Edit',
                delete: 'Delete',
                add: 'Add',
                close: 'Close',
                confirm: 'Confirm',
                clear: 'Clear',
                preview: 'Preview',
                duplicate: 'Duplicate',
                export: 'Export',
                import: 'Import',
                reset: 'Reset',
                search: 'Search',
                download: 'Download',
                upload: 'Upload',
                filter: 'Filter',
                print: 'Print',

                // Order Form
                orderDetails: 'Order Details',
                clientName: 'Client Name',
                contact: 'Contact',
                venue: 'Venue',
                orderDate: 'Order Date',
                readyTime: 'Ready Time',
                eventType: 'Event Type',
                transport: 'Transport',
                customTransport: 'Custom Transport',
                driverName: 'Driver Name',
                operator: 'Operator',
                helpers: 'Helper(s)',
                helperPlaceholder: 'Enter helper name(s), separate multiple with commas',
                orderStatus: 'Order Status',
                notes: 'Notes',
                items: 'Items',
                addItem: 'Add Item',
                itemName: 'Item Name',
                quantity: 'Quantity',
                remarks: 'Remarks',
                serialNumber: 'Sr. No.',

                // Status
                confirmed: 'Confirmed',
                completed: 'Completed',
                cancelled: 'Cancelled',
                pending: 'Pending',
                active: 'Active',
                inactive: 'Inactive',

                // Actions
                saveOrder: 'üíæ Save Order',
                saveOrderShortcut: 'üíæ Save Order (Ctrl+S)',
                duplicateLast: 'üìã Duplicate Last',
                sameDay: 'üìÖ Same Day',
                clearForm: 'üóëÔ∏è Clear',
                clearFormShortcut: 'üóëÔ∏è Clear (Ctrl+D)',
                notifyTeam: 'üì± Notify Allocated Team',
                sendReport: 'üìä Send Manager Report',

                // Settings
                systemSettings: '‚öôÔ∏è System Settings',
                printSettings: 'üñ®Ô∏è Print Settings',
                tableLayoutSettings: 'üìã Table Layout Settings',
                colorCustomization: 'üé® Color Customization',
                systemPreferences: 'üîß System Preferences',
                dataManagement: 'üìä Data Management',

                fontSize: 'Default Font Size',
                paperFormat: 'Paper Format',
                pageOrientation: 'Page Orientation',
                imageQuality: 'Image Quality',
                functionColor: 'Function Slot Color',
                portrait: 'üìÑ Portrait',
                landscape: 'üìÉ Landscape',
                low: 'Low',
                medium: 'Medium',
                high: 'High',
                ultra: 'Ultra',
                faster: 'Faster',
                balanced: 'Balanced',
                betterQuality: 'Better Quality',
                bestQuality: 'Best Quality',

                srColumnWidth: 'Sr.No Column Width',
                itemColumnWidth: 'Item Name Width',
                qtyColumnWidth: 'Quantity Width',
                remarksColumnWidth: 'Remarks Width',
                leftMarginFiling: 'Left Margin (filing)',

                headerBackground: 'Header Background',
                headerText: 'Header Text',
                orderIdBackground: 'Order ID Background',
                orderIdText: 'Order ID Text',
                tableHeaderBackground: 'Table Header Background',
                tableHeaderText: 'Table Header Text',
                tableBorder: 'Table Border',
                notesBackground: 'Notes Background',

                defaultOrderStatus: 'Default Order Status',
                lowStockThreshold: 'Low Stock Threshold',
                language: 'Language',
                invoiceFormat: 'Invoice Number Format',

                saveAllSettings: 'üíæ Save All Settings',
                resetToDefaults: 'üîÑ Reset to Defaults',
                exportJSON: 'üì§ Export JSON',
                exportCSV: 'üìä Export CSV',
                importBackup: 'üì• Import Backup',
                resetAllData: 'üóëÔ∏è Reset All Data',

                // Multi-day
                multiDayOrder: 'Multi-day Order',
                singleDayOrder: 'Single-day Order',
                startDate: 'Start Date',
                endDate: 'End Date',
                addDay: '‚ûï Add Day',
                addFunction: '‚ûï Add Function',
                removeDay: 'üóëÔ∏è Remove Day',
                removeFunction: 'üóëÔ∏è Remove Function',
                dayNumber: 'Day',
                functionNumber: 'Function',
                functionType: 'Function Type',
                timeSlot: 'Time Slot',
                driver: 'Driver',

                // Dashboard
                totalOrders: 'Total Orders',
                confirmedOrders: 'Confirmed',
                completedOrders: 'Completed',
                cancelledOrders: 'Cancelled',
                pendingOrders: 'Pending',
                recentOrders: 'Recent Orders',
                quickStats: 'Quick Stats',
                thisMonth: 'This Month',
                thisWeek: 'This Week',
                today: 'Today',

                // Team
                teamManagement: 'Team Management',
                addTeamMember: 'Add Team Member',
                memberName: 'Member Name',
                role: 'Role',
                roles: 'Roles',
                phoneNumber: 'Phone Number',
                email: 'Email',
                status: 'Status',
                actions: 'Actions',

                // Inventory
                inventoryManagement: 'Inventory Management',
                addCategory: 'Add Category',
                addInventoryItem: 'Add Inventory Item',
                categoryName: 'Category Name',
                currentStock: 'Current Stock',
                unit: 'Unit',
                reorderLevel: 'Reorder Level',

                // Calendar
                month: 'Month',
                week: 'Week',
                day: 'Day',
                ordersFor: 'Orders for',
                noOrders: 'No orders for this date',

                // History
                orderHistory: 'Order History',
                deletedOrders: 'Deleted Orders',
                restore: 'Restore',
                permanentlyDelete: 'Permanently Delete',

                // Analytics
                analyticsReport: 'Analytics Report',
                dateRange: 'Date Range',
                from: 'From',
                to: 'To',
                generateReport: 'Generate Report',
                topItems: 'Top Items',
                orderTrends: 'Order Trends',

                // Messages
                orderSaved: 'Order saved successfully!',
                orderDeleted: 'Order deleted!',
                settingsSaved: 'All settings saved successfully!',
                itemAdded: 'Item added!',
                itemRemoved: 'Item removed!',
                error: 'Error',
                success: 'Success',
                warning: 'Warning',
                info: 'Info',
                loading: 'Loading...',
                generatingImage: 'Generating image...',
                downloadComplete: 'Download complete!',

                // Placeholders
                enterClientName: 'Enter client name',
                enterContact: 'Enter contact number',
                enterVenue: 'Enter venue',
                selectDate: 'Select date',
                selectTime: 'Select time',
                selectEventType: 'Select event type',
                selectTransport: 'Select transport',
                selectDriver: 'Select Driver',
                selectOperator: 'Select Operator',
                selectHelper: 'Select Helper',
                enterNotes: 'Enter notes...',
                searchItem: 'Search item...',

                // Confirmations
                confirmDelete: 'Are you sure you want to delete?',
                confirmReset: 'Reset all settings?',
                confirmClear: 'Clear form?',
                cannotUndo: 'This action cannot be undone.',

                // Info messages
                multiOrderNote: 'Note: Multi-order images use smart auto-sizing',
                higherQualityNote: 'Higher quality = larger file size',
                multipleHelpersNote: 'You can add multiple helpers separated by commas (e.g., John, Mary, David)',
                chooseFormat: 'Choose paper size for print layout',
                portraitOrLandscape: 'Portrait or landscape mode',
                customColorNote: 'Custom color for function slots',

                // Additional translations for complete coverage
                lowStock: 'Low Stock',
                orderId: 'Order ID',
                client: 'Client',
                event: 'Event',
                date: 'Date',
                view: 'View',
                ordersText: 'orders',
                batchUpdate: '‚ö° Batch Update',
                categories: 'Categories',
                enterCategoryName: 'Category name',
                enterItemName: 'Item name',
                selectCategory: 'Select category',
                category: 'Category',
                item: 'Item',
                stock: 'Stock',
                topCustomer: 'Top Customer',
                preparationForecast: 'Preparation Forecast',
                selectDateRange: 'Select Date Range',
                generate: 'Generate',
                aggregatedItems: 'Aggregated Items for Date Range',
                forecastSummary: 'Forecast Summary',
                totalItems: 'Total Items',
                ordersInRange: 'Orders in Range',
                itemsToPrep: 'Items to Prepare',
                noOrdersFound: 'No orders found in the selected date range',
                customers: 'Customers',
                addCustomer: 'Add Customer',
                customerName: 'Customer Name',
                totalOrdersCount: 'Total Orders',
                lastOrder: 'Last Order',
                never: 'Never',
                na: 'N/A',
                viewOrders: 'View Orders',
                editTeamMember: 'Edit Team Member',
                addThisDay: '‚ûï Add to This Day',
                removeThisDay: 'üóëÔ∏è Remove',
                functionColor: 'Function Slot Color',
                addFunctionToThisDay: 'Add Function to This Day',
                selectOperatorPlaceholder: 'Select Operator',
                selectHelperPlaceholder: 'Select Helper',
                functionNotes: 'Special requirements for this function...',
                searchItems: 'üîç Search items...',
                noItemsAdded: 'No items added yet',
                calendarView: 'Calendar View',
                previousMonth: '‚Äπ Previous',
                nextMonth: 'Next ‚Ä∫',
                ordersScheduled: 'orders scheduled',
                noOrdersForDate: 'No orders for this date',
                viewOrderDetails: 'View details',
                restoreOrder: 'Restore',
                permanentDelete: 'Permanently Delete',
                ordersInHistory: 'orders in history',
                deletedOrdersCount: 'deleted orders',
                chartPlaceholder: 'Chart will appear here',
                noDataForRange: 'No data available for selected range',
                multiDayToggle: 'Multi-day Order',
                singleDay: 'Single Day',
                multiDay: 'Multi Day',
                transportOptions: 'Transport',
                customTransportOption: 'Custom',
                enterCustomTransport: 'Enter custom transport',
                selectStatus: 'Select Status',
                switchToEnglish: 'Switch to English',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: 'Preparation',
                forecast: 'Forecast',
                selectOperatorDropdown: 'Select Operator',
                noSelection: '',
                multiDayFormLabel: 'Multi-day Order?',
                enterFunctionType: 'e.g., Sangeet, Reception',
                enterTimeSlot: 'e.g., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: 'You can add multiple helpers separated by commas',
                tomorrow: 'Tomorrow',
                next7Days: 'Next 7 Days',
                next30Days: 'Next 30 Days',
                noOrdersFoundShort: 'No Orders Found',
                noOrdersScheduledBetween: 'No orders scheduled between',
                summary: 'Summary',
                uniqueItems: 'Unique Items',
                totalQuantity: 'Total Quantity',
                shortages: 'Shortages',
                sufficient: 'Sufficient',
                itemsPreparationList: 'Items Preparation List',
                sr: 'Sr',
                required: 'Required',
                inStock: 'In Stock',
                difference: 'Difference',
                usedInOrders: 'Used In Orders',
                ok: 'OK',
                short: 'SHORT',
                more: 'more',
                details: 'Details',
                grandTotal: 'GRAND TOTAL',
                orderDetailsBreakdown: 'Order Details Breakdown',
                shareWhatsApp: 'üì± Share WhatsApp',
                exportPDF: 'üìÑ Export PDF'
            },
            gu: {
                // Header
                companyName: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ',
                searchPlaceholder: 'üîç ‡™¨‡™ß‡´Å‡™Ç ‡™∂‡´ã‡™ß‡´ã...',
                next: '‡™Ü‡™ó‡™≥',
                logout: 'üö™ ‡™≤‡´ã‡™ó‡™Ü‡™â‡™ü',

                // Tabs
                dashboard: 'üìä ‡™°‡´á‡™∂‡™¨‡´ã‡™∞‡´ç‡™°',
                orders: 'üìã ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                inventory: 'üì¶ ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä',
                preparation: 'üç≥ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                customers: 'üë• ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                team: 'üë®‚Äçüíº ‡™ü‡´Ä‡™Æ',
                calendar: 'üìÖ ‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞',
                history: 'üïí ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                analytics: 'üìà ‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£',
                settings: '‚öôÔ∏è ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',

                // Common Buttons
                save: '‡™∏‡™æ‡™ö‡™µ‡´ã',
                cancel: '‡™∞‡™¶ ‡™ï‡™∞‡´ã',
                edit: '‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                delete: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                add: '‡™â‡™Æ‡´á‡™∞‡´ã',
                close: '‡™¨‡™Ç‡™ß ‡™ï‡™∞‡´ã',
                confirm: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™ï‡™∞‡´ã',
                clear: '‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                preview: '‡™™‡´Ç‡™∞‡´ç‡™µ‡™æ‡™µ‡™≤‡´ã‡™ï‡™®',
                duplicate: '‡™®‡™ï‡™≤',
                export: '‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                import: '‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                reset: '‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                search: '‡™∂‡´ã‡™ß‡´ã',
                download: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                upload: '‡™Ö‡™™‡™≤‡´ã‡™° ‡™ï‡™∞‡´ã',
                filter: '‡™´‡™ø‡™≤‡´ç‡™ü‡™∞',
                print: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü',

                // Order Form
                orderDetails: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™µ‡™ø‡™ó‡™§‡´ã',
                clientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                contact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï',
                venue: '‡™∏‡´ç‡™•‡™≥',
                orderDate: '‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                readyTime: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™∏‡™Æ‡™Ø',
                eventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                transport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                driverName: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                operator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞',
                helpers: '‡™π‡´á‡™≤‡´ç‡™™‡™∞(‡™∏)',
                helperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞‡™®‡™æ ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã, ‡™µ‡™ß‡´Å ‡™Æ‡™æ‡™ü‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´ã',
                orderStatus: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                notes: '‡™®‡´ã‡™Ç‡™ß',
                items: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                addItem: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                itemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                quantity: '‡™ú‡™•‡´ç‡™•‡´ã',
                remarks: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä',
                serialNumber: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï',

                // Status
                confirmed: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completed: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelled: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pending: '‡™¨‡™æ‡™ï‡´Ä',
                active: '‡™∏‡™ï‡´ç‡™∞‡™ø‡™Ø',
                inactive: '‡™®‡™ø‡™∑‡´ç‡™ï‡´ç‡™∞‡™ø‡™Ø',

                // Actions
                saveOrder: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                saveOrderShortcut: 'üíæ ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™æ‡™ö‡™µ‡´ã (Ctrl+S)',
                duplicateLast: 'üìã ‡™õ‡´á‡™≤‡´ç‡™≤‡´Ä ‡™®‡™ï‡™≤',
                sameDay: 'üìÖ ‡™∏‡™Æ‡™æ‡™® ‡™¶‡™ø‡™µ‡™∏',
                clearForm: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã',
                clearFormShortcut: 'üóëÔ∏è ‡™∏‡™æ‡™´ ‡™ï‡™∞‡´ã (Ctrl+D)',
                notifyTeam: 'üì± ‡™ü‡´Ä‡™Æ‡™®‡´á ‡™∏‡´Ç‡™ö‡™®‡™æ',
                sendReport: 'üìä ‡™Æ‡´á‡™®‡´á‡™ú‡™∞ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™Æ‡´ã‡™ï‡™≤‡´ã',

                // Settings
                systemSettings: '‚öôÔ∏è ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                printSettings: 'üñ®Ô∏è ‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                tableLayoutSettings: 'üìã ‡™ü‡´á‡™¨‡™≤ ‡™≤‡´á‡™Ü‡™â‡™ü ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏',
                colorCustomization: 'üé® ‡™∞‡™Ç‡™ó ‡™ï‡™∏‡´ç‡™ü‡™Æ‡™æ‡™á‡™ù‡´á‡™∂‡™®',
                systemPreferences: 'üîß ‡™∏‡™ø‡™∏‡´ç‡™ü‡™Æ ‡™™‡™∏‡™Ç‡™¶‡™ó‡´Ä‡™ì',
                dataManagement: 'üìä ‡™°‡´á‡™ü‡™æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',

                fontSize: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™´‡´ã‡™®‡´ç‡™ü ‡™∏‡™æ‡™á‡™ù',
                paperFormat: '‡™™‡´á‡™™‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',
                pageOrientation: '‡™™‡´á‡™ú ‡™ì‡™∞‡™ø‡™è‡™®‡´ç‡™ü‡´á‡™∂‡™®',
                imageQuality: '‡™á‡™Æ‡´á‡™ú ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                portrait: 'üìÑ ‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü',
                landscape: 'üìÉ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™',
                low: '‡™ì‡™õ‡´Ä',
                medium: '‡™Æ‡™ß‡´ç‡™Ø‡™Æ',
                high: '‡™â‡™ö‡´ç‡™ö',
                ultra: '‡™Ö‡™≤‡´ç‡™ü‡´ç‡™∞‡™æ',
                faster: '‡™ù‡™°‡™™‡´Ä',
                balanced: '‡™∏‡™Ç‡™§‡´Å‡™≤‡™ø‡™§',
                betterQuality: '‡™∏‡™æ‡™∞‡´Ä ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',
                bestQuality: '‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ',

                srColumnWidth: '‡™ï‡´ç‡™∞‡™Æ‡™æ‡™Ç‡™ï ‡™ï‡´â‡™≤‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                itemColumnWidth: '‡™Ü‡™á‡™ü‡™Æ ‡™®‡™æ‡™Æ ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                qtyColumnWidth: '‡™ú‡™•‡´ç‡™•‡´ã ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                remarksColumnWidth: '‡™ü‡™ø‡™™‡´ç‡™™‡™£‡´Ä ‡™™‡™π‡´ã‡™≥‡™æ‡™à',
                leftMarginFiling: '‡™°‡™æ‡™¨‡´ã ‡™Æ‡™æ‡™∞‡´ç‡™ú‡™ø‡™® (‡™´‡™æ‡™á‡™≤‡™ø‡™Ç‡™ó)',

                headerBackground: '‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                headerText: '‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                orderIdBackground: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                orderIdText: '‡™ì‡™∞‡´ç‡™°‡™∞ ID ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableHeaderBackground: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',
                tableHeaderText: '‡™ü‡´á‡™¨‡™≤ ‡™π‡´á‡™°‡™∞ ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü',
                tableBorder: '‡™ü‡´á‡™¨‡™≤ ‡™¨‡´ã‡™∞‡´ç‡™°‡™∞',
                notesBackground: '‡™®‡´ã‡™Ç‡™ß ‡™™‡´É‡™∑‡´ç‡™†‡™≠‡´Ç‡™Æ‡™ø',

                defaultOrderStatus: '‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                lowStockThreshold: '‡™ì‡™õ‡™æ ‡™∏‡´ç‡™ü‡´â‡™ï‡™®‡´Ä ‡™Æ‡™∞‡´ç‡™Ø‡™æ‡™¶‡™æ',
                language: '‡™≠‡™æ‡™∑‡™æ',
                invoiceFormat: '‡™á‡™®‡´ç‡™µ‡´â‡™á‡™∏ ‡™®‡™Ç‡™¨‡™∞ ‡™´‡´ã‡™∞‡´ç‡™Æ‡´á‡™ü',

                saveAllSettings: 'üíæ ‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™æ‡™ö‡™µ‡´ã',
                resetToDefaults: 'üîÑ ‡™°‡™ø‡™´‡´â‡™≤‡´ç‡™ü ‡™™‡™∞ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',
                exportJSON: 'üì§ JSON ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                exportCSV: 'üìä CSV ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã',
                importBackup: 'üì• ‡™¨‡´á‡™ï‡™Ö‡™™ ‡™Ü‡™Ø‡™æ‡™§ ‡™ï‡™∞‡´ã',
                resetAllData: 'üóëÔ∏è ‡™¨‡™ß‡´ã ‡™°‡´á‡™ü‡™æ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡´ã',

                // Multi-day
                multiDayOrder: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDayOrder: '‡™∏‡™ø‡™Ç‡™ó‡™≤-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                startDate: '‡™∂‡™∞‡´Ç‡™Ü‡™§‡™®‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                endDate: '‡™Ö‡™Ç‡™§‡™ø‡™Æ ‡™§‡™æ‡™∞‡´Ä‡™ñ',
                addDay: '‚ûï ‡™¶‡™ø‡™µ‡™∏ ‡™â‡™Æ‡´á‡™∞‡´ã',
                addFunction: '‚ûï ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeDay: 'üóëÔ∏è ‡™¶‡™ø‡™µ‡™∏ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                removeFunction: 'üóëÔ∏è ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                dayNumber: '‡™¶‡™ø‡™µ‡™∏',
                functionNumber: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®',
                functionType: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™®‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞',
                timeSlot: '‡™∏‡™Æ‡™Ø',
                driver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞',

                // Dashboard
                totalOrders: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                confirmedOrders: '‡™™‡´Å‡™∑‡´ç‡™ü‡™ø ‡™•‡™Ø‡´á‡™≤',
                completedOrders: '‡™™‡´Ç‡™∞‡´ç‡™£ ‡™•‡™Ø‡´Å‡™Ç',
                cancelledOrders: '‡™∞‡™¶ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç',
                pendingOrders: '‡™¨‡™æ‡™ï‡´Ä',
                recentOrders: '‡™§‡™æ‡™ú‡´á‡™§‡™∞‡™®‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                quickStats: '‡™ù‡™°‡™™‡´Ä ‡™Ü‡™Ç‡™ï‡™°‡™æ',
                thisMonth: '‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á',
                thisWeek: '‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´á',
                today: '‡™Ü‡™ú‡´á',

                // Team
                teamManagement: '‡™ü‡´Ä‡™Æ ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™â‡™Æ‡´á‡™∞‡´ã',
                memberName: '‡™∏‡™≠‡´ç‡™Ø‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                role: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ',
                roles: '‡™≠‡´Ç‡™Æ‡™ø‡™ï‡™æ‡™ì',
                phoneNumber: '‡™´‡´ã‡™® ‡™®‡™Ç‡™¨‡™∞',
                email: '‡™á‡™Æ‡´á‡™á‡™≤',
                status: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø',
                actions: '‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ‡™ì',

                // Inventory
                inventoryManagement: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü',
                addCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™â‡™Æ‡´á‡™∞‡´ã',
                addInventoryItem: '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ã',
                categoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                currentStock: '‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™∏‡´ç‡™ü‡´â‡™ï',
                unit: '‡™è‡™ï‡™Æ',
                reorderLevel: '‡™´‡™∞‡´Ä‡™•‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞‡™®‡´Ä ‡™∏‡´ç‡™§‡™∞',

                // Calendar
                month: '‡™Æ‡™π‡™ø‡™®‡´ã',
                week: '‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´Å‡™Ç',
                day: '‡™¶‡™ø‡™µ‡™∏',
                ordersFor: '‡™Æ‡™æ‡™ü‡´á ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                noOrders: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',

                // History
                orderHistory: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™§‡™ø‡™π‡™æ‡™∏',
                deletedOrders: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                restore: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentlyDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',

                // Analytics
                analyticsReport: '‡™µ‡™ø‡™∂‡´ç‡™≤‡´á‡™∑‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü',
                dateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä',
                from: '‡™•‡´Ä',
                to: '‡™∏‡´Å‡™ß‡´Ä',
                generateReport: '‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™¨‡™®‡™æ‡™µ‡´ã',
                topItems: '‡™ü‡´ã‡™™ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                orderTrends: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ü‡´ç‡™∞‡´á‡™®‡´ç‡™°‡´ç‡™∏',

                // Messages
                orderSaved: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´ç‡™Ø‡´ã!',
                orderDeleted: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ç‡™Ø‡´ã!',
                settingsSaved: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™∏‡™æ‡™ö‡™µ‡´Ä!',
                itemAdded: '‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                itemRemoved: '‡™Ü‡™á‡™ü‡™Æ ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ç‡™Ø‡´Å‡™Ç!',
                error: '‡™≠‡´Ç‡™≤',
                success: '‡™∏‡™´‡™≥‡™§‡™æ',
                warning: '‡™ö‡´á‡™§‡™µ‡™£‡´Ä',
                info: '‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä',
                loading: '‡™≤‡´ã‡™° ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´Å‡™Ç ‡™õ‡´á...',
                generatingImage: '‡™á‡™Æ‡´á‡™ú ‡™¨‡™®‡™æ‡™µ‡´Ä ‡™∞‡™π‡´ç‡™Ø‡™æ ‡™õ‡´Ä‡™è...',
                downloadComplete: '‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™™‡´Ç‡™∞‡´ç‡™£!',

                // Placeholders
                enterClientName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterContact: '‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï ‡™®‡™Ç‡™¨‡™∞ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                enterVenue: '‡™∏‡´ç‡™•‡™≥ ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectDate: '‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTime: '‡™∏‡™Æ‡™Ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectEventType: '‡™á‡™µ‡´á‡™®‡´ç‡™ü‡™®‡´ã ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectTransport: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectDriver: '‡™°‡´ç‡™∞‡™æ‡™à‡™µ‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectOperator: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelper: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                enterNotes: '‡™®‡´ã‡™Ç‡™ß ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã...',
                searchItem: '‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',

                // Confirmations
                confirmDelete: '‡™∂‡´Å‡™Ç ‡™§‡™Æ‡´á ‡™ñ‡™∞‡´á‡™ñ‡™∞ ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã?',
                confirmReset: '‡™¨‡™ß‡´Ä ‡™∏‡´á‡™ü‡™ø‡™Ç‡™ó‡´ç‡™∏ ‡™∞‡´Ä‡™∏‡´á‡™ü ‡™ï‡™∞‡™µ‡´Ä ‡™õ‡´á?',
                confirmClear: '‡™´‡´ã‡™∞‡´ç‡™Æ ‡™∏‡™æ‡™´ ‡™ï‡™∞‡™µ‡´Å‡™Ç ‡™õ‡´á?',
                cannotUndo: '‡™Ü ‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§‡´ç ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡™æ‡™§‡´Ä ‡™®‡™•‡´Ä.',

                // Info messages
                multiOrderNote: '‡™®‡´ã‡™Ç‡™ß: ‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™ì‡™∞‡´ç‡™°‡™∞ ‡™á‡™Æ‡´á‡™ú‡´Ä‡™∏ ‡™∏‡´ç‡™Æ‡™æ‡™∞‡´ç‡™ü ‡™ì‡™ü‡´ã-‡™∏‡™æ‡™á‡™ù‡™ø‡™Ç‡™ó ‡™µ‡™æ‡™™‡™∞‡´á ‡™õ‡´á',
                higherQualityNote: '‡™â‡™ö‡´ç‡™ö ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ = ‡™Æ‡´ã‡™ü‡´Ä ‡™´‡™æ‡™á‡™≤ ‡™∏‡™æ‡™á‡™ù',
                multipleHelpersNote: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã (‡™¶‡™æ.‡™§., ‡™ú‡´ã‡™®, ‡™Æ‡´á‡™∞‡´Ä, ‡™°‡´á‡™µ‡™ø‡™°)',
                chooseFormat: '‡™™‡´ç‡™∞‡™ø‡™®‡´ç‡™ü ‡™≤‡´á‡™Ü‡™â‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™™‡´á‡™™‡™∞ ‡™∏‡™æ‡™á‡™ù ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                portraitOrLandscape: '‡™™‡´ã‡™∞‡´ç‡™ü‡´ç‡™∞‡´á‡™ü ‡™Ö‡™•‡™µ‡™æ ‡™≤‡´á‡™®‡´ç‡™°‡™∏‡´ç‡™ï‡´á‡™™ ‡™Æ‡´ã‡™°',
                customColorNote: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™∞‡™Ç‡™ó',

                // Additional translations for complete coverage
                lowStock: '‡™ì‡™õ‡´ã ‡™∏‡´ç‡™ü‡´â‡™ï',
                orderId: '‡™ì‡™∞‡´ç‡™°‡™∞ ID',
                client: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                event: '‡™á‡™µ‡´á‡™®‡´ç‡™ü',
                date: '‡™§‡™æ‡™∞‡´Ä‡™ñ',
                view: '‡™ú‡´Å‡™ì',
                ordersText: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                batchUpdate: '‚ö° ‡™¨‡´á‡™ö ‡™Ö‡™™‡™°‡´á‡™ü',
                categories: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™ì',
                enterCategoryName: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                enterItemName: '‡™Ü‡™á‡™ü‡™Æ‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                selectCategory: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                category: '‡™ï‡´á‡™ü‡´á‡™ó‡™∞‡´Ä',
                item: '‡™Ü‡™á‡™ü‡™Æ',
                stock: '‡™∏‡´ç‡™ü‡´â‡™ï',
                topCustomer: '‡™ü‡´ã‡™™ ‡™ó‡´ç‡™∞‡™æ‡™π‡™ï',
                preparationForecast: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectDateRange: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                generate: '‡™¨‡™®‡™æ‡™µ‡´ã',
                aggregatedItems: '‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™è‡™ï‡™§‡´ç‡™∞‡™ø‡™§ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                forecastSummary: '‡™Ö‡™Ç‡™¶‡™æ‡™ú ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                totalItems: '‡™ï‡´Å‡™≤ ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                ordersInRange: '‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                itemsToPrep: '‡™§‡´à‡™Ø‡™æ‡™∞ ‡™ï‡™∞‡™µ‡™æ‡™®‡´Ä ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                noOrdersFound: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™§‡™æ‡™∞‡´Ä‡™ñ‡™®‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™Æ‡™æ‡™Ç ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                customers: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡´ã',
                addCustomer: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï ‡™â‡™Æ‡´á‡™∞‡´ã',
                customerName: '‡™ó‡´ç‡™∞‡™æ‡™π‡™ï‡™®‡´Å‡™Ç ‡™®‡™æ‡™Æ',
                totalOrdersCount: '‡™ï‡´Å‡™≤ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                lastOrder: '‡™õ‡´á‡™≤‡´ç‡™≤‡´ã ‡™ì‡™∞‡´ç‡™°‡™∞',
                never: '‡™ï‡´ç‡™Ø‡™æ‡™∞‡´á‡™Ø ‡™®‡™π‡´Ä‡™Ç',
                na: '‡™≤‡™æ‡™ó‡´Å ‡™®‡™•‡´Ä',
                viewOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™ú‡´Å‡™ì',
                editTeamMember: '‡™ü‡´Ä‡™Æ ‡™∏‡™≠‡´ç‡™Ø ‡™∏‡´Å‡™ß‡™æ‡™∞‡´ã',
                addThisDay: '‚ûï ‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™â‡™Æ‡´á‡™∞‡´ã',
                removeThisDay: 'üóëÔ∏è ‡™¶‡´Ç‡™∞ ‡™ï‡™∞‡´ã',
                functionColor: '‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™∏‡´ç‡™≤‡´ã‡™ü ‡™∞‡™Ç‡™ó',
                addFunctionToThisDay: '‡™Ü ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™â‡™Æ‡´á‡™∞‡´ã',
                selectOperatorPlaceholder: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                selectHelperPlaceholder: '‡™π‡´á‡™≤‡´ç‡™™‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                functionNotes: '‡™Ü ‡™´‡™Ç‡™ï‡´ç‡™∂‡™® ‡™Æ‡™æ‡™ü‡´á ‡™µ‡™ø‡™∂‡´á‡™∑ ‡™ú‡™∞‡´Ç‡™∞‡™ø‡™Ø‡™æ‡™§‡´ã...',
                searchItems: 'üîç ‡™Ü‡™á‡™ü‡™Æ ‡™∂‡´ã‡™ß‡´ã...',
                noItemsAdded: '‡™π‡™ú‡´Å ‡™∏‡´Å‡™ß‡´Ä ‡™ï‡´ã‡™à ‡™Ü‡™á‡™ü‡™Æ ‡™â‡™Æ‡´á‡™∞‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                calendarView: '‡™ï‡´á‡™≤‡´á‡™®‡´ç‡™°‡™∞ ‡™¶‡´É‡™∂‡´ç‡™Ø',
                previousMonth: '‚Äπ ‡™™‡™π‡´á‡™≤‡™æ‡™Ç',
                nextMonth: '‡™Ü‡™ó‡™≥ ‚Ä∫',
                ordersScheduled: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§',
                noOrdersForDate: '‡™Ü ‡™§‡™æ‡™∞‡´Ä‡™ñ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™®‡™•‡´Ä',
                viewOrderDetails: '‡™µ‡™ø‡™ó‡™§‡´ã ‡™ú‡´Å‡™ì',
                restoreOrder: '‡™™‡´Å‡™®‡™É‡™∏‡´ç‡™•‡™æ‡™™‡™ø‡™§ ‡™ï‡™∞‡´ã',
                permanentDelete: '‡™ï‡™æ‡™Ø‡™Æ ‡™Æ‡™æ‡™ü‡´á ‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´ã',
                ordersInHistory: '‡™á‡™§‡™ø‡™π‡™æ‡™∏‡™Æ‡™æ‡™Ç ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                deletedOrdersCount: '‡™ï‡™æ‡™¢‡´Ä ‡™®‡™æ‡™ñ‡´á‡™≤‡™æ ‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏',
                chartPlaceholder: '‡™ö‡™æ‡™∞‡´ç‡™ü ‡™Ö‡™π‡´Ä‡™Ç ‡™¶‡´á‡™ñ‡™æ‡™∂‡´á',
                noDataForRange: '‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´á‡™≤‡´Ä ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä ‡™Æ‡™æ‡™ü‡´á ‡™ï‡´ã‡™à ‡™°‡´á‡™ü‡™æ ‡™â‡™™‡™≤‡™¨‡´ç‡™ß ‡™®‡™•‡´Ä',
                multiDayToggle: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞',
                singleDay: '‡™∏‡™ø‡™Ç‡™ó‡™≤ ‡™°‡´á',
                multiDay: '‡™Æ‡™≤‡´ç‡™ü‡™ø ‡™°‡´á',
                transportOptions: '‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü',
                customTransportOption: '‡™ï‡™∏‡´ç‡™ü‡™Æ',
                enterCustomTransport: '‡™ï‡™∏‡´ç‡™ü‡™Æ ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™™‡´ã‡™∞‡´ç‡™ü ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã',
                selectStatus: '‡™∏‡´ç‡™•‡™ø‡™§‡™ø ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                switchToEnglish: '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                switchToGujarati: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã',
                englishShort: 'EN',
                gujaratiShort: '‡™ó‡´Å',
                preparation: '‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä',
                forecast: '‡™Ö‡™Ç‡™¶‡™æ‡™ú',
                selectOperatorDropdown: '‡™ì‡™™‡™∞‡´á‡™ü‡™∞ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã',
                noSelection: '',
                multiDayFormLabel: '‡™Æ‡™≤‡´ç‡™ü‡™ø-‡™°‡´á ‡™ì‡™∞‡´ç‡™°‡™∞?',
                enterFunctionType: '‡™¶‡™æ.‡™§., ‡™∏‡™Ç‡™ó‡´Ä‡™§, ‡™∞‡™ø‡™∏‡´á‡™™‡´ç‡™∂‡™®',
                enterTimeSlot: '‡™¶‡™æ.‡™§., 5:00 PM - 9:00 PM',
                multipleHelpersSeparated: '‡™§‡™Æ‡´á ‡™Ö‡™≤‡´ç‡™™‡™µ‡™ø‡™∞‡™æ‡™Æ‡™•‡´Ä ‡™Ö‡™≤‡™ó ‡™ï‡™∞‡´Ä‡™®‡´á ‡™ò‡™£‡™æ ‡™π‡´á‡™≤‡´ç‡™™‡™∞‡´ã ‡™â‡™Æ‡´á‡™∞‡´Ä ‡™∂‡™ï‡´ã ‡™õ‡´ã',
                tomorrow: '‡™Ü‡™µ‡™§‡´Ä ‡™ï‡™æ‡™≤‡´á',
                next7Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 7 ‡™¶‡™ø‡™µ‡™∏',
                next30Days: '‡™Ü‡™ó‡™æ‡™Æ‡´Ä 30 ‡™¶‡™ø‡™µ‡™∏',
                noOrdersFoundShort: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä',
                noOrdersScheduledBetween: '‡™ï‡´ã‡™à ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Å‡™®‡™ø‡™∂‡´ç‡™ö‡™ø‡™§ ‡™®‡™•‡´Ä',
                summary: '‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
                uniqueItems: '‡™Ö‡™®‡™®‡´ç‡™Ø ‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏',
                totalQuantity: '‡™ï‡´Å‡™≤ ‡™ú‡™•‡´ç‡™•‡´ã',
                shortages: '‡™â‡™£‡™™',
                sufficient: '‡™™‡™∞‡´ç‡™Ø‡™æ‡™™‡´ç‡™§',
                itemsPreparationList: '‡™Ü‡™á‡™ü‡™Æ‡´ç‡™∏ ‡™§‡´à‡™Ø‡™æ‡™∞‡´Ä ‡™Ø‡™æ‡™¶‡´Ä',
                sr: '‡™ï‡´ç‡™∞‡™Æ',
                required: '‡™ú‡™∞‡´Ç‡™∞‡´Ä',
                inStock: '‡™∏‡´ç‡™ü‡´â‡™ï‡™Æ‡™æ‡™Ç',
                difference: '‡™§‡™´‡™æ‡™µ‡™§',
                usedInOrders: '‡™ì‡™∞‡´ç‡™°‡™∞‡´ç‡™∏‡™Æ‡™æ‡™Ç ‡™µ‡™™‡™∞‡™æ‡™Ø‡´á‡™≤',
                ok: '‡™¨‡™∞‡™æ‡™¨‡™∞',
                short: '‡™ì‡™õ‡´Å‡™Ç',
                more: '‡™µ‡™ß‡´Å',
                details: '‡™µ‡™ø‡™ó‡™§‡´ã',
                grandTotal: '‡™ï‡´Å‡™≤ ‡™∏‡™∞‡™µ‡™æ‡™≥‡´ã',
                orderDetailsBreakdown: '‡™ì‡™∞‡´ç‡™°‡™∞ ‡™µ‡™ø‡™ó‡™§ ‡™µ‡™ø‡™≠‡™æ‡™ú‡™®',
                shareWhatsApp: 'üì± WhatsApp ‡™∂‡´á‡™∞ ‡™ï‡™∞‡´ã',
                exportPDF: 'üìÑ PDF ‡™®‡™ø‡™ï‡™æ‡™∏ ‡™ï‡™∞‡´ã'
            }
        };

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [] },
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                settings: {
                    printFontSize: 32,
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["‡§Æ‡§ï‡§∞ ‡§∏‡§Ç‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡§ø", "Makar Sankranti"],
                "2025-01-26": ["‡§ó‡§£‡§§‡§Ç‡§§‡•ç‡§∞ ‡§¶‡§ø‡§µ‡§∏", "Republic Day"],
                "2025-02-13": ["‡§Æ‡§π‡§æ ‡§∂‡§ø‡§µ‡§∞‡§æ‡§§‡•ç‡§∞‡§ø", "Maha Shivratri"],
                "2025-03-13": ["‡§π‡•ã‡§≤‡•Ä", "Holi"],
                "2025-03-14": ["‡§ß‡•Å‡§≤‡•á‡§ü‡•Ä", "Dhuleti"],
                "2025-04-06": ["‡§∞‡§æ‡§Æ ‡§®‡§µ‡§Æ‡•Ä", "Ram Navami"],
                "2025-08-15": ["‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞‡§§‡§æ ‡§¶‡§ø‡§µ‡§∏", "Independence Day"],
                "2025-08-19": ["‡§ú‡§®‡•ç‡§Æ‡§æ‡§∑‡•ç‡§ü‡§Æ‡•Ä", "Janmashtami"],
                "2025-10-02": ["‡§ó‡§æ‡§Ç‡§ß‡•Ä ‡§ú‡§Ø‡§Ç‡§§‡•Ä", "Gandhi Jayanti"],
                "2025-11-01": ["‡§ß‡§®‡§§‡•á‡§∞‡§∏", "Dhanteras"],
                "2025-11-02": ["‡§¶‡•Ä‡§µ‡§æ‡§≤‡•Ä", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('‚ö†Ô∏è Already initialized - skipping duplicate init');
        return;
    }
    
    console.log('üöÄ Initializing OMS...');
    this.initialized = true;
    await this.loadFromStorage();
    await this.loadTrackingFromFirestore();
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
                this.applyLanguage(); // Apply saved language
            },

            // ============ LANGUAGE SWITCHING ============
            toggleLanguage() {
                const currentLang = this.data.settings.language || 'en';
                const newLang = currentLang === 'en' ? 'gu' : 'en';
                this.data.settings.language = newLang;
                this.saveToStorage();
                this.applyLanguage();
                this.showToast(newLang === 'en' ? 'Language switched to English' : '‡™≠‡™æ‡™∑‡™æ ‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡™æ‡™à ‡™ó‡™à', 'success');
            },

            applyLanguage() {
                const lang = this.data.settings.language || 'en';
                const t = translations[lang];

                // Update language toggle button
                const toggleBtn = document.getElementById('languageToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = lang === 'en' ? 'üåê EN' : 'üåê ‡™ó‡´Å';
                    toggleBtn.title = lang === 'en' ? 'Switch to Gujarati' : '‡™Ö‡™Ç‡™ó‡´ç‡™∞‡´á‡™ú‡´Ä‡™Æ‡™æ‡™Ç ‡™¨‡™¶‡™≤‡´ã';
                }

                // Update header
                const companyName = document.querySelector('.company-name');
                if (companyName) companyName.textContent = t.companyName;

                const searchInput = document.getElementById('globalSearch');
                if (searchInput) searchInput.placeholder = t.searchPlaceholder;

                // Update tabs
                const tabs = document.querySelectorAll('.nav-tab');
                const tabKeys = ['dashboard', 'orders', 'inventory', 'preparation', 'customers', 'team', 'calendar', 'history', 'analytics', 'settings'];
                tabs.forEach((tab, index) => {
                    if (tabKeys[index] && t[tabKeys[index]]) {
                        tab.textContent = t[tabKeys[index]];
                    }
                });

                // Update Orders tab static labels using data-translate attributes
                this.updateOrdersTabLabels();

                // Update action buttons
                this.updateActionButtons();

                // Re-render current tab to apply translations
                if (this.currentTab) {
                    this.switchTab(this.currentTab);
                }
            },

            updateOrdersTabLabels() {
                // Helper function to update label text
                const updateLabel = (selector, translationKey) => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.textContent = this.t(translationKey);
                    });
                };

                // Update form labels by finding them with specific text patterns
                // This will update all label elements in the orders tab
                const labels = {
                    'Client Name': 'clientName',
                    'Contact': 'contact',
                    'Venue': 'venue',
                    'Ready Time': 'readyTime',
                    'Order Status': 'orderStatus',
                    'Notes': 'notes',
                    'Driver Name': 'driverName',
                    'Operator': 'operator',
                    'Helper(s)': 'helpers',
                    'Transport': 'transport'
                };

                document.querySelectorAll('.form-label').forEach(label => {
                    const text = label.textContent.trim();
                    Object.keys(labels).forEach(key => {
                        if (text.includes(key)) {
                            const translatedText = this.t(labels[key]);
                            label.textContent = label.textContent.replace(key, translatedText);
                        }
                    });
                });

                // Update helper placeholder
                const helperInput = document.getElementById('helper');
                if (helperInput) {
                    helperInput.placeholder = this.t('helperPlaceholder');
                }

                // Update client name placeholder
                const clientInput = document.getElementById('clientName');
                if (clientInput) {
                    clientInput.placeholder = this.t('enterClientName');
                }
            },

            updateActionButtons() {
                // Update button texts by finding buttons with specific onclick handlers
                const updateButton = (selector, translationKey) => {
                    const btn = document.querySelector(selector);
                    if (btn) btn.textContent = this.t(translationKey);
                };

                // Update form action buttons
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    const text = btn.textContent.trim();
                    if (text.includes('Save Order')) btn.textContent = this.t('saveOrderShortcut');
                    else if (text.includes('Duplicate Last')) btn.textContent = this.t('duplicateLast');
                    else if (text.includes('Same Day')) btn.textContent = this.t('sameDay');
                    else if (text.includes('Clear') && text.includes('Ctrl')) btn.textContent = this.t('clearFormShortcut');
                    else if (text.includes('Preview')) btn.textContent = `üëÅÔ∏è ${this.t('preview')}`;
                    else if (text.includes('Notify')) btn.textContent = this.t('notifyTeam');
                    else if (text.includes('Send Manager')) btn.textContent = this.t('sendReport');
                });
            },

            // Helper function to get translations
            t(key) {
                const lang = this.data.settings.language || 'en';
                return translations[lang][key] || translations.en[key] || key;
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    // FIXED: Get all data attributes from the same element to avoid mismatched selections
                    const actionElement = e.target.closest('[data-action]');
                    if (!actionElement) return;

                    const action = actionElement.dataset.action;
                    const id = actionElement.dataset.id;
                    const type = actionElement.dataset.type;

                    console.log('üñ±Ô∏è Button clicked - Action:', action, 'ID:', id, 'Type:', type);

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;

        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;

        if (!startDate || !endDate) {
            container.innerHTML = '';
            return;
        }

        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">${this.t('dayNumber')} ${i + 1} - ${dateStr}</h4>

                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>

                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ${this.t('addFunctionToThisDay')}
                    </button>
                </div>
            `;
        }

        container.innerHTML = html;

        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;

        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }

        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;

        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });

        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">${this.t('functionNumber')} ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">${this.t('removeFunction')}</button>` : ''}
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('functionType')}</label>
                        <input type="text" id="${functionId}Type" class="form-input"
                               placeholder="${this.t('enterFunctionType')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('timeSlot')}</label>
                        <input type="text" id="${functionId}Time" class="form-input highlight-datetime"
                               placeholder="${this.t('enterTimeSlot')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">${this.t('driver')}</label>
                        <select id="${functionId}Driver" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', this.value)">
                            <option value="">${this.t('selectDriver')}</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('operator')}</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">${this.t('selectOperator')}</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">${this.t('helpers')}</label>
                        <input type="text" id="${functionId}Helper" class="form-input"
                               placeholder="${this.t('helperPlaceholder')}"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value)">
                        <small style="color: var(--text-gray);">${this.t('multipleHelpersSeparated')}</small>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('notes')}</label>
                    <textarea id="${functionId}Notes" class="form-textarea"
                              placeholder="${this.t('functionNotes')}"
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">${this.t('items')}</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input"
                               placeholder="${this.t('searchItems')}" autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>

                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">${this.t('noItemsAdded')}</div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); this.saveOrder(); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); this.clearForm(); },
                            'd': () => { e.preventDefault(); this.clearForm(); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                document.getElementById('shortcutsPanel').classList.add('show');
            },

            hideShortcuts() {
                document.getElementById('shortcutsPanel').classList.remove('show');
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    const form = document.getElementById('orderForm');
                    if (form && this.hasUnsavedChanges()) {
                        localStorage.setItem('oms_draft', JSON.stringify(this.collectFormData()));
                    }
                }, 30000); // Auto-save every 30 seconds
            },

            hasUnsavedChanges() {
                return Utils.get('clientName') || this.currentOrderItems.length > 0;
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('‚úÖ Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('‚úÖ Auto-backup created successfully');
                    this.showToast('üì¶ Auto-backup created', 'success');
                } catch (error) {
                    console.error('‚ùå Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('üì• Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            initGlobalSearch() {
                const input = document.getElementById('globalSearch');
                const results = document.getElementById('globalSearchResults');

                input.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    if (query.length < 2) {
                        results.classList.remove('show');
                        return;
                    }

                    const searchResults = this.performGlobalSearch(query);
                    this.displayGlobalSearchResults(searchResults);
                }, 300));

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        results.classList.remove('show');
                        input.value = '';
                    }
                });
            },

            performGlobalSearch(query) {
                const results = [];

                // Search orders
                this.data.orders.forEach(order => {
                    if (order.orderId.toLowerCase().includes(query) ||
                        order.clientName.toLowerCase().includes(query) ||
                        order.venue.toLowerCase().includes(query)) {
                        results.push({ type: 'order', data: order });
                    }
                });

                // Search customers
                this.data.customers.forEach(customer => {
                    if (customer.name.toLowerCase().includes(query) ||
                        customer.contact.includes(query)) {
                        results.push({ type: 'customer', data: customer });
                    }
                });

                // Search inventory
                this.data.inventory.items.forEach(item => {
                    if (item.name.toLowerCase().includes(query)) {
                        results.push({ type: 'item', data: item });
                    }
                });

                return results.slice(0, 10);
            },

            displayGlobalSearchResults(results) {
                const container = document.getElementById('globalSearchResults');
                if (results.length === 0) {
                    container.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    container.innerHTML = results.map(r => `
                        <div class="search-result-item" onclick="OMS.navigateToResult('${r.type}', '${r.data.id || r.data.orderId}')">
                            <div>
                                <div class="search-result-type">${r.type}</div>
                                <div>${r.type === 'order' ? r.data.orderId + ' - ' + r.data.clientName : 
                                       r.type === 'customer' ? r.data.name : r.data.name}</div>
                            </div>
                        </div>
                    `).join('');
                }
                container.classList.add('show');
            },

            navigateToResult(type, id) {
                const tabMap = { order: 'history', customer: 'customers', item: 'inventory' };
                this.switchTab(tabMap[type]);
                document.getElementById('globalSearchResults').classList.remove('show');
                document.getElementById('globalSearch').value = '';
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('üî• Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`üî• Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('üß© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    // FIXED: Search by docId first (always unique), then orderId as fallback
    const index = this.data.orders.findIndex(o => o.docId === id || o.orderId === id);
    if (index === -1) {
        console.warn('‚ö†Ô∏è Order not found in local array:', id);
        return false;
    }

    try {
        console.log('üîÑ Attempting to delete orderId:', id);

        // Use the actual docId from the found order
        const orderToDelete = this.data.orders[index];
        const docRef = db.collection('orders').doc(orderToDelete.docId || id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('‚úÖ Deleted Firestore doc with ID:', id);
        } else {
            console.warn('‚ö†Ô∏è No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`üìù Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('‚ùå Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();
        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        console.log('üîç EditItem called with ID:', id);
                        console.log('üìã All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                        // FIXED: Search by docId first (always unique), then orderId as fallback
                        const order = this.data.orders.find(o => o.docId === id || o.orderId === id);
                        console.log('‚úÖ Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                        if (!order) return;
                        this.switchTab('orders');
                        this.loadOrderToForm(order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
    document.getElementById('currentOrderId').textContent = `${this.t('next')}: ${nextId}`;
},

            getNextOrderId() {
                const prefix = this.data.settings.invoicePrefix || 'FP';
                const counter = this.data.settings.orderIdCounter || 1;
                return `${prefix}${String(counter).padStart(3, '0')}`;
            },

            incrementOrderCounter() {
                this.data.settings.orderIdCounter = (this.data.settings.orderIdCounter || 1) + 1;
                this.refreshOrderId();
            },

   collectFormData() {

        const transport = Utils.get('transport');
        const eventType = Utils.get('eventTypeSelect');
        const isMultiDay = eventType === 'multi';

        // Get multiple selected helpers from multi-select dropdown
        const helperSelect = document.getElementById('helper');
        const selectedHelpers = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v).join(', ') : '';

        // Collect day-wise data for multi-day events
        let dayWiseData = [];
        if (isMultiDay) {
            const startDate = Utils.get('startDate');
            const endDate = Utils.get('endDate');
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;

            for (let i = 0; i < diffDays; i++) {
                const currentDate = new Date(start);
                currentDate.setDate(start.getDate() + i);

                // Get functions for this day
                const dayFunctions = window.dayFunctionsData?.[i] || [];

                dayWiseData.push({
                    dayNumber: i + 1,
                    date: Utils.toDateString(currentDate),
                    functions: dayFunctions.map(func => ({
                        functionType: func.functionType || '',
                        timeSlot: func.timeSlot || '',
                        driver: func.driver || '',
                        operator: func.operator || '',
                        helper: func.helper || '',
                        notes: func.notes || '',
                        items: func.items || []
                    }))
                });
            }
        }

        return {
            orderId: Utils.get('orderId'),
            isMultiDay: isMultiDay,
            date: isMultiDay ? null : Utils.get('orderDate'),
            startDate: isMultiDay ? Utils.get('startDate') : null,
            endDate: isMultiDay ? Utils.get('endDate') : null,
            dayWiseData: dayWiseData,
            lastEventDate: isMultiDay ? Utils.get('endDate') : Utils.get('orderDate'),
            readyTime: Utils.get('readyTime'),
            clientName: Utils.get('clientName'),
            contact: Utils.get('contact'),
            venue: Utils.get('venue'),
            eventType: Utils.get('eventType'),
            transport: transport === 'Other' ? Utils.get('customTransport') : transport,
            driverName: Utils.get('driverName'),
            operator: Utils.get('operator'),
            helper: selectedHelpers,
            status: Utils.get('orderStatus'),
            notes: Utils.get('orderNotes'),
            items: isMultiDay ? [] : [...this.currentOrderItems],
            createdAt: new Date().toISOString()
        };
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'contact', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate', 'readyTime');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('‚úÖ Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('‚ö†Ô∏è Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('‚è≥ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('üíæ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('‚úèÔ∏è Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('‚úèÔ∏è Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Calculate total amount from items
        const totalAmount = orderData.isMultiDay
            ? (orderData.dayWiseData || []).reduce((sum, day) => {
                const dayTotal = (day.functions || []).reduce((daySum, func) => {
                    const funcTotal = (func.items || []).reduce((itemSum, item) => {
                        return itemSum + ((item.price || 0) * (item.quantity || 0));
                    }, 0);
                    return daySum + funcTotal;
                }, 0);
                return sum + dayTotal;
            }, 0)
            : (orderData.items || []).reduce((sum, item) => {
                return sum + ((item.price || 0) * (item.quantity || 0));
            }, 0);

        console.log('üí∞ Calculated total amount:', totalAmount);

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    totalAmount: totalAmount,  // CRITICAL: Add totalAmount field
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('‚úèÔ∏è Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('üîÑ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('üóëÔ∏è Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('‚úÖ Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} ‚Üí ${finalOrderId} ‚úÖ`);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('‚úÖ Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            totalAmount: totalAmount  // Include totalAmount in local data
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        this.showToast('Order updated! ‚úèÔ∏è');
    }

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;
    
} else {
            // CREATE new order
            console.log('üÜï Creating new order');

            // Save to Firestore
            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('üìù Auto-generated docId:', docRef.id);
            }

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || [],
        totalAmount: totalAmount  // Include totalAmount in local data
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
    console.log('‚úÖ Order added to local array with totalAmount:', totalAmount);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION (if order is completed)
                if (status === 'completed' && orderData.items) {
                    this.deductInventory(orderData.items, orderData.orderId);
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! üÜï`);
                this.refreshOrderId();
                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('‚ùå Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`üì¶ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} ‚Üí ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`‚ö†Ô∏è LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`üö® CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`üìù Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
getCurrentUser() {
    if (!this.data.currentUser) {
        this.data.currentUser = {
            id: 'admin',
            name: this.data.settings.businessOwner || 'Admin',
            role: 'admin',
            permissions: ['all']
        };
    }
    return this.data.currentUser;
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('üîç Loading order to form:', order);
        console.log('üîç Order status:', order.status);
        console.log('üîç Is Multi-Day:', order.isMultiDay);

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('üìÖ Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (driverSelect) driverSelect.value = func.driver || '';
                                        if (operatorSelect) operatorSelect.value = func.operator || '';
                                        if (helperSelect) helperSelect.value = func.helper || '';
                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            window.dayFunctionsData[dayIndex][funcIndex].items = [...func.items];
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('‚úÖ Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order (original code)
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                operator: order.operator,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Handle multi-select helper field separately
            if (order.helper) {
                const helperSelect = document.getElementById('helper');
                if (helperSelect) {
                    // Split comma-separated helpers and select them
                    const helperNames = order.helper.split(',').map(h => h.trim()).filter(h => h);
                    Array.from(helperSelect.options).forEach(option => {
                        option.selected = helperNames.includes(option.value);
                    });
                }
            }

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            this.currentOrderItems = order.items ? [...order.items] : [];
            this.updateOrderItemsTable();
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            clearForm() {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'block';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`‚úÖ Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                this.loadOrderToForm(lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                const errors = Utils.validateRequired(['clientName', 'contact']);
                if (errors.length > 0) {
                this.showToast('Fill required fields first', 'error');
                return;
                }
                
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }
                
                const orders = this.data.orders.filter(o => o.date === date);
                if (orders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    return;
                }
                
                this.generateMultiOrderImage(orders, date);
            },

            downloadOrderImage(orderId) {
                console.log('üñ®Ô∏è DownloadOrderImage called with ID:', orderId);
                console.log('üìã All order IDs in data.orders:', this.data.orders.map(o => o.orderId));
                // FIXED: Search by docId first (always unique), then orderId as fallback
                const order = this.data.orders.find(o => o.docId === orderId || o.orderId === orderId);
                console.log('‚úÖ Found order:', order ? order.orderId + ' - ' + order.clientName : 'NOT FOUND');
                if (!order) return;
                this.generateSingleOrderImage(order);
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const loading = this.showLoading('Generating image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 32;

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    template.innerHTML = this.buildOrderHTML(order, fontSize, colors);
                    template.style.display = 'block';

                    await new Promise(r => setTimeout(r, 1000));

                    const canvas = await html2canvas(template, {
                        scale: this.data.settings.imageQuality || 2,
                        backgroundColor: '#ffffff',
                        width: paperDimensions.width,
                        logging: false,
                        useCORS: true
                    });

                    template.style.display = 'none';

                    // Add error handling for blob creation
                    canvas.toBlob(blob => {
                        if (!blob) {
                            this.hideLoading(loading);
                            this.showToast('Error: Image too large. Try reducing quality or paper size.', 'error');
                            return;
                        }

                        try {
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = `Order_${order.orderId}.png`;
                            link.click();
                            URL.revokeObjectURL(url);

                            this.hideLoading(loading);
                            this.showToast('Image downloaded!');
                        } catch (e) {
                            this.hideLoading(loading);
                            this.showToast('Error creating download: ' + e.message, 'error');
                        }
                    }, 'image/png', 0.95);
                } catch (error) {
                    this.hideLoading(loading);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async generateMultiOrderImage(orders, date) {
                const loading = this.showLoading('Generating multi-order image...');

                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 32;

                    // Get paper dimensions based on settings
                    const paperDimensions = this.getPaperDimensions();

                    // Apply left margin from settings (convert mm to pixels: 1mm = 11.811px at 300 DPI)
                    const leftMarginMm = this.data.settings.tableSettings?.leftMargin || 50;
                    const leftMarginPx = Math.round(leftMarginMm * 11.811);
                    template.style.paddingLeft = leftMarginPx + 'px';

                    // Set template width to match paper dimensions
                    template.style.width = paperDimensions.width + 'px';
                    template.style.paddingRight = '80px';

                    // Smart quality adjustment for multi-order images to prevent memory issues
                    let qualityScale = this.data.settings.imageQuality || 2;
                    if (orders.length > 5 && qualityScale > 3) {
                        qualityScale = 3; // Limit to High quality for more than 5 orders
                        console.log('‚ö†Ô∏è Quality reduced to High due to multiple orders to prevent memory issues');
                    }

                    let html = `
                        <div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Orders for ${Utils.formatDate(date)}
                            </h1>
                        </div>
                    `;

                    // Use fontSize from settings, but slightly smaller for compact multi-order view
                    const compactFontSize = Math.max(16, fontSize - 6);

                    orders.forEach((order, i) => {
                        html += this.buildOrderHTML(order, compactFontSize, colors, true);
                        if (i < orders.length - 1) {
                            html += '<div style="page-break-before: always;"></div>';
                        }
                    });

                    template.innerHTML = html;
                    template.style.display = 'block';

                    await new Promise(r => setTimeout(r, 2000));

                    const canvas = await html2canvas(template, {
                        scale: qualityScale,
                        backgroundColor: '#ffffff',
                        width: paperDimensions.width,
                        logging: false,
                        useCORS: true
                    });

                    template.style.display = 'none';

                    // Add error handling for blob creation
                    canvas.toBlob(blob => {
                        if (!blob) {
                            this.hideLoading(loading);
                            this.showToast('Error: Image too large. Try reducing quality or paper size.', 'error');
                            return;
                        }

                        try {
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = `Orders_${date}.png`;
                            link.click();
                            URL.revokeObjectURL(url);

                            this.hideLoading(loading);
                            this.showToast(`${orders.length} orders downloaded!`);
                        } catch (e) {
                            this.hideLoading(loading);
                            this.showToast('Error creating download: ' + e.message, 'error');
                        }
                    }, 'image/png', 0.95);
                } catch (error) {
                    this.hideLoading(loading);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            // Get paper dimensions based on format and orientation
            getPaperDimensions() {
                const format = this.data.settings.paperFormat || 'A4';
                const orientation = this.data.settings.paperOrientation || 'portrait';

                // Paper dimensions in pixels (at 300 DPI)
                const formats = {
                    'A4': { width: 2480, height: 3508 },
                    'Legal': { width: 2550, height: 4200 },
                    'Letter': { width: 2550, height: 3300 },
                    'A3': { width: 3508, height: 4960 },
                    'A5': { width: 1748, height: 2480 },
                    'Tabloid': { width: 3300, height: 5100 }
                };

                let dimensions = formats[format] || formats['A4'];

                // Swap dimensions for landscape
                if (orientation === 'landscape') {
                    return {
                        width: dimensions.height,
                        height: dimensions.width
                    };
                }

                return dimensions;
            },

            buildOrderHTML(order, fontSize, colors, compact = false) {
                console.log('üñºÔ∏è Building image for order:', order.orderId);
                console.log('üñºÔ∏è isMultiDay:', order.isMultiDay);
                console.log('üñºÔ∏è dayWiseData:', order.dayWiseData);
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                const functionColor = this.data.settings.functionColor || '#667eea';

                return `
                    <div style="margin-bottom: ${compact ? '40px' : '60px'}; ${compact ? 'border: 2px solid ' + colors.tableBorder + '; padding: 20px;' : ''}; color: #000000;">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px; color: #000000;">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : `<h3 style="text-align: center; color: #000000;">
                            <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 8px 15px; border-radius: 6px;">
                                ${order.orderId}
                            </span>
                        </h3>`}

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; font-size: ${fontSize}px; margin-bottom: 20px; color: #000000;">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong style="color: #000000;">Start Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.startDate) || 'N/A'}</span><br>
                                    <strong style="color: #000000;">End Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.endDate) || 'N/A'}</span><br>
                                ` : `
                                    <strong style="color: #000000;">Date:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${Utils.formatDate(order.date) || 'N/A'}</span><br>
                                    <strong style="color: #000000;">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">${order.readyTime || '-'}</span><br>
                                `}
                                <strong style="color: #000000;">Client:</strong> ${order.clientName || '-'}<br>
                                <strong style="color: #000000;">Contact:</strong> ${order.contact || '-'}<br>
                                <strong style="color: #000000;">Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <strong style="color: #000000;">Transport:</strong> ${order.transport || '-'}<br>
                                <strong style="color: #000000;">Driver:</strong> ${order.driverName || '-'}<br>
                                <strong style="color: #000000;">Event:</strong> ${order.eventType || '-'}<br>
                                <strong style="color: #000000;">Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong style="color: #000000;">Helper:</strong> ${order.helper || '-'}<br>
                                <strong style="color: #000000;">Status:</strong> ${order.status || '-'}<br>
                                <strong style="color: #000000;">Dry Ice:</strong> <br>
                                <strong style="color: #000000;">Flowers:</strong>
                            </div>
                        </div>

                            ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ?
                            '<div style="margin-top: 30px;">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: 15px; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) =>
                                    '<div style="margin-top: 25px; border: 2px solid ' + colors.tableBorder + '; padding: 15px; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: 15px;">Day ' + day.dayNumber + ' - <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + Utils.formatDate(day.date) + '</span></h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: white; padding: 15px; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '0') + '; color: #000000;">' +
                                                    '<h5 style="color: ' + functionColor + '; margin-bottom: 10px; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="font-size: ' + fontSize + 'px; margin-bottom: 10px; color: #000000;">' +
                                                        '<strong style="color: #000000;">Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                        '<strong style="color: #000000;">Time:</strong> <span style="background: #ffeb3b; color: #000000; padding: 2px 4px;">' + (func.timeSlot || '-') + '</span><br>' +
                                                        '<strong style="color: #000000;">Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                        '<strong style="color: #000000;">Operator:</strong> ' + (func.operator || '-') + '<br>' +
                                                        '<strong style="color: #000000;">Helper:</strong> ' + (func.helper || '-') + '<br>' +
                                                        (func.notes ? '<strong style="color: #000000;">Notes:</strong> ' + func.notes + '<br>' : '') +
                                                    '</div>' +
                                                    (func.items && func.items.length > 0 ?
                                                        '<table style="width: 100%; border-collapse: collapse; font-size: ' + (fontSize - 4) + 'px; color: #000000;">' +
                                                            '<thead>' +
                                                                '<tr style="background: ' + colors.tableHeaderBg + '; color: ' + colors.tableHeaderText + ';">' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthSr + '%;">Sr</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthItem + '%;">Item</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthQty + '%;">Qty</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthRemarks + '%;">Remarks</th>' +
                                                                '</tr>' +
                                                            '</thead>' +
                                                            '<tbody>' +
                                                                func.items.map((item, i) =>
                                                                    '<tr style="color: #000000;">' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; text-align: center; color: #000000;">' + (i + 1) + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; color: #000000;">' + item.name + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; text-align: center; color: #000000;">' + item.quantity + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; color: #000000;">' + (item.remarks || '-') + '</td>' +
                                                                    '</tr>'
                                                                ).join('') +
                                                            '</tbody>' +
                                                        '</table>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <table style="width: 100%; border-collapse: collapse; font-size: ${fontSize - 4}px; margin-top: 20px; color: #000000;">
                                <thead>
                                    <tr style="background: ${colors.tableHeaderBg}; color: ${colors.tableHeaderText};">
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthSr}%;">Sr</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthItem}%;">Item</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthQty}%;">Qty</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthRemarks}%;">Remarks</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${order.items.map((item, i) => `
                                        <tr style="color: #000000;">
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; text-align: center; color: #000000;">${i + 1}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; color: #000000;">${item.name}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; text-align: center; color: #000000;">${item.quantity}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; color: #000000;">${item.remarks || ''}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: 20px;">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: 20px; font-size: ${fontSize}px; color: #000000;">
                                <strong style="color: #000000;">Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: 15px; border: 1px solid ${colors.tableBorder}; color: #000000;">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            renderCalendar(date = new Date()) {
                const year = date.getFullYear();
                const month = date.getMonth();

                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];

                let html = `
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(-1)">${this.t('previousMonth')}</button>
                                <h3>${monthNames[month]} ${year}</h3>
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(1)">${this.t('nextMonth')}</button>
                            </div>
                            <button class="btn btn-secondary btn-small" onclick="OMS.showToday()">${this.t('today')}</button>
                        </div>
                        <div class="calendar-grid">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day =>
                                `<div class="calendar-day-header">${day}</div>`
                            ).join('')}
                            ${Array(firstDay).fill('').map(() => '<div class="calendar-day"></div>').join('')}
                            ${Array.from({length: daysInMonth}, (_, i) => {
                                const day = i + 1;
                                const dateStr = Utils.toDateString(new Date(year, month, day));
                                const today = Utils.toDateString(new Date());
                                const orders = this.data.orders.filter(o => {
                                    if (o.isMultiDay) {
                                        // Check if dateStr falls within the multi-day range
                                        const checkDate = new Date(dateStr);
                                        const start = new Date(o.startDate);
                                        const end = new Date(o.endDate);
                                        return checkDate >= start && checkDate <= end;
                                    }
                                    return o.date === dateStr;
                                });
                                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                                const festival = this.festivals[dateStr];

                                let classes = 'calendar-day';
                                if (dateStr === today) classes += ' today';
                                if (orders.length) classes += ' has-orders';
                                if (tasks.length) classes += ' has-tasks';
                                if (festival) classes += ' has-festival';

                                // Get color indicators for this day's orders
                                const orderColorDots = orders.slice(0, 3).map(o => {
                                    const color = this.getOrderColor(o);
                                    return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin:0 2px;"></span>`;
                                }).join('');

                                return `
                                    <div class="${classes}" onclick="OMS.showDayDetails('${dateStr}')">
                                        <div class="calendar-day-number">${day}</div>
                                        ${festival ? `<div class="festival-text">${festival[1]}</div>` : ''}
                                        ${orders.length ? `<div class="order-count" title="${orders.length} ${this.t('ordersText')}">${orderColorDots}${orders.length > 3 ? '+' : ''}</div>` : ''}
                                        ${tasks.length ? `<div class="calendar-day-content">${tasks.length} ${tasks.length > 1 ? this.t('ordersText') : this.t('order')}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="card">
                        <h3 class="card-title">${this.t('calendar')}</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <input type="date" id="taskDate" class="form-input" value="${Utils.toDateString(new Date())}">
                            </div>
                            <div class="form-group">
                                <input type="text" id="taskDescription" class="form-input" placeholder="${this.t('enterNotes')}">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-primary" onclick="OMS.addTask()">${this.t('add')}</button>
                            </div>
                        </div>
                    </div>
                `;

                return html;
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const date = Utils.getLocalDate(dateStr);
                const orders = this.data.orders.filter(o => {
                    if (o.isMultiDay) {
                        // Check if dateStr falls within the multi-day range
                        const checkDate = new Date(dateStr);
                        const start = new Date(o.startDate);
                        const end = new Date(o.endDate);
                        return checkDate >= start && checkDate <= end;
                    }
                    return o.date === dateStr;
                });
                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                const festival = this.festivals[dateStr];

                let content = `<h3>${this.t('details')} ${this.t('for')} ${Utils.formatDate(dateStr)}</h3>`;

                if (festival) {
                    content += `<div class="festival-text" style="font-size: 1.2rem; margin: 1rem 0;">üéâ ${festival[1]} (${festival[0]})</div>`;
                }

                if (orders.length > 0) {
                    content += `<h4>${this.t('orders')} (${orders.length})</h4>`;
                    orders.forEach(o => {
                        const color = this.getOrderColor(o);
                        let dateInfo = '';
                        if (o.isMultiDay) {
                            dateInfo = `<br><small style="color:#666;">${this.t('multiDayOrder')}: ${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}</small>`;
                        }
                        content += `
                            <div style="padding:10px;margin:8px 0;border-left:4px solid ${color};background:#f9f9f9;border-radius:4px;">
                                <strong>${o.orderId || '[No ID]'}</strong> - ${o.clientName}
                                <br>
                                <span style="color:${color};font-weight:bold;">${o.eventType || this.t('event')}</span> |
                                <span style="background:${color};color:white;padding:2px 6px;border-radius:3px;font-size:12px;">${this.t(o.status.toLowerCase())}</span>
                                ${dateInfo}
                            </div>
                        `;
                    });
                }

                if (tasks.length > 0) {
                    content += `<h4>${this.t('calendar')} (${tasks.length})</h4><ul>`;
                    tasks.forEach(t => {
                        content += `<li>
                            ${t.description}
                            <button class="btn btn-secondary btn-small" data-action="edit" data-type="task" data-id="${t.id}">${this.t('edit')}</button>
                            <button class="btn btn-danger btn-small" data-action="delete" data-type="task" data-id="${t.id}">${this.t('delete')}</button>
                        </li>`;
                    });
                    content += '</ul>';
                }

                content += `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.addTaskForDate('${dateStr}')">${this.t('add')}</button>
                        <button class="btn btn-secondary" onclick="OMS.createOrderForDate('${dateStr}')">${this.t('orders')}</button>
                    </div>
                `;

                this.showModal(this.t('details'), content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders as CSV
                        const headers = ['Order ID', 'Date', 'Client', 'Contact', 'Venue', 'Status', 'Total Items'];
                        const rows = this.data.orders.map(o => [
                            o.orderId, o.date, o.clientName, o.contact, o.venue, o.status, o.items.length
                        ]);
                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();
                
                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        Utils.elem('button', { 
                            class: 'modal-close', 
                            onclick: () => this.closeModal() 
                        }, ['√ó']),
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);
                
                document.getElementById('modalsContainer').appendChild(modal);
            },

            closeModal() {
                const modal = document.getElementById('dynamicModal');
                if (modal) modal.remove();
            },

            showToast(message, type = 'success', actions = []) {
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let topOffset = 20; // Initial top position

                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    topOffset = Math.max(topOffset, rect.bottom - document.documentElement.scrollTop + 10);
                });

                const toast = Utils.elem('div', {
                    class: `toast show ${type === 'error' ? 'error' : ''} ${type === 'warning' ? 'warning' : ''}`,
                    style: { top: `${topOffset}px` }
                }, [
                    Utils.elem('div', {}, [message]),
                    actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' },
                        actions.map(a => Utils.elem('button', { class: 'toast-btn', onclick: a.handler }, [a.label]))
                    ) : null
                ].filter(Boolean));

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },

            repositionToasts() {
                const toasts = document.querySelectorAll('.toast');
                let topOffset = 20;

                toasts.forEach(toast => {
                    toast.style.top = `${topOffset}px`;
                    const rect = toast.getBoundingClientRect();
                    topOffset = rect.bottom - document.documentElement.scrollTop + 10;
                });
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', {}, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ NAVIGATION ============
            switchTab(tabName) {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(tabName).classList.add('active');
                
                this.currentTab = tabName;
                
                // Render tab content
                setTimeout(() => {
                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') this.renderInventory();
                    else if (tabName === 'preparation') this.renderPreparation();
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'team') this.renderTeam();
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') this.initItemSearch();
                }, 50);
            },

            // ============ TAB RENDERERS ============
            renderDashboard() {
                const stats = [
                    { label: this.t('totalOrders'), value: this.data.orders.length, class: '' },
                    { label: this.t('confirmedOrders'), value: this.data.orders.filter(o => o.status === 'Confirmed').length, class: 'success' },
                    { label: this.t('completedOrders'), value: this.data.orders.filter(o => o.status === 'Completed').length, class: 'info' },
                    { label: this.t('customers'), value: this.data.customers.length, class: '' },
                    { label: this.t('lowStock'), value: this.data.inventory.items.filter(i => i.quantity <= this.data.settings.lowStockThreshold).length, class: 'warning' },
                    { label: this.t('today'), value: this.data.orders.filter(o => o.date === Utils.toDateString(new Date())).length, class: 'danger' }
                ];

                document.getElementById('dashboardStats').innerHTML = stats.map(s => `
                    <div class="stat-card ${s.class}">
                        <div class="stat-value">${s.value}</div>
                        <div class="stat-label">${s.label}</div>
                    </div>
                `).join('');

                const recentOrders = this.data.orders.slice(-5).reverse();
                this.renderTable('recentOrdersContainer', [
                    { key: 'orderId', label: this.t('orderId'), render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: this.t('client') },
                    { key: 'eventType', label: this.t('event'), render: o => o.eventType || this.t('na') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${o.status}</span>` }
                ], recentOrders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('view')}</button>
                    <button class="btn btn-info btn-small" onclick="OMS.duplicateOrder('${row.docId || row.orderId}')">üìã ${this.t('duplicate')}</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                `);

                // Top customer
                if (this.data.customers.length > 0) {
                    const top = this.data.customers.reduce((prev, curr) =>
                        (prev.totalOrders > curr.totalOrders) ? prev : curr
                    );
                    document.getElementById('topCustomerInfo').innerHTML = `
                        <div style="background: var(--light); padding: 1rem; border-radius: var(--radius);">
                            <strong>${top.name}</strong><br>
                            ${top.contact}<br>
                            <strong>${top.totalOrders} ${this.t('ordersText')}</strong>
                        </div>
                    `;
                }
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('inventoryManagement')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">${this.t('batchUpdate')}</button>
                        </div>
                        <div class="card">
                            <h3>${this.t('categories')}</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="${this.t('enterCategoryName')}">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">${this.t('add')}</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>${this.t('items')}</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="${this.t('enterItemName')}">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="${this.t('quantity')}" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">${this.t('add')}</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;

                this.updateInventoryDisplay();
            },

            updateInventoryDisplay() {
                // Populate category dropdown
                const select = document.getElementById('itemCategory');
                if (select) {
                    select.innerHTML = `<option value="">${this.t('selectCategory')}</option>` +
                        this.data.inventory.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
                }

                // Render categories table
                this.renderTable('categoriesContainer', [
                    { key: 'name', label: this.t('category') },
                    { key: 'id', label: this.t('items'), render: c => this.data.inventory.items.filter(i => i.categoryId === c.id).length }
                ], this.data.inventory.categories, (row) => `
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="category" data-id="${row.id}">${this.t('delete')}</button>
                `);

                // Render items table
                this.renderTable('itemsContainer', [
                    { key: 'name', label: this.t('item') },
                    { key: 'categoryId', label: this.t('category'), render: i => this.data.inventory.categories.find(c => c.id === i.categoryId)?.name || this.t('na') },
                    { key: 'quantity', label: this.t('stock') }
                ], this.data.inventory.items, (row) => `
                    <button class="btn btn-success btn-small" onclick="OMS.increaseItemQuantity('${row.id}')">+</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.decreaseItemQuantity('${row.id}')">-</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.editInventoryItem('${row.id}')">‚úèÔ∏è ${this.t('edit')}</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="item" data-id="${row.id}">üóëÔ∏è ${this.t('delete')}</button>
                `);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Quantity</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION / FORECAST FUNCTIONS ============

            renderPreparation() {
                const container = document.getElementById('preparation');
                const today = new Date().toISOString().split('T')[0];
                const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                const nextWeek = new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('preparationForecast')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('itemsToPrep')}</p>
                        </div>

                        <div class="card">
                            <h3>${this.t('selectDateRange')}</h3>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('today')">${this.t('today')}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('tomorrow')">${this.t('tomorrow') || 'Tomorrow'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('week')">${this.t('next7Days') || 'Next 7 Days'}</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('month')">${this.t('next30Days') || 'Next 30 Days'}</button>
                            </div>
                            <div class="form-row">
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('from')}</label>
                                    <input type="date" id="forecastStartDate" class="form-input" value="${today}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">${this.t('to')}</label>
                                    <input type="date" id="forecastEndDate" class="form-input" value="${tomorrow}">
                                </div>
                                <div style="display: flex; align-items: flex-end;">
                                    <button class="btn btn-primary" onclick="OMS.generateForecast()" style="height: fit-content;">
                                        üîç ${this.t('generateReport')}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="forecastResults"></div>
                    </div>
                `;

                // Auto-generate forecast for tomorrow by default
                setTimeout(() => this.generateForecast(), 100);
            },

            quickForecast(period) {
                const today = new Date();
                const startInput = document.getElementById('forecastStartDate');
                const endInput = document.getElementById('forecastEndDate');

                let start = new Date(today);
                let end = new Date(today);

                switch(period) {
                    case 'today':
                        // Start and end are same (today)
                        break;
                    case 'tomorrow':
                        start.setDate(start.getDate() + 1);
                        end.setDate(end.getDate() + 1);
                        break;
                    case 'week':
                        end.setDate(end.getDate() + 7);
                        break;
                    case 'month':
                        end.setDate(end.getDate() + 30);
                        break;
                }

                startInput.value = start.toISOString().split('T')[0];
                endInput.value = end.toISOString().split('T')[0];

                this.generateForecast();
            },

            generateForecast() {
                const startDate = Utils.get('forecastStartDate');
                const endDate = Utils.get('forecastEndDate');

                if (!startDate || !endDate) {
                    this.showToast('Please select both start and end dates', 'error');
                    return;
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (end < start) {
                    this.showToast('End date must be after start date', 'error');
                    return;
                }

                // Get orders in date range
                const ordersInRange = this.getOrdersInDateRange(startDate, endDate);

                // Aggregate items from all orders
                const itemsMap = new Map();
                const orderItemsMap = new Map(); // Track which orders use which items

                ordersInRange.forEach(order => {
                    const items = this.getItemsFromOrder(order, startDate, endDate);

                    items.forEach(item => {
                        // Aggregate quantities
                        const current = itemsMap.get(item.name) || 0;
                        itemsMap.set(item.name, current + item.quantity);

                        // Track order references
                        if (!orderItemsMap.has(item.name)) {
                            orderItemsMap.set(item.name, []);
                        }
                        orderItemsMap.get(item.name).push({
                            orderId: order.orderId,
                            clientName: order.clientName,
                            quantity: item.quantity
                        });
                    });
                });

                // Convert to array and sort by quantity (descending)
                const aggregatedItems = Array.from(itemsMap, ([name, quantity]) => {
                    // Find matching inventory item
                    const inventoryItem = this.data.inventory.items.find(i =>
                        i.name.toLowerCase() === name.toLowerCase()
                    );

                    return {
                        name,
                        required: quantity,
                        inStock: inventoryItem ? inventoryItem.quantity : 0,
                        difference: inventoryItem ? inventoryItem.quantity - quantity : -quantity,
                        orders: orderItemsMap.get(name) || []
                    };
                }).sort((a, b) => b.required - a.required);

                // Render forecast results
                this.renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate);
            },

            getOrdersInDateRange(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);

                return this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day orders, check if any day falls in range
                        const orderStart = new Date(order.startDate);
                        const orderEnd = new Date(order.endDate);

                        // Check for overlap: order overlaps if it starts before range ends AND ends after range starts
                        return orderStart <= end && orderEnd >= start;
                    } else {
                        // For single-day orders
                        const orderDate = new Date(order.date);
                        return orderDate >= start && orderDate <= end;
                    }
                });
            },

            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            renderForecastResults(orders, items, startDate, endDate) {
                const container = document.getElementById('forecastResults');

                if (orders.length === 0) {
                    container.innerHTML = `
                        <div class="card" style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <h3>üì≠ ${this.t('noOrdersFoundShort')}</h3>
                            <p>${this.t('noOrdersScheduledBetween')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate statistics
                const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
                const pendingOrders = orders.filter(o => o.status !== 'Confirmed' && o.status !== 'Completed').length;
                const completedOrders = orders.filter(o => o.status === 'Completed').length;
                const totalItems = items.reduce((sum, item) => sum + item.required, 0);
                const shortageItems = items.filter(i => i.difference < 0);
                const okItems = items.filter(i => i.difference >= 0);

                container.innerHTML = `
                    <!-- Summary Cards -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 1.5rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">üìä ${this.t('summary')} ${Utils.formatDate(startDate)} ${this.t('to')} ${Utils.formatDate(endDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${orders.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalOrders')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${confirmedOrders}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ ${this.t('confirmed')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${items.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('uniqueItems')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${totalItems}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">${this.t('totalQuantity')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: ${shortageItems.length > 0 ? '#fca5a5' : '#86efac'};">${shortageItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚ö†Ô∏è ${this.t('shortages')}</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: #86efac;">${okItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ ${this.t('sufficient')}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Export Buttons -->
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="OMS.printForecast()">üñ®Ô∏è ${this.t('print')}</button>
                        <button class="btn btn-info" onclick="OMS.exportForecastPDF()">${this.t('exportPDF')}</button>
                        <button class="btn btn-warning" onclick="OMS.shareForecastWhatsApp()">${this.t('shareWhatsApp')}</button>
                    </div>

                    <!-- Items Table -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üì¶ ${this.t('itemsPreparationList')}</h3>
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th style="width: 5%;">${this.t('sr')}</th>
                                        <th style="width: 25%;">${this.t('itemName')}</th>
                                        <th style="width: 10%;">${this.t('required')}</th>
                                        <th style="width: 10%;">${this.t('inStock')}</th>
                                        <th style="width: 10%;">${this.t('difference')}</th>
                                        <th style="width: 10%;">${this.t('status')}</th>
                                        <th style="width: 30%;">${this.t('usedInOrders')}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${items.map((item, index) => {
                                        const statusBadge = item.difference >= 0
                                            ? `<span style="background: var(--success); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚úÖ ${this.t('ok')}</span>`
                                            : `<span style="background: var(--danger); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚ö†Ô∏è ${this.t('short')} ${item.difference}</span>`;

                                        const ordersText = item.orders.slice(0, 3).map(o => o.orderId).join(', ') +
                                            (item.orders.length > 3 ? ` +${item.orders.length - 3} ${this.t('more')}` : '');

                                        return `
                                            <tr style="background: ${item.difference < 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'};">
                                                <td>${index + 1}</td>
                                                <td><strong>${item.name}</strong></td>
                                                <td><strong>${item.required}</strong></td>
                                                <td>${item.inStock}</td>
                                                <td style="color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                </td>
                                                <td>${statusBadge}</td>
                                                <td>
                                                    <small style="color: var(--text-gray);">${ordersText}</small>
                                                    <button class="btn btn-secondary btn-small" onclick="OMS.showItemOrderDetails('${item.name.replace(/'/g, "\\'")}')"> ${this.t('details')}</button>
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                                <tfoot>
                                    <tr style="background: var(--light); font-weight: 700;">
                                        <td colspan="2">${this.t('grandTotal')}</td>
                                        <td>${totalItems}</td>
                                        <td>${items.reduce((sum, i) => sum + i.inStock, 0)}</td>
                                        <td style="color: ${items.reduce((sum, i) => sum + i.difference, 0) >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                            ${items.reduce((sum, i) => sum + i.difference, 0)}
                                        </td>
                                        <td colspan="2"></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Orders Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üìã ${this.t('orderDetailsBreakdown')}</h3>
                        </div>
                        <div style="display: grid; gap: 1rem;">
                            ${orders.map(order => {
                                const items = this.getItemsFromOrder(order, startDate, endDate);
                                const statusColor = {
                                    'Confirmed': 'var(--success)',
                                    'Completed': 'var(--info)',
                                    'Cancelled': 'var(--danger)'
                                }[order.status] || 'var(--warning)';

                                return `
                                    <div style="border: 2px solid var(--border); border-radius: var(--radius); padding: 1rem; background: var(--bg-card);">
                                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                                            <div>
                                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--primary);">${order.orderId}</div>
                                                <div style="color: var(--text-dark); font-weight: 500;">${order.clientName}</div>
                                                <div style="font-size: 0.9rem; color: var(--text-gray);">
                                                    üìç ${order.venue} |
                                                    üìÖ ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)} |
                                                    üïê ${order.readyTime || 'N/A'}
                                                </div>
                                            </div>
                                            <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                ${order.status || 'Pending'}
                                            </span>
                                        </div>
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                                            <strong style="font-size: 0.9rem; color: var(--text-gray);">Items Required:</strong>
                                            <div style="margin-top: 0.25rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                ${items.map(item => `
                                                    <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                        ${item.name}: <strong>${item.quantity}</strong>
                                                    </span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                // Store current forecast data for export
                this.currentForecastData = {
                    orders,
                    items,
                    startDate,
                    endDate,
                    stats: {
                        totalOrders: orders.length,
                        confirmed: confirmedOrders,
                        pending: pendingOrders,
                        completed: completedOrders,
                        totalItems: totalItems,
                        shortages: shortageItems.length,
                        sufficient: okItems.length
                    }
                };
            },

            showItemOrderDetails(itemName) {
                if (!this.currentForecastData) return;

                const item = this.currentForecastData.items.find(i => i.name === itemName);
                if (!item) return;

                const ordersHtml = item.orders.map(o => `
                    <div style="padding: 0.75rem; border-bottom: 1px solid var(--border);">
                        <div style="font-weight: 600; color: var(--primary);">${o.orderId}</div>
                        <div style="color: var(--text-gray); font-size: 0.9rem;">${o.clientName}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                Quantity: <strong>${o.quantity}</strong>
                            </span>
                        </div>
                    </div>
                `).join('');

                this.showModal(`
                    <h2 style="margin-bottom: 1rem;">üì¶ ${itemName}</h2>
                    <div style="margin-bottom: 1rem;">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${item.required}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Required</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);">${item.inStock}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">In Stock</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Difference</div>
                            </div>
                        </div>
                    </div>
                    <h3 style="margin-bottom: 0.5rem;">Used in ${item.orders.length} order(s):</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: var(--radius);">
                        ${ordersHtml}
                    </div>
                `);
            },

            printForecast() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to print', 'error');
                    return;
                }

                const { items, orders, startDate, endDate, stats } = this.currentForecastData;

                const printWindow = window.open('', '', 'width=800,height=600');
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Preparation Forecast - ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #667eea; margin-top: 20px; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #667eea; color: white; }
                            .shortage { background: #fee; color: #c00; font-weight: bold; }
                            .ok { background: #efe; color: #060; font-weight: bold; }
                            .summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
                            .summary-card { border: 2px solid #667eea; padding: 15px; border-radius: 8px; text-align: center; }
                            .summary-card .value { font-size: 2rem; font-weight: bold; color: #667eea; }
                            .summary-card .label { color: #666; margin-top: 5px; }
                            @media print {
                                button { display: none; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>üìã Preparation & Forecast Report</h1>
                        <p><strong>Period:</strong> ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</p>
                        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

                        <div class="summary">
                            <div class="summary-card">
                                <div class="value">${stats.totalOrders}</div>
                                <div class="label">Total Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${items.length}</div>
                                <div class="label">Unique Items</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.totalItems}</div>
                                <div class="label">Total Quantity</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.confirmed}</div>
                                <div class="label">Confirmed Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: ${stats.shortages > 0 ? '#c00' : '#060'};">${stats.shortages}</div>
                                <div class="label">Items Short</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: #060;">${stats.sufficient}</div>
                                <div class="label">Items OK</div>
                            </div>
                        </div>

                        <h2>üì¶ Items Preparation List</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Sr</th>
                                    <th>Item Name</th>
                                    <th>Required</th>
                                    <th>In Stock</th>
                                    <th>Difference</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr class="${item.difference < 0 ? 'shortage' : ''}">
                                        <td>${index + 1}</td>
                                        <td><strong>${item.name}</strong></td>
                                        <td>${item.required}</td>
                                        <td>${item.inStock}</td>
                                        <td class="${item.difference >= 0 ? 'ok' : 'shortage'}">
                                            ${item.difference >= 0 ? '+' : ''}${item.difference}
                                        </td>
                                        <td>${item.difference >= 0 ? '‚úÖ OK' : '‚ö†Ô∏è SHORT'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <h2>üìã Orders Summary</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order ID</th>
                                    <th>Client</th>
                                    <th>Venue</th>
                                    <th>Date</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${orders.map(order => `
                                    <tr>
                                        <td>${order.orderId}</td>
                                        <td>${order.clientName}</td>
                                        <td>${order.venue}</td>
                                        <td>${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}</td>
                                        <td>${order.status || 'Pending'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <button onclick="window.print()" style="background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-top: 20px;">
                            üñ®Ô∏è Print This Report
                        </button>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            },

            exportForecastPDF() {
                this.showToast('PDF export coming soon! Use Print for now.', 'info');
                // Future: Implement PDF generation using jsPDF or similar
            },

            shareForecastWhatsApp() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to share', 'error');
                    return;
                }

                const { items, startDate, endDate, stats } = this.currentForecastData;

                // Create WhatsApp message
                let message = `üìã *PREPARATION FORECAST*\n\n`;
                message += `üìÖ *Period:* ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}\n\n`;
                message += `üìä *SUMMARY*\n`;
                message += `‚Ä¢ Total Orders: ${stats.totalOrders}\n`;
                message += `‚Ä¢ Confirmed: ${stats.confirmed}\n`;
                message += `‚Ä¢ Total Items: ${items.length}\n`;
                message += `‚Ä¢ Total Quantity: ${stats.totalItems}\n`;
                message += `‚Ä¢ Shortages: ${stats.shortages}\n\n`;

                message += `üì¶ *ITEMS NEEDED*\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;

                items.forEach((item, index) => {
                    const status = item.difference >= 0 ? '‚úÖ' : '‚ö†Ô∏è';
                    message += `${index + 1}. ${item.name}\n`;
                    message += `   Required: ${item.required} | Stock: ${item.inStock} | ${item.difference >= 0 ? '+' : ''}${item.difference} ${status}\n`;
                });

                message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `Generated: ${new Date().toLocaleString()}\n`;
                message += `\n_Powered by FirepowerSFX Admin_`;

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCustomers() {
                const container = document.getElementById('customers');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('customers')}</h2>
                        </div>
                        <div class="form-row">
                            <input type="text" id="customerSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}">
                            <button class="btn btn-primary" onclick="OMS.refreshCustomerDatabase()">üîÑ ${this.t('reset')}</button>
                        </div>
                        <div id="customersContainer"></div>
                    </div>
                `;

                this.renderTable('customersContainer', [
                    { key: 'name', label: this.t('customerName') },
                    { key: 'contact', label: this.t('contact') },
                    { key: 'totalOrders', label: this.t('totalOrdersCount') },
                    { key: 'lastOrderDate', label: this.t('lastOrder'), render: c => Utils.formatDate(c.lastOrderDate) }
                ], this.data.customers, (row) => `
                    <button class="btn btn-secondary btn-small" onclick="OMS.viewCustomerOrders('${row.id}')">${this.t('viewOrders')}</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.createOrderForCustomer('${row.id}')">${this.t('orders')}</button>
                `);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('history');
                // Filter logic would go here
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ TEAM MANAGEMENT ============

            renderTeam() {
                const container = document.getElementById('team');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('teamManagement')}</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">${this.t('teamManagement')}</p>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('addTeamMember')}</h3>
                            </div>
                            <div class="form-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="form-group">
                                    <label class="form-label required">${this.t('memberName')}</label>
                                    <input type="text" id="teamMemberName" class="form-input" placeholder="e.g., Rajesh Kumar">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('phoneNumber')}</label>
                                    <input type="tel" id="teamMemberWhatsApp" class="form-input" placeholder="e.g., +91 98765 43210">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('email')}</label>
                                    <input type="email" id="teamMemberEmail" class="form-input" placeholder="e.g., rajesh@example.com">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">${this.t('status')}</label>
                                    <select id="teamMemberStatus" class="form-select">
                                        <option value="Active">${this.t('active')}</option>
                                        <option value="Inactive">${this.t('inactive')}</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label required">${this.t('roles')}</label>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleDriver" value="Driver" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üöó ${this.t('driver')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleOperator" value="Operator" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>‚öôÔ∏è ${this.t('operator')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleHelper" value="Helper" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ü§ù ${this.t('helpers')}</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleManager" value="Manager" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üëî Manager</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleSupervisor" value="Supervisor" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üìã Supervisor</span>
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">${this.t('roles')}</label>
                                <input type="text" id="teamMemberSkills" class="form-input" placeholder="e.g., Wedding Expert, Corporate Events, Sound Systems">
                                <small style="color: var(--text-gray);">${this.t('multipleHelpersSeparated')}</small>
                            </div>

                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="OMS.addTeamMember()">${this.t('addTeamMember')}</button>
                                <button class="btn btn-secondary" onclick="OMS.clearTeamForm()">${this.t('clearForm')}</button>
                            </div>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">${this.t('team')}</h3>
                            </div>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <select id="teamRoleFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('roles')}</option>
                                    <option value="Driver">üöó ${this.t('driver')}</option>
                                    <option value="Operator">‚öôÔ∏è ${this.t('operator')}</option>
                                    <option value="Helper">ü§ù ${this.t('helpers')}</option>
                                    <option value="Manager">üëî Manager</option>
                                    <option value="Supervisor">üìã Supervisor</option>
                                </select>
                                <select id="teamStatusFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">${this.t('status')}</option>
                                    <option value="Active">${this.t('active')}</option>
                                    <option value="Inactive">${this.t('inactive')}</option>
                                </select>
                                <input type="text" id="teamSearch" class="form-input" placeholder="${this.t('searchPlaceholder')}" oninput="OMS.renderTeamTable()">
                            </div>
                            <div id="teamMembersContainer"></div>
                        </div>
                    </div>
                `;

                this.renderTeamTable();
            },

            renderTeamTable() {
                const container = document.getElementById('teamMembersContainer');
                if (!container) return;

                // Get filter values
                const roleFilter = document.getElementById('teamRoleFilter')?.value || '';
                const statusFilter = document.getElementById('teamStatusFilter')?.value || '';
                const searchQuery = document.getElementById('teamSearch')?.value.toLowerCase() || '';

                // Filter team members
                let filteredTeam = this.data.team.filter(member => {
                    const matchesRole = !roleFilter || member.roles.includes(roleFilter);
                    const matchesStatus = !statusFilter || member.status === statusFilter;
                    const matchesSearch = !searchQuery || member.name.toLowerCase().includes(searchQuery);
                    return matchesRole && matchesStatus && matchesSearch;
                });

                if (filteredTeam.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>${this.t('noOrdersFound')}</p>
                        </div>
                    `;
                    return;
                }

                // Render table
                const tableHtml = `
                    <div style="overflow-x: auto;">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>${this.t('memberName')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('phoneNumber')}</th>
                                    <th>${this.t('email')}</th>
                                    <th>${this.t('roles')}</th>
                                    <th>${this.t('status')}</th>
                                    <th>${this.t('actions')}</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${filteredTeam.map(member => {
                                    const roleIcons = {
                                        'Driver': 'üöó',
                                        'Operator': '‚öôÔ∏è',
                                        'Helper': 'ü§ù',
                                        'Manager': 'üëî',
                                        'Supervisor': 'üìã'
                                    };
                                    const roleBadges = member.roles.map(role =>
                                        `<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; margin-right: 0.25rem;">${roleIcons[role] || ''} ${role}</span>`
                                    ).join('');

                                    const statusColor = member.status === 'Active' ? 'var(--success)' : 'var(--text-gray)';
                                    const statusBadge = `<span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">${this.t(member.status.toLowerCase())}</span>`;

                                    return `
                                        <tr>
                                            <td><strong>${member.name}</strong></td>
                                            <td>${roleBadges}</td>
                                            <td>
                                                <a href="https://wa.me/${member.whatsApp.replace(/[^0-9]/g, '')}" target="_blank" style="color: var(--success);">
                                                    ${member.whatsApp}
                                                </a>
                                            </td>
                                            <td>${member.email || '-'}</td>
                                            <td><small>${member.skills && member.skills.length > 0 ? member.skills.join(', ') : '-'}</small></td>
                                            <td>${statusBadge}</td>
                                            <td>
                                                <button class="btn btn-info btn-small" onclick="OMS.editTeamMember('${member.id}')">${this.t('edit')}</button>
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteTeamMember('${member.id}')">${this.t('delete')}</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                container.innerHTML = tableHtml;
            },

            addTeamMember() {
                const name = Utils.get('teamMemberName');
                const whatsApp = Utils.get('teamMemberWhatsApp');
                const email = Utils.get('teamMemberEmail');
                const status = Utils.get('teamMemberStatus');
                const skillsStr = Utils.get('teamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('roleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('roleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('roleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('roleManager')?.checked) roles.push('Manager');
                if (document.getElementById('roleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill Name, WhatsApp, and select at least one Role', 'error');
                    return;
                }

                // Parse skills
                const skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // Create team member object
                const teamMember = {
                    id: Utils.generateId(),
                    name,
                    roles,
                    whatsApp,
                    email: email || '',
                    skills,
                    status,
                    createdAt: new Date().toISOString()
                };

                this.data.team.push(teamMember);
                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(teamMember).then(success => {
                    if (success) {
                        this.showToast(`${name} added to team and synced!`, 'success');
                    } else {
                        this.showToast(`${name} added locally, but sync failed`, 'warning');
                    }
                });

                this.renderTeamTable();
                this.clearTeamForm();
            },

            clearTeamForm() {
                Utils.set('teamMemberName', '');
                Utils.set('teamMemberWhatsApp', '');
                Utils.set('teamMemberEmail', '');
                Utils.set('teamMemberSkills', '');
                Utils.set('teamMemberStatus', 'Active');

                // Uncheck all role checkboxes
                ['roleDriver', 'roleOperator', 'roleHelper', 'roleManager', 'roleSupervisor'].forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) checkbox.checked = false;
                });
            },

            editTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                // Show edit modal
                this.showModal('Edit Team Member', `
                    <div class="form-group">
                        <label class="form-label required">Name</label>
                        <input type="text" id="editTeamMemberName" class="form-input" value="${member.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">WhatsApp Number</label>
                        <input type="tel" id="editTeamMemberWhatsApp" class="form-input" value="${member.whatsApp}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" id="editTeamMemberEmail" class="form-input" value="${member.email || ''}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Status</label>
                        <select id="editTeamMemberStatus" class="form-select">
                            <option value="Active" ${member.status === 'Active' ? 'selected' : ''}>Active</option>
                            <option value="Inactive" ${member.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Roles</label>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleDriver" value="Driver" ${member.roles.includes('Driver') ? 'checked' : ''}>
                                üöó Driver
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleOperator" value="Operator" ${member.roles.includes('Operator') ? 'checked' : ''}>
                                ‚öôÔ∏è Operator
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleHelper" value="Helper" ${member.roles.includes('Helper') ? 'checked' : ''}>
                                ü§ù Helper
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleManager" value="Manager" ${member.roles.includes('Manager') ? 'checked' : ''}>
                                üëî Manager
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleSupervisor" value="Supervisor" ${member.roles.includes('Supervisor') ? 'checked' : ''}>
                                üìã Supervisor
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Skills (comma-separated)</label>
                        <input type="text" id="editTeamMemberSkills" class="form-input" value="${member.skills && member.skills.length > 0 ? member.skills.join(', ') : ''}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTeamMemberEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveTeamMemberEdit(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                const name = Utils.get('editTeamMemberName');
                const whatsApp = Utils.get('editTeamMemberWhatsApp');
                const email = Utils.get('editTeamMemberEmail');
                const status = Utils.get('editTeamMemberStatus');
                const skillsStr = Utils.get('editTeamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('editRoleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('editRoleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('editRoleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('editRoleManager')?.checked) roles.push('Manager');
                if (document.getElementById('editRoleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update member
                member.name = name;
                member.whatsApp = whatsApp;
                member.email = email;
                member.status = status;
                member.roles = roles;
                member.skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];
                member.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(member).then(success => {
                    if (success) {
                        this.showToast('Team member updated and synced!', 'success');
                    } else {
                        this.showToast('Team member updated locally, but sync failed', 'warning');
                    }
                });

                this.renderTeamTable();
                this.closeModal();
            },

            deleteTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                if (confirm(`Are you sure you want to delete ${member.name} from the team?`)) {
                    const index = this.data.team.findIndex(m => m.id === id);
                    if (index !== -1) {
                        const memberName = member.name;

                        this.data.team.splice(index, 1);
                        this.saveToStorage();

                        // Delete from Firestore
                        this.deleteTeamMemberFromFirestore(id).then(success => {
                            if (success) {
                                this.showToast(`${memberName} removed from team and synced!`, 'success');
                            } else {
                                this.showToast(`${memberName} removed locally, but sync failed`, 'warning');
                            }
                        });

                        this.renderTeamTable();
                    }
                }
            },

            // ============ TEAM ALLOCATION & NOTIFICATIONS ============

            populateTeamDropdowns() {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');

                // Populate Driver dropdown
                const driverSelect = document.getElementById('driverName');
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown
                const operatorSelect = document.getElementById('operator');
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}">‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Populate Helper multi-select dropdown
                const helperSelect = document.getElementById('helper');
                if (helperSelect) {
                    const helpers = activeTeam.filter(m => m.roles.includes('Helper'));
                    // Keep existing selections
                    const currentValues = Array.from(helperSelect.selectedOptions).map(opt => opt.value);
                    helperSelect.innerHTML = helpers.map(h =>
                        `<option value="${h.name}" data-id="${h.id}" ${currentValues.includes(h.name) ? 'selected' : ''}>üë∑ ${h.name}</option>`
                    ).join('');
                }
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');
                const functionId = `day${dayIndex}func${functionIndex}`;

                // Populate Driver dropdown for this function
                const driverSelect = document.getElementById(`${functionId}Driver`);
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    const currentValue = driverSelect.value;
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}" ${d.name === currentValue ? 'selected' : ''}>üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown for this function
                const operatorSelect = document.getElementById(`${functionId}Operator`);
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    const currentValue = operatorSelect.value;
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}" ${o.name === currentValue ? 'selected' : ''}>‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Helper is now a text input field, no need to populate dropdown
            },

            notifyAllocatedTeam() {
                // Get current order form data
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v) : [];

                // Get order details
                const orderId = Utils.get('orderId') || 'NEW';
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const date = Utils.get('orderDate');
                const readyTime = Utils.get('readyTime');
                const contact = Utils.get('contact');

                if (!clientName || !venue || !date) {
                    this.showToast('Please fill Order ID, Client Name, Venue, and Date first', 'error');
                    return;
                }

                // Get items from current order
                const items = this.currentOrderItems || [];

                // Collect all team members to notify
                const teamToNotify = [];

                // Prepare team list for messages
                const teamListForMessage = [
                    driverName ? `Driver: ${driverName}` : null,
                    operatorName ? `Operator: ${operatorName}` : null,
                    helperNames.length > 0 ? `Helper(s): ${helperNames.join(', ')}` : null
                ].filter(Boolean).join(', ');

                // Add Driver
                if (driverName) {
                    const driver = this.data.team.find(m => m.name === driverName);
                    if (driver && driver.whatsApp) {
                        teamToNotify.push({ member: driver, role: 'Driver' });
                    }
                }

                // Add Operator
                if (operatorName) {
                    const operator = this.data.team.find(m => m.name === operatorName);
                    if (operator && operator.whatsApp) {
                        teamToNotify.push({ member: operator, role: 'Operator' });
                    }
                }

                // Add ALL Helpers
                if (helperNames.length > 0) {
                    helperNames.forEach(helperName => {
                        const helper = this.data.team.find(m => m.name === helperName);
                        if (helper && helper.whatsApp) {
                            teamToNotify.push({ member: helper, role: 'Helper' });
                        }
                    });
                }

                if (teamToNotify.length === 0) {
                    this.showToast('No team members selected or no WhatsApp numbers found', 'warning');
                    return;
                }

                // Send notifications with delay to prevent popup blocking
                teamToNotify.forEach((item, index) => {
                    setTimeout(() => {
                        this.sendTeamMemberNotification(item.member, item.role, {
                            orderId, clientName, venue, date, readyTime, contact, items,
                            teamList: teamListForMessage
                        });
                    }, index * 500); // 500ms delay between each window
                });

                this.showToast(`Opening WhatsApp for ${teamToNotify.length} team member(s): ${teamToNotify.map(t => t.member.name).join(', ')}`, 'success');

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'team_allocation',
                    orderId,
                    recipients: teamToNotify.map(t => t.member.name),
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);
            },

            sendTeamMemberNotification(teamMember, role, orderDetails) {
                const { orderId, clientName, venue, date, readyTime, contact, items, teamList } = orderDetails;

                // Format items list
                const itemsList = items && items.length > 0
                    ? items.map(item => `‚Ä¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}`).join('\n')
                    : '‚Ä¢ No items added yet';

                // Create WhatsApp message
                let message = `üéâ *NEW ORDER ASSIGNED TO YOU*\n\n`;
                message += `üìã *Order ID:* ${orderId}\n`;
                message += `üë§ *Client:* ${clientName}\n`;
                message += `üìç *Venue:* ${venue}\n`;
                message += `üìÖ *Date:* ${Utils.formatDate(date)}\n`;
                message += `üïê *Ready Time:* ${readyTime || 'TBD'}\n\n`;
                message += `üé≠ *Your Role:* ${role.toUpperCase()}\n\n`;

                if (teamList) {
                    message += `üë∑ *Team Members:*\n${teamList}\n\n`;
                }

                message += `üì¶ *Items Required:*\n${itemsList}\n\n`;

                if (contact) {
                    message += `üìû *Client Contact:* ${contact}\n\n`;
                }

                message += `‚ö° Please confirm receipt by replying "OK"\n\n`;
                message += `--\n_FirepowerSFX Order Management_`;

                // Encode and open WhatsApp
                const phoneNumber = teamMember.whatsApp.replace(/[^0-9]/g, '');
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
            },

            sendManagerReport() {
                // Get all managers
                const managers = this.data.team.filter(m => m.roles.includes('Manager') && m.status === 'Active');

                if (managers.length === 0) {
                    this.showToast('No managers found in team. Add a team member with Manager role first.', 'warning');
                    return;
                }

                // Get the current order data from the form
                const currentOrderId = Utils.get('orderId');
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const currentOrderDate = Utils.get('orderDate');
                const currentStartDate = Utils.get('startDate');
                const eventType = Utils.get('eventTypeSelect');
                const isMultiDay = eventType === 'multi';
                const readyTime = Utils.get('readyTime');
                const status = Utils.get('orderStatus');
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');

                // Get multiple selected helpers from multi-select dropdown
                const helperSelect = document.getElementById('helper');
                const helperNames = helperSelect ? Array.from(helperSelect.selectedOptions).map(opt => opt.value).filter(v => v).join(', ') : '';

                // Check if we have order data in the form
                if (!clientName || !venue) {
                    this.showToast('Please open/select an order first to send report', 'warning');
                    return;
                }

                // Use the order date from the form
                const targetDate = isMultiDay ? currentStartDate : currentOrderDate;

                if (!targetDate) {
                    this.showToast('Order date is missing', 'error');
                    return;
                }

                // Build manager report for THIS SPECIFIC ORDER ONLY
                let message = `üìä *ORDER REPORT*\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

                message += `*ORDER ID:* ${currentOrderId || 'NEW'}\n`;
                message += `üë§ *Client:* ${clientName}\n`;
                message += `üìç *Venue:* ${venue}\n`;
                message += `üìÖ *Date:* ${Utils.formatDate(targetDate)}\n`;
                message += `üïê *Ready Time:* ${readyTime || 'TBD'}\n`;
                message += `üìä *Status:* ${status || 'Pending'}\n\n`;

                if (driverName || operatorName || helperNames) {
                    message += `üë∑ *Team Allocation:*\n`;
                    if (driverName) message += `  ‚Ä¢ Driver: ${driverName}\n`;
                    if (operatorName) message += `  ‚Ä¢ Operator: ${operatorName}\n`;
                    if (helperNames) message += `  ‚Ä¢ Helper(s): ${helperNames}\n`;
                } else {
                    message += `‚ö†Ô∏è *Team Not Allocated Yet*\n`;
                }

                message += `\n`;

                // Get items from current order
                const items = this.currentOrderItems || [];
                if (items.length > 0) {
                    message += `üì¶ *Items Required:*\n`;
                    items.forEach(item => {
                        message += `  ‚Ä¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}\n`;
                    });
                    message += `\n`;
                }

                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `--\n_FirepowerSFX Admin_`;

                // Filter managers with valid WhatsApp numbers
                const managersWithWhatsApp = managers.filter(m => m.whatsApp && m.whatsApp.trim() !== '');

                if (managersWithWhatsApp.length === 0) {
                    this.showToast('No managers have WhatsApp numbers configured', 'warning');
                    return;
                }

                // Send to all managers with delay to prevent popup blocking
                const encodedMessage = encodeURIComponent(message);
                const managerNames = [];

                managersWithWhatsApp.forEach((manager, index) => {
                    const phoneNumber = manager.whatsApp.replace(/[^0-9]/g, '');
                    if (phoneNumber) {
                        managerNames.push(manager.name);
                        // Add delay between each window to prevent popup blocking
                        setTimeout(() => {
                            window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
                        }, index * 500); // 500ms delay between each window
                    }
                });

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'manager_report',
                    recipients: managerNames,
                    orderId: currentOrderId,
                    targetDate: targetDate,
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);

                this.showToast(`Opening WhatsApp for ${managerNames.length} manager(s): ${managerNames.join(', ')}`, 'success');
            },

            renderCalendarTab() {
                document.getElementById('calendar').innerHTML = this.renderCalendar(this.currentCalendarDate || new Date());
            },

            renderHistory() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('orderHistory')}</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">${this.t('export')}</button>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;

                this.renderTable('historyContainer', [
                    { key: 'orderId', label: this.t('orderId'), render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: this.t('client') },
                    { key: 'venue', label: this.t('venue') },
                    { key: 'date', label: this.t('date'), render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} ${this.t('to')} ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: this.t('status'), render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${this.t(o.status.toLowerCase())}</span>` }
                ], this.data.orders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.docId || row.orderId}">${this.t('edit')}</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.docId || row.orderId}">${this.t('print')}</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.docId || row.orderId}">${this.t('delete')}</button>
                `);
            },

            renderAnalytics() {
    const container = document.getElementById('analytics');
    const trackingData = this.data.trackingData || [];
    const orders = this.data.orders || [];

    // Website visitor analytics
    const pageViews = trackingData.filter(t => t.type === 'page_view').length;
    const cartActions = trackingData.filter(t => t.type === 'cart_add' || t.type === 'cart_remove').length;
    const uniqueSessions = [...new Set(trackingData.map(t => t.sessionId))].length;

    // Get device breakdown
    const devices = {};
    trackingData.forEach(t => {
        const device = t.userInfo?.device || 'Unknown';
        devices[device] = (devices[device] || 0) + 1;
    });

    // Get location breakdown
    const locations = {};
    trackingData.forEach(t => {
        const city = t.userInfo?.city || 'Unknown';
        locations[city] = (locations[city] || 0) + 1;
    });

    // Order-based analytics
    const totalOrders = orders.length;
    const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
    const completedOrders = orders.filter(o => o.status === 'Completed').length;
    const cancelledOrders = orders.filter(o => o.status === 'Cancelled').length;

    // Get event type breakdown
    const eventTypes = {};
    orders.forEach(o => {
        const type = o.eventType || 'Other';
        eventTypes[type] = (eventTypes[type] || 0) + 1;
    });

    container.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analyticsReport')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card info">
                    <div class="stat-value">${pageViews}</div>
                    <div class="stat-label">${this.t('analytics')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${uniqueSessions}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${cartActions}</div>
                    <div class="stat-label">${this.t('actions')}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${trackingData.length}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(devices).length > 0 ? Object.entries(devices).map(([device, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${device}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('analytics')}</h3>
            <div class="stats-grid">
                ${Object.entries(locations).length > 0 ? Object.entries(locations).slice(0, 8).map(([city, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${city}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('history')}</h3>
            <div class="table-container">
                ${trackingData.length > 0 ? `
                <table class="table">
                    <thead>
                        <tr>
                            <th>${this.t('readyTime')}</th>
                            <th>${this.t('eventType')}</th>
                            <th>${this.t('status')}</th>
                            <th>${this.t('venue')}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${trackingData.slice(0, 20).map(t => {
                            const date = t.timestamp instanceof Date ? t.timestamp : new Date(t.timestamp);
                            const formattedDate = date.toLocaleDateString('en-GB') + ' ' + date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                            const formattedType = (t.type || 'unknown').replace(/_/g, ' ').split(' ').map(word =>
                                word.charAt(0).toUpperCase() + word.slice(1)
                            ).join(' ');

                            return `
                                <tr>
                                    <td>${formattedDate}</td>
                                    <td><span class="status-badge">${formattedType}</span></td>
                                    <td>${t.userInfo?.device || this.t('na')}</td>
                                    <td>${t.userInfo?.city || this.t('na')}${t.userInfo?.country ? ', ' + t.userInfo.country : ''}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
                ` : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2 class="card-title">${this.t('analytics')}</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${totalOrders}</div>
                    <div class="stat-label">${this.t('totalOrders')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${confirmedOrders}</div>
                    <div class="stat-label">${this.t('confirmedOrders')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${completedOrders}</div>
                    <div class="stat-label">${this.t('completedOrders')}</div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-value">${cancelledOrders}</div>
                    <div class="stat-label">${this.t('cancelledOrders')}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('eventType')}</h3>
            <div class="stats-grid">
                ${Object.entries(eventTypes).length > 0 ? Object.entries(eventTypes).map(([type, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${type}</div>
                    </div>
                `).join('') : `<p style="text-align: center; color: var(--text-gray); padding: 2rem;">${this.t('noDataForRange')}</p>`}
            </div>
        </div>

        <div class="card">
            <h3 class="card-title">${this.t('customers')}</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${this.data.customers.length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders > 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders === 1).length}</div>
                    <div class="stat-label">${this.t('customers')}</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${this.data.customers.length > 0 ? Math.round(orders.length / this.data.customers.length * 10) / 10 : 0}</div>
                    <div class="stat-label">${this.t('totalOrdersCount')}</div>
                </div>
            </div>
        </div>
    `;
},

            renderSettings() {
                const container = document.getElementById('settings');
                const s = this.data.settings;
                const ts = s.tableSettings;
                const colors = s.printColors;

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">${this.t('systemSettings')}</h2>
                        </div>

                        <div class="card">
                            <h3>${this.t('tableLayoutSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('srColumnWidth')}: <span id="srWidthValue">${ts.columnWidthSr}%</span></label>
                                    <input type="range" id="columnWidthSr" class="form-input" min="5" max="25" value="${ts.columnWidthSr}"
                                           oninput="document.getElementById('srWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('itemColumnWidth')}: <span id="itemWidthValue">${ts.columnWidthItem}%</span></label>
                                    <input type="range" id="columnWidthItem" class="form-input" min="15" max="60" value="${ts.columnWidthItem}"
                                           oninput="document.getElementById('itemWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('qtyColumnWidth')}: <span id="qtyWidthValue">${ts.columnWidthQty}%</span></label>
                                    <input type="range" id="columnWidthQty" class="form-input" min="5" max="30" value="${ts.columnWidthQty}"
                                           oninput="document.getElementById('qtyWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('remarksColumnWidth')}: <span id="remarksWidthValue">${ts.columnWidthRemarks}%</span></label>
                                    <input type="range" id="columnWidthRemarks" class="form-input" min="15" max="60" value="${ts.columnWidthRemarks}"
                                           oninput="document.getElementById('remarksWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('leftMarginFiling')}: <span id="leftMarginValue">${ts.leftMargin}mm</span></label>
                                    <input type="range" id="leftMargin" class="form-input" min="30" max="100" value="${ts.leftMargin}"
                                           oninput="document.getElementById('leftMarginValue').textContent = this.value + 'mm'">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('colorCustomization')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerBackground')}</label>
                                    <input type="color" id="printHeaderBg" class="form-input" value="${colors.headerBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('headerText')}</label>
                                    <input type="color" id="printHeaderText" class="form-input" value="${colors.headerText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdBackground')}</label>
                                    <input type="color" id="printOrderIdBg" class="form-input" value="${colors.orderIdBg || '#667eea'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('orderIdText')}</label>
                                    <input type="color" id="printOrderIdText" class="form-input" value="${colors.orderIdText || '#ffffff'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderBackground')}</label>
                                    <input type="color" id="printTableHeaderBg" class="form-input" value="${colors.tableHeaderBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableHeaderText')}</label>
                                    <input type="color" id="printTableHeaderText" class="form-input" value="${colors.tableHeaderText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('tableBorder')}</label>
                                    <input type="color" id="printTableBorder" class="form-input" value="${colors.tableBorder}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('notesBackground')}</label>
                                    <input type="color" id="printNotesBg" class="form-input" value="${colors.notesBg}" style="height: 50px;">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('printSettings')}</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">${this.t('fontSize')}: <span id="fontSizeValue">${s.printFontSize}px</span></label>
                                    <input type="range" id="printFontSize" class="form-input" min="16" max="80" value="${s.printFontSize}"
                                           oninput="document.getElementById('fontSizeValue').textContent = this.value + 'px'">
                                    <small style="color: var(--text-gray);">${this.t('multiOrderNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('paperFormat')}</label>
                                    <select id="paperFormat" class="form-select">
                                        <option value="A4" ${s.paperFormat === 'A4' ? 'selected' : ''}>A4 (210 √ó 297 mm)</option>
                                        <option value="Legal" ${s.paperFormat === 'Legal' ? 'selected' : ''}>Legal (216 √ó 356 mm)</option>
                                        <option value="Letter" ${s.paperFormat === 'Letter' ? 'selected' : ''}>Letter (216 √ó 279 mm)</option>
                                        <option value="A3" ${s.paperFormat === 'A3' ? 'selected' : ''}>A3 (297 √ó 420 mm)</option>
                                        <option value="A5" ${s.paperFormat === 'A5' ? 'selected' : ''}>A5 (148 √ó 210 mm)</option>
                                        <option value="Tabloid" ${s.paperFormat === 'Tabloid' ? 'selected' : ''}>Tabloid (279 √ó 432 mm)</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('chooseFormat')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('pageOrientation')}</label>
                                    <select id="paperOrientation" class="form-select">
                                        <option value="portrait" ${s.paperOrientation === 'portrait' ? 'selected' : ''}>${this.t('portrait')}</option>
                                        <option value="landscape" ${s.paperOrientation === 'landscape' ? 'selected' : ''}>${this.t('landscape')}</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('portraitOrLandscape')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('imageQuality')}</label>
                                    <select id="imageQuality" class="form-select">
                                        <option value="1" ${s.imageQuality === 1 ? 'selected' : ''}>${this.t('low')} (${this.t('faster')})</option>
                                        <option value="2" ${s.imageQuality === 2 ? 'selected' : ''}>${this.t('medium')} (${this.t('balanced')})</option>
                                        <option value="3" ${s.imageQuality === 3 ? 'selected' : ''}>${this.t('high')} (${this.t('betterQuality')})</option>
                                        <option value="4" ${s.imageQuality === 4 ? 'selected' : ''}>${this.t('ultra')} (${this.t('bestQuality')})</option>
                                    </select>
                                    <small style="color: var(--text-gray);">${this.t('higherQualityNote')}</small>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">${this.t('functionColor')}</label>
                                    <input type="color" id="functionColor" class="form-input" value="${s.functionColor || '#667eea'}" style="height: 50px;">
                                    <small style="color: var(--text-gray);">${this.t('customColorNote')}</small>
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>${this.t('systemPreferences')}</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('defaultOrderStatus')}</label>
                                    <select id="defaultOrderStatus" class="form-select">
                                        <option value="Confirmed" ${s.defaultOrderStatus === 'Confirmed' ? 'selected' : ''}>${this.t('confirmed')}</option>
                                        <option value="Completed" ${s.defaultOrderStatus === 'Completed' ? 'selected' : ''}>${this.t('completed')}</option>
                                        <option value="Cancelled" ${s.defaultOrderStatus === 'Cancelled' ? 'selected' : ''}>${this.t('cancelled')}</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('lowStockThreshold')}</label>
                                    <input type="number" id="lowStockThreshold" class="form-input" value="${s.lowStockThreshold}" min="1">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">${this.t('language')}</label>
                                    <select id="appLanguage" class="form-select">
                                        <option value="en" ${s.language === 'en' ? 'selected' : ''}>English</option>
                                        <option value="gu" ${s.language === 'gu' ? 'selected' : ''}>‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">${this.t('invoiceFormat')}</label>
                                    <select id="invoiceFormat" class="form-select">
                                        <option value="FP" ${s.invoicePrefix === 'FP' ? 'selected' : ''}>FP001</option>
                                        <option value="ORD" ${s.invoicePrefix === 'ORD' ? 'selected' : ''}>ORD001</option>
                                        <option value="INV" ${s.invoicePrefix === 'INV' ? 'selected' : ''}>INV001</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="OMS.saveSettings()">${this.t('saveAllSettings')}</button>
                            <button class="btn btn-secondary" onclick="OMS.resetSettings()">${this.t('resetToDefaults')}</button>
                        </div>

                        <div class="card">
                            <h3>${this.t('dataManagement')}</h3>
                            <div class="btn-group">
                                <button class="btn btn-info" data-action="exportData">${this.t('exportJSON')}</button>
                                <button class="btn btn-success" onclick="OMS.exportData('csv')">${this.t('exportCSV')}</button>
                                <button class="btn btn-warning" data-action="importData">${this.t('importBackup')}</button>
                                <button class="btn btn-danger" onclick="OMS.resetAllData()">${this.t('resetAllData')}</button>
                            </div>
                        </div>
                    </div>
                `;
            },

            async saveSettings() {
                // Save table settings
                this.data.settings.tableSettings = {
                    columnWidthSr: parseInt(Utils.get('columnWidthSr')) || 8,
                    columnWidthItem: parseInt(Utils.get('columnWidthItem')) || 40,
                    columnWidthQty: parseInt(Utils.get('columnWidthQty')) || 12,
                    columnWidthRemarks: parseInt(Utils.get('columnWidthRemarks')) || 40,
                    leftMargin: parseInt(Utils.get('leftMargin')) || 50
                };

                // Save colors
                this.data.settings.printColors = {
                    headerBg: Utils.get('printHeaderBg') || '#667eea',
                    headerText: Utils.get('printHeaderText') || '#ffffff',
                    orderIdBg: Utils.get('printOrderIdBg') || '#667eea',
                    orderIdText: Utils.get('printOrderIdText') || '#ffffff',
                    tableHeaderBg: Utils.get('printTableHeaderBg') || '#f8f9fa',
                    tableHeaderText: Utils.get('printTableHeaderText') || '#333333',
                    tableBorder: Utils.get('printTableBorder') || '#333333',
                    notesBg: Utils.get('printNotesBg') || '#f9f9f9'
                };

                // Save other settings
                this.data.settings.printFontSize = parseInt(Utils.get('printFontSize')) || 32;
                this.data.settings.defaultOrderStatus = Utils.get('defaultOrderStatus') || 'Confirmed';
                this.data.settings.lowStockThreshold = parseInt(Utils.get('lowStockThreshold')) || 5;
                this.data.settings.language = Utils.get('appLanguage') || 'en';
                this.data.settings.invoicePrefix = Utils.get('invoiceFormat') || 'FP';

                // Save new print settings
                this.data.settings.paperFormat = Utils.get('paperFormat') || 'A4';
                this.data.settings.paperOrientation = Utils.get('paperOrientation') || 'portrait';
                this.data.settings.imageQuality = parseInt(Utils.get('imageQuality')) || 2;
                this.data.settings.functionColor = Utils.get('functionColor') || '#667eea';

                // Save to localStorage
                this.saveToStorage();

                // Save to Firestore for persistence across devices
                const saved = await this.saveSettingsToFirestore();

                if (saved) {
                    this.refreshOrderId();
                    this.showToast('All settings saved successfully!');
                } else {
                    this.showToast('Settings saved locally, but Firestore sync failed. Check permissions.');
                }
            },

            resetAllData() {
                if (!confirm('‚ö†Ô∏è This will delete ALL data permanently. Are you absolutely sure?')) return;
                if (!confirm('Last chance! This action CANNOT be undone. Confirm data reset?')) return;
                
                localStorage.removeItem('oms_data');
                this.showToast('Data reset! Reloading...');
                setTimeout(() => location.reload(), 1000);
            },

            resetSettings() {
                if (!confirm('Reset all settings?')) return;

                this.data.settings = {
                    printFontSize: 32,
                    orderIdCounter: this.data.settings.orderIdCounter,
                    invoicePrefix: 'FP',
                    lowStockThreshold: 5,
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    paperFormat: 'A4',
                    paperOrientation: 'portrait',
                    imageQuality: 2,
                    functionColor: '#667eea',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9'
                    },
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                };

                this.saveToStorage();
                this.renderSettings();
                this.showToast('Settings reset!');
            },

            // ============ ITEM SEARCH ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                itemSearch.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    
                    if (query.length > 0) {
                        const items = this.data.inventory.items.filter(i => 
                            i.name.toLowerCase().includes(query)
                        );
                        
                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                }, 300));
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;
                
                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }
                
                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;
                
                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }
                
                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)" 
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}" 
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('üì• Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        await Promise.all([
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore()
        ]);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('‚úÖ All data loaded from Firestore successfully!');

    } catch (error) {
        console.error('‚ùå Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('üì• Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`‚ö†Ô∏è Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                console.warn(`   Customer: ${customer.name}, Date: ${customer.dates}`);
                skippedDeleted++;
                return;
            }

            const loadedOrder = {
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                date: Utils.convertDateFormat(customer.dates) || '',
                readyTime: customer.timeSlot || '',
                clientName: customer.name || '',
                contact: customer.phone || '',
                venue: customer.venue || '',
                eventType: orderData.functionType || customer.functionType || '',
                transport: '',
                driverName: '',
                operator: '',
                helper: '',
                status: orderData.status || 'Confirmed',
                notes: '',
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.qty || 0,
                    remarks: item.desc || '',
                    price: item.price || 0
                })),
                createdAt: orderData.createdAt || new Date().toISOString(),
                totalAmount: orderData.totalAmount || 0,
                // Multi-day order fields
                isMultiDay: orderData.isMultiDay || false,
                startDate: orderData.startDate || null,
                endDate: orderData.endDate || null,
                dayWiseData: orderData.dayWiseData || []
            };

            // Debug log multi-day orders
            if (orderData.isMultiDay) {
                console.log(`üìÖ Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`‚úÖ Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('‚ùå Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('üìä Loading tracking data from Firestore...');

        // Check if user is authenticated
        if (!auth.currentUser) {
            console.warn('‚ö†Ô∏è Not authenticated yet - skipping tracking data load');
            this.data.trackingData = [];
            return;
        }

        // Load without orderBy to avoid index requirement
        // We'll sort in JavaScript instead
        const trackingSnapshot = await db.collection('tracking')
            .limit(500)  // Get more data, will sort client-side
            .get();

        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });

        // Sort by timestamp in JavaScript (newest first)
        this.data.trackingData.sort((a, b) => b.timestamp - a.timestamp);

        console.log(`‚úÖ Loaded ${this.data.trackingData.length} tracking events from website`);
        console.log(`üìç Sample data:`, this.data.trackingData.slice(0, 3));

    } catch (error) {
        console.error('‚ùå Error loading tracking data:', error);
        console.error('Error details:', error.code, error.message);

        // If permissions error, log it but don't retry
        // (retrying won't help if Firestore rules don't allow access)
        if (error.code === 'permission-denied') {
            console.warn('‚ö†Ô∏è Insufficient permissions to access tracking data. Please check Firestore security rules.');
        }

        this.data.trackingData = [];
    }
},

// ============ TEAM FIRESTORE SYNC ============

async saveTeamMemberToFirestore(teamMember) {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('‚ùå No user logged in');
            return false;
        }

        await db.collection('team').doc(teamMember.id).set({
            ...teamMember,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Team member saved to Firestore:', teamMember.name);
        return true;
    } catch (error) {
        console.error('‚ùå Error saving team member to Firestore:', error);
        this.showToast('Failed to sync team member: ' + error.message, 'error');
        return false;
    }
},

async loadTeamFromFirestore() {
    try {
        console.log('üë∑ Loading team from Firestore...');

        const teamSnapshot = await db.collection('team')
            .orderBy('createdAt', 'desc')
            .get();

        this.data.team = [];
        teamSnapshot.forEach(doc => {
            this.data.team.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`‚úÖ Loaded ${this.data.team.length} team members from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading team from Firestore:', error);
        // Try to load from localStorage as fallback
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data.team = parsed.team || [];
            console.log('üì¶ Loaded team from localStorage backup');
        }
        return false;
    }
},

async deleteTeamMemberFromFirestore(teamMemberId) {
    try {
        await db.collection('team').doc(teamMemberId).delete();
        console.log('‚úÖ Team member deleted from Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting team member from Firestore:', error);
        return false;
    }
},

// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('üì¶ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`üì¶ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`üì¶ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`‚úÖ Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`‚úÖ Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`‚ö†Ô∏è Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('üîÑ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('‚úÖ Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('‚ö†Ô∏è‚ö†Ô∏è Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('‚ùå‚ùå CRITICAL: Both Firestore AND local are empty!');
            console.error('‚ùå ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('‚ö†Ô∏è Keeping existing local inventory due to error');
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('‚úÖ Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('‚úÖ Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('‚úÖ Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('üîî Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`‚úÖ Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ SETTINGS FIRESTORE SYNC ============

async saveSettingsToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) return false;

        await db.collection('settings').doc('app_settings').set({
            ...this.data.settings,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Settings saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving settings to Firestore:', error);
        return false;
    }
},

async loadSettingsFromFirestore() {
    try {
        console.log('‚öôÔ∏è Loading settings from Firestore...');

        const settingsDoc = await db.collection('settings').doc('app_settings').get();

        if (settingsDoc.exists) {
            const firestoreSettings = settingsDoc.data();
            // Merge with default settings
            this.data.settings = {
                ...this.data.settings,
                ...firestoreSettings
            };
            console.log('‚úÖ Settings loaded from Firestore');
            return true;
        } else {
            console.log('üìù No settings in Firestore, using defaults');
            // Save default settings to Firestore
            await this.saveSettingsToFirestore();
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error loading settings from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('‚ö†Ô∏è All listeners already active');
        return;
    }

    console.log('üîÑ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('üë∑ Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                }
                // Update UI if on team tab
                if (this.currentTab === 'team') {
                    this.renderTeamTable();
                }
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('üë∑ Team member removed:', teamMember.name);
                    if (this.currentTab === 'team') {
                        this.renderTeamTable();
                    }
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('üì¶ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`üìÅ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        console.log(`üóëÔ∏è Category removed:`, category.name);
                    }
                }
            });

            console.log(`üì¶ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('üì¶ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`üì¶ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        console.log(`üóëÔ∏è Item removed:`, item.name);
                    }
                }
            });

            console.log(`üì¶ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('‚öôÔ∏è Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    console.log('‚úÖ All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('‚ö†Ô∏è Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('üõë Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('üîÑ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`üìã Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('üÜï New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    const newOrder = {
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        isMultiDay: orderData.isMultiDay || false,
                        startDate: orderData.startDate || null,
                        endDate: orderData.endDate || null,
                        dayWiseData: orderData.dayWiseData || [],
                        date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
                        readyTime: customer.timeSlot || '',
                        clientName: customer.name || '',
                        contact: customer.phone || '',
                        venue: customer.venue || '',
                        eventType: orderData.functionType || customer.functionType || '',
                        transport: orderData.transport || '',
                        driverName: orderData.driverName || '',
                        operator: orderData.operator || '',
                        helper: orderData.helper || '',
                        status: orderData.status || 'Confirmed',
                        notes: orderData.notes || '',
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.qty || 0,
                            remarks: item.desc || '',
                            price: item.price || 0
                        })),
                        createdAt: orderData.createdAt || new Date().toISOString(),
                        totalAmount: orderData.totalAmount || 0
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        this.showToast(`üÜï New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('‚úèÔ∏è Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // Update existing order
        this.data.orders[index] = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();
        this.showToast(`‚úèÔ∏è Order updated: ${this.data.orders[index].clientName}`, 'success');
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('‚ö†Ô∏è Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('‚ö†Ô∏è Modified order not found locally, adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                console.log('üóëÔ∏è Order removed from Firestore:', orderData.orderId || change.doc.id);
                const index = this.data.orders.findIndex(o => o.orderId === (orderData.orderId || change.doc.id));
                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();
                    this.showToast(`üóëÔ∏è Order deleted: ${deleted.orderId}`, 'success');
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`‚úÖ Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('‚úÖ Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('üìã Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('‚ö†Ô∏è Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('‚ö†Ô∏è Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('üìã No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('‚úÖ Demo data loaded for first-time user');
    } else {
        console.log('‚úÖ Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') this.updateInventoryDisplay();
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `‚ö†Ô∏è OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'üî• TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = '‚ö° TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `‚è∞ In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `üìÖ In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    ‚úì Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            this.loadOrderToForm(order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('‚úÖ Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('‚ùå Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('‚ùå Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`‚úÖ Cleared ${count} entries from deletedOrders list`);
                console.log('üîÑ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('‚úÖ Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('üîÑ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('‚úÖ Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`‚úÖ Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('‚úÖ No demo orders found!');
                        return [];
                    }

                    console.log(`‚ö†Ô∏è Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`‚úÖ Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('‚ùå Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('‚úÖ Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`üìã Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('üîÑ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('üì¶ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('‚ùå Firestore inventory is empty! Nothing to recover.');
                        console.log('üí° Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('‚ùå No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('‚ùå No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('üì¶ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('üì¶ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('üîç Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`üìÅ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`üì¶ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('‚ùå Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`‚úÖ Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('üëª Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('‚úÖ No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`üëª Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nüí° These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('‚ùå Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('‚ö†Ô∏è This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('‚ùå Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('‚úÖ Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`üóëÔ∏è Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('üîç Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`üî• Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('‚úÖ Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('‚úÖ Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('‚ö†Ô∏è Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('‚úÖ Added to deletedOrders block list');
                } else {
                    console.log('‚ÑπÔ∏è Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\n‚úÖ Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  ‚úì Firestore database');
                console.log('  ‚úì Local data');
                console.log('  ‚úì Added to block list (deletedOrders)');
                console.log('  ‚úì Saved to localStorage');
                console.log('\nüõ°Ô∏è This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('üîç Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('üìä ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`‚ö†Ô∏è Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('‚úÖ Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nüì¶ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('‚ùå CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('üßπ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`‚ö†Ô∏è Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`‚úÖ Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`üìã Deleted orders list: ${before} ‚Üí ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('‚úÖ No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('üîçüîçüîç COMPREHENSIVE SYSTEM DIAGNOSTIC üîçüîçüîç\n');

                // 1. Check localStorage
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('1Ô∏è‚É£ LOCALSTORAGE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('‚úÖ localStorage exists');
                    console.log(`  üì¶ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  üì¶ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  üìã Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  üóëÔ∏è Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('‚ùå NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('2Ô∏è‚É£ CURRENT MEMORY (OMS.data)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  üì¶ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  üì¶ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  üìã Orders: ${OMS.data.orders.length}`);
                console.log(`  üóëÔ∏è Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('3Ô∏è‚É£ FIRESTORE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  üìã Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  üì¶ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  üì¶ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('4Ô∏è‚É£ MISMATCH ANALYSIS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  ‚ö†Ô∏è Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  ‚ùå DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  ‚úÖ ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  ‚ö†Ô∏è Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('5Ô∏è‚É£ RECOMMENDATIONS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  üí° Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN MEMORY!');
                    console.log('  üí° Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  üí° Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\n‚úÖ Diagnostic complete!\n');
            }
        };

        console.log('üõ†Ô∏è Admin utilities loaded. Available commands:');
        console.log('\nüìã ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - ‚≠ê PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nüì¶ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - ‚≠ê LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nüîç DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - ‚≠ê FULL SYSTEM DIAGNOSTIC (find all bugs)');

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'block';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Show fields needed for single day
            const readyTimeField = document.getElementById('readyTime');
            readyTimeField.parentElement.style.display = 'block';
            readyTimeField.required = true;

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // Set required fields
    document.getElementById('orderDate').required = true;
    document.getElementById('startDate').required = false;
    document.getElementById('endDate').required = false;

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Hide fields not needed for multi-day
            const readyTimeField = document.getElementById('readyTime');
            readyTimeField.parentElement.style.display = 'none';
            readyTimeField.required = false;
            document.getElementById('eventType').parentElement.style.display = 'none';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // Set required fields
    document.getElementById('orderDate').required = false;
    document.getElementById('startDate').required = true;
    document.getElementById('endDate').required = true;

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });
    }    
    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // Initialize Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyC5c2BmVHnbWlBwwHtFwll97nq_xOdqxCc",
                authDomain: "firepowersfx-2558.firebaseapp.com",
                projectId: "firepowersfx-2558",
                storageBucket: "firepowersfx-2558.firebasestorage.app",
                messagingSenderId: "723483292867",
                appId: "1:723483292867:web:d6d83a79ba87cd2dee5e76"
            };

            firebase.initializeApp(firebaseConfig);
            window.auth = firebase.auth();
            window.db = firebase.firestore();
            console.log('‚úÖ Firebase initialized successfully!');

            // Track token refresh errors to prevent infinite loops
            let tokenErrorCount = 0;
            let lastTokenError = 0;
            const TOKEN_ERROR_THRESHOLD = 3; // Sign out after 3 consecutive errors
            const TOKEN_ERROR_WINDOW = 10000; // 10 seconds window

            // Monitor for token refresh errors
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                return originalFetch.apply(this, args).catch(error => {
                    // Check if this is a token refresh error
                    if (args[0] && typeof args[0] === 'string' && args[0].includes('securetoken.googleapis.com')) {
                        const now = Date.now();

                        // Reset counter if errors are not consecutive (more than 10s apart)
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`‚ö†Ô∏è Firebase token refresh failed (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive errors, sign out user to force fresh login
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('‚ùå Multiple token refresh failures detected. Signing out to force fresh login...');
                            tokenErrorCount = 0; // Reset counter

                            // Sign out user
                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    }
                    throw error;
                }).then(response => {
                    // Check for 403 errors on token refresh
                    if (args[0] && typeof args[0] === 'string' &&
                        args[0].includes('securetoken.googleapis.com') &&
                        response.status === 403) {

                        const now = Date.now();

                        // Reset counter if errors are not consecutive
                        if (now - lastTokenError > TOKEN_ERROR_WINDOW) {
                            tokenErrorCount = 0;
                        }

                        tokenErrorCount++;
                        lastTokenError = now;

                        console.warn(`‚ö†Ô∏è Firebase token refresh 403 error (${tokenErrorCount}/${TOKEN_ERROR_THRESHOLD})`);

                        // If too many consecutive 403 errors, sign out user
                        if (tokenErrorCount >= TOKEN_ERROR_THRESHOLD) {
                            console.error('‚ùå Multiple 403 token errors detected. Signing out to force fresh login...');
                            tokenErrorCount = 0;

                            if (window.auth && window.auth.currentUser) {
                                window.auth.signOut().catch(err => {
                                    console.error('Error during forced sign out:', err);
                                });
                            }
                        }
                    } else {
                        // Reset counter on successful non-token requests
                        if (response.ok) {
                            tokenErrorCount = 0;
                        }
                    }
                    return response;
                });
            };

            // Check if user is logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    // User is logged in
                    console.log('‚úÖ User logged in:', user.email);
                    tokenErrorCount = 0; // Reset error counter on successful auth
                    document.getElementById('loginScreen').style.display = 'none';
                    document.querySelector('.app-container').style.display = 'flex';
                    OMS.init().then(() => OMS.updateAllDisplays());
                } else {
                    // User is logged out
                    console.log('‚ùå User not logged in');
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.querySelector('.app-container').style.display = 'none';
                }
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');
                
                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';
                
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('‚úÖ Login successful!');
                } catch (error) {
                    console.error('‚ùå Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });
            
    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('‚úÖ Date restrictions removed - can add orders from any date');
        });
    </script>
</body>
</html>
