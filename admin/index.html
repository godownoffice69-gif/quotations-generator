<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Gujarati:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --light: #f8fafc;
            --white: #ffffff;
            --text-dark: #1f2937;
            --text-gray: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        /* Dark Theme Variables */
        [data-theme="dark"] {
            --light: #1a1d23;
            --white: #242832;
            --text-dark: #e5e7eb;
            --text-gray: #9ca3af;
            --border: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.3);
            --bg-body: #0f1117;
            --bg-card: #1a1d23;
            --bg-hover: #2a2d35;
            --bg-input: #2a2d35;
            --table-header-bg: #1f2329;
            --modal-backdrop: rgba(0, 0, 0, 0.8);
        }

        /* Light Theme specific variables */
        [data-theme="light"], :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-hover: rgba(102, 126, 234, 0.05);
            --bg-input: #ffffff;
            --table-header-bg: #f8f9fa;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* Smooth transitions for theme switching */
        body, .card, .modal-content, .table-container, .form-input, .form-select, .form-textarea,
        .search-global input, .search-results, .search-dropdown, .stat-card, .calendar-container,
        .calendar-day, .toast, .loading, .nav-tabs, .table th {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        body {
            font-family: 'Segoe UI', 'Noto Sans Gujarati', sans-serif;
            background: var(--bg-body);
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Layout */
        .app-container { min-height: 100vh; display: flex; flex-direction: column; }
        
        .app-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--white);
            padding: 1rem 0;
            box-shadow: var(--shadow-lg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .company-name { font-size: 1.8rem; font-weight: 700; }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .search-global {
            position: relative;
            width: 300px;
        }

        .search-global input {
            width: 100%;
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        .search-global-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            max-height: 400px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
            margin-top: 0.25rem;
            box-shadow: var(--shadow-lg);
        }

        .search-results.show { display: block; }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-dark);
        }

        .search-result-item:hover { background: var(--bg-hover); }

        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-gray);
            text-transform: uppercase;
        }

        /* Navigation */
        .nav-tabs {
            background: var(--bg-card);
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            padding: 0 1rem;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-gray);
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-tab:hover { color: var(--primary); background: var(--bg-hover); }
        .nav-tab.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg-hover); }

        .main-content {
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
            width: 100%;
        }

        .tab-content { display: none; animation: fadeIn 0.3s ease-in; }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .card-header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Forms */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.95rem;
        }

        .form-label.required::after { content: ' *'; color: var(--danger); }

        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--bg-input);
            color: var(--text-dark);
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Noto Sans Gujarati', sans-serif;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            justify-content: center;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%); color: var(--white); }
        .btn-secondary { background: var(--white); color: var(--primary); border: 2px solid var(--primary); }
        .btn-success { background: var(--success); color: var(--white); }
        .btn-warning { background: var(--warning); color: var(--white); }
        .btn-danger { background: var(--danger); color: var(--white); }
        .btn-info { background: var(--info); color: var(--white); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.info { border-left-color: var(--info); }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: var(--text-gray);
            font-weight: 500;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th, .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--table-header-bg);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-dark);
        }

        .table tr:hover { background: var(--bg-hover); }
        .table tr:last-child td { border-bottom: none; }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-confirmed { background: rgba(16, 185, 129, 0.1); color: var(--success); }
        .status-completed { background: rgba(102, 126, 234, 0.1); color: var(--primary); }
        .status-cancelled { background: rgba(239, 68, 68, 0.1); color: var(--danger); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-backdrop);
            z-index: 2000;
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: 2rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-gray);
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border-left: 4px solid var(--success);
            padding: 1rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            color: var(--text-dark);
        }

        .toast.show { transform: translateX(0); }
        .toast.error { border-left-color: var(--danger); }
        .toast-actions { display: flex; gap: 0.5rem; }
        .toast-btn { background: none; border: none; color: var(--primary); cursor: pointer; font-weight: 500; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            text-align: center;
            color: var(--text-dark);
        }

        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--light);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Calendar */
        .calendar-container {
            background: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: var(--border);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .calendar-day-header {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .calendar-day {
            background: var(--bg-card);
            min-height: 100px;
            padding: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .calendar-day:hover { background: var(--bg-hover); }
        .calendar-day.today { background: rgba(102, 126, 234, 0.2); }
        .calendar-day.has-orders { border-left: 4px solid var(--success); }
        .calendar-day.has-tasks { border-right: 4px solid var(--warning); }
        .calendar-day.has-festival { border-top: 4px solid var(--danger); }

        .calendar-day-number {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .calendar-day-content {
            font-size: 0.8rem;
            color: var(--text-gray);
        }

        .festival-text {
            color: var(--danger);
            font-size: 0.7rem;
            font-weight: 500;
        }

        .order-count {
            background: var(--success);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
        }

        /* Quantity Controls */
        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quantity-btn {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-dark);
        }

        /* Search Dropdown */
        .search-container { position: relative; margin-bottom: 1rem; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius) var(--radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-dropdown.show { display: block; }

        .search-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-dark);
        }

        .search-item:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.3s ease;
        }

        /* Order ID Highlight */
        .order-id-highlight {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: bold;
            display: inline-block;
        }

        /* Print Template */
        .print-template {
            display: none;
            width: 2480px;
            min-height: 3508px;
            background: white;
            padding: 354px 118px 118px 590px;
            font-family: 'Noto Sans Gujarati', Arial, sans-serif;
            font-size: 32px;
            line-height: 1.4;
        }

        /* Undo Bar */
        .undo-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--text-dark);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 3000;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: transform 0.3s ease;
        }

        .undo-bar.show { transform: translateX(-50%) translateY(0); }

        .undo-btn {
            background: var(--white);
            color: var(--text-dark);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Quick Action Menu */
        .quick-menu {
            position: absolute;
            background: var(--white);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            padding: 0.5rem 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .quick-menu.show { display: block; }

        .quick-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .quick-menu-item:hover { background: var(--light); }

        /* Keyboard Shortcuts Panel */
        .shortcuts-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            z-index: 2500;
            max-width: 600px;
            display: none;
        }

        .shortcuts-panel.show { display: block; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-key {
            background: var(--light);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }

        /* Drag Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        /* Theme Toggle Button */
        .theme-toggle {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            padding: 2px;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .theme-toggle-slider {
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        [data-theme="dark"] .theme-toggle-slider {
            transform: translateX(30px);
        }

        .theme-toggle-icon {
            font-size: 14px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .form-grid { grid-template-columns: 1fr; }
            .form-row { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: 1fr; }
            .calendar-day { min-height: 80px; }
            .search-global { width: 200px; }
            .header-content { flex-direction: column; gap: 1rem; }
        }

        /* Utility Classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: 0.5rem; }
        .mb-1 { margin-bottom: 0.5rem; }
    </style>
    <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
</head>

<body>
    <!-- Login Screen -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 3rem; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h1 style="text-align: center; color: #667eea; margin-bottom: 2rem; font-size: 2rem;">üîê Admin Login</h1>
            
            <form id="loginForm">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Email</label>
                    <input type="email" id="loginEmail" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #333;">Password</label>
                    <input type="password" id="loginPassword" required style="width: 100%; padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
                </div>
                
                <div id="loginError" style="display: none; background: #fee; color: #c00; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                
                <button type="submit" id="loginBtn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                    Login
                </button>
            </form>
            
            <div style="margin-top: 1.5rem; text-align: center; font-size: 0.85rem; color: #666;">
                Admin or Owner access only
            </div>
        </div>
    </div>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="company-name">Order Management System</h1>
                <div class="header-controls">
                    <div class="search-global">
                        <input type="text" id="globalSearch" placeholder="üîç Search everything..." autocomplete="off">
                        <div class="search-results" id="globalSearchResults"></div>
                    </div>
                    <span id="currentOrderId" style="font-weight: bold;">Next: FP001</span>
                    <div class="theme-toggle" onclick="ThemeManager.toggleTheme()" title="Toggle Dark Mode">
                        <div class="theme-toggle-slider">
                            <span class="theme-toggle-icon" id="themeIcon">‚òÄÔ∏è</span>
                        </div>
                    </div>
                    <button class="btn btn-secondary btn-small" onclick="OMS.showShortcuts()">‚å®Ô∏è</button>
                    <button class="btn btn-danger btn-small" onclick="auth.signOut()">üö™ Logout</button>
                </div>
            </div>
        </header>

        <nav class="nav-tabs">
            <div class="nav-container">
                <button class="nav-tab active" data-tab="dashboard">üìä Dashboard</button>
                <button class="nav-tab" data-tab="orders">üìù Orders</button>
                <button class="nav-tab" data-tab="inventory">üì¶ Inventory</button>
                <button class="nav-tab" data-tab="preparation">üìã Preparation</button>
                <button class="nav-tab" data-tab="customers">üë• Customers</button>
                <button class="nav-tab" data-tab="team">üë∑ Team</button>
                <button class="nav-tab" data-tab="calendar">üóìÔ∏è Calendar</button>
                <button class="nav-tab" data-tab="history">üìö History</button>
                <button class="nav-tab" data-tab="analytics">üìà Analytics</button>
                <button class="nav-tab" data-tab="settings">‚öôÔ∏è Settings</button>
            </div>
        </nav>

        <main class="main-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="stats-grid" id="dashboardStats"></div>

                <!-- Smart Notifications Panel -->
                <div id="notificationsPanel" class="card" style="display:none; border-left: 4px solid var(--warning);">
                    <div class="card-header" style="background: transparent;">
                        <h2 class="card-title">üîî Action Required</h2>
                        <button class="btn btn-sm" onclick="OMS.dismissNotifications()">Dismiss All</button>
                    </div>
                    <div id="notificationsContent"></div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üçï Recent Orders</h2>
                    </div>
                    <div class="table-container" id="recentOrdersContainer"></div>
                </div>
                <div class="card">
                    <h3 class="card-title">Top Customer</h3>
                    <div id="topCustomerInfo"></div>
                </div>
            </div>

            <!-- Orders Tab -->
            <div id="orders" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">üìù Create New Order</h2>
                        <div class="progress-bar">
                            <div class="progress-fill" id="orderProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <form id="orderForm">
                        <div class="form-grid">
                            <div class="form-group" id="orderIdGroup">
                                <label class="form-label required">Order ID (Completed Orders Only)</label>
                                <input type="text" id="orderId" class="form-input">
                                <small style="color: var(--text-gray);">Only needed for completed orders. Leave empty for pending/confirmed.</small>
                            </div>
                            <div class="form-group">
    <label class="form-label required">Event Type</label>
    <select id="eventTypeSelect" class="form-select" required>
        <option value="single">Single Day Event</option>
        <option value="multi">Multi-Day Event</option>
    </select>
</div>

<!-- Single Day Fields -->
<div id="singleDayFields" class="form-group">
    <label class="form-label required">Event Date</label>
    <input type="date" id="orderDate" class="form-input" required>
</div>

<!-- Multi-Day Fields -->
<div id="multiDayFields" class="form-grid" style="display: none;">
    <div class="form-group">
        <label class="form-label required">Start Date</label>
        <input type="date" id="startDate" class="form-input">
    </div>
    <div class="form-group">
        <label class="form-label required">End Date</label>
        <input type="date" id="endDate" class="form-input">
    </div>
    <div class="form-group">
        <label class="form-label">Total Days</label>
        <input type="text" id="totalDays" class="form-input" readonly>
    </div>
</div>

<!-- Day-wise Functions Container -->
<div id="dayWiseFunctions" style="display: none;">
    <div class="card">
        <h3 class="card-title">üìÖ Day-wise Functions</h3>
        <div id="functionsContainer"></div>
    </div>
</div>
                            <div class="form-group">
                                <label class="form-label required">Ready Time</label>
                                <select id="readyTime" class="form-select" required></select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label required">Client Name</label>
                                <div class="search-container">
                                    <input type="text" id="clientName" class="form-input" placeholder="Start typing..." required>
                                    <div id="clientSearchDropdown" class="search-dropdown"></div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Contact</label>
                                <input type="tel" id="contact" class="form-input" required>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Venue</label>
                                <input type="text" id="venue" class="form-input" required>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Event Type</label>
                                <input type="text" id="eventType" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Transport</label>
                                <select id="transport" class="form-select" required>
                                    <option value="">Select</option>
                                    <option value="Bolero">Bolero</option>
                                    <option value="Isuzu">Isuzu</option>
                                    <option value="Porter">Porter</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="form-group hidden" id="customTransportGroup">
                                <label class="form-label">Custom Transport</label>
                                <input type="text" id="customTransport" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Driver</label>
                                <select id="driverName" class="form-select">
                                    <option value="">Select Driver</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">Operator</label>
                                <select id="operator" class="form-select">
                                    <option value="">Select Operator</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label required">Status</label>
                                <select id="orderStatus" class="form-select" required>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Cancelled">Cancelled</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Helper</label>
                                <select id="helper" class="form-select">
                                    <option value="">Select Helper</option>
                                </select>
                            </div>
                        </div>

                        <div class="btn-group" style="margin-top: 0.5rem;">
                            <button type="button" class="btn btn-success" onclick="OMS.notifyAllocatedTeam()">üì± Notify Allocated Team</button>
                            <button type="button" class="btn btn-info" onclick="OMS.sendManagerReport()">üìä Send Manager Report</button>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Notes</label>
                            <textarea id="orderNotes" class="form-textarea"></textarea>
                        </div>

                        <div class="card">
                            <h3 class="card-title">üì¶ Order Items</h3>
                            <div class="search-container">
                                <input type="text" id="itemSearch" class="form-input" placeholder="üîç Search items..." autocomplete="off">
                                <div id="itemSearchDropdown" class="search-dropdown"></div>
                            </div>
                            <div class="table-container" id="orderItemsContainer"></div>
                        </div>

                        <div class="btn-group">
                            <button type="submit" class="btn btn-primary">üíæ Save Order (Ctrl+S)</button>
                            <button type="button" class="btn btn-secondary" data-action="preview">üëÅÔ∏è Preview</button>
                            <button type="button" class="btn btn-info" data-action="duplicate">üìã Duplicate Last</button>
                            <button type="button" class="btn btn-warning" data-action="sameDay">üìÖ Same Day</button>
                            <button type="button" class="btn btn-danger" data-action="clear">üóëÔ∏è Clear (Ctrl+D)</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Other tabs will be dynamically populated -->
            <div id="inventory" class="tab-content"></div>
            <div id="preparation" class="tab-content"></div>
            <div id="customers" class="tab-content"></div>
            <div id="team" class="tab-content"></div>
            <div id="calendar" class="tab-content"></div>
            <div id="history" class="tab-content"></div>
            <div id="analytics" class="tab-content"></div>
            <div id="settings" class="tab-content"></div>
        </main>
    </div>

    <!-- Modals Container -->
    <div id="modalsContainer"></div>

    <!-- Print Template -->
    <div id="printTemplate" class="print-template"></div>

    <!-- Undo Bar -->
    <div id="undoBar" class="undo-bar">
        <span id="undoMessage"></span>
        <button class="undo-btn" onclick="OMS.undo()">Undo</button>
    </div>

    <!-- Shortcuts Panel -->
    <div id="shortcutsPanel" class="shortcuts-panel">
        <button class="modal-close" onclick="OMS.hideShortcuts()">√ó</button>
        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <div style="margin-top: 1rem;">
            <div class="shortcut-item">
                <span>Save Order</span>
                <span class="shortcut-key">Ctrl + S</span>
            </div>
            <div class="shortcut-item">
                <span>New Order</span>
                <span class="shortcut-key">Ctrl + N</span>
            </div>
            <div class="shortcut-item">
                <span>Clear Form</span>
                <span class="shortcut-key">Ctrl + D</span>
            </div>
            <div class="shortcut-item">
                <span>Global Search</span>
                <span class="shortcut-key">Ctrl + K</span>
            </div>
            <div class="shortcut-item">
                <span>Show Shortcuts</span>
                <span class="shortcut-key">Ctrl + /</span>
            </div>
        </div>
    </div>

    <script>
        
        // ============ UTILITIES ============
        const Utils = {
            get: (id, defaultValue = '') => {
                const el = document.getElementById(id);
                return el ? (el.value || '').toString().trim() : defaultValue;
            },

            set: (id, value) => {
                const el = document.getElementById(id);
                if (el) el.value = value;
            },

            elem: (tag, props = {}, children = []) => {
                const el = document.createElement(tag);
                Object.entries(props).forEach(([key, val]) => {
                    if (key === 'class') el.className = val;
                    else if (key === 'style') Object.assign(el.style, val);
                    else if (key.startsWith('on')) el.addEventListener(key.slice(2), val);
                    else if (key.startsWith('data-')) el.dataset[key.slice(5)] = val;
                    else el[key] = val;
                });
                children.forEach(child => {
                    el.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
                });
                return el;
            },

            formatDate: (dateStr) => {
    if (!dateStr) return 'N/A';
    try {
        const date = new Date(dateStr + 'T00:00:00');
        return date.toLocaleDateString('en-GB');
    } catch {
        return dateStr;
    }
},

convertDateFormat: (dateStr) => {
    if (!dateStr) return '';
    try {
        // Convert DD/MM/YYYY to YYYY-MM-DD
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            const day = parts[0].padStart(2, '0');
            const month = parts[1].padStart(2, '0');
            const year = parts[2];
            return `${year}-${month}-${day}`;
        }
        return dateStr;
    } catch {
        return dateStr;
    }
},

getLocalDate: (dateStr) => {
    if (!dateStr) return new Date();
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day);
},

toDateString: (date) => {
    const d = date instanceof Date ? date : new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
},

generateId: () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

debounce: (func, wait) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
},

            validateRequired: (fields) => {
                const errors = [];
                fields.forEach(field => {
                    const value = Utils.get(field);
                    if (!value) errors.push(field);
                });
                return errors;
            }
        };

        // ============ THEME MANAGER ============
        const ThemeManager = {
            init: () => {
                // Load saved theme from localStorage or default to 'light'
                const savedTheme = localStorage.getItem('admin-theme') || 'light';
                ThemeManager.setTheme(savedTheme);
            },

            setTheme: (theme) => {
                // Set the theme attribute on the HTML element
                document.documentElement.setAttribute('data-theme', theme);

                // Update the icon
                const icon = document.getElementById('themeIcon');
                if (icon) {
                    icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
                }

                // Save to localStorage
                localStorage.setItem('admin-theme', theme);
            },

            toggleTheme: () => {
                // Get current theme
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';

                // Toggle to opposite theme
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';

                // Apply new theme
                ThemeManager.setTheme(newTheme);
            },

            getTheme: () => {
                return document.documentElement.getAttribute('data-theme') || 'light';
            }
        };

        // Initialize theme on page load
        ThemeManager.init();

        // ============ MAIN APP ============
const OMS = {
            initialized: false,
            realtimeListenerActive: false,
    ordersUnsubscribe: null,
            data: {
                orders: [],
                customers: [],
                team: [],
                inventory: { categories: [], items: [] },
                tasks: [],
                deletedOrders: [],
                undoStack: [],
                notifications: [],
                settings: {
                    printFontSize: 32,
                    orderIdCounter: 1,
                    invoicePrefix: 'FP',
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    lowStockThreshold: 5,
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff'
                    },
                    // Color coding for different order/event types
                    eventTypeColors: {
                        'Wedding': '#e91e63',
                        'Birthday': '#ff9800',
                        'Corporate': '#2196f3',
                        'Anniversary': '#9c27b0',
                        'Festival': '#4caf50',
                        'Party': '#ff5722',
                        'Meeting': '#607d8b',
                        'Conference': '#3f51b5',
                        'default': '#667eea'
                    },
                    statusColors: {
                        'pending': '#ff9800',
                        'confirmed': '#2196f3',
                        'completed': '#4caf50',
                        'cancelled': '#f44336'
                    }
                }
            },

            currentOrderItems: [],
            currentTab: 'dashboard',
            
            festivals: {
                "2025-01-14": ["‡§Æ‡§ï‡§∞ ‡§∏‡§Ç‡§ï‡•ç‡§∞‡§æ‡§Ç‡§§‡§ø", "Makar Sankranti"],
                "2025-01-26": ["‡§ó‡§£‡§§‡§Ç‡§§‡•ç‡§∞ ‡§¶‡§ø‡§µ‡§∏", "Republic Day"],
                "2025-02-13": ["‡§Æ‡§π‡§æ ‡§∂‡§ø‡§µ‡§∞‡§æ‡§§‡•ç‡§∞‡§ø", "Maha Shivratri"],
                "2025-03-13": ["‡§π‡•ã‡§≤‡•Ä", "Holi"],
                "2025-03-14": ["‡§ß‡•Å‡§≤‡•á‡§ü‡•Ä", "Dhuleti"],
                "2025-04-06": ["‡§∞‡§æ‡§Æ ‡§®‡§µ‡§Æ‡•Ä", "Ram Navami"],
                "2025-08-15": ["‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞‡§§‡§æ ‡§¶‡§ø‡§µ‡§∏", "Independence Day"],
                "2025-08-19": ["‡§ú‡§®‡•ç‡§Æ‡§æ‡§∑‡•ç‡§ü‡§Æ‡•Ä", "Janmashtami"],
                "2025-10-02": ["‡§ó‡§æ‡§Ç‡§ß‡•Ä ‡§ú‡§Ø‡§Ç‡§§‡•Ä", "Gandhi Jayanti"],
                "2025-11-01": ["‡§ß‡§®‡§§‡•á‡§∞‡§∏", "Dhanteras"],
                "2025-11-02": ["‡§¶‡•Ä‡§µ‡§æ‡§≤‡•Ä", "Diwali"]
            },

    async init() {
                // Prevent duplicate initialization
    if (this.initialized) {
        console.log('‚ö†Ô∏è Already initialized - skipping duplicate init');
        return;
    }
    
    console.log('üöÄ Initializing OMS...');
    this.initialized = true;
    await this.loadFromStorage();
    await this.loadTrackingFromFirestore();
    this.setupRealtimeListeners();
    this.setupEventDelegation();
                this.setupKeyboardShortcuts();
                this.setupAutoSave();
                this.setupDragDrop();
                this.setupAutoBackup(); // Automatic backup system
                this.populateTimeDropdown();
                this.loadDemoData();
                this.updateAllDisplays();
                this.initGlobalSearch();
            },

            // ============ EVENT DELEGATION ============
    setupEventDelegation() {
                document.addEventListener('click', (e) => {
                    const action = e.target.closest('[data-action]')?.dataset.action;
                    const id = e.target.closest('[data-id]')?.dataset.id;
                    const type = e.target.closest('[data-type]')?.dataset.type;

                    if (!action) return;

                    e.preventDefault();
                    const handlers = {
    'preview': () => OMS.previewOrder(),
    'duplicate': () => OMS.duplicateLastOrder(),
    'sameDay': () => OMS.downloadSameDayOrders(),
    'clear': () => OMS.clearForm(),
    'edit': () => OMS.editItem(type, id),
    'delete': () => OMS.deleteItem(type, id),
    'print': () => OMS.downloadOrderImage(id),
    'quickAction': () => OMS.showQuickMenu(e.target, id),
    'undo': () => OMS.undo(),
    'exportData': () => OMS.exportData(),
    'importData': () => OMS.importData()
};

                    handlers[action]?.();
                });

                // Navigation - use event delegation on parent
                document.querySelector('.nav-container')?.addEventListener('click', (e) => {
                    const tab = e.target.closest('.nav-tab');
                    if (tab && tab.dataset.tab) {
                        this.switchTab(tab.dataset.tab);
                    }
                });

                // Close dropdowns on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        document.querySelectorAll('.search-dropdown').forEach(d => d.classList.remove('show'));
                    }
                });
    },
    generateDayWiseFunctions() {
        const container = document.getElementById('functionsContainer');
        if (!container) return;
        
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (!startDate || !endDate) {
            container.innerHTML = '';
            return;
        }
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;
        
        let html = '';
        for (let i = 0; i < diffDays; i++) {
            const currentDate = new Date(start);
            currentDate.setDate(start.getDate() + i);
            const dateStr = currentDate.toLocaleDateString('en-IN', { 
                weekday: 'short', 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
            
            html += `
                <div class="card" style="background: rgba(102, 126, 234, 0.05); margin-bottom: 1.5rem;" id="day${i}Card">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">Day ${i + 1} - ${dateStr}</h4>
                    
                    <div id="day${i}FunctionsContainer">
                        <!-- Functions will be added here -->
                    </div>
                    
                    <button type="button" class="btn btn-secondary" onclick="OMS.addFunctionToDay(${i})" style="width: 100%; margin-top: 1rem;">
                        ‚ûï Add Function to This Day
                    </button>
                </div>
            `;
        }
        
        container.innerHTML = html;
        
        // Initialize first function for each day
        setTimeout(() => {
            for (let i = 0; i < diffDays; i++) {
                OMS.addFunctionToDay(i, true); // true = first function (auto-add)
            }
        }, 100);
    },
    addFunctionToDay(dayIndex, isFirst = false) {
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (!container) return;
        
        // Initialize functions array for this day
        if (!window.dayFunctionsData) {
            window.dayFunctionsData = {};
        }
        if (!window.dayFunctionsData[dayIndex]) {
            window.dayFunctionsData[dayIndex] = [];
        }
        
        const functionIndex = window.dayFunctionsData[dayIndex].length;
        const functionId = `day${dayIndex}func${functionIndex}`;
        
        // Add function data
        window.dayFunctionsData[dayIndex].push({
            functionType: '',
            timeSlot: '',
            driver: '',
            operator: '',
            helper: '',
            notes: '',
            items: []
        });
        
        // Create function HTML
        const functionHTML = `
            <div class="card" style="margin-bottom: 1rem;" id="${functionId}Card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h5 style="color: var(--primary); margin: 0;">Function ${functionIndex + 1}</h5>
                    ${!isFirst ? `<button type="button" class="btn btn-danger btn-small" onclick="OMS.removeFunctionFromDay(${dayIndex}, ${functionIndex})">üóëÔ∏è Remove</button>` : ''}
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Function Type</label>
                        <input type="text" id="${functionId}Type" class="form-input" 
                               placeholder="e.g., Sangeet, Reception" 
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'functionType', this.value)">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Time Slot</label>
                        <input type="text" id="${functionId}Time" class="form-input" 
                               placeholder="e.g., 5:00 PM - 9:00 PM"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'timeSlot', this.value)">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Driver</label>
                        <select id="${functionId}Driver" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'driver', this.value)">
                            <option value="">Select Driver</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Operator</label>
                        <select id="${functionId}Operator" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'operator', this.value)">
                            <option value="">Select Operator</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Helper</label>
                        <select id="${functionId}Helper" class="form-select"
                               onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'helper', this.value)">
                            <option value="">Select Helper</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Notes</label>
                    <textarea id="${functionId}Notes" class="form-textarea" 
                              placeholder="Special requirements for this function..."
                              onchange="OMS.updateFunctionData(${dayIndex}, ${functionIndex}, 'notes', this.value)"></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Items for this function</label>
                    <div class="search-container">
                        <input type="text" id="${functionId}ItemSearch" class="form-input" 
                               placeholder="üîç Search items..." autocomplete="off">
                        <div id="${functionId}ItemDropdown" class="search-dropdown"></div>
                    </div>
                </div>
                
                <div id="${functionId}ItemsList" class="table-container" style="margin-top: 1rem;">
                    <div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>
                </div>
            </div>
        `;
        
        container.insertAdjacentHTML('beforeend', functionHTML);

        // Setup item search for this function
        this.setupFunctionItemSearch(dayIndex, functionIndex);

        // Populate team dropdowns for this function
        this.populateFunctionTeamDropdowns(dayIndex, functionIndex);
    },
    updateFunctionData(dayIndex, functionIndex, field, value) {
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        window.dayFunctionsData[dayIndex][functionIndex][field] = value;
    },

    removeFunctionFromDay(dayIndex, functionIndex) {
        if (!window.dayFunctionsData?.[dayIndex]) return;
        
        const functionId = `day${dayIndex}func${functionIndex}`;
        const card = document.getElementById(`${functionId}Card`);
        if (card) {
            card.remove();
        }
        
        // Remove from data
        window.dayFunctionsData[dayIndex].splice(functionIndex, 1);
        
        // Re-render all functions for this day to fix indices
        const container = document.getElementById(`day${dayIndex}FunctionsContainer`);
        if (container) {
            container.innerHTML = '';
            const functionsCount = window.dayFunctionsData[dayIndex].length;
            
            // Re-add all remaining functions
            const tempData = [...window.dayFunctionsData[dayIndex]];
            window.dayFunctionsData[dayIndex] = [];
            
            tempData.forEach((funcData, idx) => {
                this.addFunctionToDay(dayIndex, idx === 0);
                // Restore data
                Object.keys(funcData).forEach(key => {
                    if (key !== 'items') {
                        const functionId = `day${dayIndex}func${idx}`;
                        const input = document.getElementById(`${functionId}${key.charAt(0).toUpperCase() + key.slice(1)}`);
                        if (input) input.value = funcData[key];
                        window.dayFunctionsData[dayIndex][idx][key] = funcData[key];
                    }
                });
                window.dayFunctionsData[dayIndex][idx].items = funcData.items;
                this.updateFunctionItemsList(dayIndex, idx);
            });
        }
    },

    setupFunctionItemSearch(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length > 0) {
                const items = this.data.inventory.items.filter(i => 
                    i.name.toLowerCase().includes(query)
                );
                
                if (items.length > 0) {
                    dropdown.innerHTML = items.map(i => `
                        <div class="search-item" onclick="OMS.addItemToFunction(${dayIndex}, ${functionIndex}, '${i.id}')">
                            <span>${i.name}</span>
                            <span>${i.quantity} in stock</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('show');
                } else {
                    dropdown.classList.remove('show');
                }
            } else {
                dropdown.classList.remove('show');
            }
        });
    },
    addItemToFunction(dayIndex, functionIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        if (!window.dayFunctionsData?.[dayIndex]?.[functionIndex]) return;
        
        const funcItems = window.dayFunctionsData[dayIndex][functionIndex].items;
        
        // Check if item already added
        const existing = funcItems.find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            funcItems.push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateFunctionItemsList(dayIndex, functionIndex);
        
        // Clear search
        const functionId = `day${dayIndex}func${functionIndex}`;
        const searchInput = document.getElementById(`${functionId}ItemSearch`);
        const dropdown = document.getElementById(`${functionId}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateFunctionItemsList(dayIndex, functionIndex) {
        const functionId = `day${dayIndex}func${functionIndex}`;
        const container = document.getElementById(`${functionId}ItemsList`);
        if (!container) return;
        
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustFunctionItemQty(${dayIndex}, ${functionIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setFunctionItemRemarks(${dayIndex}, ${functionIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeFunctionItem(${dayIndex}, ${functionIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustFunctionItemQty(dayIndex, functionIndex, itemIndex, delta) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, items[itemIndex].quantity + delta);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemQty(dayIndex, functionIndex, itemIndex, qty) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].quantity = Math.max(1, parseInt(qty) || 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },

    setFunctionItemRemarks(dayIndex, functionIndex, itemIndex, remarks) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items?.[itemIndex]) return;
        
        items[itemIndex].remarks = remarks;
    },

    removeFunctionItem(dayIndex, functionIndex, itemIndex) {
        const items = window.dayFunctionsData?.[dayIndex]?.[functionIndex]?.items;
        if (!items) return;
        
        items.splice(itemIndex, 1);
        this.updateFunctionItemsList(dayIndex, functionIndex);
    },
    addItemToDay(dayIndex, itemId) {
        const item = this.data.inventory.items.find(i => i.id === itemId);
        if (!item) return;
        
        // Initialize day items array if not exists
        if (!this.dayWiseItems) {
            this.dayWiseItems = {};
        }
        if (!this.dayWiseItems[dayIndex]) {
            this.dayWiseItems[dayIndex] = [];
        }
        
        // Check if item already added
        const existing = this.dayWiseItems[dayIndex].find(i => i.itemId === itemId);
        if (existing) {
            existing.quantity++;
        } else {
            this.dayWiseItems[dayIndex].push({
                itemId: itemId,
                name: item.name,
                quantity: 1,
                remarks: ''
            });
        }
        
        this.updateDayItemsList(dayIndex);
        
        // Clear search and hide dropdown
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        if (searchInput) searchInput.value = '';
        if (dropdown) dropdown.classList.remove('show');
    },

    updateDayItemsList(dayIndex) {
        const container = document.getElementById(`day${dayIndex}ItemsList`);
        if (!container) return;
        
        const items = this.dayWiseItems?.[dayIndex] || [];
        
        if (items.length === 0) {
            container.innerHTML = '<div style="color: var(--text-gray); text-align: center; padding: 1rem;">No items added yet</div>';
            return;
        }
        
        container.innerHTML = `
            <table class="table">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Qty</th>
                        <th>Remarks</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    ${items.map((item, idx) => `
                        <tr>
                            <td>${item.name}</td>
                            <td>
                                <div class="quantity-controls">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, -1)">-</button>
                                    <input type="number" value="${item.quantity}" 
                                           onchange="OMS.setDayItemQty(${dayIndex}, ${idx}, this.value)" 
                                           style="width: 60px; text-align: center; border: 1px solid var(--border); border-radius: 4px; padding: 0.25rem;" 
                                           min="1">
                                    <button class="quantity-btn" onclick="OMS.adjustDayItemQty(${dayIndex}, ${idx}, 1)">+</button>
                                </div>
                            </td>
                            <td>
                                <input type="text" class="form-input" value="${item.remarks || ''}" 
                                       onchange="OMS.setDayItemRemarks(${dayIndex}, ${idx}, this.value)" 
                                       placeholder="Notes">
                            </td>
                            <td>
                                <button class="btn btn-danger btn-small" onclick="OMS.removeDayItem(${dayIndex}, ${idx})">üóëÔ∏è</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    },

    adjustDayItemQty(dayIndex, itemIndex, delta) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, item.quantity + delta);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemQty(dayIndex, itemIndex, qty) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.quantity = Math.max(1, parseInt(qty) || 1);
            this.updateDayItemsList(dayIndex);
        }
    },

    setDayItemRemarks(dayIndex, itemIndex, remarks) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        const item = this.dayWiseItems[dayIndex][itemIndex];
        if (item) {
            item.remarks = remarks;
        }
    },

    removeDayItem(dayIndex, itemIndex) {
        if (!this.dayWiseItems?.[dayIndex]) return;
        this.dayWiseItems[dayIndex].splice(itemIndex, 1);
        this.updateDayItemsList(dayIndex);
    },

    // ============ KEYBOARD SHORTCUTS ============
    setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        const shortcuts = {
                            's': () => { e.preventDefault(); this.saveOrder(); },
                            'n': () => { e.preventDefault(); this.switchTab('orders'); this.clearForm(); },
                            'd': () => { e.preventDefault(); this.clearForm(); },
                            'k': () => { e.preventDefault(); document.getElementById('globalSearch').focus(); },
                            '/': () => { e.preventDefault(); this.showShortcuts(); },
                            'z': () => { e.preventDefault(); this.undo(); }
                        };
                        shortcuts[e.key]?.();
                    }
                });
            },

            showShortcuts() {
                document.getElementById('shortcutsPanel').classList.add('show');
            },

            hideShortcuts() {
                document.getElementById('shortcutsPanel').classList.remove('show');
            },

            // ============ AUTO-SAVE ============
            setupAutoSave() {
                setInterval(() => {
                    const form = document.getElementById('orderForm');
                    if (form && this.hasUnsavedChanges()) {
                        localStorage.setItem('oms_draft', JSON.stringify(this.collectFormData()));
                    }
                }, 30000); // Auto-save every 30 seconds
            },

            hasUnsavedChanges() {
                return Utils.get('clientName') || this.currentOrderItems.length > 0;
            },

            // ============ DRAG & DROP ============
            setupDragDrop() {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone hidden';
                dropZone.innerHTML = '<h2>Drop JSON backup file here</h2>';
                document.body.appendChild(dropZone);

                ['dragenter', 'dragover'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('hidden');
                        dropZone.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(event => {
                    document.addEventListener(event, (e) => {
                        e.preventDefault();
                        dropZone.classList.add('hidden');
                        dropZone.classList.remove('dragover');
                    });
                });

                document.addEventListener('drop', (e) => {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.json')) {
                        this.handleImportFile(file);
                    }
                });
            },

            // ============ AUTOMATIC BACKUP SYSTEM ============
            setupAutoBackup() {
                // Auto-export every 24 hours
                const BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours

                setInterval(() => {
                    this.autoExportData();
                }, BACKUP_INTERVAL);

                // Also backup on significant changes
                let changeCounter = 0;
                const originalSaveToStorage = this.saveToStorage.bind(this);
                this.saveToStorage = function() {
                    originalSaveToStorage();
                    changeCounter++;

                    // Backup every 50 changes
                    if (changeCounter >= 50) {
                        this.autoExportData();
                        changeCounter = 0;
                    }
                };

                console.log('‚úÖ Auto-backup system initialized (exports every 24h or 50 changes)');
            },

            autoExportData() {
                try {
                    const exportData = {
                        exportDate: new Date().toISOString(),
                        version: '2.0',
                        data: {
                            orders: this.data.orders,
                            customers: this.data.customers,
                            inventory: this.data.inventory,
                            team: this.data.team,
                            settings: this.data.settings,
                            tasks: this.data.tasks,
                            orderAuditLog: this.data.orderAuditLog || {}
                        },
                        stats: {
                            totalOrders: this.data.orders.length,
                            totalCustomers: this.data.customers.length,
                            totalInventoryItems: this.data.inventory.items.length
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `OMS_AutoBackup_${Utils.toDateString(new Date())}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    console.log('‚úÖ Auto-backup created successfully');
                    this.showToast('üì¶ Auto-backup created', 'success');
                } catch (error) {
                    console.error('‚ùå Auto-backup failed:', error);
                }
            },

            // Manual export function (can be called anytime)
            manualExport() {
                this.autoExportData();
                this.showToast('üì• Manual backup created!', 'success');
            },

            // ============ GLOBAL SEARCH ============
            initGlobalSearch() {
                const input = document.getElementById('globalSearch');
                const results = document.getElementById('globalSearchResults');

                input.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    if (query.length < 2) {
                        results.classList.remove('show');
                        return;
                    }

                    const searchResults = this.performGlobalSearch(query);
                    this.displayGlobalSearchResults(searchResults);
                }, 300));

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        results.classList.remove('show');
                        input.value = '';
                    }
                });
            },

            performGlobalSearch(query) {
                const results = [];

                // Search orders
                this.data.orders.forEach(order => {
                    if (order.orderId.toLowerCase().includes(query) ||
                        order.clientName.toLowerCase().includes(query) ||
                        order.venue.toLowerCase().includes(query)) {
                        results.push({ type: 'order', data: order });
                    }
                });

                // Search customers
                this.data.customers.forEach(customer => {
                    if (customer.name.toLowerCase().includes(query) ||
                        customer.contact.includes(query)) {
                        results.push({ type: 'customer', data: customer });
                    }
                });

                // Search inventory
                this.data.inventory.items.forEach(item => {
                    if (item.name.toLowerCase().includes(query)) {
                        results.push({ type: 'item', data: item });
                    }
                });

                return results.slice(0, 10);
            },

            displayGlobalSearchResults(results) {
                const container = document.getElementById('globalSearchResults');
                if (results.length === 0) {
                    container.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    container.innerHTML = results.map(r => `
                        <div class="search-result-item" onclick="OMS.navigateToResult('${r.type}', '${r.data.id || r.data.orderId}')">
                            <div>
                                <div class="search-result-type">${r.type}</div>
                                <div>${r.type === 'order' ? r.data.orderId + ' - ' + r.data.clientName : 
                                       r.type === 'customer' ? r.data.name : r.data.name}</div>
                            </div>
                        </div>
                    `).join('');
                }
                container.classList.add('show');
            },

            navigateToResult(type, id) {
                const tabMap = { order: 'history', customer: 'customers', item: 'inventory' };
                this.switchTab(tabMap[type]);
                document.getElementById('globalSearchResults').classList.remove('show');
                document.getElementById('globalSearch').value = '';
            },

            // ============ CRUD OPERATIONS ============
            createItem(type, data) {
                const handlers = {
                    order: () => {
                        const isDuplicate = this.data.orders.some(o => o.orderId === data.orderId);
                        if (isDuplicate) {
                            this.showToast('Order ID already exists!', 'error');
                            return false;
                        }
                        
                        this.addToUndoStack('create', 'order', data);
                        this.data.orders.push(data);
                        this.updateCustomerDatabase(data);
                        this.incrementOrderCounter();
                        return true;
                    },
                    category: () => {
                        this.data.inventory.categories.push(data);
                        return true;
                    },
                    item: () => {
                        this.data.inventory.items.push(data);
                        return true;
                    },
                    task: () => {
                        this.data.tasks.push(data);
                        return true;
                    }
                };
                return handlers[type]?.() || false;
            },

async updateItem(type, id, newData) {
    const handlers = {
        order: async () => {
    try {
        // Find the document by orderId field (instead of doc(id))
        const snapshot = await db.collection('orders')
            .where('orderId', '==', id)
            .get();
            console.log('üî• Deleting orderId:', id);
console.log('Firestore snapshot size:', snapshot.size);
snapshot.forEach(doc => console.log('Found Firestore doc ID:', doc.id));

        if (snapshot.empty) {
            console.warn('No Firestore doc found for', id);
            return false;
        }

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`üî• Deleted ${snapshot.size} Firestore doc(s) for orderId ${id}`);

        // Local delete
        const index = this.data.orders.findIndex(o => o.orderId === id);
        if (index !== -1) {
            const deleted = this.data.orders.splice(index, 1)[0];
            this.addToUndoStack('delete', 'order', deleted);
            this.data.deletedOrders.push({
                ...deleted,
                deletedAt: new Date().toISOString(),
                deleteReason: 'Manual deletion'
            });
        }

        return true;
    } catch (error) {
        console.error('Error deleting Firestore order:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            this.data.tasks[index] = { ...this.data.tasks[index], ...newData };
            return true;
        }
    };

    return handlers[type]?.() || false;
},

// ============ DELETE ITEM ============
async deleteItem(type, id) {
    console.log('Auth user during delete:', firebase.auth().currentUser?.email || 'none');
    console.log('üß© deleteItem CALLED');
    console.log('type:', type);
    console.log('id:', id);

    const confirmations = {
        order: 'Delete this order?',
        category: 'Delete category and all items?',
        item: 'Delete this item?',
        task: 'Delete this task?'
    };

    if (!confirm(confirmations[type] || 'Delete this item?')) return false;

    const handlers = {
order: async () => {
    const index = this.data.orders.findIndex(o => o.orderId === id);
    if (index === -1) {
        console.warn('‚ö†Ô∏è Order not found in local array:', id);
        return false;
    }

    try {
        console.log('üîÑ Attempting to delete orderId:', id);

        // Delete directly by document ID (since doc ID = orderId)
        const docRef = db.collection('orders').doc(id);
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            await docRef.delete();
            console.log('‚úÖ Deleted Firestore doc with ID:', id);
        } else {
            console.warn('‚ö†Ô∏è No Firestore document found with ID:', id);
            // Continue with local deletion even if Firestore doc doesn't exist
        }

        // Delete from local array FIRST
        const deleted = this.data.orders.splice(index, 1)[0];

        // Add to deletedOrders to prevent reappearing
        const deletedRecord = {
            ...deleted,
            deletedAt: new Date().toISOString(),
            deleteReason: 'Manual deletion'
        };
        this.data.deletedOrders.push(deletedRecord);

        // CRITICAL: Save to localStorage immediately
        this.saveToStorage();
        console.log(`üìù Saved deletedOrders list (${this.data.deletedOrders.length} total)`);

        // Add to undo stack
        this.addToUndoStack('delete', 'order', deleted);

        return true;
    } catch (error) {
        console.error('‚ùå Delete error:', error);
        this.showToast('Delete failed: ' + error.message, 'error');
        return false;
    }
},

        category: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'category');

                // Delete from local array
                this.data.inventory.categories = this.data.inventory.categories.filter(c => c.id !== id);
                this.data.inventory.items = this.data.inventory.items.filter(i => i.categoryId !== id);

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting category:', error);
                return false;
            }
        },

        item: async () => {
            try {
                // Delete from Firestore
                await this.deleteInventoryItemFromFirestore(id, 'item');

                // Delete from local array
                this.data.inventory.items = this.data.inventory.items.filter(i => i.id !== id);

                return true;
            } catch (error) {
                console.error('‚ùå Error deleting item:', error);
                return false;
            }
        },

        task: () => {
            const index = this.data.tasks.findIndex(t => t.id === id);
            if (index === -1) return false;
            const deleted = this.data.tasks.splice(index, 1)[0];
            this.addToUndoStack('delete', 'task', deleted);
            return true;
        }
    };

    let success = false;
    if (handlers[type]) success = await handlers[type]();

    if (success) {
        this.saveToStorage();
        this.updateAllDisplays();
        this.showToast(`${type} deleted successfully`);
        this.showUndoBar(`${type} deleted`);
    }

    return success;
},


async editItem(type, id) {
                const handlers = {
                    order: () => {
                        const order = this.data.orders.find(o => o.orderId === id);
                        if (!order) return;
                        this.switchTab('orders');
                        this.loadOrderToForm(order);
                    },
                    task: () => {
                        const task = this.data.tasks.find(t => t.id === id);
                        if (!task) return;
                        this.showTaskEditModal(task);
                    }
                };
                handlers[type]?.();
            },

            // ============ UNDO FUNCTIONALITY ============
            addToUndoStack(action, type, data) {
                this.data.undoStack.push({ action, type, data, timestamp: Date.now() });
                if (this.data.undoStack.length > 10) this.data.undoStack.shift();
            },

            undo() {
                const lastAction = this.data.undoStack.pop();
                if (!lastAction) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                const { action, type, data } = lastAction;
                
                if (action === 'delete' && type === 'order') {
                    this.data.orders.push(data);
                    this.data.deletedOrders = this.data.deletedOrders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'create' && type === 'order') {
                    this.data.orders = this.data.orders.filter(o => o.orderId !== data.orderId);
                } else if (action === 'update' && type === 'order') {
                    const index = this.data.orders.findIndex(o => o.orderId === data.orderId);
                    if (index !== -1) this.data.orders[index] = data;
                }

                this.hideUndoBar();
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Action undone');
            },

            showUndoBar(message) {
                const bar = document.getElementById('undoBar');
                document.getElementById('undoMessage').textContent = message;
                bar.classList.add('show');
                
                setTimeout(() => this.hideUndoBar(), 5000);
            },

            hideUndoBar() {
                document.getElementById('undoBar').classList.remove('show');
            },

            // ============ ORDER FORM ============
            populateTimeDropdown() {
                const select = document.getElementById('readyTime');
                select.innerHTML = '<option value="">Select Time</option>';
                
                for (let h = 1; h <= 12; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        ['AM', 'PM'].forEach(period => {
                            const time = `${h}:${m.toString().padStart(2, '0')} ${period}`;
                            select.add(new Option(time, time));
                        });
                    }
                }
            },

async refreshOrderId() {
    const nextId = await this.previewNextOrderId();
    Utils.set('orderId', nextId);
    document.getElementById('currentOrderId').textContent = `Next: ${nextId}`;
},

            getNextOrderId() {
                const prefix = this.data.settings.invoicePrefix || 'FP';
                const counter = this.data.settings.orderIdCounter || 1;
                return `${prefix}${String(counter).padStart(3, '0')}`;
            },

            incrementOrderCounter() {
                this.data.settings.orderIdCounter = (this.data.settings.orderIdCounter || 1) + 1;
                this.refreshOrderId();
            },

   collectFormData() {
       
        const transport = Utils.get('transport');
        const eventType = Utils.get('eventTypeSelect');
        const isMultiDay = eventType === 'multi';
        
        // Collect day-wise data for multi-day events
        let dayWiseData = [];
        if (isMultiDay) {
            const startDate = Utils.get('startDate');
            const endDate = Utils.get('endDate');
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil(Math.abs(end - start) / (1000 * 60 * 60 * 24)) + 1;
            
            for (let i = 0; i < diffDays; i++) {
                const currentDate = new Date(start);
                currentDate.setDate(start.getDate() + i);
                
                // Get functions for this day
                const dayFunctions = window.dayFunctionsData?.[i] || [];
                
                dayWiseData.push({
                    dayNumber: i + 1,
                    date: Utils.toDateString(currentDate),
                    functions: dayFunctions.map(func => ({
                        functionType: func.functionType || '',
                        timeSlot: func.timeSlot || '',
                        driver: func.driver || '',
                        operator: func.operator || '',
                        helper: func.helper || '',
                        notes: func.notes || '',
                        items: func.items || []
                    }))
                });
            }
        }
        
        return {
            orderId: Utils.get('orderId'),
            isMultiDay: isMultiDay,
            date: isMultiDay ? null : Utils.get('orderDate'),
            startDate: isMultiDay ? Utils.get('startDate') : null,
            endDate: isMultiDay ? Utils.get('endDate') : null,
            dayWiseData: dayWiseData,
            lastEventDate: isMultiDay ? Utils.get('endDate') : Utils.get('orderDate'),
            readyTime: Utils.get('readyTime'),
            clientName: Utils.get('clientName'),
            contact: Utils.get('contact'),
            venue: Utils.get('venue'),
            eventType: Utils.get('eventType'),
            transport: transport === 'Other' ? Utils.get('customTransport') : transport,
            driverName: Utils.get('driverName'),
            operator: Utils.get('operator'),
            helper: Utils.get('helper'),
            status: Utils.get('orderStatus'),
            notes: Utils.get('orderNotes'),
            items: isMultiDay ? [] : [...this.currentOrderItems],
            createdAt: new Date().toISOString()
        };
    },

async saveOrder() {
    // Conditional validation based on event type
    const eventType = Utils.get('eventTypeSelect');
    const isMultiDay = eventType === 'multi';
    
    let requiredFields = ['clientName', 'contact', 'venue', 'orderStatus'];

    if (isMultiDay) {
        requiredFields.push('startDate', 'endDate');
} else {
    requiredFields.push('orderDate', 'readyTime');
}

const errors = Utils.validateRequired(requiredFields);
    if (errors.length > 0) {
        this.showToast('Please fill all required fields', 'error');
        return;
    }

    const orderData = this.collectFormData();
    const status = orderData.status.toLowerCase();
    const manualOrderId = Utils.get('orderId').trim();

    // NEW ID SYSTEM: Only completed orders get FP IDs
    let finalOrderId;

    if (status === 'completed') {
        // Completed orders MUST have manual FP ID
        if (manualOrderId && manualOrderId.startsWith('FP')) {
            finalOrderId = manualOrderId;
            console.log('‚úÖ Using manual FP ID:', finalOrderId);
        } else {
            this.showToast('‚ö†Ô∏è Completed orders require a manual FP ID (e.g., FP001)', 'error');
            return;
        }
    } else {
        // Pending/Confirmed orders have NO ID (blank)
        finalOrderId = '';
        console.log('‚è≥ Order saved without ID (status: ' + status + ')');
    }

    // Update order data with final ID (can be blank)
    orderData.orderId = finalOrderId;
    
    try {
        console.log('üíæ Saving order:', orderData.orderId);

        // Check if we're editing an existing order
let existingSnapshot;

if (this.editingOrderId || this.editingDocId) {
    // Editing mode - find by doc ID or order ID
    if (this.editingDocId) {
        const doc = await db.collection('orders').doc(this.editingDocId).get();
        existingSnapshot = doc.exists ? { empty: false, docs: [doc] } : { empty: true };
        console.log('‚úèÔ∏è Editing existing order by docId:', this.editingDocId);
    } else {
        existingSnapshot = await db.collection('orders')
            .where('orderId', '==', this.editingOrderId)
            .get();
        console.log('‚úèÔ∏è Editing existing order:', this.editingOrderId);
    }
} else if (finalOrderId) {
    // New order with ID - check if ID already exists
    existingSnapshot = await db.collection('orders')
        .where('orderId', '==', finalOrderId)
        .get();
} else {
    // New order without ID
    existingSnapshot = { empty: true };
}

        // Convert admin format to quotation format for Firestore
const firestoreData = {
    orderId: finalOrderId,
    isMultiDay: orderData.isMultiDay || false,
    startDate: orderData.startDate || null,
    endDate: orderData.endDate || null,
    dayWiseData: orderData.dayWiseData || [],
    customer: {
        name: orderData.clientName,
        phone: orderData.contact,
        venue: orderData.venue,
        dates: orderData.isMultiDay 
            ? `${Utils.formatDate(orderData.startDate)} to ${Utils.formatDate(orderData.endDate)}`
            : this.convertToQuotationDateFormat(orderData.date),
        timeSlot: orderData.readyTime || '',
        functionType: orderData.eventType || '',
        location: ''
    },
    functionType: orderData.eventType || '',
    items: orderData.isMultiDay ? [] : (orderData.items || []).map(item => ({
        name: item.name,
        qty: item.quantity,
        desc: item.remarks || '',
        price: item.price || 0
    })),
    clientName: orderData.clientName,
    contact: orderData.contact,
    venue: orderData.venue,
    date: orderData.date || '',
    readyTime: orderData.readyTime || '',
    eventType: orderData.eventType || '',
    transport: orderData.transport || '',
    driverName: orderData.driverName || '',
    operator: orderData.operator || '',
    helper: orderData.helper || '',
    status: orderData.status.toLowerCase(),
    notes: orderData.notes || '',
    createdAt: orderData.createdAt || new Date().toISOString(),
    updatedAt: new Date().toISOString()
};

        if (!existingSnapshot.empty) {
    // UPDATE existing order
    const docId = existingSnapshot.docs[0].id;
    const oldData = existingSnapshot.docs[0].data();
    const oldOrderId = oldData.orderId || '';

    console.log('‚úèÔ∏è Updating order, old ID:', oldOrderId || '[blank]', 'new ID:', finalOrderId || '[blank]');

    // Check if status changed to completed (needs FP ID)
    if (oldOrderId !== finalOrderId && finalOrderId) {
        console.log('üîÑ Status upgraded - assigning FP ID to order');

        // Delete old document
        await db.collection('orders').doc(docId).delete();
        console.log('üóëÔ∏è Deleted old doc (ID: ' + (oldOrderId || docId) + ')');

        // Create new document with FP ID
        await db.collection('orders').doc(finalOrderId).set(firestoreData);
        console.log('‚úÖ Created new doc with FP ID:', finalOrderId);
        orderData.docId = finalOrderId;

// Update local array with all data including multi-day
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || []
};

const localIndex = this.data.orders.findIndex(o =>
    (o.orderId && o.orderId === oldOrderId) ||
    (o.docId && o.docId === docId)
);
if (localIndex !== -1) {
    this.data.orders[localIndex] = completeOrderData;
}

        this.showToast(`Order upgraded: ${oldOrderId || '[No ID]'} ‚Üí ${finalOrderId} ‚úÖ`);
    } else {
        // Same status - just update existing doc
        await db.collection('orders').doc(docId).update(firestoreData);
        console.log('‚úÖ Updated order:', finalOrderId || docId);
        orderData.docId = docId;

        const completeOrderData = {
            ...orderData,
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || []
        };

        const localIndex = this.data.orders.findIndex(o =>
            (o.orderId && o.orderId === finalOrderId) ||
            (o.docId && o.docId === docId)
        );
        if (localIndex !== -1) {
            this.data.orders[localIndex] = completeOrderData;
        }

        this.showToast('Order updated! ‚úèÔ∏è');
    }

    // Clear editing flags
    this.editingOrderId = null;
    this.editingDocId = null;
    
} else {
            // CREATE new order
            console.log('üÜï Creating new order');

            // Save to Firestore
            let docRef;
            if (finalOrderId) {
                // Order has FP ID - use it as doc ID
                docRef = await db.collection('orders').doc(finalOrderId).set(firestoreData);
                orderData.docId = finalOrderId;
            } else {
                // No ID (pending/confirmed) - let Firestore generate doc ID
                docRef = await db.collection('orders').add(firestoreData);
                orderData.docId = docRef.id;
                console.log('üìù Auto-generated docId:', docRef.id);
            }

// Add to local array with all multi-day data
const completeOrderData = {
        ...orderData,
        isMultiDay: orderData.isMultiDay || false,
        startDate: orderData.startDate || null,
        endDate: orderData.endDate || null,
        dayWiseData: orderData.dayWiseData || []
};

const localExists = this.data.orders.some(o =>
    (o.orderId && o.orderId === finalOrderId) ||
    (o.docId && o.docId === orderData.docId)
);
if (!localExists) {
    this.data.orders.push(completeOrderData);
}

                const displayId = finalOrderId || `[${status.toUpperCase()}]`;

                // AUTOMATIC INVENTORY DEDUCTION (if order is completed)
                if (status === 'completed' && orderData.items) {
                    this.deductInventory(orderData.items, orderData.orderId);
                }

                // ADD TO ORDER AUDIT HISTORY
                this.addAuditEntry(orderData.orderId || orderData.docId, {
                    action: 'created',
                    user: this.getCurrentUser().name || 'Admin',
                    timestamp: new Date().toISOString(),
                    details: `Order created with status: ${status}`
                });

                this.showToast(`Order ${displayId} saved to Firestore! üÜï`);
                this.refreshOrderId();
                this.saveToStorage();
                this.updateAllDisplays();
                localStorage.removeItem('oms_draft');
        }

    } catch (error) {
        console.error('‚ùå Error saving to Firestore:', error);
        this.showToast('Error saving order: ' + error.message, 'error');
    }
},

// Automatic Inventory Deduction
deductInventory(items, orderId) {
    if (!items || items.length === 0) return;

    items.forEach(orderItem => {
        const inventoryItem = this.data.inventory.items.find(i =>
            i.name.toLowerCase() === orderItem.name.toLowerCase()
        );

        if (inventoryItem) {
            const previousQty = inventoryItem.quantity;
            inventoryItem.quantity -= orderItem.quantity;

            console.log(`üì¶ Deducted ${orderItem.quantity} ${orderItem.name} from inventory (${previousQty} ‚Üí ${inventoryItem.quantity})`);

            // Low stock warning
            if (inventoryItem.quantity <= this.data.settings.lowStockThreshold) {
                this.showToast(`‚ö†Ô∏è LOW STOCK: ${inventoryItem.name} (${inventoryItem.quantity} left)`, 'warning');
            }

            // Negative stock alert
            if (inventoryItem.quantity < 0) {
                this.showToast(`üö® CRITICAL: ${inventoryItem.name} stock is NEGATIVE!`, 'error');
            }
        }
    });

    this.saveToStorage();
},

// Order Audit History System
addAuditEntry(identifier, entry) {
    if (!this.data.orderAuditLog) {
        this.data.orderAuditLog = {};
    }

    if (!this.data.orderAuditLog[identifier]) {
        this.data.orderAuditLog[identifier] = [];
    }

    this.data.orderAuditLog[identifier].push(entry);
    console.log(`üìù Audit log: ${entry.action} by ${entry.user}`);
},

// Get current logged in user (for multi-user system)
getCurrentUser() {
    if (!this.data.currentUser) {
        this.data.currentUser = {
            id: 'admin',
            name: this.data.settings.businessOwner || 'Admin',
            role: 'admin',
            permissions: ['all']
        };
    }
    return this.data.currentUser;
},

convertToQuotationDateFormat(dateStr) {
    if (!dateStr) return '';
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateStr;
},

            loadOrderToForm(order) {
        // Store original order ID and docId for updates
        this.editingOrderId = order.orderId;
        this.editingDocId = order.docId;

        console.log('üîç Loading order to form:', order);
        console.log('üîç Order status:', order.status);
        console.log('üîç Is Multi-Day:', order.isMultiDay);

        // Check if this is a multi-day order
        if (order.isMultiDay) {
            // Load multi-day order
            console.log('üìÖ Loading multi-day order with dayWiseData:', order.dayWiseData);

            // Set event type to multi
            Utils.set('eventTypeSelect', 'multi');

            // Load basic fields
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                startDate: order.startDate,
                endDate: order.endDate,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            // Show/hide transport fields
            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            // Trigger event type change to show multi-day fields
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            if (eventTypeSelect) {
                const event = new Event('change');
                eventTypeSelect.dispatchEvent(event);
            }

            // Wait for DOM to update, then regenerate day-wise functions
            setTimeout(() => {
                // Initialize dayFunctionsData
                window.dayFunctionsData = {};

                // Generate day-wise functions based on date range
                this.generateDayWiseFunctions();

                // Wait a bit more for function cards to be created
                setTimeout(() => {
                    // Populate each day's functions from order.dayWiseData
                    if (order.dayWiseData && Array.isArray(order.dayWiseData)) {
                        order.dayWiseData.forEach((day, dayIndex) => {
                            if (day.functions && Array.isArray(day.functions)) {
                                // First, add additional function cards if needed (beyond the default first one)
                                const additionalFunctions = day.functions.length - 1;
                                for (let i = 0; i < additionalFunctions; i++) {
                                    this.addFunctionToDay(dayIndex, false);
                                }

                                // Now populate all functions after a short delay
                                setTimeout(() => {
                                    // Store function data
                                    window.dayFunctionsData[dayIndex] = day.functions.map(f => ({...f}));

                                    day.functions.forEach((func, funcIndex) => {
                                        const functionId = `day${dayIndex}func${funcIndex}`;

                                        // Populate form fields
                                        const typeInput = document.getElementById(`${functionId}Type`);
                                        const timeInput = document.getElementById(`${functionId}Time`);
                                        const driverSelect = document.getElementById(`${functionId}Driver`);
                                        const operatorSelect = document.getElementById(`${functionId}Operator`);
                                        const helperSelect = document.getElementById(`${functionId}Helper`);
                                        const notesTextarea = document.getElementById(`${functionId}Notes`);

                                        if (typeInput) typeInput.value = func.functionType || '';
                                        if (timeInput) timeInput.value = func.timeSlot || '';
                                        if (driverSelect) driverSelect.value = func.driver || '';
                                        if (operatorSelect) operatorSelect.value = func.operator || '';
                                        if (helperSelect) helperSelect.value = func.helper || '';
                                        if (notesTextarea) notesTextarea.value = func.notes || '';

                                        // Update function data in memory
                                        this.updateFunctionData(dayIndex, funcIndex, 'functionType', func.functionType || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'timeSlot', func.timeSlot || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'driver', func.driver || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'operator', func.operator || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'helper', func.helper || '');
                                        this.updateFunctionData(dayIndex, funcIndex, 'notes', func.notes || '');

                                        // Set items for this function
                                        if (func.items && Array.isArray(func.items)) {
                                            window.dayFunctionsData[dayIndex][funcIndex].items = [...func.items];
                                            this.updateFunctionItemsList(dayIndex, funcIndex);
                                        }
                                    });
                                }, 100);
                            }
                        });
                    }

                    console.log('‚úÖ Multi-day order loaded successfully');
                }, 300);
            }, 200);

        } else {
            // Load single-day order (original code)
            Object.entries({
                orderId: order.orderId,
                clientName: order.clientName,
                contact: order.contact,
                venue: order.venue,
                orderDate: order.date,
                readyTime: order.readyTime,
                eventType: order.eventType,
                transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                driverName: order.driverName,
                operator: order.operator,
                helper: order.helper,
                orderStatus: order.status ? order.status.charAt(0).toUpperCase() + order.status.slice(1) : '',
                orderNotes: order.notes
            }).forEach(([key, value]) => Utils.set(key, value));

            if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                document.getElementById('customTransportGroup').classList.remove('hidden');
            }

            this.currentOrderItems = order.items ? [...order.items] : [];
            this.updateOrderItemsTable();
        }

        // Trigger status change to show/hide order ID field
        setTimeout(() => {
            const statusSelect = document.getElementById('orderStatus');
            if (statusSelect) {
                const event = new Event('change');
                statusSelect.dispatchEvent(event);
            }
        }, 100);
            },

            clearForm() {
                this.editingOrderId = null;  // Clear editing flags
                this.editingDocId = null;
                if (this.hasUnsavedChanges() && !confirm('Clear all data?')) return;

                document.getElementById('orderForm').reset();
                this.currentOrderItems = [];
                this.updateOrderItemsTable();
                this.refreshOrderId();
                Utils.set('orderDate', Utils.toDateString(new Date()));
                document.getElementById('customTransportGroup').classList.add('hidden');

                // Clear multi-day data
                if (window.dayFunctionsData) {
                    window.dayFunctionsData = {};
                }

                // Reset event type to single day
                Utils.set('eventTypeSelect', 'single');
                const singleDayFields = document.getElementById('singleDayFields');
                const multiDayFields = document.getElementById('multiDayFields');
                if (singleDayFields) singleDayFields.style.display = 'block';
                if (multiDayFields) multiDayFields.style.display = 'none';

                // Clear multi-day containers
                const multiDayContainer = document.getElementById('multiDayContainer');
                if (multiDayContainer) {
                    multiDayContainer.innerHTML = '';
                }

                this.showToast('Form cleared');
            },

            // Duplicate any order by ID or docId
            duplicateOrder(identifier) {
                const order = this.data.orders.find(o =>
                    o.orderId === identifier || o.docId === identifier
                );

                if (!order) {
                    this.showToast('Order not found', 'error');
                    return;
                }

                if (confirm(`Duplicate order for "${order.clientName}"?\n\nThis will create a new order with the same details.`)) {
                    // Clear any editing state
                    this.editingOrderId = null;
                    this.editingDocId = null;

                    // Load order data but clear ID and set to pending
                    Object.entries({
                        orderId: '', // No ID for new order
                        clientName: order.clientName,
                        contact: order.contact,
                        venue: order.venue,
                        orderDate: Utils.toDateString(new Date()), // Today's date
                        readyTime: order.readyTime,
                        eventType: order.eventType,
                        transport: ['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : 'Other',
                        customTransport: !['Bolero', 'Isuzu', 'Porter'].includes(order.transport) ? order.transport : '',
                        driverName: order.driverName || '',
                        operator: order.operator || '',
                        helper: order.helper || '',
                        orderStatus: 'Pending', // New duplicate starts as pending
                        orderNotes: order.notes ? `[DUPLICATED] ${order.notes}` : '[DUPLICATED ORDER]'
                    }).forEach(([key, value]) => Utils.set(key, value));

                    // Copy items
                    this.currentOrderItems = order.items ? order.items.map(item => ({...item})) : [];
                    this.updateOrderItemsTable();

                    // Show transport field if needed
                    if (!['Bolero', 'Isuzu', 'Porter'].includes(order.transport)) {
                        document.getElementById('customTransportGroup').classList.remove('hidden');
                    }

                    // Switch to orders tab
                    this.switchTab('orders');
                    this.showToast(`‚úÖ Order duplicated! Review and save.`, 'success');

                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            },

            duplicateLastOrder() {
                if (this.data.orders.length === 0) {
                    this.showToast('No orders to duplicate', 'error');
                    return;
                }
                
                const lastOrder = this.data.orders[this.data.orders.length - 1];
                this.loadOrderToForm(lastOrder);
                this.refreshOrderId();
                this.showToast('Last order duplicated');
            },
            previewOrder() {
                const errors = Utils.validateRequired(['clientName', 'contact', 'venue']);
                if (errors.length > 0) {
                this.showToast('Fill required fields first', 'error');
                return;
                }
                
                const orderData = this.collectFormData();
                this.showModal('Order Preview', this.generatePreviewHTML(orderData));
            },
            generatePreviewHTML(order) {
                return `
                    <div style="font-family: Arial, sans-serif;">
                        <h3 style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">
                            Order ID: ${order.orderId || 'Not assigned yet'}
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Client Name:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Event Type:</strong> Multi-Day<br>
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate)}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate)}
                                ` : `
                                    <strong>Event Type:</strong> Single Day<br>
                                    <strong>Date:</strong> ${Utils.formatDate(order.date)}<br>
                                    <strong>Ready Time:</strong> ${order.readyTime || '-'}
                                `}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                <strong>Status:</strong> <span class="status-badge status-${order.status.toLowerCase()}">${order.status}</span>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
                            <div>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}
                            </div>
                            <div>
                                <strong>Function Type:</strong> ${order.eventType || '-'}
                            </div>
                        </div>
                        
                        ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<h4 style="color: var(--primary); margin-top: 30px;">Day-wise Details:</h4>' +
                            order.dayWiseData.map((day, idx) => 
                                '<div style="background: rgba(102, 126, 234, 0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px;">' +
                                    '<h5 style="color: var(--primary);">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h5>' +
                                    (day.functions && day.functions.length > 0 ? 
                                        day.functions.map((func, funcIdx) => 
                                            '<div style="background: var(--bg-card); padding: 15px; border: 1px solid var(--border); border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '10px') + ';">' +
                                                '<h6 style="color: var(--primary); margin-bottom: 10px;">Function ' + (funcIdx + 1) + '</h6>' +
                                                '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">' +
                                                    '<div><strong>Type:</strong> ' + (func.functionType || '-') + '</div>' +
                                                    '<div><strong>Time:</strong> ' + (func.timeSlot || '-') + '</div>' +
                                                    '<div><strong>Driver:</strong> ' + (func.driver || '-') + '</div>' +
                                                    '<div><strong>Operator:</strong> ' + (func.operator || '-') + '</div>' +
                                                    '<div><strong>Helper:</strong> ' + (func.helper || '-') + '</div>' +
                                                '</div>' +
                                                (func.notes ? '<div style="margin-bottom: 10px;"><strong>Notes:</strong> ' + func.notes + '</div>' : '') +
                                                (func.items && func.items.length > 0 ? 
                                                    '<table class="table" style="margin-top: 10px;">' +
                                                        '<thead><tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th></tr></thead>' +
                                                        '<tbody>' +
                                                            func.items.map((item, i) => 
                                                                '<tr>' +
                                                                    '<td>' + (i + 1) + '</td>' +
                                                                    '<td>' + item.name + '</td>' +
                                                                    '<td>' + item.quantity + '</td>' +
                                                                    '<td>' + (item.remarks || '-') + '</td>' +
                                                                '</tr>'
                                                            ).join('') +
                                                        '</tbody>' +
                                                    '</table>'
                                                : '<p style="color: var(--text-gray); margin-top: 10px; font-style: italic;">No items for this function</p>') +
                                            '</div>'
                                        ).join('')
                                    : '<p style="color: var(--text-gray); margin-top: 10px;">No functions added for this day</p>') +
                                '</div>'
                            ).join('')
                        : ''}
                    </div>
                `;
            },

            downloadSameDayOrders() {
                const date = Utils.get('orderDate');
                if (!date) {
                    this.showToast('Select date first', 'error');
                    return;
                }
                
                const orders = this.data.orders.filter(o => o.date === date);
                if (orders.length === 0) {
                    this.showToast('No orders for this date', 'error');
                    return;
                }
                
                this.generateMultiOrderImage(orders, date);
            },

            downloadOrderImage(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                this.generateSingleOrderImage(order);
            },

            // ============ IMAGE GENERATION ============
            async generateSingleOrderImage(order) {
                const loading = this.showLoading('Generating image...');
                
                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    const fontSize = this.data.settings.printFontSize || 32;
                    
                    template.innerHTML = this.buildOrderHTML(order, fontSize, colors);
                    template.style.display = 'block';
                    
                    await new Promise(r => setTimeout(r, 1000));
                    
                    const canvas = await html2canvas(template, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        width: 2480
                    });
                    
                    template.style.display = 'none';
                    
                    canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `Order_${order.orderId}.png`;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        this.hideLoading(loading);
                        this.showToast('Image downloaded!');
                    });
                } catch (error) {
                    this.hideLoading(loading);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            async generateMultiOrderImage(orders, date) {
                const loading = this.showLoading('Generating multi-order image...');
                
                try {
                    const template = document.getElementById('printTemplate');
                    const colors = this.data.settings.printColors;
                    
                    let html = `
                        <div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Orders for ${Utils.formatDate(date)}
                            </h1>
                        </div>
                    `;
                    
                    orders.forEach((order, i) => {
                        html += this.buildOrderHTML(order, 28, colors, true);
                        if (i < orders.length - 1) {
                            html += '<div style="page-break-before: always;"></div>';
                        }
                    });
                    
                    template.innerHTML = html;
                    template.style.display = 'block';
                    
                    await new Promise(r => setTimeout(r, 2000));
                    
                    const canvas = await html2canvas(template, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        width: 2480
                    });
                    
                    template.style.display = 'none';
                    
                    canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `Orders_${date}.png`;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        this.hideLoading(loading);
                        this.showToast(`${orders.length} orders downloaded!`);
                    });
                } catch (error) {
                    this.hideLoading(loading);
                    this.showToast('Error: ' + error.message, 'error');
                }
            },

            buildOrderHTML(order, fontSize, colors, compact = false) {
                console.log('üñºÔ∏è Building image for order:', order.orderId);
                console.log('üñºÔ∏è isMultiDay:', order.isMultiDay);
                console.log('üñºÔ∏è dayWiseData:', order.dayWiseData);
                const ts = this.data.settings.tableSettings;
                const orderIdBg = colors.orderIdBg || '#667eea';
                const orderIdText = colors.orderIdText || '#ffffff';
                
                return `
                    <div style="margin-bottom: ${compact ? '40px' : '60px'}; ${compact ? 'border: 2px solid ' + colors.tableBorder + '; padding: 20px;' : ''}">
                        ${!compact ? `<div style="text-align: center; margin-bottom: 40px;">
                            <h1 style="color: ${colors.headerText}; background: ${colors.headerBg}; padding: 20px;">
                                Order Management
                            </h1>
                            <h2 style="margin-top: 20px;">
                                <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 10px 20px; border-radius: 8px;">
                                    ${order.orderId}
                                </span>
                            </h2>
                        </div>` : `<h3 style="text-align: center;">
                            <span style="background: ${orderIdBg}; color: ${orderIdText}; padding: 8px 15px; border-radius: 6px;">
                                ${order.orderId}
                            </span>
                        </h3>`}
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; font-size: ${fontSize}px; margin-bottom: 20px;">
                            <div>
                                ${order.isMultiDay ? `
                                    <strong>Start Date:</strong> ${Utils.formatDate(order.startDate) || 'N/A'}<br>
                                    <strong>End Date:</strong> ${Utils.formatDate(order.endDate) || 'N/A'}<br>
                                ` : `
                                    <strong>Date:</strong> ${Utils.formatDate(order.date) || 'N/A'}<br>
                                    <strong>Time:</strong> ${order.readyTime || '-'}<br>
                                `}
                                <strong>Client:</strong> ${order.clientName || '-'}<br>
                                <strong>Contact:</strong> ${order.contact || '-'}<br>
                                <strong>Venue:</strong> ${order.venue || '-'}
                            </div>
                            <div>
                                <strong>Transport:</strong> ${order.transport || '-'}<br>
                                <strong>Driver:</strong> ${order.driverName || '-'}<br>
                                <strong>Event:</strong> ${order.eventType || '-'}<br>
                                <strong>Operator:</strong> ${order.operator || '-'}
                            </div>
                            <div>
                                <strong>Helper:</strong> ${order.helper || '-'}<br>
                                <strong>Status:</strong> ${order.status || '-'}
                            </div>
                        </div>

                            ${order.isMultiDay && order.dayWiseData && order.dayWiseData.length > 0 ? 
                            '<div style="margin-top: 30px;">' +
                                '<h3 style="color: ' + colors.headerText + '; background: ' + colors.headerBg + '; padding: 15px; text-align: center;">Day-wise Details</h3>' +
                                order.dayWiseData.map((day, idx) => 
                                    '<div style="margin-top: 25px; border: 2px solid ' + colors.tableBorder + '; padding: 15px; background: rgba(102, 126, 234, 0.05);">' +
                                        '<h4 style="color: ' + orderIdBg + '; margin-bottom: 15px;">Day ' + day.dayNumber + ' - ' + Utils.formatDate(day.date) + '</h4>' +
                                        (day.functions && day.functions.length > 0 ?
                                            day.functions.map((func, funcIdx) =>
                                                '<div style="background: white; padding: 15px; border: 1px solid ' + colors.tableBorder + '; border-radius: 6px; margin-top: ' + (funcIdx > 0 ? '15px' : '0') + ';">' +
                                                    '<h5 style="color: ' + orderIdBg + '; margin-bottom: 10px; font-size: ' + (fontSize - 2) + 'px;">Function ' + (funcIdx + 1) + '</h5>' +
                                                    '<div style="font-size: ' + fontSize + 'px; margin-bottom: 10px;">' +
                                                        '<strong>Type:</strong> ' + (func.functionType || '-') + '<br>' +
                                                        '<strong>Time:</strong> ' + (func.timeSlot || '-') + '<br>' +
                                                        '<strong>Driver:</strong> ' + (func.driver || '-') + '<br>' +
                                                        '<strong>Operator:</strong> ' + (func.operator || '-') + '<br>' +
                                                        '<strong>Helper:</strong> ' + (func.helper || '-') + '<br>' +
                                                        (func.notes ? '<strong>Notes:</strong> ' + func.notes + '<br>' : '') +
                                                    '</div>' +
                                                    (func.items && func.items.length > 0 ?
                                                        '<table style="width: 100%; border-collapse: collapse; font-size: ' + (fontSize - 4) + 'px;">' +
                                                            '<thead>' +
                                                                '<tr style="background: ' + colors.tableHeaderBg + '; color: ' + colors.tableHeaderText + ';">' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthSr + '%;">Sr</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthItem + '%;">Item</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthQty + '%;">Qty</th>' +
                                                                    '<th style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; width: ' + ts.columnWidthRemarks + '%;">Remarks</th>' +
                                                                '</tr>' +
                                                            '</thead>' +
                                                            '<tbody>' +
                                                                func.items.map((item, i) =>
                                                                    '<tr>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; text-align: center;">' + (i + 1) + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px;">' + item.name + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px; text-align: center;">' + item.quantity + '</td>' +
                                                                        '<td style="border: 2px solid ' + colors.tableBorder + '; padding: 10px;">' + (item.remarks || '-') + '</td>' +
                                                                    '</tr>'
                                                                ).join('') +
                                                            '</tbody>' +
                                                        '</table>'
                                                    : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No items for this function</p>') +
                                                '</div>'
                                            ).join('')
                                        : '<p style="text-align: center; color: #666; font-style: italic; margin-top: 10px;">No functions for this day</p>') +
                                    '</div>'
                                ).join('') +
                            '</div>'
                        : ''}
                        
                        ${!order.isMultiDay && order.items && order.items.length > 0 ? `
                            <table style="width: 100%; border-collapse: collapse; font-size: ${fontSize - 4}px; margin-top: 20px;">
                                <thead>
                                    <tr style="background: ${colors.tableHeaderBg}; color: ${colors.tableHeaderText};">
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthSr}%;">Sr</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthItem}%;">Item</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthQty}%;">Qty</th>
                                        <th style="border: 2px solid ${colors.tableBorder}; padding: 10px; width: ${ts.columnWidthRemarks}%;">Remarks</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${order.items.map((item, i) => `
                                        <tr>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; text-align: center;">${i + 1}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px;">${item.name}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px; text-align: center;">${item.quantity}</td>
                                            <td style="border: 2px solid ${colors.tableBorder}; padding: 10px;">${item.remarks || ''}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        ` : (!order.isMultiDay ? '<p style="text-align: center; color: #666; font-style: italic; margin-top: 20px;">No items added</p>' : '')}

                        ${order.notes ? `
                            <div style="margin-top: 20px; font-size: ${fontSize}px;">
                                <strong>Notes:</strong><br>
                                <div style="background: ${colors.notesBg}; padding: 15px; border: 1px solid ${colors.tableBorder};">
                                    ${order.notes}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // ============ CUSTOMER MANAGEMENT ============
            updateCustomerDatabase(orderData) {
                let customer = this.data.customers.find(c => 
                    c.contact === orderData.contact || c.name.toLowerCase() === orderData.clientName.toLowerCase()
                );
                
                if (customer) {
                    customer.name = orderData.clientName;
                    customer.lastVenue = orderData.venue;
                    customer.lastOrderDate = orderData.date;
                    customer.lastOrderId = orderData.orderId;
                    customer.totalOrders = this.data.orders.filter(o => 
                        o.contact === customer.contact
                    ).length;
                } else {
                    customer = {
                        id: Utils.generateId(),
                        name: orderData.clientName,
                        contact: orderData.contact,
                        email: '',
                        address: '',
                        firstOrderDate: orderData.date,
                        lastOrderDate: orderData.date,
                        lastOrderId: orderData.orderId,
                        lastVenue: orderData.venue,
                        totalOrders: 1,
                        // Enhanced customer profile fields
                        preferences: {
                            preferredItems: [],
                            dietaryRestrictions: '',
                            specialRequests: ''
                        },
                        notes: '',
                        paymentHistory: [],
                        totalRevenue: 0,
                        creditLimit: 0,
                        discount: 0, // Percentage discount for loyal customers
                        tags: [], // e.g., ['VIP', 'Corporate', 'Regular']
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    this.data.customers.push(customer);
                }
            },

            mergeCustomers(id1, id2) {
                const c1 = this.data.customers.find(c => c.id === id1);
                const c2 = this.data.customers.find(c => c.id === id2);
                if (!c1 || !c2) return;

                // Merge into c1
                c1.totalOrders += c2.totalOrders;
                if (new Date(c2.lastOrderDate) > new Date(c1.lastOrderDate)) {
                    c1.lastOrderDate = c2.lastOrderDate;
                    c1.lastOrderId = c2.lastOrderId;
                }

                // Update orders
                this.data.orders.forEach(o => {
                    if (o.contact === c2.contact) {
                        o.contact = c1.contact;
                        o.clientName = c1.name;
                    }
                });

                // Remove c2
                this.data.customers = this.data.customers.filter(c => c.id !== id2);
                this.saveToStorage();
                this.updateAllDisplays();
                this.showToast('Customers merged');
            },

            // ============ CALENDAR & TASKS ============
            renderCalendar(date = new Date()) {
                const year = date.getFullYear();
                const month = date.getMonth();
                
                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];
                
                let html = `
                    <div class="calendar-container">
                        <div class="calendar-header">
                            <div class="calendar-nav">
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(-1)">‚Üê</button>
                                <h3>${monthNames[month]} ${year}</h3>
                                <button class="btn btn-primary btn-small" onclick="OMS.changeMonth(1)">‚Üí</button>
                            </div>
                            <button class="btn btn-secondary btn-small" onclick="OMS.showToday()">Today</button>
                        </div>
                        <div class="calendar-grid">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => 
                                `<div class="calendar-day-header">${day}</div>`
                            ).join('')}
                            ${Array(firstDay).fill('').map(() => '<div class="calendar-day"></div>').join('')}
                            ${Array.from({length: daysInMonth}, (_, i) => {
                                const day = i + 1;
                                const dateStr = Utils.toDateString(new Date(year, month, day));
                                const today = Utils.toDateString(new Date());
                                const orders = this.data.orders.filter(o => {
                                    if (o.isMultiDay) {
                                        // Check if dateStr falls within the multi-day range
                                        const checkDate = new Date(dateStr);
                                        const start = new Date(o.startDate);
                                        const end = new Date(o.endDate);
                                        return checkDate >= start && checkDate <= end;
                                    }
                                    return o.date === dateStr;
                                });
                                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                                const festival = this.festivals[dateStr];
                                
                                let classes = 'calendar-day';
                                if (dateStr === today) classes += ' today';
                                if (orders.length) classes += ' has-orders';
                                if (tasks.length) classes += ' has-tasks';
                                if (festival) classes += ' has-festival';
                                
                                // Get color indicators for this day's orders
                                const orderColorDots = orders.slice(0, 3).map(o => {
                                    const color = this.getOrderColor(o);
                                    return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${color};margin:0 2px;"></span>`;
                                }).join('');

                                return `
                                    <div class="${classes}" onclick="OMS.showDayDetails('${dateStr}')">
                                        <div class="calendar-day-number">${day}</div>
                                        ${festival ? `<div class="festival-text">${festival[1]}</div>` : ''}
                                        ${orders.length ? `<div class="order-count" title="${orders.length} order(s)">${orderColorDots}${orders.length > 3 ? '+' : ''}</div>` : ''}
                                        ${tasks.length ? `<div class="calendar-day-content">${tasks.length} task${tasks.length > 1 ? 's' : ''}</div>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <div class="card">
                        <h3 class="card-title">üìù Add Task</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <input type="date" id="taskDate" class="form-input" value="${Utils.toDateString(new Date())}">
                            </div>
                            <div class="form-group">
                                <input type="text" id="taskDescription" class="form-input" placeholder="Task description">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-primary" onclick="OMS.addTask()">‚ûï Add</button>
                            </div>
                        </div>
                    </div>
                `;
                
                return html;
            },

            changeMonth(delta) {
                this.currentCalendarDate = this.currentCalendarDate || new Date();
                this.currentCalendarDate.setMonth(this.currentCalendarDate.getMonth() + delta);
                this.switchTab('calendar');
            },

            showToday() {
                this.currentCalendarDate = new Date();
                this.switchTab('calendar');
            },

            // Fixed: Use local date without timezone issues
            showDayDetails(dateStr) {
                const date = Utils.getLocalDate(dateStr);
                const orders = this.data.orders.filter(o => {
                    if (o.isMultiDay) {
                        // Check if dateStr falls within the multi-day range
                        const checkDate = new Date(dateStr);
                        const start = new Date(o.startDate);
                        const end = new Date(o.endDate);
                        return checkDate >= start && checkDate <= end;
                    }
                    return o.date === dateStr;
                });
                const tasks = this.data.tasks.filter(t => t.date === dateStr);
                const festival = this.festivals[dateStr];
                
                let content = `<h3>Details for ${Utils.formatDate(dateStr)}</h3>`;
                
                if (festival) {
                    content += `<div class="festival-text" style="font-size: 1.2rem; margin: 1rem 0;">üéâ ${festival[1]} (${festival[0]})</div>`;
                }
                
                if (orders.length > 0) {
                    content += `<h4>üìã Orders (${orders.length})</h4>`;
                    orders.forEach(o => {
                        const color = this.getOrderColor(o);
                        let dateInfo = '';
                        if (o.isMultiDay) {
                            dateInfo = `<br><small style="color:#666;">üìÖ Multi-day: ${Utils.formatDate(o.startDate)} to ${Utils.formatDate(o.endDate)}</small>`;
                        }
                        content += `
                            <div style="padding:10px;margin:8px 0;border-left:4px solid ${color};background:#f9f9f9;border-radius:4px;">
                                <strong>${o.orderId || '[No ID]'}</strong> - ${o.clientName}
                                <br>
                                <span style="color:${color};font-weight:bold;">${o.eventType || 'Event'}</span> |
                                <span style="background:${color};color:white;padding:2px 6px;border-radius:3px;font-size:12px;">${o.status}</span>
                                ${dateInfo}
                            </div>
                        `;
                    });
                }
                
                if (tasks.length > 0) {
                    content += `<h4>üìù Tasks (${tasks.length})</h4><ul>`;
                    tasks.forEach(t => {
                        content += `<li>
                            ${t.description}
                            <button class="btn btn-secondary btn-small" data-action="edit" data-type="task" data-id="${t.id}">Edit</button>
                            <button class="btn btn-danger btn-small" data-action="delete" data-type="task" data-id="${t.id}">Delete</button>
                        </li>`;
                    });
                    content += '</ul>';
                }
                
                content += `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.addTaskForDate('${dateStr}')">Add Task</button>
                        <button class="btn btn-secondary" onclick="OMS.createOrderForDate('${dateStr}')">New Order</button>
                    </div>
                `;
                
                this.showModal('Day Details', content);
            },

            addTask() {
                const date = Utils.get('taskDate');
                const description = Utils.get('taskDescription');
                
                if (!date || !description) {
                    this.showToast('Enter date and description', 'error');
                    return;
                }
                
                const task = {
                    id: Utils.generateId(),
                    date: date,
                    description: description,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.createItem('task', task);
                this.saveToStorage();
                this.switchTab('calendar');
                Utils.set('taskDescription', '');
                this.showToast('Task added!');
            },

            addTaskForDate(date) {
                this.switchTab('calendar');
                setTimeout(() => {
                    Utils.set('taskDate', date);
                    document.getElementById('taskDescription').focus();
                }, 100);
            },

            createOrderForDate(date) {
                this.switchTab('orders');
                Utils.set('orderDate', date);
            },

            showTaskEditModal(task) {
                const content = `
                    <div class="form-group">
                        <label class="form-label">Date</label>
                        <input type="date" id="editTaskDate" class="form-input" value="${task.date}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" id="editTaskDescription" class="form-input" value="${task.description}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTaskEdit('${task.id}')">Save</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Edit Task', content);
            },

            saveTaskEdit(taskId) {
                const newData = {
                    date: Utils.get('editTaskDate'),
                    description: Utils.get('editTaskDescription')
                };
                
                if (this.updateItem('task', taskId, newData)) {
                    this.saveToStorage();
                    this.switchTab('calendar');
                    this.closeModal();
                    this.showToast('Task updated!');
                }
            },

            // ============ INVENTORY BATCH OPERATIONS ============
            batchUpdateInventory() {
                const content = `
                    <h3>Batch Update Inventory</h3>
                    <div class="form-group">
                        <label class="form-label">Select Operation</label>
                        <select id="batchOp" class="form-select">
                            <option value="increase">Increase All Stock</option>
                            <option value="decrease">Decrease All Stock</option>
                            <option value="set">Set All Stock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Amount</label>
                        <input type="number" id="batchAmount" class="form-input" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.executeBatchInventory()">Execute</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `;
                this.showModal('Batch Operations', content);
            },

            executeBatchInventory() {
                const op = Utils.get('batchOp');
                const amount = parseInt(Utils.get('batchAmount')) || 0;
                
                this.data.inventory.items.forEach(item => {
                    if (op === 'increase') item.quantity += amount;
                    else if (op === 'decrease') item.quantity = Math.max(0, item.quantity - amount);
                    else if (op === 'set') item.quantity = amount;
                });
                
                this.saveToStorage();
                this.updateAllDisplays();
                this.closeModal();
                this.showToast('Inventory updated!');
            },

            // ============ DATA EXPORT ============
            exportData(format = 'json') {
                try {
                    let dataStr, filename, mimeType;
                    
                    if (format === 'json') {
                        dataStr = JSON.stringify(this.data, null, 2);
                        filename = `oms_backup_${Utils.toDateString(new Date())}.json`;
                        mimeType = 'application/json';
                    } else if (format === 'csv') {
                        // Export orders as CSV
                        const headers = ['Order ID', 'Date', 'Client', 'Contact', 'Venue', 'Status', 'Total Items'];
                        const rows = this.data.orders.map(o => [
                            o.orderId, o.date, o.clientName, o.contact, o.venue, o.status, o.items.length
                        ]);
                        dataStr = [headers, ...rows].map(row => row.join(',')).join('\n');
                        filename = `orders_${Utils.toDateString(new Date())}.csv`;
                        mimeType = 'text/csv';
                    }
                    
                    const blob = new Blob([dataStr], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Data exported!');
                } catch (error) {
                    this.showToast('Export error: ' + error.message, 'error');
                }
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleImportFile(file);
                };
                input.click();
            },

            handleImportFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.orders && imported.inventory) {
                            if (confirm('This will replace all data. Continue?')) {
                                this.data = imported;
                                this.saveToStorage();
                                this.showToast('Data imported! Reloading...');
                                setTimeout(() => location.reload(), 1000);
                            }
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        this.showToast('Import error: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            },

            // ============ ORDER HISTORY & TIMELINE ============
            showOrderHistory(orderId) {
                const order = this.data.orders.find(o => o.orderId === orderId);
                if (!order) return;
                
                const timeline = [
                    { date: order.createdAt, event: 'Order Created', status: order.status }
                ];
                
                const content = `
                    <h3>Order Timeline: ${orderId}</h3>
                    <div style="margin-top: 1rem;">
                        ${timeline.map(t => `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="font-weight: bold;">${t.event}</div>
                                <div style="color: var(--text-gray);">${new Date(t.date).toLocaleString()}</div>
                                <div>Status: ${t.status}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                this.showModal('Order History', content);
            },

            // ============ UI HELPERS ============
            renderTable(containerId, columns, data, actions) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                if (data.length === 0) {
                    container.innerHTML = `<table class="table"><tbody><tr><td colspan="${columns.length + 1}" class="text-center">No data available</td></tr></tbody></table>`;
                    return;
                }
                
                const html = `
                    <table class="table">
                        <thead>
                            <tr>
                                ${columns.map(col => `<th>${col.label}</th>`).join('')}
                                ${actions ? '<th>Actions</th>' : ''}
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `
                                <tr>
                                    ${columns.map(col => `<td>${col.render ? col.render(row) : row[col.key]}</td>`).join('')}
                                    ${actions ? `<td>${actions(row)}</td>` : ''}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                
                container.innerHTML = html;
            },

            showModal(title, content) {
                const existing = document.getElementById('dynamicModal');
                if (existing) existing.remove();
                
                const modal = Utils.elem('div', { id: 'dynamicModal', class: 'modal show' }, [
                    Utils.elem('div', { class: 'modal-content' }, [
                        Utils.elem('button', { 
                            class: 'modal-close', 
                            onclick: () => this.closeModal() 
                        }, ['√ó']),
                        Utils.elem('h2', {}, [title]),
                        Utils.elem('div', { innerHTML: content })
                    ])
                ]);
                
                document.getElementById('modalsContainer').appendChild(modal);
            },

            closeModal() {
                const modal = document.getElementById('dynamicModal');
                if (modal) modal.remove();
            },

            showToast(message, type = 'success', actions = []) {
                const toast = Utils.elem('div', { class: `toast show ${type === 'error' ? 'error' : ''}` }, [
                    Utils.elem('div', {}, [message]),
                    actions.length > 0 ? Utils.elem('div', { class: 'toast-actions' }, 
                        actions.map(a => Utils.elem('button', { class: 'toast-btn', onclick: a.handler }, [a.label]))
                    ) : null
                ].filter(Boolean));
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            },

            showLoading(message) {
                const loading = Utils.elem('div', { class: 'loading' }, [
                    Utils.elem('div', {}, [message]),
                    Utils.elem('div', { class: 'spinner' })
                ]);
                document.body.appendChild(loading);
                return loading;
            },

            hideLoading(loading) {
                if (loading) loading.remove();
            },

            // ============ NAVIGATION ============
            switchTab(tabName) {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(tabName).classList.add('active');
                
                this.currentTab = tabName;
                
                // Render tab content
                setTimeout(() => {
                    if (tabName === 'dashboard') this.renderDashboard();
                    else if (tabName === 'inventory') this.renderInventory();
                    else if (tabName === 'preparation') this.renderPreparation();
                    else if (tabName === 'customers') this.renderCustomers();
                    else if (tabName === 'team') this.renderTeam();
                    else if (tabName === 'calendar') this.renderCalendarTab();
                    else if (tabName === 'history') this.renderHistory();
                    else if (tabName === 'analytics') this.renderAnalytics();
                    else if (tabName === 'settings') this.renderSettings();
                    else if (tabName === 'orders') this.initItemSearch();
                }, 50);
            },

            // ============ TAB RENDERERS ============
            renderDashboard() {
                const stats = [
                    { label: 'Total Orders', value: this.data.orders.length, class: '' },
                    { label: 'Confirmed', value: this.data.orders.filter(o => o.status === 'Confirmed').length, class: 'success' },
                    { label: 'Completed', value: this.data.orders.filter(o => o.status === 'Completed').length, class: 'info' },
                    { label: 'Customers', value: this.data.customers.length, class: '' },
                    { label: 'Low Stock', value: this.data.inventory.items.filter(i => i.quantity <= this.data.settings.lowStockThreshold).length, class: 'warning' },
                    { label: 'Today', value: this.data.orders.filter(o => o.date === Utils.toDateString(new Date())).length, class: 'danger' }
                ];
                
                document.getElementById('dashboardStats').innerHTML = stats.map(s => `
                    <div class="stat-card ${s.class}">
                        <div class="stat-value">${s.value}</div>
                        <div class="stat-label">${s.label}</div>
                    </div>
                `).join('');
                
                const recentOrders = this.data.orders.slice(-5).reverse();
                this.renderTable('recentOrdersContainer', [
                    { key: 'orderId', label: 'Order ID', render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'eventType', label: 'Event', render: o => o.eventType || 'N/A' },
                    { key: 'date', label: 'Date', render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} to ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: 'Status', render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${o.status}</span>` }
                ], recentOrders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.orderId || row.docId}">View</button>
                    <button class="btn btn-info btn-small" onclick="OMS.duplicateOrder('${row.orderId || row.docId}')">üìã Duplicate</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.orderId}">Print</button>
                `);
                
                // Top customer
                if (this.data.customers.length > 0) {
                    const top = this.data.customers.reduce((prev, curr) => 
                        (prev.totalOrders > curr.totalOrders) ? prev : curr
                    );
                    document.getElementById('topCustomerInfo').innerHTML = `
                        <div style="background: var(--light); padding: 1rem; border-radius: var(--radius);">
                            <strong>${top.name}</strong><br>
                            ${top.contact}<br>
                            <strong>${top.totalOrders} orders</strong>
                        </div>
                    `;
                }
            },

            renderInventory() {
                const container = document.getElementById('inventory');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üì¶ Inventory Management</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="OMS.batchUpdateInventory()">‚ö° Batch Update</button>
                        </div>
                        <div class="card">
                            <h3>Categories</h3>
                            <div class="form-row">
                                <input type="text" id="categoryName" class="form-input" placeholder="Category name">
                                <button class="btn btn-primary" onclick="OMS.addCategory()">Add</button>
                            </div>
                            <div id="categoriesContainer"></div>
                        </div>
                        <div class="card">
                            <h3>Items</h3>
                            <div class="form-row">
                                <select id="itemCategory" class="form-select"></select>
                                <input type="text" id="itemName" class="form-input" placeholder="Item name">
                                <input type="number" id="itemQuantity" class="form-input" placeholder="Quantity" min="0">
                                <button class="btn btn-primary" onclick="OMS.addItem()">Add</button>
                            </div>
                            <div id="itemsContainer"></div>
                        </div>
                    </div>
                `;
                
                this.updateInventoryDisplay();
            },

            updateInventoryDisplay() {
                // Populate category dropdown
                const select = document.getElementById('itemCategory');
                if (select) {
                    select.innerHTML = '<option value="">Select category</option>' +
                        this.data.inventory.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
                }
                
                // Render categories table
                this.renderTable('categoriesContainer', [
                    { key: 'name', label: 'Category' },
                    { key: 'id', label: 'Items', render: c => this.data.inventory.items.filter(i => i.categoryId === c.id).length }
                ], this.data.inventory.categories, (row) => `
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="category" data-id="${row.id}">Delete</button>
                `);
                
                // Render items table
                this.renderTable('itemsContainer', [
                    { key: 'name', label: 'Item' },
                    { key: 'categoryId', label: 'Category', render: i => this.data.inventory.categories.find(c => c.id === i.categoryId)?.name || 'N/A' },
                    { key: 'quantity', label: 'Stock' }
                ], this.data.inventory.items, (row) => `
                    <button class="btn btn-success btn-small" onclick="OMS.increaseItemQuantity('${row.id}')">+</button>
                    <button class="btn btn-warning btn-small" onclick="OMS.decreaseItemQuantity('${row.id}')">-</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.editInventoryItem('${row.id}')">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="item" data-id="${row.id}">üóëÔ∏è Delete</button>
                `);
            },

            addCategory() {
                const name = Utils.get('categoryName');
                if (!name) return;

                const category = {
                    id: Utils.generateId(),
                    name: name,
                    createdAt: new Date().toISOString()
                };

                this.createItem('category', category);

                Utils.set('categoryName', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryCategoryToFirestore(category);

                this.updateInventoryDisplay();
                this.showToast('Category added and synced!');
            },

            addItem() {
                const categoryId = Utils.get('itemCategory');
                const name = Utils.get('itemName');
                const quantity = parseInt(Utils.get('itemQuantity')) || 0;

                if (!categoryId || !name) {
                    this.showToast('Select category and enter name', 'error');
                    return;
                }

                const item = {
                    id: Utils.generateId(),
                    categoryId: categoryId,
                    name: name,
                    quantity: quantity,
                    createdAt: new Date().toISOString()
                };

                this.createItem('item', item);

                Utils.set('itemName', '');
                Utils.set('itemQuantity', '');
                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast('Item added and synced!');
            },

            editInventoryItem(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                // Show edit modal
                this.showModal('Edit Inventory Item', `
                    <div class="form-group">
                        <label class="form-label required">Item Name</label>
                        <input type="text" id="editItemName" class="form-input" value="${item.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Category</label>
                        <select id="editItemCategory" class="form-select">
                            ${this.data.inventory.categories.map(c => `
                                <option value="${c.id}" ${c.id === item.categoryId ? 'selected' : ''}>${c.name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Quantity</label>
                        <input type="number" id="editItemQuantity" class="form-input" value="${item.quantity}" min="0">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveInventoryItemEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveInventoryItemEdit(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                const name = Utils.get('editItemName');
                const categoryId = Utils.get('editItemCategory');
                const quantity = parseInt(Utils.get('editItemQuantity')) || 0;

                if (!name || !categoryId) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update item
                item.name = name;
                item.categoryId = categoryId;
                item.quantity = quantity;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveInventoryItemToFirestore(item);

                this.closeModal();
                this.updateInventoryDisplay();
                this.showToast('Item updated and synced!');
            },

            async increaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                item.quantity = (item.quantity || 0) + 1;
                item.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                await this.saveInventoryItemToFirestore(item);

                this.updateInventoryDisplay();
                this.showToast(`${item.name} quantity increased to ${item.quantity}`);
            },

            async decreaseItemQuantity(id) {
                const item = this.data.inventory.items.find(i => i.id === id);
                if (!item) return;

                if (item.quantity > 0) {
                    item.quantity -= 1;
                    item.updatedAt = new Date().toISOString();

                    this.saveToStorage();

                    // Save to Firestore
                    await this.saveInventoryItemToFirestore(item);

                    this.updateInventoryDisplay();
                    this.showToast(`${item.name} quantity decreased to ${item.quantity}`);
                } else {
                    this.showToast('Quantity cannot be negative', 'error');
                }
            },

            // ============ PREPARATION / FORECAST FUNCTIONS ============

            renderPreparation() {
                const container = document.getElementById('preparation');
                const today = new Date().toISOString().split('T')[0];
                const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                const nextWeek = new Date(Date.now() + 7 * 86400000).toISOString().split('T')[0];

                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìã Preparation & Forecast</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">Plan your inventory and see what items you need for upcoming orders</p>
                        </div>

                        <div class="card">
                            <h3>üìÖ Select Date Range</h3>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('today')">Today</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('tomorrow')">Tomorrow</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('week')">Next 7 Days</button>
                                <button class="btn btn-secondary" onclick="OMS.quickForecast('month')">Next 30 Days</button>
                            </div>
                            <div class="form-row">
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">From Date</label>
                                    <input type="date" id="forecastStartDate" class="form-input" value="${today}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; margin-bottom: 0.25rem; font-weight: 500;">To Date</label>
                                    <input type="date" id="forecastEndDate" class="form-input" value="${tomorrow}">
                                </div>
                                <div style="display: flex; align-items: flex-end;">
                                    <button class="btn btn-primary" onclick="OMS.generateForecast()" style="height: fit-content;">
                                        üîç Generate Forecast
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="forecastResults"></div>
                    </div>
                `;

                // Auto-generate forecast for tomorrow by default
                setTimeout(() => this.generateForecast(), 100);
            },

            quickForecast(period) {
                const today = new Date();
                const startInput = document.getElementById('forecastStartDate');
                const endInput = document.getElementById('forecastEndDate');

                let start = new Date(today);
                let end = new Date(today);

                switch(period) {
                    case 'today':
                        // Start and end are same (today)
                        break;
                    case 'tomorrow':
                        start.setDate(start.getDate() + 1);
                        end.setDate(end.getDate() + 1);
                        break;
                    case 'week':
                        end.setDate(end.getDate() + 7);
                        break;
                    case 'month':
                        end.setDate(end.getDate() + 30);
                        break;
                }

                startInput.value = start.toISOString().split('T')[0];
                endInput.value = end.toISOString().split('T')[0];

                this.generateForecast();
            },

            generateForecast() {
                const startDate = Utils.get('forecastStartDate');
                const endDate = Utils.get('forecastEndDate');

                if (!startDate || !endDate) {
                    this.showToast('Please select both start and end dates', 'error');
                    return;
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (end < start) {
                    this.showToast('End date must be after start date', 'error');
                    return;
                }

                // Get orders in date range
                const ordersInRange = this.getOrdersInDateRange(startDate, endDate);

                // Aggregate items from all orders
                const itemsMap = new Map();
                const orderItemsMap = new Map(); // Track which orders use which items

                ordersInRange.forEach(order => {
                    const items = this.getItemsFromOrder(order, startDate, endDate);

                    items.forEach(item => {
                        // Aggregate quantities
                        const current = itemsMap.get(item.name) || 0;
                        itemsMap.set(item.name, current + item.quantity);

                        // Track order references
                        if (!orderItemsMap.has(item.name)) {
                            orderItemsMap.set(item.name, []);
                        }
                        orderItemsMap.get(item.name).push({
                            orderId: order.orderId,
                            clientName: order.clientName,
                            quantity: item.quantity
                        });
                    });
                });

                // Convert to array and sort by quantity (descending)
                const aggregatedItems = Array.from(itemsMap, ([name, quantity]) => {
                    // Find matching inventory item
                    const inventoryItem = this.data.inventory.items.find(i =>
                        i.name.toLowerCase() === name.toLowerCase()
                    );

                    return {
                        name,
                        required: quantity,
                        inStock: inventoryItem ? inventoryItem.quantity : 0,
                        difference: inventoryItem ? inventoryItem.quantity - quantity : -quantity,
                        orders: orderItemsMap.get(name) || []
                    };
                }).sort((a, b) => b.required - a.required);

                // Render forecast results
                this.renderForecastResults(ordersInRange, aggregatedItems, startDate, endDate);
            },

            getOrdersInDateRange(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);

                return this.data.orders.filter(order => {
                    if (order.isMultiDay) {
                        // For multi-day orders, check if any day falls in range
                        const orderStart = new Date(order.startDate);
                        const orderEnd = new Date(order.endDate);

                        // Check for overlap: order overlaps if it starts before range ends AND ends after range starts
                        return orderStart <= end && orderEnd >= start;
                    } else {
                        // For single-day orders
                        const orderDate = new Date(order.date);
                        return orderDate >= start && orderDate <= end;
                    }
                });
            },

            getItemsFromOrder(order, startDate, endDate) {
                const items = [];

                if (order.isMultiDay && order.dayWiseData) {
                    // Filter days that fall in the date range
                    const start = new Date(startDate);
                    const end = new Date(endDate);

                    order.dayWiseData.forEach(day => {
                        const dayDate = new Date(day.date);
                        if (dayDate >= start && dayDate <= end) {
                            // Get items from all functions of this day
                            if (day.functions) {
                                day.functions.forEach(func => {
                                    if (func.items) {
                                        items.push(...func.items);
                                    }
                                });
                            }
                        }
                    });
                } else if (order.items) {
                    // Single-day order
                    items.push(...order.items);
                }

                return items;
            },

            renderForecastResults(orders, items, startDate, endDate) {
                const container = document.getElementById('forecastResults');

                if (orders.length === 0) {
                    container.innerHTML = `
                        <div class="card" style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <h3>üì≠ No Orders Found</h3>
                            <p>No orders scheduled between ${Utils.formatDate(startDate)} and ${Utils.formatDate(endDate)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate statistics
                const confirmedOrders = orders.filter(o => o.status === 'Confirmed').length;
                const pendingOrders = orders.filter(o => o.status !== 'Confirmed' && o.status !== 'Completed').length;
                const completedOrders = orders.filter(o => o.status === 'Completed').length;
                const totalItems = items.reduce((sum, item) => sum + item.required, 0);
                const shortageItems = items.filter(i => i.difference < 0);
                const okItems = items.filter(i => i.difference >= 0);

                container.innerHTML = `
                    <!-- Summary Cards -->
                    <div class="card" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 1.5rem;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.3rem;">üìä Summary for ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${orders.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">Total Orders</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${confirmedOrders}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ Confirmed</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${items.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">Unique Items</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700;">${totalItems}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">Total Quantity</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: ${shortageItems.length > 0 ? '#fca5a5' : '#86efac'};">${shortageItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚ö†Ô∏è Shortages</div>
                            </div>
                            <div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 2rem; font-weight: 700; color: #86efac;">${okItems.length}</div>
                                <div style="font-size: 0.9rem; opacity: 0.9;">‚úÖ Sufficient</div>
                            </div>
                        </div>
                    </div>

                    <!-- Export Buttons -->
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="OMS.printForecast()">üñ®Ô∏è Print</button>
                        <button class="btn btn-info" onclick="OMS.exportForecastPDF()">üìÑ Export PDF</button>
                        <button class="btn btn-warning" onclick="OMS.shareForecastWhatsApp()">üì± Share WhatsApp</button>
                    </div>

                    <!-- Items Table -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üì¶ Items Preparation List</h3>
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th style="width: 5%;">Sr</th>
                                        <th style="width: 25%;">Item Name</th>
                                        <th style="width: 10%;">Required</th>
                                        <th style="width: 10%;">In Stock</th>
                                        <th style="width: 10%;">Difference</th>
                                        <th style="width: 10%;">Status</th>
                                        <th style="width: 30%;">Used In Orders</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${items.map((item, index) => {
                                        const statusBadge = item.difference >= 0
                                            ? `<span style="background: var(--success); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚úÖ OK</span>`
                                            : `<span style="background: var(--danger); color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">‚ö†Ô∏è SHORT ${item.difference}</span>`;

                                        const ordersText = item.orders.slice(0, 3).map(o => o.orderId).join(', ') +
                                            (item.orders.length > 3 ? ` +${item.orders.length - 3} more` : '');

                                        return `
                                            <tr style="background: ${item.difference < 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'};">
                                                <td>${index + 1}</td>
                                                <td><strong>${item.name}</strong></td>
                                                <td><strong>${item.required}</strong></td>
                                                <td>${item.inStock}</td>
                                                <td style="color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'}; font-weight: 600;">
                                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                                </td>
                                                <td>${statusBadge}</td>
                                                <td>
                                                    <small style="color: var(--text-gray);">${ordersText}</small>
                                                    <button class="btn btn-secondary btn-small" onclick="OMS.showItemOrderDetails('${item.name.replace(/'/g, "\\'")}')">Details</button>
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                                <tfoot>
                                    <tr style="background: var(--light); font-weight: 700;">
                                        <td colspan="2">GRAND TOTAL</td>
                                        <td>${totalItems}</td>
                                        <td>${items.reduce((sum, i) => sum + i.inStock, 0)}</td>
                                        <td style="color: ${items.reduce((sum, i) => sum + i.difference, 0) >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                            ${items.reduce((sum, i) => sum + i.difference, 0)}
                                        </td>
                                        <td colspan="2"></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Orders Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">üìã Order Details Breakdown</h3>
                        </div>
                        <div style="display: grid; gap: 1rem;">
                            ${orders.map(order => {
                                const items = this.getItemsFromOrder(order, startDate, endDate);
                                const statusColor = {
                                    'Confirmed': 'var(--success)',
                                    'Completed': 'var(--info)',
                                    'Cancelled': 'var(--danger)'
                                }[order.status] || 'var(--warning)';

                                return `
                                    <div style="border: 2px solid var(--border); border-radius: var(--radius); padding: 1rem; background: var(--bg-card);">
                                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                                            <div>
                                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--primary);">${order.orderId}</div>
                                                <div style="color: var(--text-dark); font-weight: 500;">${order.clientName}</div>
                                                <div style="font-size: 0.9rem; color: var(--text-gray);">
                                                    üìç ${order.venue} |
                                                    üìÖ ${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)} |
                                                    üïê ${order.readyTime || 'N/A'}
                                                </div>
                                            </div>
                                            <span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                ${order.status || 'Pending'}
                                            </span>
                                        </div>
                                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                                            <strong style="font-size: 0.9rem; color: var(--text-gray);">Items Required:</strong>
                                            <div style="margin-top: 0.25rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                                ${items.map(item => `
                                                    <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                                        ${item.name}: <strong>${item.quantity}</strong>
                                                    </span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;

                // Store current forecast data for export
                this.currentForecastData = {
                    orders,
                    items,
                    startDate,
                    endDate,
                    stats: {
                        totalOrders: orders.length,
                        confirmed: confirmedOrders,
                        pending: pendingOrders,
                        completed: completedOrders,
                        totalItems: totalItems,
                        shortages: shortageItems.length,
                        sufficient: okItems.length
                    }
                };
            },

            showItemOrderDetails(itemName) {
                if (!this.currentForecastData) return;

                const item = this.currentForecastData.items.find(i => i.name === itemName);
                if (!item) return;

                const ordersHtml = item.orders.map(o => `
                    <div style="padding: 0.75rem; border-bottom: 1px solid var(--border);">
                        <div style="font-weight: 600; color: var(--primary);">${o.orderId}</div>
                        <div style="color: var(--text-gray); font-size: 0.9rem;">${o.clientName}</div>
                        <div style="margin-top: 0.25rem;">
                            <span style="background: var(--light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">
                                Quantity: <strong>${o.quantity}</strong>
                            </span>
                        </div>
                    </div>
                `).join('');

                this.showModal(`
                    <h2 style="margin-bottom: 1rem;">üì¶ ${itemName}</h2>
                    <div style="margin-bottom: 1rem;">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${item.required}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Required</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);">${item.inStock}</div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">In Stock</div>
                            </div>
                            <div style="background: var(--light); padding: 1rem; border-radius: var(--radius); text-align: center;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: ${item.difference >= 0 ? 'var(--success)' : 'var(--danger)'};">
                                    ${item.difference >= 0 ? '+' : ''}${item.difference}
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-gray);">Difference</div>
                            </div>
                        </div>
                    </div>
                    <h3 style="margin-bottom: 0.5rem;">Used in ${item.orders.length} order(s):</h3>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: var(--radius);">
                        ${ordersHtml}
                    </div>
                `);
            },

            printForecast() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to print', 'error');
                    return;
                }

                const { items, orders, startDate, endDate, stats } = this.currentForecastData;

                const printWindow = window.open('', '', 'width=800,height=600');
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Preparation Forecast - ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #667eea; margin-top: 20px; }
                            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                            th { background: #667eea; color: white; }
                            .shortage { background: #fee; color: #c00; font-weight: bold; }
                            .ok { background: #efe; color: #060; font-weight: bold; }
                            .summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
                            .summary-card { border: 2px solid #667eea; padding: 15px; border-radius: 8px; text-align: center; }
                            .summary-card .value { font-size: 2rem; font-weight: bold; color: #667eea; }
                            .summary-card .label { color: #666; margin-top: 5px; }
                            @media print {
                                button { display: none; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>üìã Preparation & Forecast Report</h1>
                        <p><strong>Period:</strong> ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}</p>
                        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

                        <div class="summary">
                            <div class="summary-card">
                                <div class="value">${stats.totalOrders}</div>
                                <div class="label">Total Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${items.length}</div>
                                <div class="label">Unique Items</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.totalItems}</div>
                                <div class="label">Total Quantity</div>
                            </div>
                            <div class="summary-card">
                                <div class="value">${stats.confirmed}</div>
                                <div class="label">Confirmed Orders</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: ${stats.shortages > 0 ? '#c00' : '#060'};">${stats.shortages}</div>
                                <div class="label">Items Short</div>
                            </div>
                            <div class="summary-card">
                                <div class="value" style="color: #060;">${stats.sufficient}</div>
                                <div class="label">Items OK</div>
                            </div>
                        </div>

                        <h2>üì¶ Items Preparation List</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Sr</th>
                                    <th>Item Name</th>
                                    <th>Required</th>
                                    <th>In Stock</th>
                                    <th>Difference</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${items.map((item, index) => `
                                    <tr class="${item.difference < 0 ? 'shortage' : ''}">
                                        <td>${index + 1}</td>
                                        <td><strong>${item.name}</strong></td>
                                        <td>${item.required}</td>
                                        <td>${item.inStock}</td>
                                        <td class="${item.difference >= 0 ? 'ok' : 'shortage'}">
                                            ${item.difference >= 0 ? '+' : ''}${item.difference}
                                        </td>
                                        <td>${item.difference >= 0 ? '‚úÖ OK' : '‚ö†Ô∏è SHORT'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <h2>üìã Orders Summary</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order ID</th>
                                    <th>Client</th>
                                    <th>Venue</th>
                                    <th>Date</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${orders.map(order => `
                                    <tr>
                                        <td>${order.orderId}</td>
                                        <td>${order.clientName}</td>
                                        <td>${order.venue}</td>
                                        <td>${order.isMultiDay ? `${Utils.formatDate(order.startDate)} to ${Utils.formatDate(order.endDate)}` : Utils.formatDate(order.date)}</td>
                                        <td>${order.status || 'Pending'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>

                        <button onclick="window.print()" style="background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-top: 20px;">
                            üñ®Ô∏è Print This Report
                        </button>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            },

            exportForecastPDF() {
                this.showToast('PDF export coming soon! Use Print for now.', 'info');
                // Future: Implement PDF generation using jsPDF or similar
            },

            shareForecastWhatsApp() {
                if (!this.currentForecastData) {
                    this.showToast('No forecast data to share', 'error');
                    return;
                }

                const { items, startDate, endDate, stats } = this.currentForecastData;

                // Create WhatsApp message
                let message = `üìã *PREPARATION FORECAST*\n\n`;
                message += `üìÖ *Period:* ${Utils.formatDate(startDate)} to ${Utils.formatDate(endDate)}\n\n`;
                message += `üìä *SUMMARY*\n`;
                message += `‚Ä¢ Total Orders: ${stats.totalOrders}\n`;
                message += `‚Ä¢ Confirmed: ${stats.confirmed}\n`;
                message += `‚Ä¢ Total Items: ${items.length}\n`;
                message += `‚Ä¢ Total Quantity: ${stats.totalItems}\n`;
                message += `‚Ä¢ Shortages: ${stats.shortages}\n\n`;

                message += `üì¶ *ITEMS NEEDED*\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;

                items.forEach((item, index) => {
                    const status = item.difference >= 0 ? '‚úÖ' : '‚ö†Ô∏è';
                    message += `${index + 1}. ${item.name}\n`;
                    message += `   Required: ${item.required} | Stock: ${item.inStock} | ${item.difference >= 0 ? '+' : ''}${item.difference} ${status}\n`;
                });

                message += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `Generated: ${new Date().toLocaleString()}\n`;
                message += `\n_Powered by FirepowerSFX Admin_`;

                // Encode and open WhatsApp
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');

                this.showToast('Opening WhatsApp...', 'success');
            },

            renderCustomers() {
                const container = document.getElementById('customers');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üë• Customer Database</h2>
                        </div>
                        <div class="form-row">
                            <input type="text" id="customerSearch" class="form-input" placeholder="Search customers...">
                            <button class="btn btn-primary" onclick="OMS.refreshCustomerDatabase()">üîÑ Refresh</button>
                        </div>
                        <div id="customersContainer"></div>
                    </div>
                `;
                
                this.renderTable('customersContainer', [
                    { key: 'name', label: 'Name' },
                    { key: 'contact', label: 'Contact' },
                    { key: 'totalOrders', label: 'Orders' },
                    { key: 'lastOrderDate', label: 'Last Order', render: c => Utils.formatDate(c.lastOrderDate) }
                ], this.data.customers, (row) => `
                    <button class="btn btn-secondary btn-small" onclick="OMS.viewCustomerOrders('${row.id}')">Orders</button>
                    <button class="btn btn-primary btn-small" onclick="OMS.createOrderForCustomer('${row.id}')">New Order</button>
                `);
            },

            refreshCustomerDatabase() {
                // Rebuild customer database from orders
                this.data.customers = [];
                this.data.orders.forEach(order => {
                    this.updateCustomerDatabase(order);
                });
                this.saveToStorage();
                this.renderCustomers();
                this.showToast('Customer database refreshed!');
            },

            viewCustomerOrders(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('history');
                // Filter logic would go here
            },

            createOrderForCustomer(customerId) {
                const customer = this.data.customers.find(c => c.id === customerId);
                if (!customer) return;
                
                this.switchTab('orders');
                Utils.set('clientName', customer.name);
                Utils.set('contact', customer.contact);
                if (customer.lastVenue) Utils.set('venue', customer.lastVenue);
            },

            // ============ TEAM MANAGEMENT ============

            renderTeam() {
                const container = document.getElementById('team');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üë∑ Team Management</h2>
                            <p style="color: var(--text-gray); margin-top: 0.5rem;">Manage your staff members and their roles</p>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">‚ûï Add Team Member</h3>
                            </div>
                            <div class="form-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="form-group">
                                    <label class="form-label required">Name</label>
                                    <input type="text" id="teamMemberName" class="form-input" placeholder="e.g., Rajesh Kumar">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">WhatsApp Number</label>
                                    <input type="tel" id="teamMemberWhatsApp" class="form-input" placeholder="e.g., +91 98765 43210">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Email (Optional)</label>
                                    <input type="email" id="teamMemberEmail" class="form-input" placeholder="e.g., rajesh@example.com">
                                </div>
                                <div class="form-group">
                                    <label class="form-label required">Status</label>
                                    <select id="teamMemberStatus" class="form-select">
                                        <option value="Active">Active</option>
                                        <option value="Inactive">Inactive</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label required">Roles (Select one or more)</label>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleDriver" value="Driver" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üöó Driver</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleOperator" value="Operator" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>‚öôÔ∏è Operator</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleHelper" value="Helper" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>ü§ù Helper</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleManager" value="Manager" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üëî Manager</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.5rem; border: 2px solid var(--border); border-radius: var(--radius); background: var(--white);">
                                        <input type="checkbox" id="roleSupervisor" value="Supervisor" style="width: 18px; height: 18px; cursor: pointer;">
                                        <span>üìã Supervisor</span>
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Skills/Specialties (Optional)</label>
                                <input type="text" id="teamMemberSkills" class="form-input" placeholder="e.g., Wedding Expert, Corporate Events, Sound Systems">
                                <small style="color: var(--text-gray);">Separate multiple skills with commas</small>
                            </div>

                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="OMS.addTeamMember()">‚ûï Add Team Member</button>
                                <button class="btn btn-secondary" onclick="OMS.clearTeamForm()">üîÑ Clear Form</button>
                            </div>
                        </div>

                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">üë• Team Members</h3>
                            </div>
                            <div class="form-row" style="margin-bottom: 1rem;">
                                <select id="teamRoleFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">All Roles</option>
                                    <option value="Driver">üöó Drivers</option>
                                    <option value="Operator">‚öôÔ∏è Operators</option>
                                    <option value="Helper">ü§ù Helpers</option>
                                    <option value="Manager">üëî Managers</option>
                                    <option value="Supervisor">üìã Supervisors</option>
                                </select>
                                <select id="teamStatusFilter" class="form-select" onchange="OMS.renderTeamTable()">
                                    <option value="">All Status</option>
                                    <option value="Active">Active</option>
                                    <option value="Inactive">Inactive</option>
                                </select>
                                <input type="text" id="teamSearch" class="form-input" placeholder="Search by name..." oninput="OMS.renderTeamTable()">
                            </div>
                            <div id="teamMembersContainer"></div>
                        </div>
                    </div>
                `;

                this.renderTeamTable();
            },

            renderTeamTable() {
                const container = document.getElementById('teamMembersContainer');
                if (!container) return;

                // Get filter values
                const roleFilter = document.getElementById('teamRoleFilter')?.value || '';
                const statusFilter = document.getElementById('teamStatusFilter')?.value || '';
                const searchQuery = document.getElementById('teamSearch')?.value.toLowerCase() || '';

                // Filter team members
                let filteredTeam = this.data.team.filter(member => {
                    const matchesRole = !roleFilter || member.roles.includes(roleFilter);
                    const matchesStatus = !statusFilter || member.status === statusFilter;
                    const matchesSearch = !searchQuery || member.name.toLowerCase().includes(searchQuery);
                    return matchesRole && matchesStatus && matchesSearch;
                });

                if (filteredTeam.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-gray);">
                            <p>No team members found. Add your first team member above!</p>
                        </div>
                    `;
                    return;
                }

                // Render table
                const tableHtml = `
                    <div style="overflow-x: auto;">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Roles</th>
                                    <th>WhatsApp</th>
                                    <th>Email</th>
                                    <th>Skills</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${filteredTeam.map(member => {
                                    const roleIcons = {
                                        'Driver': 'üöó',
                                        'Operator': '‚öôÔ∏è',
                                        'Helper': 'ü§ù',
                                        'Manager': 'üëî',
                                        'Supervisor': 'üìã'
                                    };
                                    const roleBadges = member.roles.map(role =>
                                        `<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; margin-right: 0.25rem;">${roleIcons[role] || ''} ${role}</span>`
                                    ).join('');

                                    const statusColor = member.status === 'Active' ? 'var(--success)' : 'var(--text-gray)';
                                    const statusBadge = `<span style="background: ${statusColor}; color: white; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.85rem;">${member.status}</span>`;

                                    return `
                                        <tr>
                                            <td><strong>${member.name}</strong></td>
                                            <td>${roleBadges}</td>
                                            <td>
                                                <a href="https://wa.me/${member.whatsApp.replace(/[^0-9]/g, '')}" target="_blank" style="color: var(--success);">
                                                    ${member.whatsApp}
                                                </a>
                                            </td>
                                            <td>${member.email || '-'}</td>
                                            <td><small>${member.skills && member.skills.length > 0 ? member.skills.join(', ') : '-'}</small></td>
                                            <td>${statusBadge}</td>
                                            <td>
                                                <button class="btn btn-info btn-small" onclick="OMS.editTeamMember('${member.id}')">Edit</button>
                                                <button class="btn btn-danger btn-small" onclick="OMS.deleteTeamMember('${member.id}')">Delete</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                container.innerHTML = tableHtml;
            },

            addTeamMember() {
                const name = Utils.get('teamMemberName');
                const whatsApp = Utils.get('teamMemberWhatsApp');
                const email = Utils.get('teamMemberEmail');
                const status = Utils.get('teamMemberStatus');
                const skillsStr = Utils.get('teamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('roleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('roleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('roleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('roleManager')?.checked) roles.push('Manager');
                if (document.getElementById('roleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill Name, WhatsApp, and select at least one Role', 'error');
                    return;
                }

                // Parse skills
                const skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];

                // Create team member object
                const teamMember = {
                    id: Utils.generateId(),
                    name,
                    roles,
                    whatsApp,
                    email: email || '',
                    skills,
                    status,
                    createdAt: new Date().toISOString()
                };

                this.data.team.push(teamMember);
                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(teamMember).then(success => {
                    if (success) {
                        this.showToast(`${name} added to team and synced!`, 'success');
                    } else {
                        this.showToast(`${name} added locally, but sync failed`, 'warning');
                    }
                });

                this.renderTeamTable();
                this.clearTeamForm();
            },

            clearTeamForm() {
                Utils.set('teamMemberName', '');
                Utils.set('teamMemberWhatsApp', '');
                Utils.set('teamMemberEmail', '');
                Utils.set('teamMemberSkills', '');
                Utils.set('teamMemberStatus', 'Active');

                // Uncheck all role checkboxes
                ['roleDriver', 'roleOperator', 'roleHelper', 'roleManager', 'roleSupervisor'].forEach(id => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) checkbox.checked = false;
                });
            },

            editTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                // Show edit modal
                this.showModal('Edit Team Member', `
                    <div class="form-group">
                        <label class="form-label required">Name</label>
                        <input type="text" id="editTeamMemberName" class="form-input" value="${member.name}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">WhatsApp Number</label>
                        <input type="tel" id="editTeamMemberWhatsApp" class="form-input" value="${member.whatsApp}">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Email</label>
                        <input type="email" id="editTeamMemberEmail" class="form-input" value="${member.email || ''}">
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Status</label>
                        <select id="editTeamMemberStatus" class="form-select">
                            <option value="Active" ${member.status === 'Active' ? 'selected' : ''}>Active</option>
                            <option value="Inactive" ${member.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label required">Roles</label>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.5rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleDriver" value="Driver" ${member.roles.includes('Driver') ? 'checked' : ''}>
                                üöó Driver
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleOperator" value="Operator" ${member.roles.includes('Operator') ? 'checked' : ''}>
                                ‚öôÔ∏è Operator
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleHelper" value="Helper" ${member.roles.includes('Helper') ? 'checked' : ''}>
                                ü§ù Helper
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleManager" value="Manager" ${member.roles.includes('Manager') ? 'checked' : ''}>
                                üëî Manager
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="checkbox" id="editRoleSupervisor" value="Supervisor" ${member.roles.includes('Supervisor') ? 'checked' : ''}>
                                üìã Supervisor
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Skills (comma-separated)</label>
                        <input type="text" id="editTeamMemberSkills" class="form-input" value="${member.skills && member.skills.length > 0 ? member.skills.join(', ') : ''}">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="OMS.saveTeamMemberEdit('${id}')">üíæ Save Changes</button>
                        <button class="btn btn-secondary" onclick="OMS.closeModal()">Cancel</button>
                    </div>
                `);
            },

            saveTeamMemberEdit(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                const name = Utils.get('editTeamMemberName');
                const whatsApp = Utils.get('editTeamMemberWhatsApp');
                const email = Utils.get('editTeamMemberEmail');
                const status = Utils.get('editTeamMemberStatus');
                const skillsStr = Utils.get('editTeamMemberSkills');

                // Get selected roles
                const roles = [];
                if (document.getElementById('editRoleDriver')?.checked) roles.push('Driver');
                if (document.getElementById('editRoleOperator')?.checked) roles.push('Operator');
                if (document.getElementById('editRoleHelper')?.checked) roles.push('Helper');
                if (document.getElementById('editRoleManager')?.checked) roles.push('Manager');
                if (document.getElementById('editRoleSupervisor')?.checked) roles.push('Supervisor');

                // Validation
                if (!name || !whatsApp || roles.length === 0) {
                    this.showToast('Please fill all required fields', 'error');
                    return;
                }

                // Update member
                member.name = name;
                member.whatsApp = whatsApp;
                member.email = email;
                member.status = status;
                member.roles = roles;
                member.skills = skillsStr ? skillsStr.split(',').map(s => s.trim()).filter(s => s) : [];
                member.updatedAt = new Date().toISOString();

                this.saveToStorage();

                // Save to Firestore
                this.saveTeamMemberToFirestore(member).then(success => {
                    if (success) {
                        this.showToast('Team member updated and synced!', 'success');
                    } else {
                        this.showToast('Team member updated locally, but sync failed', 'warning');
                    }
                });

                this.renderTeamTable();
                this.closeModal();
            },

            deleteTeamMember(id) {
                const member = this.data.team.find(m => m.id === id);
                if (!member) return;

                if (confirm(`Are you sure you want to delete ${member.name} from the team?`)) {
                    const index = this.data.team.findIndex(m => m.id === id);
                    if (index !== -1) {
                        const memberName = member.name;

                        this.data.team.splice(index, 1);
                        this.saveToStorage();

                        // Delete from Firestore
                        this.deleteTeamMemberFromFirestore(id).then(success => {
                            if (success) {
                                this.showToast(`${memberName} removed from team and synced!`, 'success');
                            } else {
                                this.showToast(`${memberName} removed locally, but sync failed`, 'warning');
                            }
                        });

                        this.renderTeamTable();
                    }
                }
            },

            // ============ TEAM ALLOCATION & NOTIFICATIONS ============

            populateTeamDropdowns() {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');

                // Populate Driver dropdown
                const driverSelect = document.getElementById('driverName');
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}">üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown
                const operatorSelect = document.getElementById('operator');
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}">‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Populate Helper dropdown
                const helperSelect = document.getElementById('helper');
                if (helperSelect) {
                    const helpers = activeTeam.filter(m => m.roles.includes('Helper'));
                    helperSelect.innerHTML = '<option value="">Select Helper</option>' +
                        helpers.map(h => `<option value="${h.name}" data-id="${h.id}">ü§ù ${h.name}</option>`).join('');
                }
            },

            populateFunctionTeamDropdowns(dayIndex, functionIndex) {
                // Get active team members
                const activeTeam = this.data.team.filter(m => m.status === 'Active');
                const functionId = `day${dayIndex}func${functionIndex}`;

                // Populate Driver dropdown for this function
                const driverSelect = document.getElementById(`${functionId}Driver`);
                if (driverSelect) {
                    const drivers = activeTeam.filter(m => m.roles.includes('Driver'));
                    const currentValue = driverSelect.value;
                    driverSelect.innerHTML = '<option value="">Select Driver</option>' +
                        drivers.map(d => `<option value="${d.name}" data-id="${d.id}" ${d.name === currentValue ? 'selected' : ''}>üöó ${d.name}</option>`).join('');
                }

                // Populate Operator dropdown for this function
                const operatorSelect = document.getElementById(`${functionId}Operator`);
                if (operatorSelect) {
                    const operators = activeTeam.filter(m => m.roles.includes('Operator'));
                    const currentValue = operatorSelect.value;
                    operatorSelect.innerHTML = '<option value="">Select Operator</option>' +
                        operators.map(o => `<option value="${o.name}" data-id="${o.id}" ${o.name === currentValue ? 'selected' : ''}>‚öôÔ∏è ${o.name}</option>`).join('');
                }

                // Populate Helper dropdown for this function
                const helperSelect = document.getElementById(`${functionId}Helper`);
                if (helperSelect) {
                    const helpers = activeTeam.filter(m => m.roles.includes('Helper'));
                    const currentValue = helperSelect.value;
                    helperSelect.innerHTML = '<option value="">Select Helper</option>' +
                        helpers.map(h => `<option value="${h.name}" data-id="${h.id}" ${h.name === currentValue ? 'selected' : ''}>ü§ù ${h.name}</option>`).join('');
                }
            },

            notifyAllocatedTeam() {
                // Get current order form data
                const driverName = Utils.get('driverName');
                const operatorName = Utils.get('operator');
                const helperName = Utils.get('helper');

                // Get order details
                const orderId = Utils.get('orderId') || 'NEW';
                const clientName = Utils.get('clientName');
                const venue = Utils.get('venue');
                const date = Utils.get('orderDate');
                const readyTime = Utils.get('readyTime');
                const contact = Utils.get('contact');

                if (!clientName || !venue || !date) {
                    this.showToast('Please fill Order ID, Client Name, Venue, and Date first', 'error');
                    return;
                }

                // Get items from current order
                const items = this.currentOrderItems || [];

                // Find team members and send notifications
                const notifications = [];

                if (driverName) {
                    const driver = this.data.team.find(m => m.name === driverName);
                    if (driver && driver.whatsApp) {
                        this.sendTeamMemberNotification(driver, 'Driver', {
                            orderId, clientName, venue, date, readyTime, contact, items,
                            driverName, operatorName, helperName
                        });
                        notifications.push(driver.name);
                    }
                }

                if (operatorName) {
                    const operator = this.data.team.find(m => m.name === operatorName);
                    if (operator && operator.whatsApp) {
                        this.sendTeamMemberNotification(operator, 'Operator', {
                            orderId, clientName, venue, date, readyTime, contact, items,
                            driverName, operatorName, helperName
                        });
                        notifications.push(operator.name);
                    }
                }

                if (helperName) {
                    const helper = this.data.team.find(m => m.name === helperName);
                    if (helper && helper.whatsApp) {
                        this.sendTeamMemberNotification(helper, 'Helper', {
                            orderId, clientName, venue, date, readyTime, contact, items,
                            driverName, operatorName, helperName
                        });
                        notifications.push(helper.name);
                    }
                }

                if (notifications.length > 0) {
                    this.showToast(`Notifications sent to ${notifications.join(', ')}`, 'success');

                    // Log notification
                    const notification = {
                        id: Utils.generateId(),
                        type: 'team_allocation',
                        orderId,
                        recipients: notifications,
                        timestamp: new Date().toISOString()
                    };
                    this.data.notifications.push(notification);
                    this.saveToStorage();

                    // Save to Firestore
                    this.saveNotificationToFirestore(notification);
                } else {
                    this.showToast('No team members selected or no WhatsApp numbers found', 'warning');
                }
            },

            sendTeamMemberNotification(teamMember, role, orderDetails) {
                const { orderId, clientName, venue, date, readyTime, contact, items, driverName, operatorName, helperName } = orderDetails;

                // Format items list
                const itemsList = items && items.length > 0
                    ? items.map(item => `‚Ä¢ ${item.name}: ${item.quantity}${item.remarks ? ' (' + item.remarks + ')' : ''}`).join('\n')
                    : '‚Ä¢ No items added yet';

                // Build team members list
                const teamList = [
                    driverName ? `‚Ä¢ Driver: ${driverName}` : null,
                    operatorName ? `‚Ä¢ Operator: ${operatorName}` : null,
                    helperName ? `‚Ä¢ Helper: ${helperName}` : null
                ].filter(Boolean).join('\n');

                // Create WhatsApp message
                let message = `üéâ *NEW ORDER ASSIGNED TO YOU*\n\n`;
                message += `üìã *Order ID:* ${orderId}\n`;
                message += `üë§ *Client:* ${clientName}\n`;
                message += `üìç *Venue:* ${venue}\n`;
                message += `üìÖ *Date:* ${Utils.formatDate(date)}\n`;
                message += `üïê *Ready Time:* ${readyTime || 'TBD'}\n\n`;
                message += `üé≠ *Your Role:* ${role.toUpperCase()}\n\n`;

                if (teamList) {
                    message += `üë∑ *Team Members:*\n${teamList}\n\n`;
                }

                message += `üì¶ *Items Required:*\n${itemsList}\n\n`;

                if (contact) {
                    message += `üìû *Client Contact:* ${contact}\n\n`;
                }

                message += `‚ö° Please confirm receipt by replying "OK"\n\n`;
                message += `--\n_FirepowerSFX Order Management_`;

                // Encode and open WhatsApp
                const phoneNumber = teamMember.whatsApp.replace(/[^0-9]/g, '');
                const encodedMessage = encodeURIComponent(message);
                window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
            },

            sendManagerReport() {
                // Get all managers
                const managers = this.data.team.filter(m => m.roles.includes('Manager') && m.status === 'Active');

                if (managers.length === 0) {
                    this.showToast('No managers found in team. Add a team member with Manager role first.', 'warning');
                    return;
                }

                // Get today's and upcoming orders
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];
                const next7Days = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

                // Filter keywords for demo/test orders
                const demoKeywords = ['demo', 'test', 'sample', 'example', 'blank'];

                const upcomingOrders = this.data.orders.filter(order => {
                    // Filter by date
                    const orderDate = order.isMultiDay ? order.startDate : order.date;
                    if (!orderDate || orderDate < todayStr || orderDate > next7Days) {
                        return false;
                    }

                    // Filter out deleted orders
                    const isDeleted = this.data.deletedOrders.some(d => d.orderId === order.orderId);
                    if (isDeleted) {
                        return false;
                    }

                    // Filter out demo/test orders
                    const clientName = (order.clientName || '').toLowerCase();
                    const orderId = (order.orderId || '').toLowerCase();
                    const isDemo = demoKeywords.some(keyword =>
                        clientName.includes(keyword) || orderId.includes(keyword)
                    );
                    if (isDemo) {
                        return false;
                    }

                    // Filter out orders with empty client names
                    if (!order.clientName || order.clientName.trim() === '') {
                        return false;
                    }

                    return true;
                }).sort((a, b) => {
                    const dateA = a.isMultiDay ? a.startDate : a.date;
                    const dateB = b.isMultiDay ? b.startDate : b.date;
                    return dateA.localeCompare(dateB);
                });

                if (upcomingOrders.length === 0) {
                    this.showToast('No upcoming orders in next 7 days to report', 'info');
                    return;
                }

                // Build manager report
                let message = `üìä *TEAM ALLOCATION REPORT*\n`;
                message += `üìÖ *Date:* ${new Date().toLocaleDateString()}\n`;
                message += `üìã *Period:* Next 7 Days\n\n`;
                message += `*Total Orders:* ${upcomingOrders.length}\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

                // Group orders by date
                const ordersByDate = {};
                upcomingOrders.forEach(order => {
                    const orderDate = order.isMultiDay ? order.startDate : order.date;
                    if (!ordersByDate[orderDate]) {
                        ordersByDate[orderDate] = [];
                    }
                    ordersByDate[orderDate].push(order);
                });

                // Add orders to message
                Object.keys(ordersByDate).sort().forEach(date => {
                    message += `üìÖ *${Utils.formatDate(date)}*\n\n`;

                    ordersByDate[date].forEach((order, index) => {
                        message += `*ORDER #${index + 1}: ${order.orderId}*\n`;
                        message += `üë§ Client: ${order.clientName}\n`;
                        message += `üìç Venue: ${order.venue}\n`;
                        message += `üïê ${order.readyTime || 'TBD'}\n`;
                        message += `üìä Status: ${order.status || 'Pending'}\n`;

                        if (order.driverName || order.operator || order.helper) {
                            message += `üë∑ Team:\n`;
                            if (order.driverName) message += `  ‚Ä¢ Driver: ${order.driverName}\n`;
                            if (order.operator) message += `  ‚Ä¢ Operator: ${order.operator}\n`;
                            if (order.helper) message += `  ‚Ä¢ Helper: ${order.helper}\n`;
                        } else {
                            message += `‚ö†Ô∏è *Not Allocated Yet*\n`;
                        }
                        message += `\n`;
                    });
                });

                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

                // Workload summary
                const workload = {};
                upcomingOrders.forEach(order => {
                    if (order.driverName) {
                        workload[order.driverName] = (workload[order.driverName] || 0) + 1;
                    }
                    if (order.operator) {
                        workload[order.operator] = (workload[order.operator] || 0) + 1;
                    }
                    if (order.helper) {
                        workload[order.helper] = (workload[order.helper] || 0) + 1;
                    }
                });

                if (Object.keys(workload).length > 0) {
                    message += `üìä *WORKLOAD SUMMARY:*\n`;
                    Object.entries(workload)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([name, count]) => {
                            message += `${name}: ${count} order${count > 1 ? 's' : ''}\n`;
                        });
                    message += `\n`;
                }

                message += `--\n_FirepowerSFX Admin_`;

                // Send to all managers
                managers.forEach(manager => {
                    const phoneNumber = manager.whatsApp.replace(/[^0-9]/g, '');
                    const encodedMessage = encodeURIComponent(message);
                    window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
                });

                // Log notification
                const notification = {
                    id: Utils.generateId(),
                    type: 'manager_report',
                    recipients: managers.map(m => m.name),
                    orderCount: upcomingOrders.length,
                    timestamp: new Date().toISOString()
                };
                this.data.notifications.push(notification);
                this.saveToStorage();

                // Save to Firestore
                this.saveNotificationToFirestore(notification);

                this.showToast(`Manager report sent to ${managers.length} manager(s)`, 'success');
            },

            renderCalendarTab() {
                document.getElementById('calendar').innerHTML = this.renderCalendar(this.currentCalendarDate || new Date());
            },

            renderHistory() {
                const container = document.getElementById('history');
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìö Order History</h2>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" data-action="exportData">üì• Export</button>
                        </div>
                        <div id="historyContainer"></div>
                    </div>
                `;
                
                this.renderTable('historyContainer', [
                    { key: 'orderId', label: 'Order ID', render: o => `<span class="order-id-highlight">${o.orderId}</span>` },
                    { key: 'clientName', label: 'Client' },
                    { key: 'venue', label: 'Venue' },
                    { key: 'date', label: 'Date', render: o => {
                        if (o.isMultiDay) {
                            return `${Utils.formatDate(o.startDate)} to ${Utils.formatDate(o.endDate)}`;
                        }
                        return Utils.formatDate(o.date);
                    }},
                    { key: 'status', label: 'Status', render: o => `<span class="status-badge status-${o.status.toLowerCase()}">${o.status}</span>` }
                ], this.data.orders, (row) => `
                    <button class="btn btn-secondary btn-small" data-action="edit" data-type="order" data-id="${row.orderId}">Edit</button>
                    <button class="btn btn-success btn-small" data-action="print" data-id="${row.orderId}">Print</button>
                    <button class="btn btn-danger btn-small" data-action="delete" data-type="order" data-id="${row.orderId}">Delete</button>
                `);
            },

            renderAnalytics() {
    const container = document.getElementById('analytics');
    const trackingData = this.data.trackingData || [];
    
    // Calculate stats
    const pageViews = trackingData.filter(t => t.type === 'page_view').length;
    const cartActions = trackingData.filter(t => t.type === 'cart_add' || t.type === 'cart_remove').length;
    const uniqueSessions = [...new Set(trackingData.map(t => t.sessionId))].length;
    
    // Get device breakdown
    const devices = {};
    trackingData.forEach(t => {
        const device = t.userInfo?.device || 'unknown';
        devices[device] = (devices[device] || 0) + 1;
    });
    
    // Get location breakdown
    const locations = {};
    trackingData.forEach(t => {
        const city = t.userInfo?.city || 'Unknown';
        locations[city] = (locations[city] || 0) + 1;
    });
    
    container.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üìà Business Analytics</h2>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">${this.data.orders.length}</div>
                    <div class="stat-label">Total Orders</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-value">${this.data.customers.filter(c => c.totalOrders > 1).length}</div>
                    <div class="stat-label">Repeat Customers</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-value">${pageViews}</div>
                    <div class="stat-label">Page Views</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-value">${uniqueSessions}</div>
                    <div class="stat-label">Unique Visitors</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3 class="card-title">üì± Device Breakdown</h3>
            <div class="stats-grid">
                ${Object.entries(devices).map(([device, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${device.charAt(0).toUpperCase() + device.slice(1)}</div>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="card">
            <h3 class="card-title">üìç Visitor Locations</h3>
            <div class="stats-grid">
                ${Object.entries(locations).slice(0, 6).map(([city, count]) => `
                    <div class="stat-card">
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${city}</div>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="card">
            <h3 class="card-title">üïê Recent Activity</h3>
            <div class="table-container">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Type</th>
                            <th>Device</th>
                            <th>Location</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${trackingData.slice(0, 10).map(t => {
    const date = new Date(t.timestamp);
    const formattedDate = date.toLocaleDateString('en-GB') + ' ' + date.toLocaleTimeString('en-GB');
    const formattedType = t.type.replace(/_/g, ' ').split(' ').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
    
    return `
        <tr>
            <td>${formattedDate}</td>
            <td><span class="status-badge">${formattedType}</span></td>
            <td>${t.userInfo?.device || 'N/A'}</td>
            <td>${t.userInfo?.city || 'N/A'}, ${t.userInfo?.country || 'N/A'}</td>
        </tr>
    `;
}).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;
},

            renderSettings() {
                const container = document.getElementById('settings');
                const s = this.data.settings;
                const ts = s.tableSettings;
                const colors = s.printColors;
                
                container.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">‚öôÔ∏è System Settings</h2>
                        </div>
                        
                        <div class="card">
                            <h3>üìã Table Layout Settings</h3>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">Sr.No Column Width: <span id="srWidthValue">${ts.columnWidthSr}%</span></label>
                                    <input type="range" id="columnWidthSr" class="form-input" min="5" max="25" value="${ts.columnWidthSr}" 
                                           oninput="document.getElementById('srWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Item Name Width: <span id="itemWidthValue">${ts.columnWidthItem}%</span></label>
                                    <input type="range" id="columnWidthItem" class="form-input" min="15" max="60" value="${ts.columnWidthItem}" 
                                           oninput="document.getElementById('itemWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Quantity Width: <span id="qtyWidthValue">${ts.columnWidthQty}%</span></label>
                                    <input type="range" id="columnWidthQty" class="form-input" min="5" max="30" value="${ts.columnWidthQty}" 
                                           oninput="document.getElementById('qtyWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Remarks Width: <span id="remarksWidthValue">${ts.columnWidthRemarks}%</span></label>
                                    <input type="range" id="columnWidthRemarks" class="form-input" min="15" max="60" value="${ts.columnWidthRemarks}" 
                                           oninput="document.getElementById('remarksWidthValue').textContent = this.value + '%'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Left Margin (filing): <span id="leftMarginValue">${ts.leftMargin}mm</span></label>
                                    <input type="range" id="leftMargin" class="form-input" min="30" max="100" value="${ts.leftMargin}" 
                                           oninput="document.getElementById('leftMarginValue').textContent = this.value + 'mm'">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>üé® Color Customization</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;">
                                <div class="form-group">
                                    <label class="form-label">Header Background</label>
                                    <input type="color" id="printHeaderBg" class="form-input" value="${colors.headerBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Header Text</label>
                                    <input type="color" id="printHeaderText" class="form-input" value="${colors.headerText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Order ID Background</label>
                                    <input type="color" id="printOrderIdBg" class="form-input" value="${colors.orderIdBg || '#667eea'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Order ID Text</label>
                                    <input type="color" id="printOrderIdText" class="form-input" value="${colors.orderIdText || '#ffffff'}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Table Header Background</label>
                                    <input type="color" id="printTableHeaderBg" class="form-input" value="${colors.tableHeaderBg}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Table Header Text</label>
                                    <input type="color" id="printTableHeaderText" class="form-input" value="${colors.tableHeaderText}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Table Border</label>
                                    <input type="color" id="printTableBorder" class="form-input" value="${colors.tableBorder}" style="height: 50px;">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Notes Background</label>
                                    <input type="color" id="printNotesBg" class="form-input" value="${colors.notesBg}" style="height: 50px;">
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3>üñ®Ô∏è Print Settings</h3>
                            <div class="form-group">
                                <label class="form-label">Default Font Size: <span id="fontSizeValue">${s.printFontSize}px</span></label>
                                <input type="range" id="printFontSize" class="form-input" min="16" max="80" value="${s.printFontSize}" 
                                       oninput="document.getElementById('fontSizeValue').textContent = this.value + 'px'">
                                <small style="color: var(--text-gray);">Note: Multi-order images use smart auto-sizing</small>
                            </div>
                        </div>

                        <div class="card">
                            <h3>üîß System Preferences</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Default Order Status</label>
                                    <select id="defaultOrderStatus" class="form-select">
                                        <option value="Confirmed" ${s.defaultOrderStatus === 'Confirmed' ? 'selected' : ''}>Confirmed</option>
                                        <option value="Completed" ${s.defaultOrderStatus === 'Completed' ? 'selected' : ''}>Completed</option>
                                        <option value="Cancelled" ${s.defaultOrderStatus === 'Cancelled' ? 'selected' : ''}>Cancelled</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Low Stock Threshold</label>
                                    <input type="number" id="lowStockThreshold" class="form-input" value="${s.lowStockThreshold}" min="1">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Language</label>
                                    <select id="appLanguage" class="form-select">
                                        <option value="en" ${s.language === 'en' ? 'selected' : ''}>English</option>
                                        <option value="gu" ${s.language === 'gu' ? 'selected' : ''}>‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Invoice Number Format</label>
                                    <select id="invoiceFormat" class="form-select">
                                        <option value="FP" ${s.invoicePrefix === 'FP' ? 'selected' : ''}>FP001</option>
                                        <option value="ORD" ${s.invoicePrefix === 'ORD' ? 'selected' : ''}>ORD001</option>
                                        <option value="INV" ${s.invoicePrefix === 'INV' ? 'selected' : ''}>INV001</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="OMS.saveSettings()">üíæ Save All Settings</button>
                            <button class="btn btn-secondary" onclick="OMS.resetSettings()">üîÑ Reset to Defaults</button>
                        </div>

                        <div class="card">
                            <h3>üìä Data Management</h3>
                            <div class="btn-group">
                                <button class="btn btn-info" data-action="exportData">üì§ Export JSON</button>
                                <button class="btn btn-success" onclick="OMS.exportData('csv')">üìä Export CSV</button>
                                <button class="btn btn-warning" data-action="importData">üì• Import Backup</button>
                                <button class="btn btn-danger" onclick="OMS.resetAllData()">üóëÔ∏è Reset All Data</button>
                            </div>
                        </div>
                    </div>
                `;
            },

            async saveSettings() {
                // Save table settings
                this.data.settings.tableSettings = {
                    columnWidthSr: parseInt(Utils.get('columnWidthSr')) || 8,
                    columnWidthItem: parseInt(Utils.get('columnWidthItem')) || 40,
                    columnWidthQty: parseInt(Utils.get('columnWidthQty')) || 12,
                    columnWidthRemarks: parseInt(Utils.get('columnWidthRemarks')) || 40,
                    leftMargin: parseInt(Utils.get('leftMargin')) || 50
                };

                // Save colors
                this.data.settings.printColors = {
                    headerBg: Utils.get('printHeaderBg') || '#667eea',
                    headerText: Utils.get('printHeaderText') || '#ffffff',
                    orderIdBg: Utils.get('printOrderIdBg') || '#667eea',
                    orderIdText: Utils.get('printOrderIdText') || '#ffffff',
                    tableHeaderBg: Utils.get('printTableHeaderBg') || '#f8f9fa',
                    tableHeaderText: Utils.get('printTableHeaderText') || '#333333',
                    tableBorder: Utils.get('printTableBorder') || '#333333',
                    notesBg: Utils.get('printNotesBg') || '#f9f9f9'
                };

                // Save other settings
                this.data.settings.printFontSize = parseInt(Utils.get('printFontSize')) || 32;
                this.data.settings.defaultOrderStatus = Utils.get('defaultOrderStatus') || 'Confirmed';
                this.data.settings.lowStockThreshold = parseInt(Utils.get('lowStockThreshold')) || 5;
                this.data.settings.language = Utils.get('appLanguage') || 'en';
                this.data.settings.invoicePrefix = Utils.get('invoiceFormat') || 'FP';

                // Save to localStorage
                this.saveToStorage();

                // Save to Firestore for persistence across devices
                const saved = await this.saveSettingsToFirestore();

                if (saved) {
                    this.refreshOrderId();
                    this.showToast('All settings saved successfully!');
                } else {
                    this.showToast('Settings saved locally, but Firestore sync failed. Check permissions.');
                }
            },

            resetAllData() {
                if (!confirm('‚ö†Ô∏è This will delete ALL data permanently. Are you absolutely sure?')) return;
                if (!confirm('Last chance! This action CANNOT be undone. Confirm data reset?')) return;
                
                localStorage.removeItem('oms_data');
                this.showToast('Data reset! Reloading...');
                setTimeout(() => location.reload(), 1000);
            },

            resetSettings() {
                if (!confirm('Reset all settings?')) return;
                
                this.data.settings = {
                    printFontSize: 32,
                    orderIdCounter: this.data.settings.orderIdCounter,
                    invoicePrefix: 'FP',
                    lowStockThreshold: 5,
                    language: 'en',
                    defaultOrderStatus: 'Confirmed',
                    tableSettings: {
                        columnWidthSr: 8,
                        columnWidthItem: 40,
                        columnWidthQty: 12,
                        columnWidthRemarks: 40,
                        leftMargin: 50
                    },
                    printColors: {
                        headerBg: '#667eea',
                        headerText: '#ffffff',
                        orderIdBg: '#667eea',
                        orderIdText: '#ffffff',
                        tableHeaderBg: '#f8f9fa',
                        tableHeaderText: '#333333',
                        tableBorder: '#333333',
                        notesBg: '#f9f9f9'
                    }
                };
                
                this.saveToStorage();
                this.renderSettings();
                this.showToast('Settings reset!');
            },

            // ============ ITEM SEARCH ============
            initItemSearch() {
                const itemSearch = document.getElementById('itemSearch');
                const dropdown = document.getElementById('itemSearchDropdown');

                if (!itemSearch || !dropdown) return;

                // Populate team member dropdowns
                this.populateTeamDropdowns();

                itemSearch.addEventListener('input', Utils.debounce((e) => {
                    const query = e.target.value.toLowerCase().trim();
                    
                    if (query.length > 0) {
                        const items = this.data.inventory.items.filter(i => 
                            i.name.toLowerCase().includes(query)
                        );
                        
                        if (items.length > 0) {
                            dropdown.innerHTML = items.map(i => `
                                <div class="search-item" onclick="OMS.addItemToOrder('${i.id}')">
                                    <span>${i.name}</span>
                                    <span>${i.quantity} in stock</span>
                                </div>
                            `).join('');
                            dropdown.classList.add('show');
                        } else {
                            dropdown.classList.remove('show');
                        }
                    } else {
                        dropdown.classList.remove('show');
                    }
                }, 300));
            },

            addItemToOrder(itemId) {
                const item = this.data.inventory.items.find(i => i.id === itemId);
                if (!item) return;
                
                const existing = this.currentOrderItems.find(oi => oi.itemId === itemId);
                if (existing) {
                    existing.quantity++;
                } else {
                    this.currentOrderItems.push({
                        itemId: itemId,
                        name: item.name,
                        quantity: 1,
                        remarks: ''
                    });
                }
                
                this.updateOrderItemsTable();
                document.getElementById('itemSearchDropdown').classList.remove('show');
                Utils.set('itemSearch', '');
            },

            updateOrderItemsTable() {
                const container = document.getElementById('orderItemsContainer');
                if (!container) return;
                
                if (this.currentOrderItems.length === 0) {
                    container.innerHTML = '<table class="table"><tbody><tr><td colspan="5" class="text-center">No items added</td></tr></tbody></table>';
                    return;
                }
                
                container.innerHTML = `
                    <table class="table">
                        <thead>
                            <tr><th>Sr</th><th>Item</th><th>Qty</th><th>Remarks</th><th>Actions</th></tr>
                        </thead>
                        <tbody>
                            ${this.currentOrderItems.map((item, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${item.name}</td>
                                    <td>
                                        <div class="quantity-controls">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, -1)">-</button>
                                            <input type="number" value="${item.quantity}" onchange="OMS.setItemQty(${i}, this.value)" 
                                                   style="width: 60px; text-align: center;" min="1">
                                            <button class="quantity-btn" onclick="OMS.adjustItemQty(${i}, 1)">+</button>
                                        </div>
                                    </td>
                                    <td>
                                        <input type="text" class="form-input" value="${item.remarks || ''}" 
                                               onchange="OMS.setItemRemarks(${i}, this.value)" placeholder="Remarks">
                                    </td>
                                    <td>
                                        <button class="btn btn-danger btn-small" onclick="OMS.removeOrderItem(${i})">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            },

            adjustItemQty(index, delta) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, item.quantity + delta);
                    this.updateOrderItemsTable();
                }
            },

            setItemQty(index, qty) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.quantity = Math.max(1, parseInt(qty) || 1);
                }
            },

            setItemRemarks(index, remarks) {
                const item = this.currentOrderItems[index];
                if (item) {
                    item.remarks = remarks;
                }
            },

            removeOrderItem(index) {
                this.currentOrderItems.splice(index, 1);
                this.updateOrderItemsTable();
            },

            // ============ STORAGE ============
            saveToStorage() {
                try {
                    localStorage.setItem('oms_data', JSON.stringify(this.data));
                    return true;
                } catch (error) {
                    this.showToast('Storage error: ' + error.message, 'error');
                    return false;
                }
            },

            async loadFromStorage() {
    try {
        console.log('üì• Loading all data from Firestore...');

        // Load localStorage as fallback/cache
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data = {
                orders: [], // Will load from Firestore
                customers: parsed.customers || [],
                team: parsed.team || [],
                inventory: parsed.inventory || { categories: [], items: [] },
                tasks: parsed.tasks || [],
                deletedOrders: parsed.deletedOrders || [],
                undoStack: [],
                notifications: parsed.notifications || [],
                settings: { ...this.data.settings, ...parsed.settings }
            };
        }

        // Load ALL data from Firestore (primary source)
        await Promise.all([
            this.loadOrdersFromFirestore(),
            this.loadTrackingFromFirestore(),
            this.loadTeamFromFirestore(),
            this.loadInventoryFromFirestore(),
            this.loadNotificationsFromFirestore(),
            this.loadSettingsFromFirestore()
        ]);

        // Setup real-time listeners for all collections
        this.setupAllRealtimeListeners();

        console.log('‚úÖ All data loaded from Firestore successfully!');

    } catch (error) {
        console.error('‚ùå Load error:', error);
        this.showToast('Error loading data: ' + error.message, 'error');
    }
},

async loadOrdersFromFirestore() {
    try {
        console.log('üì• Loading orders from Firestore...');

        const ordersSnapshot = await db.collection('orders').get();

        this.data.orders = [];
        let skippedDeleted = 0;

        ordersSnapshot.forEach(doc => {
            const orderData = doc.data();
            const customer = orderData.customer || {};
            const orderId = orderData.orderId || ''; // FIXED: Keep blank if no orderId
            const docId = doc.id;

            // CRITICAL: Skip orders that are in deletedOrders list
            const wasDeleted = this.data.deletedOrders.some(o =>
                o.docId === docId || (orderId && o.orderId === orderId)
            );

            if (wasDeleted) {
                console.warn(`‚ö†Ô∏è Skipping deleted order: ${orderId || docId} (found in deletedOrders list)`);
                skippedDeleted++;
                return;
            }

            const loadedOrder = {
                orderId: orderId, // Can be blank for pending/confirmed
                docId: docId, // CRITICAL: Always store docId
                date: Utils.convertDateFormat(customer.dates) || '',
                readyTime: customer.timeSlot || '',
                clientName: customer.name || '',
                contact: customer.phone || '',
                venue: customer.venue || '',
                eventType: orderData.functionType || customer.functionType || '',
                transport: '',
                driverName: '',
                operator: '',
                helper: '',
                status: orderData.status || 'Confirmed',
                notes: '',
                items: (orderData.items || []).map(item => ({
                    name: item.name || '',
                    quantity: item.qty || 0,
                    remarks: item.desc || '',
                    price: item.price || 0
                })),
                createdAt: orderData.createdAt || new Date().toISOString(),
                totalAmount: orderData.totalAmount || 0,
                // Multi-day order fields
                isMultiDay: orderData.isMultiDay || false,
                startDate: orderData.startDate || null,
                endDate: orderData.endDate || null,
                dayWiseData: orderData.dayWiseData || []
            };

            // Debug log multi-day orders
            if (orderData.isMultiDay) {
                console.log(`üìÖ Loaded multi-day order ${orderId}:`, {
                    isMultiDay: loadedOrder.isMultiDay,
                    startDate: loadedOrder.startDate,
                    endDate: loadedOrder.endDate,
                    dayWiseData: loadedOrder.dayWiseData?.length || 0
                });
            }

            this.data.orders.push(loadedOrder);
        });

        console.log(`‚úÖ Loaded ${this.data.orders.length} orders from Firestore (skipped ${skippedDeleted} deleted)`);

        // Update customer database from orders
        this.data.orders.forEach(order => {
            this.updateCustomerDatabase(order);
        });

    } catch (error) {
        console.error('‚ùå Error loading orders from Firestore:', error);
    }
},

async loadTrackingFromFirestore() {
    try {
        console.log('üìä Loading tracking data from Firestore...');
        
        const trackingSnapshot = await db.collection('tracking')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();
        
        this.data.trackingData = [];
        trackingSnapshot.forEach(doc => {
            const data = doc.data();
            this.data.trackingData.push({
                id: doc.id,
                sessionId: data.sessionId,
                type: data.type,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate().toISOString() : data.timestamp,
                url: data.url,
                userInfo: data.userInfo || {}
            });
        });
        
        console.log(`‚úÖ Loaded ${this.data.trackingData.length} tracking events`);
        
    } catch (error) {
        console.error('‚ùå Error loading tracking data:', error);
        this.data.trackingData = [];
    }
},

// ============ TEAM FIRESTORE SYNC ============

async saveTeamMemberToFirestore(teamMember) {
    try {
        const user = auth.currentUser;
        if (!user) {
            console.error('‚ùå No user logged in');
            return false;
        }

        await db.collection('team').doc(teamMember.id).set({
            ...teamMember,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Team member saved to Firestore:', teamMember.name);
        return true;
    } catch (error) {
        console.error('‚ùå Error saving team member to Firestore:', error);
        this.showToast('Failed to sync team member: ' + error.message, 'error');
        return false;
    }
},

async loadTeamFromFirestore() {
    try {
        console.log('üë∑ Loading team from Firestore...');

        const teamSnapshot = await db.collection('team')
            .orderBy('createdAt', 'desc')
            .get();

        this.data.team = [];
        teamSnapshot.forEach(doc => {
            this.data.team.push({
                id: doc.id,
                ...doc.data()
            });
        });

        console.log(`‚úÖ Loaded ${this.data.team.length} team members from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading team from Firestore:', error);
        // Try to load from localStorage as fallback
        const saved = localStorage.getItem('oms_data');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.data.team = parsed.team || [];
            console.log('üì¶ Loaded team from localStorage backup');
        }
        return false;
    }
},

async deleteTeamMemberFromFirestore(teamMemberId) {
    try {
        await db.collection('team').doc(teamMemberId).delete();
        console.log('‚úÖ Team member deleted from Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting team member from Firestore:', error);
        return false;
    }
},

// ============ INVENTORY FIRESTORE SYNC ============

async saveInventoryCategoryToFirestore(category) {
    try {
        await db.collection('inventory').doc('categories').collection('items').doc(category.id).set({
            ...category,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory category saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving category to Firestore:', error);
        return false;
    }
},

async saveInventoryItemToFirestore(item) {
    try {
        await db.collection('inventory').doc('items').collection('list').doc(item.id).set({
            ...item,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Inventory item saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving item to Firestore:', error);
        return false;
    }
},

async loadInventoryFromFirestore() {
    try {
        console.log('üì¶ Loading inventory from Firestore...');

        const currentCatCount = this.data.inventory.categories.length;
        const currentItemCount = this.data.inventory.items.length;
        const currentTotalCount = currentCatCount + currentItemCount;

        // Load categories
        const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
        const categories = [];
        categoriesSnapshot.forEach(doc => {
            categories.push({ id: doc.id, ...doc.data() });
        });

        // Load items
        const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
        const items = [];
        itemsSnapshot.forEach(doc => {
            items.push({ id: doc.id, ...doc.data() });
        });

        const firestoreTotalCount = categories.length + items.length;

        console.log(`üì¶ Firestore inventory: ${categories.length} categories, ${items.length} items (TOTAL: ${firestoreTotalCount})`);
        console.log(`üì¶ Current local inventory: ${currentCatCount} categories, ${currentItemCount} items (TOTAL: ${currentTotalCount})`);

        // CRITICAL: Always prefer the larger dataset (prevents demo data from overwriting real data)
        if (firestoreTotalCount > currentTotalCount) {
            // Firestore has MORE data - use it (this is the real data!)
            console.log(`‚úÖ Firestore has MORE data (${firestoreTotalCount} vs ${currentTotalCount}) - loading from Firestore`);
            this.data.inventory = { categories, items };
            console.log(`‚úÖ Loaded ${categories.length} categories and ${items.length} items from Firestore`);
            this.saveToStorage(); // Save to localStorage immediately
        } else if (currentTotalCount > firestoreTotalCount && currentTotalCount > 0) {
            // Local has MORE data - keep it and sync to Firestore
            console.warn(`‚ö†Ô∏è Local has MORE data (${currentTotalCount} vs ${firestoreTotalCount}) - keeping local`);
            console.log('üîÑ Syncing local data to Firestore...');
            await this.syncInventoryToFirestore();
        } else if (firestoreTotalCount > 0) {
            // Both have same amount, but Firestore exists - use Firestore
            console.log('‚úÖ Using Firestore data (same count or Firestore is source of truth)');
            this.data.inventory = { categories, items };
            this.saveToStorage();
        } else if (currentTotalCount > 0) {
            // Firestore empty but local has data
            console.warn('‚ö†Ô∏è‚ö†Ô∏è Firestore is empty but local has data - keeping local and syncing');
            await this.syncInventoryToFirestore();
        } else {
            // Both empty - data loss!
            console.error('‚ùå‚ùå CRITICAL: Both Firestore AND local are empty!');
            console.error('‚ùå ALL INVENTORY DATA HAS BEEN LOST!');
        }

        return true;
    } catch (error) {
        console.error('‚ùå Error loading inventory from Firestore:', error);
        // On error, keep existing data
        console.log('‚ö†Ô∏è Keeping existing local inventory due to error');
        return false;
    }
},

async syncInventoryToFirestore() {
    try {
        // Sync all categories
        for (const category of this.data.inventory.categories) {
            await this.saveInventoryCategoryToFirestore(category);
        }

        // Sync all items
        for (const item of this.data.inventory.items) {
            await this.saveInventoryItemToFirestore(item);
        }

        console.log('‚úÖ Inventory synced to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error syncing inventory:', error);
        return false;
    }
},

async deleteInventoryItemFromFirestore(itemId, type = 'item') {
    try {
        if (type === 'category') {
            await db.collection('inventory').doc('categories').collection('items').doc(itemId).delete();
            console.log('‚úÖ Inventory category deleted from Firestore');
        } else {
            await db.collection('inventory').doc('items').collection('list').doc(itemId).delete();
            console.log('‚úÖ Inventory item deleted from Firestore');
        }
        return true;
    } catch (error) {
        console.error('‚ùå Error deleting inventory item:', error);
        return false;
    }
},

// ============ NOTIFICATIONS FIRESTORE SYNC ============

async saveNotificationToFirestore(notification) {
    try {
        await db.collection('notifications').doc(notification.id).set({
            ...notification,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log('‚úÖ Notification saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving notification to Firestore:', error);
        return false;
    }
},

async loadNotificationsFromFirestore() {
    try {
        console.log('üîî Loading notifications from Firestore...');

        const notifSnapshot = await db.collection('notifications')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

        this.data.notifications = [];
        notifSnapshot.forEach(doc => {
            this.data.notifications.push({ id: doc.id, ...doc.data() });
        });

        console.log(`‚úÖ Loaded ${this.data.notifications.length} notifications from Firestore`);
        return true;
    } catch (error) {
        console.error('‚ùå Error loading notifications from Firestore:', error);
        return false;
    }
},

// ============ SETTINGS FIRESTORE SYNC ============

async saveSettingsToFirestore() {
    try {
        const user = auth.currentUser;
        if (!user) return false;

        await db.collection('settings').doc('app_settings').set({
            ...this.data.settings,
            updatedBy: user.email,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        console.log('‚úÖ Settings saved to Firestore');
        return true;
    } catch (error) {
        console.error('‚ùå Error saving settings to Firestore:', error);
        return false;
    }
},

async loadSettingsFromFirestore() {
    try {
        console.log('‚öôÔ∏è Loading settings from Firestore...');

        const settingsDoc = await db.collection('settings').doc('app_settings').get();

        if (settingsDoc.exists) {
            const firestoreSettings = settingsDoc.data();
            // Merge with default settings
            this.data.settings = {
                ...this.data.settings,
                ...firestoreSettings
            };
            console.log('‚úÖ Settings loaded from Firestore');
            return true;
        } else {
            console.log('üìù No settings in Firestore, using defaults');
            // Save default settings to Firestore
            await this.saveSettingsToFirestore();
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error loading settings from Firestore:', error);
        return false;
    }
},

// ============ REAL-TIME SYNC LISTENERS ============

setupAllRealtimeListeners() {
    if (this.allListenersActive) {
        console.log('‚ö†Ô∏è All listeners already active');
        return;
    }

    console.log('üîÑ Setting up all real-time listeners...');
    this.allListenersActive = true;

    // Team real-time listener
    this.teamUnsubscribe = db.collection('team').onSnapshot((snapshot) => {
        snapshot.docChanges().forEach((change) => {
            const teamMember = { id: change.doc.id, ...change.doc.data() };

            if (change.type === 'added' || change.type === 'modified') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index === -1) {
                    this.data.team.push(teamMember);
                    console.log('üë∑ Team member added/updated:', teamMember.name);
                } else {
                    this.data.team[index] = teamMember;
                }
                // Update UI if on team tab
                if (this.currentTab === 'team') {
                    this.renderTeamTable();
                }
            } else if (change.type === 'removed') {
                const index = this.data.team.findIndex(t => t.id === teamMember.id);
                if (index !== -1) {
                    this.data.team.splice(index, 1);
                    console.log('üë∑ Team member removed:', teamMember.name);
                    if (this.currentTab === 'team') {
                        this.renderTeamTable();
                    }
                }
            }
        });

        // Update localStorage backup
        this.saveToStorage();
    });

    // Inventory real-time listeners
    let categoriesInitialLoad = true;
    this.inventoryCategoriesUnsubscribe = db.collection('inventory').doc('categories').collection('items')
        .onSnapshot((snapshot) => {
            if (categoriesInitialLoad) {
                console.log('üì¶ Inventory categories listener - initial snapshot (skipping save)');
                categoriesInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 3 && removedCount > this.data.inventory.categories.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} categories (${this.data.inventory.categories.length} total). This looks like data loss!`);
                console.error('Inventory categories NOT deleted. Check Firestore data integrity.');
                return;
            }

            changes.forEach((change) => {
                const category = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index === -1) {
                        this.data.inventory.categories.push(category);
                        console.log(`üìÅ Category ${change.type}:`, category.name);
                    } else {
                        this.data.inventory.categories[index] = category;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.categories.findIndex(c => c.id === category.id);
                    if (index !== -1) {
                        this.data.inventory.categories.splice(index, 1);
                        console.log(`üóëÔ∏è Category removed:`, category.name);
                    }
                }
            });

            console.log(`üì¶ Total categories after update: ${this.data.inventory.categories.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    let itemsInitialLoad = true;
    this.inventoryItemsUnsubscribe = db.collection('inventory').doc('items').collection('list')
        .onSnapshot((snapshot) => {
            if (itemsInitialLoad) {
                console.log('üì¶ Inventory items listener - initial snapshot (skipping save)');
                itemsInitialLoad = false;
                return; // Skip initial snapshot to prevent overwriting loaded data
            }

            const changes = snapshot.docChanges();
            const removedCount = changes.filter(c => c.type === 'removed').length;

            // SAFETY: Prevent mass deletion - if more than 50% of items are being removed, log error and skip
            if (removedCount > 5 && removedCount > this.data.inventory.items.length * 0.5) {
                console.error(`‚ö†Ô∏è‚ö†Ô∏è BLOCKED: Attempted to remove ${removedCount} items (${this.data.inventory.items.length} total). This looks like data loss!`);
                console.error('Inventory items NOT deleted. Check Firestore data integrity.');
                console.error('Use AdminUtils.recoverInventoryFromLocalStorage() to recover data');
                return;
            }

            changes.forEach((change) => {
                const item = { id: change.doc.id, ...change.doc.data() };

                if (change.type === 'added' || change.type === 'modified') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index === -1) {
                        this.data.inventory.items.push(item);
                        console.log(`üì¶ Item ${change.type}:`, item.name);
                    } else {
                        this.data.inventory.items[index] = item;
                    }
                } else if (change.type === 'removed') {
                    const index = this.data.inventory.items.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        this.data.inventory.items.splice(index, 1);
                        console.log(`üóëÔ∏è Item removed:`, item.name);
                    }
                }
            });

            console.log(`üì¶ Total items after update: ${this.data.inventory.items.length}`);
            if (this.currentTab === 'inventory') {
                this.updateInventoryDisplay();
            }
            this.saveToStorage();
        });

    // Settings real-time listener
    this.settingsUnsubscribe = db.collection('settings').doc('app_settings')
        .onSnapshot((doc) => {
            if (doc.exists) {
                this.data.settings = {
                    ...this.data.settings,
                    ...doc.data()
                };
                console.log('‚öôÔ∏è Settings updated from Firestore');
                this.saveToStorage();
            }
        });

    console.log('‚úÖ All real-time listeners active');
},

setupRealtimeListeners() {
    // CRITICAL: Prevent duplicate listeners
    if (OMS.realtimeListenerActive) {
        console.log('‚ö†Ô∏è Listener already active - preventing duplicate!');
        return;
    }

    // Unsubscribe from any previous listener
    if (OMS.ordersUnsubscribe) {
        console.log('üõë Unsubscribing from previous listener');
        OMS.ordersUnsubscribe();
    }

    console.log('üîÑ Setting up real-time listener (SINGLE INSTANCE)');
    OMS.realtimeListenerActive = true;

    // Track initial load to avoid showing toast notifications for existing orders
    let isInitialLoad = true;

    OMS.ordersUnsubscribe = db.collection('orders').onSnapshot((snapshot) => {
        const isFirstLoad = isInitialLoad;
        if (isInitialLoad) {
            console.log(`üìã Initial snapshot received - loading ${snapshot.size} existing orders from Firebase`);
            isInitialLoad = false;
        }

        snapshot.docChanges().forEach((change) => {
            const orderData = change.doc.data();
            const customer = orderData.customer || {};

            if (change.type === 'added') {
                const docId = change.doc.id;
                const orderId = orderData.orderId || '';

                // FIXED: Check by docId (primary) or orderId (if exists)
                const exists = this.data.orders.some(o =>
                    o.docId === docId || (orderId && o.orderId === orderId)
                );

                if (!exists) {
                    // FIXED: Check deletedOrders by docId AND orderId
                    const wasDeleted = this.data.deletedOrders.some(o =>
                        o.docId === docId || (orderId && o.orderId === orderId)
                    );

                    if (wasDeleted) {
                        console.warn('‚ö†Ô∏è Order was previously deleted - ignoring:', docId);
                        return;
                    }

                    if (!isFirstLoad) {
                        console.log('üÜï New order detected:', orderId || `[docId: ${docId}]`);
                    }

                    const newOrder = {
                        orderId: orderId,
                        docId: docId, // CRITICAL: Always store docId
                        isMultiDay: orderData.isMultiDay || false,
                        startDate: orderData.startDate || null,
                        endDate: orderData.endDate || null,
                        dayWiseData: orderData.dayWiseData || [],
                        date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
                        readyTime: customer.timeSlot || '',
                        clientName: customer.name || '',
                        contact: customer.phone || '',
                        venue: customer.venue || '',
                        eventType: orderData.functionType || customer.functionType || '',
                        transport: orderData.transport || '',
                        driverName: orderData.driverName || '',
                        operator: orderData.operator || '',
                        helper: orderData.helper || '',
                        status: orderData.status || 'Confirmed',
                        notes: orderData.notes || '',
                        items: (orderData.items || []).map(item => ({
                            name: item.name || '',
                            quantity: item.qty || 0,
                            remarks: item.desc || '',
                            price: item.price || 0
                        })),
                        createdAt: orderData.createdAt || new Date().toISOString(),
                        totalAmount: orderData.totalAmount || 0
                    };

                    this.data.orders.unshift(newOrder);
                    this.updateCustomerDatabase(newOrder);
                    this.saveToStorage(); // Save to local storage

                    // Only show toast for newly added orders (not initial load)
                    if (!isFirstLoad) {
                        this.updateAllDisplays();
                        this.showToast(`üÜï New order: ${newOrder.clientName}`, 'success');
                    }
                }
            }
            
if (change.type === 'modified') {
    const docId = change.doc.id;
    const orderId = orderData.orderId || '';
    console.log('‚úèÔ∏è Order modified:', orderId || `[docId: ${docId}]`);

    // FIXED: Find by docId or orderId
    const index = this.data.orders.findIndex(o =>
        o.docId === docId || (orderId && o.orderId === orderId)
    );

    if (index !== -1) {
        // Update existing order
        this.data.orders[index] = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always keep docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };

        this.saveToStorage(); // Save to local storage
        this.updateAllDisplays();
        this.showToast(`‚úèÔ∏è Order updated: ${this.data.orders[index].clientName}`, 'success');
    } else {
        // FIXED: Check deletedOrders by docId AND orderId
        const wasDeleted = this.data.deletedOrders.some(o =>
            o.docId === docId || (orderId && o.orderId === orderId)
        );

        if (wasDeleted) {
            console.warn('‚ö†Ô∏è Modified order was previously deleted - ignoring:', docId);
            return;
        }

        console.warn('‚ö†Ô∏è Modified order not found locally, adding it');
        // Add it as new if somehow missing
        const newOrder = {
            orderId: orderId,
            docId: docId, // CRITICAL: Always store docId
            isMultiDay: orderData.isMultiDay || false,
            startDate: orderData.startDate || null,
            endDate: orderData.endDate || null,
            dayWiseData: orderData.dayWiseData || [],
            date: orderData.isMultiDay ? '' : (Utils.convertDateFormat(customer.dates) || ''),
            readyTime: customer.timeSlot || '',
            clientName: customer.name || '',
            contact: customer.phone || '',
            venue: customer.venue || '',
            eventType: orderData.functionType || customer.functionType || '',
            transport: orderData.transport || '',
            driverName: orderData.driverName || '',
            operator: orderData.operator || '',
            helper: orderData.helper || '',
            status: orderData.status || 'Confirmed',
            notes: orderData.notes || '',
            items: (orderData.items || []).map(item => ({
                name: item.name || '',
                quantity: item.qty || 0,
                remarks: item.desc || '',
                price: item.price || 0
            })),
            createdAt: orderData.createdAt || new Date().toISOString(),
            totalAmount: orderData.totalAmount || 0
        };
        this.data.orders.push(newOrder);
        this.updateAllDisplays();
    }
}
            
            if (change.type === 'removed') {
                console.log('üóëÔ∏è Order removed from Firestore:', orderData.orderId || change.doc.id);
                const index = this.data.orders.findIndex(o => o.orderId === (orderData.orderId || change.doc.id));
                if (index !== -1) {
                    const deleted = this.data.orders.splice(index, 1)[0];
                    this.updateAllDisplays();
                    this.showToast(`üóëÔ∏è Order deleted: ${deleted.orderId}`, 'success');
                }
            }
        });

        // After processing all changes, update displays if this was the initial load
        if (isFirstLoad) {
            this.updateAllDisplays();
            console.log(`‚úÖ Initial load complete - ${this.data.orders.length} orders loaded from Firebase`);
        }
    });

    console.log('‚úÖ Real-time listener active (SINGLE INSTANCE CONFIRMED)');
},

loadDemoData() {
    // DISABLED: Don't load demo data if we have real data in Firestore or deletedOrders
    console.log('üìã Checking if demo data should be loaded...');

    const hasDeletedOrders = this.data.deletedOrders && this.data.deletedOrders.length > 0;
    const hasRealInventory = this.data.inventory.categories.length > 2 || this.data.inventory.items.length > 2;

    if (hasDeletedOrders) {
        console.log('‚ö†Ô∏è Found deleted orders - skipping demo data (system has been used before)');
        return;
    }

    if (hasRealInventory) {
        console.log('‚ö†Ô∏è Found real inventory - skipping demo data');
        return;
    }

    if (this.data.orders.length === 0) {
        console.log('üìã No orders found. Loading demo data for first-time users...');

        this.data.inventory.categories = [
            { id: 'cat-1', name: 'Sparklers', createdAt: new Date().toISOString() },
            { id: 'cat-2', name: 'Fountains', createdAt: new Date().toISOString() }
        ];

        this.data.inventory.items = [
            { id: 'item-1', categoryId: 'cat-1', name: '7 cm Electric Sparkler', quantity: 50, createdAt: new Date().toISOString() },
            { id: 'item-2', categoryId: 'cat-2', name: 'Golden Fountain', quantity: 5, createdAt: new Date().toISOString() }
        ];

        const demoOrder = {
            orderId: 'FP001',
            date: Utils.toDateString(new Date()),
            readyTime: '6:00 PM',
            clientName: 'Rajesh Patel',
            contact: '+91 98765 43210',
            venue: 'Rajkot Palace',
            eventType: 'Wedding',
            transport: 'Bolero',
            driverName: 'Ramesh',
            operator: 'Kiran',
            helper: 'Vijay',
            status: 'Confirmed',
            notes: 'Special display',
            items: [
                { itemId: 'item-1', name: '7 cm Electric Sparkler', quantity: 10, remarks: 'For entrance' }
            ],
            createdAt: new Date().toISOString()
        };

        this.data.orders.push(demoOrder);
        this.updateCustomerDatabase(demoOrder);
        this.data.settings.orderIdCounter = 2;
        this.saveToStorage();
        console.log('‚úÖ Demo data loaded for first-time user');
    } else {
        console.log('‚úÖ Orders exist - demo data not needed');
    }
},

updateAllDisplays() {
        if (this.currentTab === 'dashboard') this.renderDashboard();
        else if (this.currentTab === 'inventory') this.updateInventoryDisplay();
        else if (this.currentTab === 'customers') this.renderCustomers();
        else if (this.currentTab === 'calendar') this.renderCalendarTab();
        else if (this.currentTab === 'history') this.renderHistory();
        else if (this.currentTab === 'analytics') this.renderAnalytics();

        // Always update notifications
        this.updateNotifications();
    },

    // Smart Notifications System
    updateNotifications() {
        const pendingOrders = this.data.orders.filter(o =>
            o.status && (o.status.toLowerCase() === 'pending' || o.status.toLowerCase() === 'confirmed')
        );

        const panel = document.getElementById('notificationsPanel');
        const content = document.getElementById('notificationsContent');

        if (pendingOrders.length === 0) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';

        const now = new Date();
        const notifications = pendingOrders.map(order => {
            const orderDate = new Date(order.date || order.startDate);
            const daysUntil = Math.ceil((orderDate - now) / (1000 * 60 * 60 * 24));
            let urgency = '';
            let color = 'var(--warning)';

            if (daysUntil < 0) {
                urgency = `‚ö†Ô∏è OVERDUE by ${Math.abs(daysUntil)} days!`;
                color = 'var(--danger)';
            } else if (daysUntil === 0) {
                urgency = 'üî• TODAY';
                color = 'var(--danger)';
            } else if (daysUntil === 1) {
                urgency = '‚ö° TOMORROW';
                color = 'var(--warning)';
            } else if (daysUntil <= 3) {
                urgency = `‚è∞ In ${daysUntil} days`;
                color = 'var(--warning)';
            } else {
                urgency = `üìÖ In ${daysUntil} days`;
                color = 'var(--info)';
            }

            return { order, urgency, color, daysUntil };
        }).sort((a, b) => a.daysUntil - b.daysUntil);

        content.innerHTML = notifications.map(({ order, urgency, color }) => `
            <div style="padding: 12px; margin: 8px 0; background: var(--bg-card); border-left: 3px solid ${color}; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; color: var(--text-dark);">
                <div>
                    <strong style="color: ${color};">${urgency}</strong>
                    <span style="margin: 0 8px;">|</span>
                    <strong>${order.clientName || 'Unknown'}</strong> - ${order.venue || 'N/A'}
                    <span style="margin: 0 8px;">|</span>
                    Status: <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px;">${order.status}</span>
                    <span style="margin: 0 8px;">|</span>
                    Date: ${Utils.formatDate(order.date || order.startDate)}
                </div>
                <button class="btn btn-sm" onclick="OMS.markAsCompleted('${order.docId || order.orderId}')" style="background: var(--success);">
                    ‚úì Mark Complete
                </button>
            </div>
        `).join('');
    },

    markAsCompleted(identifier) {
        const order = this.data.orders.find(o =>
            o.docId === identifier || o.orderId === identifier
        );

        if (!order) {
            this.showToast('Order not found', 'error');
            return;
        }

        if (confirm(`Mark "${order.clientName}" order as completed?\n\nIMPORTANT: You'll need to provide an FP ID!`)) {
            this.loadOrderToForm(order);
            document.getElementById('orderStatus').value = 'Completed';
            this.switchTab('orders');
            this.showToast('Please enter FP ID and save the order', 'info');
        }
    },

    dismissNotifications() {
        document.getElementById('notificationsPanel').style.display = 'none';
    },

    // Get color for order based on event type or status
    getOrderColor(order) {
        if (!order) return this.data.settings.eventTypeColors.default;

        // Priority: event type color > status color > default
        const eventType = order.eventType || order.functionType || '';
        if (eventType && this.data.settings.eventTypeColors[eventType]) {
            return this.data.settings.eventTypeColors[eventType];
        }

        const status = (order.status || '').toLowerCase();
        if (status && this.data.settings.statusColors[status]) {
            return this.data.settings.statusColors[status];
        }

        return this.data.settings.eventTypeColors.default;
    },

    async getNextOrderIdFromFirestore() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            
            const newOrderId = await db.runTransaction(async (transaction) => {
                const counterDoc = await transaction.get(counterRef);
                
                if (!counterDoc.exists) {
                    transaction.set(counterRef, { currentNumber: 1 });
                    return 'FP0001';
                }
                
                const currentNumber = counterDoc.data().currentNumber || 0;
                const nextNumber = currentNumber + 1;
                
                transaction.update(counterRef, { currentNumber: nextNumber });
                
                const prefix = this.data.settings.invoicePrefix || 'FP';
                return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            });
            
            console.log('‚úÖ Generated order ID from Firestore:', newOrderId);
            return newOrderId;
            
        } catch (error) {
            console.error('‚ùå Error getting order ID:', error);
            return this.getNextOrderId();
        }
    },

    // Preview next order ID WITHOUT incrementing
    async previewNextOrderId() {
        try {
            const counterRef = db.collection('counters').doc('orderCounter');
            const counterDoc = await counterRef.get();
            
            if (!counterDoc.exists) {
                return 'FP0001';
            }
            
            const currentNumber = counterDoc.data().currentNumber || 0;
            const nextNumber = currentNumber + 1;
            
            const prefix = this.data.settings.invoicePrefix || 'FP';
            return `${prefix}${String(nextNumber).padStart(3, '0')}`;
            
        } catch (error) {
            console.error('‚ùå Error previewing order ID:', error);
            return this.getNextOrderId();
        }
    }
};

        // ============ ADMIN UTILITIES ============
        // Utility functions for debugging and cleanup

        window.AdminUtils = {
            // SYNC FIX: Clear deletedOrders list (use if orders not syncing)
            clearDeletedOrdersList() {
                const count = OMS.data.deletedOrders.length;
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log(`‚úÖ Cleared ${count} entries from deletedOrders list`);
                console.log('üîÑ Refreshing from Firestore...');
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    console.log('‚úÖ Sync complete! All Firestore orders should now be visible.');
                });
            },

            // Force full sync from Firestore (ignore localStorage)
            async forceFullSync() {
                console.log('üîÑ Force syncing from Firestore...');
                OMS.data.deletedOrders = [];
                await OMS.loadOrdersFromFirestore();
                OMS.updateAllDisplays();
                console.log('‚úÖ Full sync complete!');
            },

            // List all orders in Firestore
            async listAllFirestoreOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        orders.push({ docId: doc.id, ...doc.data() });
                    });
                    console.table(orders.map(o => ({
                        DocID: o.docId,
                        OrderID: o.orderId,
                        Client: o.clientName || o.customer?.name,
                        Date: o.date || o.customer?.dates,
                        Status: o.status
                    })));
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete a specific order from Firestore by orderId
            async deleteOrderFromFirestore(orderId) {
                try {
                    const docRef = db.collection('orders').doc(orderId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order ${orderId} from Firestore`);

                        // Also add to deletedOrders to prevent reappearing
                        const orderData = docSnap.data();
                        OMS.data.deletedOrders.push({
                            orderId: orderId,
                            ...orderData,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();

                        console.log(`‚úÖ Added ${orderId} to deletedOrders list to prevent reappearing`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Order ${orderId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find and delete demo/test orders
            async findAndDeleteDemoOrders() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const demoKeywords = ['demo', 'test', 'sample', 'example'];
                    const demoOrders = [];

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = (data.clientName || data.customer?.name || '').toLowerCase();
                        const orderId = (data.orderId || '').toLowerCase();

                        const isDemo = demoKeywords.some(keyword =>
                            clientName.includes(keyword) || orderId.includes(keyword)
                        );

                        if (isDemo) {
                            demoOrders.push({ docId: doc.id, orderId: data.orderId, clientName: data.clientName || data.customer?.name });
                        }
                    });

                    if (demoOrders.length === 0) {
                        console.log('‚úÖ No demo orders found!');
                        return [];
                    }

                    console.log(`‚ö†Ô∏è Found ${demoOrders.length} potential demo orders:`);
                    console.table(demoOrders);

                    const confirmed = confirm(`Delete ${demoOrders.length} demo orders? This cannot be undone.`);
                    if (confirmed) {
                        for (const order of demoOrders) {
                            await this.deleteOrderFromFirestore(order.orderId || order.docId);
                        }
                        console.log(`‚úÖ Deleted ${demoOrders.length} demo orders`);
                    }

                    return demoOrders;
                } catch (error) {
                    console.error('‚ùå Error finding demo orders:', error);
                }
            },

            // Clear all deleted orders from local storage
            clearDeletedOrdersList() {
                OMS.data.deletedOrders = [];
                OMS.saveToStorage();
                console.log('‚úÖ Cleared deletedOrders list');
            },

            // View deleted orders list
            viewDeletedOrders() {
                console.table(OMS.data.deletedOrders.map(o => ({
                    OrderID: o.orderId,
                    Client: o.clientName,
                    DeletedAt: o.deletedAt,
                    Reason: o.deleteReason
                })));
                console.log(`üìã Total deleted orders: ${OMS.data.deletedOrders.length}`);
            },

            // Recover inventory FROM Firestore (force reload)
            async recoverInventoryFromFirestore() {
                try {
                    console.log('üîÑ Force loading inventory from Firestore...');

                    // Load categories from Firestore
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, ...doc.data() });
                    });

                    // Load items from Firestore
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        items.push({ id: doc.id, ...doc.data() });
                    });

                    console.log('üì¶ Found in Firestore:');
                    console.log(`  Categories: ${categories.length}`);
                    console.log(`  Items: ${items.length}`);

                    if (categories.length === 0 && items.length === 0) {
                        console.error('‚ùå Firestore inventory is empty! Nothing to recover.');
                        console.log('üí° Use AdminUtils.recoverInventoryFromLocalStorage() if you have a localStorage backup');
                        return false;
                    }

                    const confirmed = confirm(`Load ${categories.length} categories and ${items.length} items from Firestore? This will replace your current local data.`);
                    if (confirmed) {
                        // Force overwrite local data
                        OMS.data.inventory = { categories, items };
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory recovered from Firestore!');
                        console.log(`  Categories: ${categories.length}`);
                        console.log(`  Items: ${items.length}`);
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory from Firestore:', error);
                    return false;
                }
            },

            // Recover inventory from localStorage backup
            recoverInventoryFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('oms_data');
                    if (!saved) {
                        console.error('‚ùå No localStorage backup found');
                        return false;
                    }

                    const parsed = JSON.parse(saved);
                    if (!parsed.inventory || (!parsed.inventory.categories && !parsed.inventory.items)) {
                        console.error('‚ùå No inventory data in localStorage backup');
                        return false;
                    }

                    console.log('üì¶ Found inventory in localStorage backup:');
                    console.log(`  Categories: ${parsed.inventory.categories?.length || 0}`);
                    console.log(`  Items: ${parsed.inventory.items?.length || 0}`);

                    const confirmed = confirm(`Restore ${parsed.inventory.categories?.length || 0} categories and ${parsed.inventory.items?.length || 0} items from backup?`);
                    if (confirmed) {
                        OMS.data.inventory = parsed.inventory;
                        OMS.saveToStorage();
                        OMS.updateInventoryDisplay();
                        console.log('‚úÖ Inventory restored from localStorage backup!');

                        // Sync to Firestore
                        OMS.syncInventoryToFirestore();
                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('‚ùå Error recovering inventory:', error);
                    return false;
                }
            },

            // View current inventory status
            checkInventoryStatus() {
                console.log('üì¶ INVENTORY STATUS:');
                console.log(`  Categories in memory: ${OMS.data.inventory.categories.length}`);
                console.log(`  Items in memory: ${OMS.data.inventory.items.length}`);

                // Check localStorage
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log(`  Categories in localStorage: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  Items in localStorage: ${parsed.inventory?.items?.length || 0}`);
                }

                console.log('\nUse AdminUtils.recoverInventoryFromLocalStorage() to restore from backup');
                console.log('Use AdminUtils.checkFirestoreInventory() to see what is in Firestore');
            },

            // Check what's actually in Firestore
            async checkFirestoreInventory() {
                try {
                    console.log('üîç Checking Firestore inventory...');

                    // Check categories
                    const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                    console.log(`üìÅ Categories in Firestore: ${categoriesSnapshot.size}`);
                    const categories = [];
                    categoriesSnapshot.forEach(doc => {
                        categories.push({ id: doc.id, name: doc.data().name });
                    });
                    console.table(categories);

                    // Check items
                    const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                    console.log(`üì¶ Items in Firestore: ${itemsSnapshot.size}`);
                    const items = [];
                    itemsSnapshot.forEach(doc => {
                        const data = doc.data();
                        items.push({ id: doc.id, name: data.name, quantity: data.quantity });
                    });
                    console.table(items.slice(0, 20)); // Show first 20

                    return { categories, items };
                } catch (error) {
                    console.error('‚ùå Error checking Firestore inventory:', error);
                    return null;
                }
            },

            // List all orders with their document IDs
            async listAllOrdersWithDetails() {
                try {
                    const snapshot = await db.collection('orders').get();
                    const orders = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        orders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates,
                            Status: data.status
                        });
                    });
                    console.table(orders);
                    console.log(`üìã Found ${orders.length} orders in Firestore`);
                    console.log('\nTo delete an order, use: await AdminUtils.deleteOrderByDocId("DOC_ID")');
                    return orders;
                } catch (error) {
                    console.error('‚ùå Error listing orders:', error);
                }
            },

            // Delete order by document ID (not orderId)
            async deleteOrderByDocId(docId) {
                try {
                    const docRef = db.collection('orders').doc(docId);
                    const docSnap = await docRef.get();

                    if (docSnap.exists) {
                        const data = docSnap.data();
                        await docRef.delete();
                        console.log(`‚úÖ Deleted order from Firestore - DocID: ${docId}, OrderID: ${data.orderId}`);

                        // Also add to deletedOrders
                        OMS.data.deletedOrders.push({
                            orderId: data.orderId || docId,
                            docId: docId,
                            ...data,
                            deletedAt: new Date().toISOString(),
                            deleteReason: 'Manual deletion via AdminUtils'
                        });
                        OMS.saveToStorage();
                        console.log(`‚úÖ Added to deletedOrders list`);
                        return true;
                    } else {
                        console.warn(`‚ö†Ô∏è Document ${docId} not found in Firestore`);
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting order:', error);
                    return false;
                }
            },

            // Find orders that are in local data but NOT in Firestore (ghost orders)
            async findGhostOrders() {
                try {
                    console.log('üëª Searching for ghost orders (in local but not in Firestore)...');

                    // Get all orders from Firestore
                    const snapshot = await db.collection('orders').get();
                    const firestoreOrderIds = new Set();
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrderIds.add(data.orderId || doc.id);
                        firestoreOrderIds.add(doc.id);
                    });

                    // Find local orders not in Firestore
                    const ghostOrders = OMS.data.orders.filter(order =>
                        !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                    );

                    if (ghostOrders.length === 0) {
                        console.log('‚úÖ No ghost orders found! All local orders exist in Firestore.');
                        return [];
                    }

                    console.log(`üëª Found ${ghostOrders.length} ghost orders:`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName,
                        Date: o.date,
                        Status: o.status,
                        IsInDeletedList: OMS.data.deletedOrders.some(d => d.orderId === o.orderId) ? 'YES' : 'NO'
                    })));

                    console.log('\nüí° These orders exist locally but NOT in Firestore.');
                    console.log('They may be reappearing because of localStorage.');
                    console.log('\nTo remove them permanently:');
                    console.log('  AdminUtils.removeGhostOrders()');

                    return ghostOrders;
                } catch (error) {
                    console.error('‚ùå Error finding ghost orders:', error);
                    return [];
                }
            },

            // Remove ghost orders from local data
            removeGhostOrders() {
                const ghostOrders = OMS.data.orders.filter(order => {
                    // Keep only orders that should exist
                    return false; // For now, will be set properly
                });

                console.log('‚ö†Ô∏è This will remove ALL orders that are NOT in Firestore.');
                console.log('First run: await AdminUtils.findGhostOrders() to see what will be removed.');

                const confirmed = confirm('Remove all ghost orders (orders not in Firestore)? This cannot be undone.');
                if (!confirmed) {
                    console.log('‚ùå Cancelled');
                    return;
                }

                // Reload from Firestore to get clean state
                OMS.loadOrdersFromFirestore().then(() => {
                    OMS.updateAllDisplays();
                    OMS.saveToStorage();
                    console.log('‚úÖ Ghost orders removed. Data reloaded from Firestore.');
                });
            },

            // Add an order to the permanently deleted list (to prevent it from reappearing)
            async permanentlyDeleteOrder(orderId) {
                console.log(`üóëÔ∏è Permanently deleting order ${orderId}...`);

                // Find the order in local data
                const order = OMS.data.orders.find(o => o.orderId === orderId);

                if (!order) {
                    console.warn(`‚ö†Ô∏è Order ${orderId} not found in local data`);
                }

                // STEP 1: Delete from Firestore (search by orderId field AND doc ID)
                try {
                    console.log('üîç Searching Firestore for this order...');

                    // Search by orderId field
                    const snapshot = await db.collection('orders')
                        .where('orderId', '==', orderId)
                        .get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => {
                            console.log(`üî• Deleting Firestore doc: ${doc.id}`);
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log('‚úÖ Deleted from Firestore (by orderId field)');
                    } else {
                        // Try deleting by doc ID
                        const docRef = db.collection('orders').doc(orderId);
                        const docSnap = await docRef.get();
                        if (docSnap.exists) {
                            await docRef.delete();
                            console.log('‚úÖ Deleted from Firestore (by doc ID)');
                        } else {
                            console.log('‚ö†Ô∏è Order not found in Firestore (may already be deleted)');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }

                // STEP 2: Add to deletedOrders list (prevents reappearing)
                const existingInDeleted = OMS.data.deletedOrders.find(o => o.orderId === orderId);
                if (!existingInDeleted) {
                    OMS.data.deletedOrders.push({
                        orderId: orderId,
                        ...(order || {}),
                        deletedAt: new Date().toISOString(),
                        deleteReason: 'Permanently deleted via AdminUtils'
                    });
                    console.log('‚úÖ Added to deletedOrders block list');
                } else {
                    console.log('‚ÑπÔ∏è Already in deletedOrders list');
                }

                // STEP 3: Remove from local orders
                OMS.data.orders = OMS.data.orders.filter(o => o.orderId !== orderId);

                // STEP 4: Save to localStorage
                OMS.saveToStorage();
                OMS.updateAllDisplays();

                console.log(`\n‚úÖ Order ${orderId} PERMANENTLY DELETED from:`);
                console.log('  ‚úì Firestore database');
                console.log('  ‚úì Local data');
                console.log('  ‚úì Added to block list (deletedOrders)');
                console.log('  ‚úì Saved to localStorage');
                console.log('\nüõ°Ô∏è This order will NEVER reappear even after refresh!');
            },

            // Check for data inconsistencies
            async checkDataConsistency() {
                console.log('üîç Checking data consistency...\n');

                // Check orders
                const snapshot = await db.collection('orders').get();
                const firestoreOrderCount = snapshot.size;
                const localOrderCount = OMS.data.orders.length;
                const deletedOrderCount = OMS.data.deletedOrders.length;

                console.log('üìä ORDER COUNTS:');
                console.log(`  Firestore orders: ${firestoreOrderCount}`);
                console.log(`  Local orders: ${localOrderCount}`);
                console.log(`  Deleted orders list: ${deletedOrderCount}`);

                if (firestoreOrderCount !== localOrderCount) {
                    console.warn(`‚ö†Ô∏è Mismatch detected! ${Math.abs(firestoreOrderCount - localOrderCount)} orders difference`);
                    console.log('\nRun these commands to investigate:');
                    console.log('  await AdminUtils.findGhostOrders() - Find local orders not in Firestore');
                    console.log('  await AdminUtils.listAllOrdersWithDetails() - See all Firestore orders');
                } else {
                    console.log('‚úÖ Order counts match!');
                }

                // Check inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();

                console.log('\nüì¶ INVENTORY COUNTS:');
                console.log(`  Firestore categories: ${categoriesSnapshot.size}, Local: ${OMS.data.inventory.categories.length}`);
                console.log(`  Firestore items: ${itemsSnapshot.size}, Local: ${OMS.data.inventory.items.length}`);

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0 &&
                    (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0)) {
                    console.error('‚ùå CRITICAL: Inventory exists locally but NOT in Firestore!');
                    console.log('Run: AdminUtils.recoverInventoryFromLocalStorage() to sync to Firestore');
                }
            },

            // Clean up deleted orders list (remove undefined entries)
            cleanupDeletedOrdersList() {
                console.log('üßπ Cleaning up deleted orders list...');
                const before = OMS.data.deletedOrders.length;
                const undefinedCount = OMS.data.deletedOrders.filter(o => !o.orderId).length;

                if (undefinedCount > 0) {
                    console.log(`‚ö†Ô∏è Found ${undefinedCount} entries with undefined orderId`);
                    OMS.data.deletedOrders = OMS.data.deletedOrders.filter(o => o.orderId && o.orderId !== 'undefined');
                    OMS.saveToStorage();
                    console.log(`‚úÖ Removed ${before - OMS.data.deletedOrders.length} invalid entries`);
                    console.log(`üìã Deleted orders list: ${before} ‚Üí ${OMS.data.deletedOrders.length}`);
                } else {
                    console.log('‚úÖ No cleanup needed - all entries have valid orderIds');
                }
            },

            // COMPREHENSIVE DIAGNOSTIC - Find all bugs
            async debugEverything() {
                console.log('üîçüîçüîç COMPREHENSIVE SYSTEM DIAGNOSTIC üîçüîçüîç\n');

                // 1. Check localStorage
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('1Ô∏è‚É£ LOCALSTORAGE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                const saved = localStorage.getItem('oms_data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('‚úÖ localStorage exists');
                    console.log(`  üì¶ Inventory categories: ${parsed.inventory?.categories?.length || 0}`);
                    console.log(`  üì¶ Inventory items: ${parsed.inventory?.items?.length || 0}`);
                    console.log(`  üìã Orders: ${parsed.orders?.length || 0}`);
                    console.log(`  üóëÔ∏è Deleted orders: ${parsed.deletedOrders?.length || 0}`);

                    if (parsed.deletedOrders && parsed.deletedOrders.length > 0) {
                        console.log('\n  Deleted Orders List:');
                        console.table(parsed.deletedOrders.map(o => ({
                            OrderID: o.orderId,
                            Client: o.clientName,
                            DeletedAt: o.deletedAt
                        })));
                    }
                } else {
                    console.error('‚ùå NO localStorage data found!');
                }

                // 2. Check current memory
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('2Ô∏è‚É£ CURRENT MEMORY (OMS.data)');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  üì¶ Inventory categories: ${OMS.data.inventory.categories.length}`);
                console.log(`  üì¶ Inventory items: ${OMS.data.inventory.items.length}`);
                console.log(`  üìã Orders: ${OMS.data.orders.length}`);
                console.log(`  üóëÔ∏è Deleted orders: ${OMS.data.deletedOrders.length}`);

                // 3. Check Firestore
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('3Ô∏è‚É£ FIRESTORE CHECK');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Orders
                const ordersSnapshot = await db.collection('orders').get();
                console.log(`  üìã Orders in Firestore: ${ordersSnapshot.size}`);
                if (ordersSnapshot.size > 0) {
                    console.log('\n  Firestore Orders:');
                    const firestoreOrders = [];
                    ordersSnapshot.forEach(doc => {
                        const data = doc.data();
                        firestoreOrders.push({
                            DocID: doc.id,
                            OrderID: data.orderId,
                            Client: data.clientName || data.customer?.name,
                            Date: data.date || data.customer?.dates
                        });
                    });
                    console.table(firestoreOrders);
                }

                // Inventory
                const categoriesSnapshot = await db.collection('inventory').doc('categories').collection('items').get();
                const itemsSnapshot = await db.collection('inventory').doc('items').collection('list').get();
                console.log(`  üì¶ Categories in Firestore: ${categoriesSnapshot.size}`);
                console.log(`  üì¶ Items in Firestore: ${itemsSnapshot.size}`);

                // 4. Find mismatches
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('4Ô∏è‚É£ MISMATCH ANALYSIS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Check if deleted orders are in Firestore
                if (OMS.data.deletedOrders.length > 0) {
                    console.log('  Checking if deleted orders still exist in Firestore...');
                    for (const delOrder of OMS.data.deletedOrders) {
                        // Skip if orderId is undefined
                        if (!delOrder.orderId) {
                            console.warn(`  ‚ö†Ô∏è Skipping deleted order with undefined ID`);
                            continue;
                        }

                        const snapshot = await db.collection('orders')
                            .where('orderId', '==', delOrder.orderId)
                            .get();

                        if (!snapshot.empty) {
                            console.error(`  ‚ùå DELETED ORDER STILL IN FIRESTORE: ${delOrder.orderId}`);
                            snapshot.forEach(doc => {
                                console.error(`     Firestore Doc ID: ${doc.id}`);
                            });
                        } else {
                            console.log(`  ‚úÖ ${delOrder.orderId} - properly deleted from Firestore`);
                        }
                    }
                }

                // Check ghost orders
                const firestoreOrderIds = new Set();
                ordersSnapshot.forEach(doc => {
                    const data = doc.data();
                    firestoreOrderIds.add(data.orderId || doc.id);
                    firestoreOrderIds.add(doc.id);
                });

                const ghostOrders = OMS.data.orders.filter(order =>
                    !firestoreOrderIds.has(order.orderId) && !firestoreOrderIds.has(order.docId)
                );

                if (ghostOrders.length > 0) {
                    console.warn(`  ‚ö†Ô∏è Found ${ghostOrders.length} GHOST ORDERS (in local but NOT in Firestore):`);
                    console.table(ghostOrders.map(o => ({
                        OrderID: o.orderId,
                        Client: o.clientName
                    })));
                }

                // 5. Final recommendations
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('5Ô∏è‚É£ RECOMMENDATIONS');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                if (categoriesSnapshot.size === 0 && itemsSnapshot.size === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN FIRESTORE!');
                    if (OMS.data.inventory.categories.length > 0 || OMS.data.inventory.items.length > 0) {
                        console.log('  üí° Run: await OMS.syncInventoryToFirestore()');
                    }
                } else if (OMS.data.inventory.categories.length === 0 && OMS.data.inventory.items.length === 0) {
                    console.error('  ‚ùå INVENTORY EMPTY IN MEMORY!');
                    console.log('  üí° Run: await AdminUtils.recoverInventoryFromFirestore()');
                }

                if (ghostOrders.length > 0) {
                    console.log('  üí° Run: AdminUtils.removeGhostOrders() to clean them up');
                }

                console.log('\n‚úÖ Diagnostic complete!\n');
            }
        };

        console.log('üõ†Ô∏è Admin utilities loaded. Available commands:');
        console.log('\nüìã ORDER COMMANDS:');
        console.log('  - await AdminUtils.listAllOrdersWithDetails() - List all orders with DocIDs');
        console.log('  - await AdminUtils.deleteOrderByDocId("DOC_ID") - Delete by document ID');
        console.log('  - await AdminUtils.findGhostOrders() - Find orders in local but NOT in Firestore');
        console.log('  - await AdminUtils.permanentlyDeleteOrder("ORDER_ID") - ‚≠ê PERMANENTLY DELETE (Firestore + local + block)');
        console.log('  - AdminUtils.removeGhostOrders() - Remove all ghost orders');
        console.log('  - await AdminUtils.findAndDeleteDemoOrders() - Find and delete demo orders');
        console.log('  - AdminUtils.viewDeletedOrders() - View deleted orders list');
        console.log('  - AdminUtils.cleanupDeletedOrdersList() - Clean up undefined entries in deleted list');
        console.log('\nüì¶ INVENTORY COMMANDS:');
        console.log('  - AdminUtils.checkInventoryStatus() - Check inventory status');
        console.log('  - await AdminUtils.checkFirestoreInventory() - See what is in Firestore');
        console.log('  - await AdminUtils.recoverInventoryFromFirestore() - ‚≠ê LOAD FROM FIRESTORE');
        console.log('  - AdminUtils.recoverInventoryFromLocalStorage() - Restore from localStorage backup');
        console.log('\nüîç DIAGNOSTIC COMMANDS:');
        console.log('  - await AdminUtils.checkDataConsistency() - Check for data mismatches');
        console.log('  - await AdminUtils.debugEverything() - ‚≠ê FULL SYSTEM DIAGNOSTIC (find all bugs)');

        // ============ INITIALIZATION ============
        document.addEventListener('DOMContentLoaded', () => {
            // Multi-day event toggle
    const eventTypeSelect = document.getElementById('eventTypeSelect');
    const singleDayFields = document.getElementById('singleDayFields');
    const multiDayFields = document.getElementById('multiDayFields');
    const dayWiseFunctions = document.getElementById('dayWiseFunctions');
    
    if (eventTypeSelect) {
        eventTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'single') {
    // Show single day fields
    singleDayFields.style.display = 'block';
    multiDayFields.style.display = 'none';
    dayWiseFunctions.style.display = 'none';

            // Show fields needed for single day
            const readyTimeField = document.getElementById('readyTime');
            readyTimeField.parentElement.style.display = 'block';
            readyTimeField.required = true;

            // Show single-day item search
            const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
            ? document.querySelector('.card h3').closest('.card')
            : null;
            if (itemSearchSection) itemSearchSection.style.display = 'block';

    // Set required fields
    document.getElementById('orderDate').required = true;
    document.getElementById('startDate').required = false;
    document.getElementById('endDate').required = false;

    // SAFEGUARD: Clear multi-day data when switching to single day
    if (window.dayFunctionsData) {
        window.dayFunctionsData = {};
    }
    const multiDayContainer = document.getElementById('multiDayContainer');
    if (multiDayContainer) {
        multiDayContainer.innerHTML = '';
    }
} else {
    // Show multi-day fields
    singleDayFields.style.display = 'none';
    multiDayFields.style.display = 'grid';
    dayWiseFunctions.style.display = 'block';

            // Hide fields not needed for multi-day
            const readyTimeField = document.getElementById('readyTime');
            readyTimeField.parentElement.style.display = 'none';
            readyTimeField.required = false;
            document.getElementById('eventType').parentElement.style.display = 'none';

    // Hide single-day item search
    const itemSearchSection = document.querySelector('.card h3')?.textContent.includes('Order Items')
        ? document.querySelector('.card h3').closest('.card')
        : null;
    if (itemSearchSection) itemSearchSection.style.display = 'none';

    // Set required fields
    document.getElementById('orderDate').required = false;
    document.getElementById('startDate').required = true;
    document.getElementById('endDate').required = true;

    // SAFEGUARD: Clear single-day items when switching to multi-day
    OMS.currentOrderItems = [];
    OMS.updateOrderItemsTable();
}
        });
    }    
    // Calculate total days
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalDaysInput = document.getElementById('totalDays');
    
    function calculateTotalDays() {
        if (startDateInput && endDateInput && startDateInput.value && endDateInput.value) {
            // Check if dates are complete (YYYY-MM-DD format)
            if (startDateInput.value.length !== 10 || endDateInput.value.length !== 10) {
            return; // Wait for complete date
            }
        
            const start = new Date(startDateInput.value);
            const end = new Date(endDateInput.value);
        
            // Validate dates are real dates
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return; // Invalid dates, wait
            }
        
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
            totalDaysInput.value = diffDays + ' days';
            OMS.generateDayWiseFunctions();
    }
}
    // Item search for multi-day events
    function setupDayItemSearch(dayIndex) {
        const searchInput = document.getElementById(`day${dayIndex}ItemSearch`);
        const dropdown = document.getElementById(`day${dayIndex}ItemDropdown`);
        
        if (!searchInput || !dropdown) return;
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase().trim();
            
            if (query.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            const items = OMS.data.inventory.items.filter(i => 
                i.name.toLowerCase().includes(query)
            );
            
            if (items.length > 0) {
                dropdown.innerHTML = items.map(i => `
                    <div class="search-item" onclick="OMS.addItemToDay(${dayIndex}, '${i.id}')">
                        <span>${i.name}</span>
                        <span style="color: var(--text-gray);">${i.quantity} in stock</span>
                    </div>
                `).join('');
                dropdown.classList.add('show');
            } else {
                dropdown.innerHTML = '<div class="search-item">No items found</div>';
                dropdown.classList.add('show');
            }
        });
    }
    
    // Initialize item search for each day after generating functions
    const originalGenerateFunctions = OMS.generateDayWiseFunctions.bind(OMS);
    OMS.generateDayWiseFunctions = function() {
        originalGenerateFunctions();

        const container = document.getElementById('functionsContainer');

        // Setup search for each day
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);

        // Validate dates
        if (end < start) {
            container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è End date must be after start date!</div>';
    return;
        }

const diffTime = end - start;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

// Safety check - max 30 days
if (diffDays > 30) {
    container.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 1rem;">‚ö†Ô∏è Maximum 30 days allowed!</div>';
    return;
}
            
            for (let i = 0; i < diffDays; i++) {
                setupDayItemSearch(i);
            }
        }
    };
    
    if (startDateInput) {
        startDateInput.addEventListener('blur', calculateTotalDays);
        startDateInput.addEventListener('click', calculateTotalDays);
}
    if (endDateInput) {
       endDateInput.addEventListener('blur', calculateTotalDays);
       endDateInput.addEventListener('click', calculateTotalDays);
}
            // Initialize Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyC5c2BmVHnbWlBwwHtFwll97nq_xOdqxCc",
                authDomain: "firepowersfx-2558.firebaseapp.com",
                projectId: "firepowersfx-2558",
                storageBucket: "firepowersfx-2558.firebasestorage.app",
                messagingSenderId: "723483292867",
                appId: "1:723483292867:web:d6d83a79ba87cd2dee5e76"
            };

            firebase.initializeApp(firebaseConfig);
            window.auth = firebase.auth();
            window.db = firebase.firestore();
            console.log('‚úÖ Firebase initialized successfully!');

            // Check if user is logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    // User is logged in
                    console.log('‚úÖ User logged in:', user.email);
                    document.getElementById('loginScreen').style.display = 'none';
                    document.querySelector('.app-container').style.display = 'flex';
                    OMS.init().then(() => OMS.updateAllDisplays());
                } else {
                    // User is logged out
                    console.log('‚ùå User not logged in');
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.querySelector('.app-container').style.display = 'none';
                }
            });

            // Handle login form
            document.getElementById('loginForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                const loginBtn = document.getElementById('loginBtn');
                const loginError = document.getElementById('loginError');
                
                loginBtn.textContent = 'Logging in...';
                loginBtn.disabled = true;
                loginError.style.display = 'none';
                
                try {
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('‚úÖ Login successful!');
                } catch (error) {
                    console.error('‚ùå Login error:', error);
                    loginError.textContent = 'Invalid email or password. Please try again.';
                    loginError.style.display = 'block';
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
            });
            
            // Setup order form
            const form = document.getElementById('orderForm');
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                OMS.saveOrder();
            });

            // Transport custom field
            document.getElementById('transport').addEventListener('change', (e) => {
                const group = document.getElementById('customTransportGroup');
                if (e.target.value === 'Other') {
                    group.classList.remove('hidden');
                } else {
                    group.classList.add('hidden');
                }
            });
            
    // Order ID visibility based on status
    document.getElementById('orderStatus').addEventListener('change', (e) => {
        const orderIdGroup = document.getElementById('orderIdGroup');
        const orderIdInput = document.getElementById('orderId');
    
    if (e.target.value === 'Completed') {
        orderIdGroup.style.display = 'block';
        orderIdInput.required = false;
    } else {
        orderIdGroup.style.display = 'none';
        orderIdInput.required = false;
        orderIdInput.value = '';
    }
});

    // Set initial date (NO restrictions - allow past dates for historical orders)
    const today = Utils.toDateString(new Date());
    Utils.set('orderDate', today);

    // NO date restrictions - allow adding past, present, and future orders
    console.log('‚úÖ Date restrictions removed - can add orders from any date');
        });
    </script>
</body>
</html>
